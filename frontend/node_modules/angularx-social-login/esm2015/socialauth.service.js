import { Inject, Injectable } from '@angular/core';
import { AsyncSubject, ReplaySubject } from 'rxjs';
import { GoogleLoginProvider } from './providers/google-login-provider';
/**
 * The service encapsulating the social login functionality. Exposes methods like
 * `signIn`, `signOut`. Also, exposes an `authState` `Observable` that one can
 * subscribe to get the current logged in user information.
 *
 * @dynamic
 */
export class SocialAuthService {
    /**
     * @param config A `SocialAuthServiceConfig` object or a `Promise` that resolves to a `SocialAuthServiceConfig` object
     */
    constructor(config) {
        this.providers = new Map();
        this.autoLogin = false;
        this._user = null;
        this._authState = new ReplaySubject(1);
        /* Consider making this an enum comprising LOADING, LOADED, FAILED etc. */
        this.initialized = false;
        this._initState = new AsyncSubject();
        if (config instanceof Promise) {
            config.then((config) => {
                this.initialize(config);
            });
        }
        else {
            this.initialize(config);
        }
    }
    /** An `Observable` that one can subscribe to get the current logged in user information */
    get authState() {
        return this._authState.asObservable();
    }
    /** An `Observable` to communicate the readiness of the service and associated login providers */
    get initState() {
        return this._initState.asObservable();
    }
    initialize(config) {
        this.autoLogin = config.autoLogin !== undefined ? config.autoLogin : false;
        const { onError = console.error } = config;
        config.providers.forEach((item) => {
            this.providers.set(item.id, item.provider);
        });
        Promise.all(Array.from(this.providers.values()).map((provider) => provider.initialize()))
            .then(() => {
            if (this.autoLogin) {
                const loginStatusPromises = [];
                let loggedIn = false;
                this.providers.forEach((provider, key) => {
                    let promise = provider.getLoginStatus();
                    loginStatusPromises.push(promise);
                    promise
                        .then((user) => {
                        user.provider = key;
                        this._user = user;
                        this._authState.next(user);
                        loggedIn = true;
                    })
                        .catch(console.debug);
                });
                Promise.all(loginStatusPromises).catch(() => {
                    if (!loggedIn) {
                        this._user = null;
                        this._authState.next(null);
                    }
                });
            }
        })
            .catch((error) => {
            onError(error);
        })
            .finally(() => {
            this.initialized = true;
            this._initState.next(this.initialized);
            this._initState.complete();
        });
    }
    refreshAuthToken(providerId) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else if (providerId !== GoogleLoginProvider.PROVIDER_ID) {
                reject(SocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN);
            }
            else {
                const providerObject = this.providers.get(providerId);
                if (providerObject) {
                    providerObject
                        .getLoginStatus({ refreshToken: true })
                        .then((user) => {
                        user.provider = providerId;
                        this._user = user;
                        this._authState.next(user);
                        resolve();
                    })
                        .catch((err) => {
                        reject(err);
                    });
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    /**
     * A method used to sign in a user with a specific `LoginProvider`.
     *
     * @param providerId Id with which the `LoginProvider` has been registered with the service
     * @param signInOptions Optional `LoginProvider` specific arguments
     * @returns A `Promise` that resolves to the authenticated user information
     */
    signIn(providerId, signInOptions) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else {
                let providerObject = this.providers.get(providerId);
                if (providerObject) {
                    providerObject
                        .signIn(signInOptions)
                        .then((user) => {
                        user.provider = providerId;
                        resolve(user);
                        this._user = user;
                        this._authState.next(user);
                    })
                        .catch((err) => {
                        reject(err);
                    });
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    /**
     * A method used to sign out the currently loggen in user.
     *
     * @param revoke Optional parameter to specify whether a hard sign out is to be performed
     * @returns A `Promise` that resolves if the operation is successful, rejects otherwise
     */
    signOut(revoke = false) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else if (!this._user) {
                reject(SocialAuthService.ERR_NOT_LOGGED_IN);
            }
            else {
                let providerId = this._user.provider;
                let providerObject = this.providers.get(providerId);
                if (providerObject) {
                    providerObject
                        .signOut(revoke)
                        .then(() => {
                        resolve();
                        this._user = null;
                        this._authState.next(null);
                    })
                        .catch((err) => {
                        reject(err);
                    });
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
}
SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND = 'Login provider not found';
SocialAuthService.ERR_NOT_LOGGED_IN = 'Not logged in';
SocialAuthService.ERR_NOT_INITIALIZED = 'Login providers not ready yet. Are there errors on your console?';
SocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN = 'Chosen login provider is not supported for refreshing a token';
SocialAuthService.decorators = [
    { type: Injectable }
];
SocialAuthService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['SocialAuthServiceConfig',] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29jaWFsYXV0aC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Ii9Vc2Vycy9qZHV0dGEvUHJvamVjdHMvd2ViL2FuZ3VsYXJ4LXNvY2lhbC1sb2dpbi9wcm9qZWN0cy9saWIvc3JjLyIsInNvdXJjZXMiOlsic29jaWFsYXV0aC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxZQUFZLEVBQWMsYUFBYSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRy9ELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBV3hFOzs7Ozs7R0FNRztBQUVILE1BQU0sT0FBTyxpQkFBaUI7SUE2QjVCOztPQUVHO0lBQ0gsWUFFRSxNQUFrRTtRQXpCNUQsY0FBUyxHQUErQixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ2xELGNBQVMsR0FBRyxLQUFLLENBQUM7UUFFbEIsVUFBSyxHQUFlLElBQUksQ0FBQztRQUN6QixlQUFVLEdBQThCLElBQUksYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXJFLDBFQUEwRTtRQUNsRSxnQkFBVyxHQUFHLEtBQUssQ0FBQztRQUNwQixlQUFVLEdBQTBCLElBQUksWUFBWSxFQUFFLENBQUM7UUFtQjdELElBQUksTUFBTSxZQUFZLE9BQU8sRUFBRTtZQUM3QixNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7Z0JBQ3JCLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDMUIsQ0FBQyxDQUFDLENBQUM7U0FDSjthQUFNO1lBQ0wsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUN6QjtJQUNILENBQUM7SUF4QkQsMkZBQTJGO0lBQzNGLElBQUksU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN4QyxD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QUFjO3lCQUNYLE9BQU8sQ0FBQyxNQUFNLENBQUM7eUJBQ2YsSUFBSSxDQUFDLEdBQUcsRUFBRTt3QkFDVCxPQUFPLEVBQUUsQ0FBQzt3QkFFVixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQzt3QkFDbEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQzdCLENBQUMsQ0FBQzt5QkFDRCxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTt3QkFDYixNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ2QsQ0FBQyxDQUFDLENBQUM7aUJBQ047cUJBQU07b0JBQ0wsTUFBTSxDQUFDLGlCQUFpQixDQUFDLDRCQUE0QixDQUFDLENBQUM7aUJBQ3hEO2FBQ0Y7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7O0FBekx1Qiw4Q0FBNEIsR0FDbEQsMEJBQTBCLENBQUM7QUFDTCxtQ0FBaUIsR0FBRyxlQUFlLENBQUM7QUFDcEMscUNBQW1CLEdBQ3pDLGtFQUFrRSxDQUFDO0FBQzdDLHFEQUFtQyxHQUN6RCwrREFBK0QsQ0FBQzs7WUFSbkUsVUFBVTs7OzRDQWtDTixNQUFNLFNBQUMseUJBQXlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBc3luY1N1YmplY3QsIE9ic2VydmFibGUsIFJlcGxheVN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IExvZ2luUHJvdmlkZXIgfSBmcm9tICcuL2VudGl0aWVzL2xvZ2luLXByb3ZpZGVyJztcbmltcG9ydCB7IFNvY2lhbFVzZXIgfSBmcm9tICcuL2VudGl0aWVzL3NvY2lhbC11c2VyJztcbmltcG9ydCB7IEdvb2dsZUxvZ2luUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9nb29nbGUtbG9naW4tcHJvdmlkZXInO1xuXG4vKipcbiAqIEFuIGludGVyZmFjZSB0byBkZWZpbmUgdGhlIHNoYXBlIG9mIHRoZSBzZXJ2aWNlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTb2NpYWxBdXRoU2VydmljZUNvbmZpZyB7XG4gIGF1dG9Mb2dpbj86IGJvb2xlYW47XG4gIHByb3ZpZGVyczogeyBpZDogc3RyaW5nOyBwcm92aWRlcjogTG9naW5Qcm92aWRlciB9W107XG4gIG9uRXJyb3I/OiAoZXJyb3I6IGFueSkgPT4gYW55O1xufVxuXG4vKipcbiAqIFRoZSBzZXJ2aWNlIGVuY2Fwc3VsYXRpbmcgdGhlIHNvY2lhbCBsb2dpbiBmdW5jdGlvbmFsaXR5LiBFeHBvc2VzIG1ldGhvZHMgbGlrZVxuICogYHNpZ25JbmAsIGBzaWduT3V0YC4gQWxzbywgZXhwb3NlcyBhbiBgYXV0aFN0YXRlYCBgT2JzZXJ2YWJsZWAgdGhhdCBvbmUgY2FuXG4gKiBzdWJzY3JpYmUgdG8gZ2V0IHRoZSBjdXJyZW50IGxvZ2dlZCBpbiB1c2VyIGluZm9ybWF0aW9uLlxuICpcbiAqIEBkeW5hbWljXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTb2NpYWxBdXRoU2VydmljZSB7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEVSUl9MT0dJTl9QUk9WSURFUl9OT1RfRk9VTkQgPVxuICAgICdMb2dpbiBwcm92aWRlciBub3QgZm91bmQnO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFUlJfTk9UX0xPR0dFRF9JTiA9ICdOb3QgbG9nZ2VkIGluJztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgRVJSX05PVF9JTklUSUFMSVpFRCA9XG4gICAgJ0xvZ2luIHByb3ZpZGVycyBub3QgcmVhZHkgeWV0LiBBcmUgdGhlcmUgZXJyb3JzIG9uIHlvdXIgY29uc29sZT8nO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFUlJfTk9UX1NVUFBPUlRFRF9GT1JfUkVGUkVTSF9UT0tFTiA9XG4gICAgJ0Nob3NlbiBsb2dpbiBwcm92aWRlciBpcyBub3Qgc3VwcG9ydGVkIGZvciByZWZyZXNoaW5nIGEgdG9rZW4nO1xuXG4gIHByaXZhdGUgcHJvdmlkZXJzOiBNYXA8c3RyaW5nLCBMb2dpblByb3ZpZGVyPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBhdXRvTG9naW4gPSBmYWxzZTtcblxuICBwcml2YXRlIF91c2VyOiBTb2NpYWxVc2VyID0gbnVsbDtcbiAgcHJpdmF0ZSBfYXV0aFN0YXRlOiBSZXBsYXlTdWJqZWN0PFNvY2lhbFVzZXI+ID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XG5cbiAgLyogQ29uc2lkZXIgbWFraW5nIHRoaXMgYW4gZW51bSBjb21wcmlzaW5nIExPQURJTkcsIExPQURFRCwgRkFJTEVEIGV0Yy4gKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplZCA9IGZhbHNlO1xuICBwcml2YXRlIF9pbml0U3RhdGU6IEFzeW5jU3ViamVjdDxib29sZWFuPiA9IG5ldyBBc3luY1N1YmplY3QoKTtcblxuICAvKiogQW4gYE9ic2VydmFibGVgIHRoYXQgb25lIGNhbiBzdWJzY3JpYmUgdG8gZ2V0IHRoZSBjdXJyZW50IGxvZ2dlZCBpbiB1c2VyIGluZm9ybWF0aW9uICovXG4gIGdldCBhdXRoU3RhdGUoKTogT2JzZXJ2YWJsZTxTb2NpYWxVc2VyPiB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dGhTdGF0ZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKiBBbiBgT2JzZXJ2YWJsZWAgdG8gY29tbXVuaWNhdGUgdGhlIHJlYWRpbmVzcyBvZiB0aGUgc2VydmljZSBhbmQgYXNzb2NpYXRlZCBsb2dpbiBwcm92aWRlcnMgKi9cbiAgZ2V0IGluaXRTdGF0ZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5faW5pdFN0YXRlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBjb25maWcgQSBgU29jaWFsQXV0aFNlcnZpY2VDb25maWdgIG9iamVjdCBvciBhIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHRvIGEgYFNvY2lhbEF1dGhTZXJ2aWNlQ29uZmlnYCBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoJ1NvY2lhbEF1dGhTZXJ2aWNlQ29uZmlnJylcbiAgICBjb25maWc6IFNvY2lhbEF1dGhTZXJ2aWNlQ29uZmlnIHwgUHJvbWlzZTxTb2NpYWxBdXRoU2VydmljZUNvbmZpZz5cbiAgKSB7XG4gICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIGNvbmZpZy50aGVuKChjb25maWcpID0+IHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKGNvbmZpZyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbml0aWFsaXplKGNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplKGNvbmZpZzogU29jaWFsQXV0aFNlcnZpY2VDb25maWcpIHtcbiAgICB0aGlzLmF1dG9Mb2dpbiA9IGNvbmZpZy5hdXRvTG9naW4gIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5hdXRvTG9naW4gOiBmYWxzZTtcbiAgICBjb25zdCB7IG9uRXJyb3IgPSBjb25zb2xlLmVycm9yIH0gPSBjb25maWc7XG5cbiAgICBjb25maWcucHJvdmlkZXJzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIHRoaXMucHJvdmlkZXJzLnNldChpdGVtLmlkLCBpdGVtLnByb3ZpZGVyKTtcbiAgICB9KTtcblxuICAgIFByb21pc2UuYWxsKFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLnByb3ZpZGVycy52YWx1ZXMoKSkubWFwKChwcm92aWRlcikgPT5cbiAgICAgICAgcHJvdmlkZXIuaW5pdGlhbGl6ZSgpXG4gICAgICApXG4gICAgKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5hdXRvTG9naW4pIHtcbiAgICAgICAgICBjb25zdCBsb2dpblN0YXR1c1Byb21pc2VzID0gW107XG4gICAgICAgICAgbGV0IGxvZ2dlZEluID0gZmFsc2U7XG5cbiAgICAgICAgICB0aGlzLnByb3ZpZGVycy5mb3JFYWNoKChwcm92aWRlcjogTG9naW5Qcm92aWRlciwga2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gcHJvdmlkZXIuZ2V0TG9naW5TdGF0dXMoKTtcbiAgICAgICAgICAgIGxvZ2luU3RhdHVzUHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2VcbiAgICAgICAgICAgICAgLnRoZW4oKHVzZXI6IFNvY2lhbFVzZXIpID0+IHtcbiAgICAgICAgICAgICAgICB1c2VyLnByb3ZpZGVyID0ga2V5O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlciA9IHVzZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXV0aFN0YXRlLm5leHQodXNlcik7XG4gICAgICAgICAgICAgICAgbG9nZ2VkSW4gPSB0cnVlO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuY2F0Y2goY29uc29sZS5kZWJ1Zyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgUHJvbWlzZS5hbGwobG9naW5TdGF0dXNQcm9taXNlcykuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFsb2dnZWRJbikge1xuICAgICAgICAgICAgICB0aGlzLl91c2VyID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5fYXV0aFN0YXRlLm5leHQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgfSlcbiAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2luaXRTdGF0ZS5uZXh0KHRoaXMuaW5pdGlhbGl6ZWQpO1xuICAgICAgICB0aGlzLl9pbml0U3RhdGUuY29tcGxldGUoKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcmVmcmVzaEF1dGhUb2tlbihwcm92aWRlcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTk9UX0lOSVRJQUxJWkVEKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvdmlkZXJJZCAhPT0gR29vZ2xlTG9naW5Qcm92aWRlci5QUk9WSURFUl9JRCkge1xuICAgICAgICByZWplY3QoU29jaWFsQXV0aFNlcnZpY2UuRVJSX05PVF9TVVBQT1JURURfRk9SX1JFRlJFU0hfVE9LRU4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJPYmplY3QgPSB0aGlzLnByb3ZpZGVycy5nZXQocHJvdmlkZXJJZCk7XG4gICAgICAgIGlmIChwcm92aWRlck9iamVjdCkge1xuICAgICAgICAgIHByb3ZpZGVyT2JqZWN0XG4gICAgICAgICAgICAuZ2V0TG9naW5TdGF0dXMoeyByZWZyZXNoVG9rZW46IHRydWUgfSlcbiAgICAgICAgICAgIC50aGVuKCh1c2VyOiBTb2NpYWxVc2VyKSA9PiB7XG4gICAgICAgICAgICAgIHVzZXIucHJvdmlkZXIgPSBwcm92aWRlcklkO1xuICAgICAgICAgICAgICB0aGlzLl91c2VyID0gdXNlcjtcbiAgICAgICAgICAgICAgdGhpcy5fYXV0aFN0YXRlLm5leHQodXNlcik7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTE9HSU5fUFJPVklERVJfTk9UX0ZPVU5EKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHVzZWQgdG8gc2lnbiBpbiBhIHVzZXIgd2l0aCBhIHNwZWNpZmljIGBMb2dpblByb3ZpZGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHByb3ZpZGVySWQgSWQgd2l0aCB3aGljaCB0aGUgYExvZ2luUHJvdmlkZXJgIGhhcyBiZWVuIHJlZ2lzdGVyZWQgd2l0aCB0aGUgc2VydmljZVxuICAgKiBAcGFyYW0gc2lnbkluT3B0aW9ucyBPcHRpb25hbCBgTG9naW5Qcm92aWRlcmAgc3BlY2lmaWMgYXJndW1lbnRzXG4gICAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGF1dGhlbnRpY2F0ZWQgdXNlciBpbmZvcm1hdGlvblxuICAgKi9cbiAgc2lnbkluKHByb3ZpZGVySWQ6IHN0cmluZywgc2lnbkluT3B0aW9ucz86IGFueSk6IFByb21pc2U8U29jaWFsVXNlcj4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgcmVqZWN0KFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9OT1RfSU5JVElBTElaRUQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHByb3ZpZGVyT2JqZWN0ID0gdGhpcy5wcm92aWRlcnMuZ2V0KHByb3ZpZGVySWQpO1xuICAgICAgICBpZiAocHJvdmlkZXJPYmplY3QpIHtcbiAgICAgICAgICBwcm92aWRlck9iamVjdFxuICAgICAgICAgICAgLnNpZ25JbihzaWduSW5PcHRpb25zKVxuICAgICAgICAgICAgLnRoZW4oKHVzZXI6IFNvY2lhbFVzZXIpID0+IHtcbiAgICAgICAgICAgICAgdXNlci5wcm92aWRlciA9IHByb3ZpZGVySWQ7XG4gICAgICAgICAgICAgIHJlc29sdmUodXNlcik7XG5cbiAgICAgICAgICAgICAgdGhpcy5fdXNlciA9IHVzZXI7XG4gICAgICAgICAgICAgIHRoaXMuX2F1dGhTdGF0ZS5uZXh0KHVzZXIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9MT0dJTl9QUk9WSURFUl9OT1RfRk9VTkQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgdXNlZCB0byBzaWduIG91dCB0aGUgY3VycmVudGx5IGxvZ2dlbiBpbiB1c2VyLlxuICAgKlxuICAgKiBAcGFyYW0gcmV2b2tlIE9wdGlvbmFsIHBhcmFtZXRlciB0byBzcGVjaWZ5IHdoZXRoZXIgYSBoYXJkIHNpZ24gb3V0IGlzIHRvIGJlIHBlcmZvcm1lZFxuICAgKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIGlmIHRoZSBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bCwgcmVqZWN0cyBvdGhlcndpc2VcbiAgICovXG4gIHNpZ25PdXQocmV2b2tlOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTk9UX0lOSVRJQUxJWkVEKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3VzZXIpIHtcbiAgICAgICAgcmVqZWN0KFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9OT1RfTE9HR0VEX0lOKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwcm92aWRlcklkID0gdGhpcy5fdXNlci5wcm92aWRlcjtcbiAgICAgICAgbGV0IHByb3ZpZGVyT2JqZWN0ID0gdGhpcy5wcm92aWRlcnMuZ2V0KHByb3ZpZGVySWQpO1xuICAgICAgICBpZiAocHJvdmlkZXJPYmplY3QpIHtcbiAgICAgICAgICBwcm92aWRlck9iamVjdFxuICAgICAgICAgICAgLnNpZ25PdXQocmV2b2tlKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fdXNlciA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX2F1dGhTdGF0ZS5uZXh0KG51bGwpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9MT0dJTl9QUk9WSURFUl9OT1RfRk9VTkQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==