{"ast":null,"code":"/**\n * vis-network\n * https://visjs.github.io/vis-network/\n *\n * A dynamic, browser-based visualization library.\n *\n * @version 9.1.0\n * @date    2021-08-29T08:43:14.666Z\n *\n * @copyright (c) 2011-2017 Almende B.V, http://almende.com\n * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs\n *\n * @license\n * vis.js is dual licensed under both\n *\n *   1. The Apache 2.0 License\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *   and\n *\n *   2. The MIT License\n *      http://opensource.org/licenses/MIT\n *\n * vis.js may be distributed under either license.\n */\n!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(exports, require(\"vis-data/peer/umd/vis-data.js\")) : \"function\" == typeof define && define.amd ? define([\"exports\", \"vis-data/peer/umd/vis-data.js\"], e) : e((t = \"undefined\" != typeof globalThis ? globalThis : t || self).vis = t.vis || {}, t.vis);\n}(this, function (t, e) {\n  var i = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {},\n      o = function (t) {\n    return t && t.Math == Math && t;\n  },\n      n = o(\"object\" == typeof globalThis && globalThis) || o(\"object\" == typeof window && window) || o(\"object\" == typeof self && self) || o(\"object\" == typeof i && i) || function () {\n    return this;\n  }() || Function(\"return this\")(),\n      r = {},\n      s = function (t) {\n    try {\n      return !!t();\n    } catch (t) {\n      return !0;\n    }\n  },\n      a = !s(function () {\n    return 7 != Object.defineProperty({}, 1, {\n      get: function () {\n        return 7;\n      }\n    })[1];\n  }),\n      h = {},\n      d = {}.propertyIsEnumerable,\n      l = Object.getOwnPropertyDescriptor,\n      c = l && !d.call({\n    1: 2\n  }, 1);\n\n  h.f = c ? function (t) {\n    var e = l(this, t);\n    return !!e && e.enumerable;\n  } : d;\n\n  var u,\n      f,\n      p = function (t, e) {\n    return {\n      enumerable: !(1 & t),\n      configurable: !(2 & t),\n      writable: !(4 & t),\n      value: e\n    };\n  },\n      v = {}.toString,\n      g = function (t) {\n    return v.call(t).slice(8, -1);\n  },\n      y = g,\n      m = \"\".split,\n      b = s(function () {\n    return !Object(\"z\").propertyIsEnumerable(0);\n  }) ? function (t) {\n    return \"String\" == y(t) ? m.call(t, \"\") : Object(t);\n  } : Object,\n      w = function (t) {\n    if (null == t) throw TypeError(\"Can't call method on \" + t);\n    return t;\n  },\n      k = b,\n      _ = w,\n      x = function (t) {\n    return k(_(t));\n  },\n      E = function (t) {\n    return \"object\" == typeof t ? null !== t : \"function\" == typeof t;\n  },\n      O = {},\n      C = O,\n      S = n,\n      T = function (t) {\n    return \"function\" == typeof t ? t : void 0;\n  },\n      M = function (t, e) {\n    return arguments.length < 2 ? T(C[t]) || T(S[t]) : C[t] && C[t][e] || S[t] && S[t][e];\n  },\n      P = M(\"navigator\", \"userAgent\") || \"\",\n      D = n,\n      B = P,\n      I = D.process,\n      z = D.Deno,\n      F = I && I.versions || z && z.version,\n      N = F && F.v8;\n\n  N ? f = (u = N.split(\".\"))[0] < 4 ? 1 : u[0] + u[1] : B && (!(u = B.match(/Edge\\/(\\d+)/)) || u[1] >= 74) && (u = B.match(/Chrome\\/(\\d+)/)) && (f = u[1]);\n\n  var A = f && +f,\n      R = A,\n      j = s,\n      L = !!Object.getOwnPropertySymbols && !j(function () {\n    var t = Symbol();\n    return !String(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && R && R < 41;\n  }),\n      H = L && !Symbol.sham && \"symbol\" == typeof Symbol.iterator,\n      W = M,\n      V = H ? function (t) {\n    return \"symbol\" == typeof t;\n  } : function (t) {\n    var e = W(\"Symbol\");\n    return \"function\" == typeof e && Object(t) instanceof e;\n  },\n      q = E,\n      U = {\n    exports: {}\n  },\n      Y = n,\n      X = function (t, e) {\n    try {\n      Object.defineProperty(Y, t, {\n        value: e,\n        configurable: !0,\n        writable: !0\n      });\n    } catch (i) {\n      Y[t] = e;\n    }\n\n    return e;\n  },\n      G = \"__core-js_shared__\",\n      K = n[G] || X(G, {}),\n      $ = K;\n\n  (U.exports = function (t, e) {\n    return $[t] || ($[t] = void 0 !== e ? e : {});\n  })(\"versions\", []).push({\n    version: \"3.16.1\",\n    mode: \"pure\",\n    copyright: \"Â© 2021 Denis Pushkarev (zloirock.ru)\"\n  });\n\n  var Z = w,\n      Q = function (t) {\n    return Object(Z(t));\n  },\n      J = Q,\n      tt = {}.hasOwnProperty,\n      et = Object.hasOwn || function (t, e) {\n    return tt.call(J(t), e);\n  },\n      it = 0,\n      ot = Math.random(),\n      nt = function (t) {\n    return \"Symbol(\" + String(void 0 === t ? \"\" : t) + \")_\" + (++it + ot).toString(36);\n  },\n      rt = n,\n      st = U.exports,\n      at = et,\n      ht = nt,\n      dt = L,\n      lt = H,\n      ct = st(\"wks\"),\n      ut = rt.Symbol,\n      ft = lt ? ut : ut && ut.withoutSetter || ht,\n      pt = function (t) {\n    return at(ct, t) && (dt || \"string\" == typeof ct[t]) || (dt && at(ut, t) ? ct[t] = ut[t] : ct[t] = ft(\"Symbol.\" + t)), ct[t];\n  },\n      vt = E,\n      gt = V,\n      yt = function (t, e) {\n    var i, o;\n    if (\"string\" === e && \"function\" == typeof (i = t.toString) && !q(o = i.call(t))) return o;\n    if (\"function\" == typeof (i = t.valueOf) && !q(o = i.call(t))) return o;\n    if (\"string\" !== e && \"function\" == typeof (i = t.toString) && !q(o = i.call(t))) return o;\n    throw TypeError(\"Can't convert object to primitive value\");\n  },\n      mt = pt(\"toPrimitive\"),\n      bt = function (t, e) {\n    if (!vt(t) || gt(t)) return t;\n    var i,\n        o = t[mt];\n\n    if (void 0 !== o) {\n      if (void 0 === e && (e = \"default\"), i = o.call(t, e), !vt(i) || gt(i)) return i;\n      throw TypeError(\"Can't convert object to primitive value\");\n    }\n\n    return void 0 === e && (e = \"number\"), yt(t, e);\n  },\n      wt = V,\n      kt = function (t) {\n    var e = bt(t, \"string\");\n    return wt(e) ? e : String(e);\n  },\n      _t = E,\n      xt = n.document,\n      Et = _t(xt) && _t(xt.createElement),\n      Ot = function (t) {\n    return Et ? xt.createElement(t) : {};\n  },\n      Ct = Ot,\n      St = !a && !s(function () {\n    return 7 != Object.defineProperty(Ct(\"div\"), \"a\", {\n      get: function () {\n        return 7;\n      }\n    }).a;\n  }),\n      Tt = a,\n      Mt = h,\n      Pt = p,\n      Dt = x,\n      Bt = kt,\n      It = et,\n      zt = St,\n      Ft = Object.getOwnPropertyDescriptor;\n\n  r.f = Tt ? Ft : function (t, e) {\n    if (t = Dt(t), e = Bt(e), zt) try {\n      return Ft(t, e);\n    } catch (t) {}\n    if (It(t, e)) return Pt(!Mt.f.call(t, e), t[e]);\n  };\n\n  var Nt = s,\n      At = /#|\\.prototype\\./,\n      Rt = function (t, e) {\n    var i = Lt[jt(t)];\n    return i == Wt || i != Ht && (\"function\" == typeof e ? Nt(e) : !!e);\n  },\n      jt = Rt.normalize = function (t) {\n    return String(t).replace(At, \".\").toLowerCase();\n  },\n      Lt = Rt.data = {},\n      Ht = Rt.NATIVE = \"N\",\n      Wt = Rt.POLYFILL = \"P\",\n      Vt = Rt,\n      qt = function (t) {\n    if (\"function\" != typeof t) throw TypeError(String(t) + \" is not a function\");\n    return t;\n  },\n      Ut = qt,\n      Yt = function (t, e, i) {\n    if (Ut(t), void 0 === e) return t;\n\n    switch (i) {\n      case 0:\n        return function () {\n          return t.call(e);\n        };\n\n      case 1:\n        return function (i) {\n          return t.call(e, i);\n        };\n\n      case 2:\n        return function (i, o) {\n          return t.call(e, i, o);\n        };\n\n      case 3:\n        return function (i, o, n) {\n          return t.call(e, i, o, n);\n        };\n    }\n\n    return function () {\n      return t.apply(e, arguments);\n    };\n  },\n      Xt = {},\n      Gt = E,\n      Kt = function (t) {\n    if (!Gt(t)) throw TypeError(String(t) + \" is not an object\");\n    return t;\n  },\n      $t = a,\n      Zt = St,\n      Qt = Kt,\n      Jt = kt,\n      te = Object.defineProperty;\n\n  Xt.f = $t ? te : function (t, e, i) {\n    if (Qt(t), e = Jt(e), Qt(i), Zt) try {\n      return te(t, e, i);\n    } catch (t) {}\n    if (\"get\" in i || \"set\" in i) throw TypeError(\"Accessors not supported\");\n    return \"value\" in i && (t[e] = i.value), t;\n  };\n\n  var ee = Xt,\n      ie = p,\n      oe = a ? function (t, e, i) {\n    return ee.f(t, e, ie(1, i));\n  } : function (t, e, i) {\n    return t[e] = i, t;\n  },\n      ne = n,\n      re = r.f,\n      se = Vt,\n      ae = O,\n      he = Yt,\n      de = oe,\n      le = et,\n      ce = function (t) {\n    var e = function (e, i, o) {\n      if (this instanceof t) {\n        switch (arguments.length) {\n          case 0:\n            return new t();\n\n          case 1:\n            return new t(e);\n\n          case 2:\n            return new t(e, i);\n        }\n\n        return new t(e, i, o);\n      }\n\n      return t.apply(this, arguments);\n    };\n\n    return e.prototype = t.prototype, e;\n  },\n      ue = function (t, e) {\n    var i,\n        o,\n        n,\n        r,\n        s,\n        a,\n        h,\n        d,\n        l = t.target,\n        c = t.global,\n        u = t.stat,\n        f = t.proto,\n        p = c ? ne : u ? ne[l] : (ne[l] || {}).prototype,\n        v = c ? ae : ae[l] || (ae[l] = {}),\n        g = v.prototype;\n\n    for (n in e) i = !se(c ? n : l + (u ? \".\" : \"#\") + n, t.forced) && p && le(p, n), s = v[n], i && (a = t.noTargetGet ? (d = re(p, n)) && d.value : p[n]), r = i && a ? a : e[n], i && typeof s == typeof r || (h = t.bind && i ? he(r, ne) : t.wrap && i ? ce(r) : f && \"function\" == typeof r ? he(Function.call, r) : r, (t.sham || r && r.sham || s && s.sham) && de(h, \"sham\", !0), v[n] = h, f && (le(ae, o = l + \"Prototype\") || de(ae, o, {}), ae[o][n] = r, t.real && g && !g[n] && de(g, n, r)));\n  },\n      fe = Math.ceil,\n      pe = Math.floor,\n      ve = function (t) {\n    return isNaN(t = +t) ? 0 : (t > 0 ? pe : fe)(t);\n  },\n      ge = ve,\n      ye = Math.min,\n      me = function (t) {\n    return t > 0 ? ye(ge(t), 9007199254740991) : 0;\n  },\n      be = ve,\n      we = Math.max,\n      ke = Math.min,\n      _e = function (t, e) {\n    var i = be(t);\n    return i < 0 ? we(i + e, 0) : ke(i, e);\n  },\n      xe = x,\n      Ee = me,\n      Oe = _e,\n      Ce = function (t) {\n    return function (e, i, o) {\n      var n,\n          r = xe(e),\n          s = Ee(r.length),\n          a = Oe(o, s);\n\n      if (t && i != i) {\n        for (; s > a;) if ((n = r[a++]) != n) return !0;\n      } else for (; s > a; a++) if ((t || a in r) && r[a] === i) return t || a || 0;\n\n      return !t && -1;\n    };\n  },\n      Se = {\n    includes: Ce(!0),\n    indexOf: Ce(!1)\n  },\n      Te = {},\n      Me = et,\n      Pe = x,\n      De = Se.indexOf,\n      Be = Te,\n      Ie = function (t, e) {\n    var i,\n        o = Pe(t),\n        n = 0,\n        r = [];\n\n    for (i in o) !Me(Be, i) && Me(o, i) && r.push(i);\n\n    for (; e.length > n;) Me(o, i = e[n++]) && (~De(r, i) || r.push(i));\n\n    return r;\n  },\n      ze = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"],\n      Fe = Ie,\n      Ne = ze,\n      Ae = Object.keys || function (t) {\n    return Fe(t, Ne);\n  },\n      Re = {};\n\n  Re.f = Object.getOwnPropertySymbols;\n  var je = a,\n      Le = s,\n      He = Ae,\n      We = Re,\n      Ve = h,\n      qe = Q,\n      Ue = b,\n      Ye = Object.assign,\n      Xe = Object.defineProperty,\n      Ge = !Ye || Le(function () {\n    if (je && 1 !== Ye({\n      b: 1\n    }, Ye(Xe({}, \"a\", {\n      enumerable: !0,\n      get: function () {\n        Xe(this, \"b\", {\n          value: 3,\n          enumerable: !1\n        });\n      }\n    }), {\n      b: 2\n    })).b) return !0;\n    var t = {},\n        e = {},\n        i = Symbol(),\n        o = \"abcdefghijklmnopqrst\";\n    return t[i] = 7, o.split(\"\").forEach(function (t) {\n      e[t] = t;\n    }), 7 != Ye({}, t)[i] || He(Ye({}, e)).join(\"\") != o;\n  }) ? function (t, e) {\n    for (var i = qe(t), o = arguments.length, n = 1, r = We.f, s = Ve.f; o > n;) for (var a, h = Ue(arguments[n++]), d = r ? He(h).concat(r(h)) : He(h), l = d.length, c = 0; l > c;) a = d[c++], je && !s.call(h, a) || (i[a] = h[a]);\n\n    return i;\n  } : Ye;\n  ue({\n    target: \"Object\",\n    stat: !0,\n    forced: Object.assign !== Ge\n  }, {\n    assign: Ge\n  });\n\n  var Ke = O.Object.assign,\n      $e = qt,\n      Ze = E,\n      Qe = [].slice,\n      Je = {},\n      ti = function (t, e, i) {\n    if (!(e in Je)) {\n      for (var o = [], n = 0; n < e; n++) o[n] = \"a[\" + n + \"]\";\n\n      Je[e] = Function(\"C,a\", \"return new C(\" + o.join(\",\") + \")\");\n    }\n\n    return Je[e](t, i);\n  },\n      ei = Function.bind || function (t) {\n    var e = $e(this),\n        i = Qe.call(arguments, 1),\n        o = function () {\n      var n = i.concat(Qe.call(arguments));\n      return this instanceof o ? ti(e, n.length, n) : e.apply(t, n);\n    };\n\n    return Ze(e.prototype) && (o.prototype = e.prototype), o;\n  };\n\n  ue({\n    target: \"Function\",\n    proto: !0\n  }, {\n    bind: ei\n  });\n\n  var ii = O,\n      oi = function (t) {\n    return ii[t + \"Prototype\"];\n  },\n      ni = oi(\"Function\").bind,\n      ri = Function.prototype,\n      si = function (t) {\n    var e = t.bind;\n    return t === ri || t instanceof Function && e === ri.bind ? ni : e;\n  };\n\n  function ai(t, e, i, o) {\n    t.beginPath(), t.arc(e, i, o, 0, 2 * Math.PI, !1), t.closePath();\n  }\n\n  function hi(t, e, i, o, n, r) {\n    var s = Math.PI / 180;\n    o - 2 * r < 0 && (r = o / 2), n - 2 * r < 0 && (r = n / 2), t.beginPath(), t.moveTo(e + r, i), t.lineTo(e + o - r, i), t.arc(e + o - r, i + r, r, 270 * s, 360 * s, !1), t.lineTo(e + o, i + n - r), t.arc(e + o - r, i + n - r, r, 0, 90 * s, !1), t.lineTo(e + r, i + n), t.arc(e + r, i + n - r, r, 90 * s, 180 * s, !1), t.lineTo(e, i + r), t.arc(e + r, i + r, r, 180 * s, 270 * s, !1), t.closePath();\n  }\n\n  function di(t, e, i, o, n) {\n    var r = .5522848,\n        s = o / 2 * r,\n        a = n / 2 * r,\n        h = e + o,\n        d = i + n,\n        l = e + o / 2,\n        c = i + n / 2;\n    t.beginPath(), t.moveTo(e, c), t.bezierCurveTo(e, c - a, l - s, i, l, i), t.bezierCurveTo(l + s, i, h, c - a, h, c), t.bezierCurveTo(h, c + a, l + s, d, l, d), t.bezierCurveTo(l - s, d, e, c + a, e, c), t.closePath();\n  }\n\n  function li(t, e, i, o, n) {\n    var r = n * (1 / 3),\n        s = .5522848,\n        a = o / 2 * s,\n        h = r / 2 * s,\n        d = e + o,\n        l = i + r,\n        c = e + o / 2,\n        u = i + r / 2,\n        f = i + (n - r / 2),\n        p = i + n;\n    t.beginPath(), t.moveTo(d, u), t.bezierCurveTo(d, u + h, c + a, l, c, l), t.bezierCurveTo(c - a, l, e, u + h, e, u), t.bezierCurveTo(e, u - h, c - a, i, c, i), t.bezierCurveTo(c + a, i, d, u - h, d, u), t.lineTo(d, f), t.bezierCurveTo(d, f + h, c + a, p, c, p), t.bezierCurveTo(c - a, p, e, f + h, e, f), t.lineTo(e, u);\n  }\n\n  function ci(t, e, i, o, n, r) {\n    t.beginPath(), t.moveTo(e, i);\n\n    for (var s = r.length, a = o - e, h = n - i, d = h / a, l = Math.sqrt(a * a + h * h), c = 0, u = !0, f = 0, p = +r[0]; l >= .1;) (p = +r[c++ % s]) > l && (p = l), f = Math.sqrt(p * p / (1 + d * d)), e += f = a < 0 ? -f : f, i += d * f, !0 === u ? t.lineTo(e, i) : t.moveTo(e, i), l -= p, u = !u;\n  }\n\n  var ui = {\n    circle: ai,\n    dashedLine: ci,\n    database: li,\n    diamond: function (t, e, i, o) {\n      t.beginPath(), t.lineTo(e, i + o), t.lineTo(e + o, i), t.lineTo(e, i - o), t.lineTo(e - o, i), t.closePath();\n    },\n    ellipse: di,\n    ellipse_vis: di,\n    hexagon: function (t, e, i, o) {\n      t.beginPath();\n      var n = 2 * Math.PI / 6;\n      t.moveTo(e + o, i);\n\n      for (var r = 1; r < 6; r++) t.lineTo(e + o * Math.cos(n * r), i + o * Math.sin(n * r));\n\n      t.closePath();\n    },\n    roundRect: hi,\n    square: function (t, e, i, o) {\n      t.beginPath(), t.rect(e - o, i - o, 2 * o, 2 * o), t.closePath();\n    },\n    star: function (t, e, i, o) {\n      t.beginPath(), i += .1 * (o *= .82);\n\n      for (var n = 0; n < 10; n++) {\n        var r = n % 2 == 0 ? 1.3 * o : .5 * o;\n        t.lineTo(e + r * Math.sin(2 * n * Math.PI / 10), i - r * Math.cos(2 * n * Math.PI / 10));\n      }\n\n      t.closePath();\n    },\n    triangle: function (t, e, i, o) {\n      t.beginPath(), i += .275 * (o *= 1.15);\n      var n = 2 * o,\n          r = n / 2,\n          s = Math.sqrt(3) / 6 * n,\n          a = Math.sqrt(n * n - r * r);\n      t.moveTo(e, i - (a - s)), t.lineTo(e + r, i + s), t.lineTo(e - r, i + s), t.lineTo(e, i - (a - s)), t.closePath();\n    },\n    triangleDown: function (t, e, i, o) {\n      t.beginPath(), i -= .275 * (o *= 1.15);\n      var n = 2 * o,\n          r = n / 2,\n          s = Math.sqrt(3) / 6 * n,\n          a = Math.sqrt(n * n - r * r);\n      t.moveTo(e, i + (a - s)), t.lineTo(e + r, i - s), t.lineTo(e - r, i - s), t.lineTo(e, i + (a - s)), t.closePath();\n    }\n  };\n  var fi = {\n    exports: {}\n  };\n  !function (t) {\n    function e(t) {\n      if (t) return function (t) {\n        for (var i in e.prototype) t[i] = e.prototype[i];\n\n        return t;\n      }(t);\n    }\n\n    t.exports = e, e.prototype.on = e.prototype.addEventListener = function (t, e) {\n      return this._callbacks = this._callbacks || {}, (this._callbacks[\"$\" + t] = this._callbacks[\"$\" + t] || []).push(e), this;\n    }, e.prototype.once = function (t, e) {\n      function i() {\n        this.off(t, i), e.apply(this, arguments);\n      }\n\n      return i.fn = e, this.on(t, i), this;\n    }, e.prototype.off = e.prototype.removeListener = e.prototype.removeAllListeners = e.prototype.removeEventListener = function (t, e) {\n      if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;\n      var i,\n          o = this._callbacks[\"$\" + t];\n      if (!o) return this;\n      if (1 == arguments.length) return delete this._callbacks[\"$\" + t], this;\n\n      for (var n = 0; n < o.length; n++) if ((i = o[n]) === e || i.fn === e) {\n        o.splice(n, 1);\n        break;\n      }\n\n      return 0 === o.length && delete this._callbacks[\"$\" + t], this;\n    }, e.prototype.emit = function (t) {\n      this._callbacks = this._callbacks || {};\n\n      for (var e = new Array(arguments.length - 1), i = this._callbacks[\"$\" + t], o = 1; o < arguments.length; o++) e[o - 1] = arguments[o];\n\n      if (i) {\n        o = 0;\n\n        for (var n = (i = i.slice(0)).length; o < n; ++o) i[o].apply(this, e);\n      }\n\n      return this;\n    }, e.prototype.listeners = function (t) {\n      return this._callbacks = this._callbacks || {}, this._callbacks[\"$\" + t] || [];\n    }, e.prototype.hasListeners = function (t) {\n      return !!this.listeners(t).length;\n    };\n  }(fi);\n\n  var pi = fi.exports,\n      vi = V,\n      gi = function (t) {\n    if (vi(t)) throw TypeError(\"Cannot convert a Symbol value to a string\");\n    return String(t);\n  },\n      yi = ve,\n      mi = gi,\n      bi = w,\n      wi = function (t) {\n    return function (e, i) {\n      var o,\n          n,\n          r = mi(bi(e)),\n          s = yi(i),\n          a = r.length;\n      return s < 0 || s >= a ? t ? \"\" : void 0 : (o = r.charCodeAt(s)) < 55296 || o > 56319 || s + 1 === a || (n = r.charCodeAt(s + 1)) < 56320 || n > 57343 ? t ? r.charAt(s) : o : t ? r.slice(s, s + 2) : n - 56320 + (o - 55296 << 10) + 65536;\n    };\n  },\n      ki = {\n    codeAt: wi(!1),\n    charAt: wi(!0)\n  },\n      _i = K,\n      xi = Function.toString;\n\n  \"function\" != typeof _i.inspectSource && (_i.inspectSource = function (t) {\n    return xi.call(t);\n  });\n\n  var Ei,\n      Oi,\n      Ci,\n      Si = _i.inspectSource,\n      Ti = n.WeakMap,\n      Mi = \"function\" == typeof Ti && /native code/.test(Si(Ti)),\n      Pi = U.exports,\n      Di = nt,\n      Bi = Pi(\"keys\"),\n      Ii = function (t) {\n    return Bi[t] || (Bi[t] = Di(t));\n  },\n      zi = Mi,\n      Fi = E,\n      Ni = oe,\n      Ai = et,\n      Ri = K,\n      ji = Ii,\n      Li = Te,\n      Hi = \"Object already initialized\",\n      Wi = n.WeakMap;\n\n  if (zi || Ri.state) {\n    var Vi = Ri.state || (Ri.state = new Wi()),\n        qi = Vi.get,\n        Ui = Vi.has,\n        Yi = Vi.set;\n    Ei = function (t, e) {\n      if (Ui.call(Vi, t)) throw new TypeError(Hi);\n      return e.facade = t, Yi.call(Vi, t, e), e;\n    }, Oi = function (t) {\n      return qi.call(Vi, t) || {};\n    }, Ci = function (t) {\n      return Ui.call(Vi, t);\n    };\n  } else {\n    var Xi = ji(\"state\");\n    Li[Xi] = !0, Ei = function (t, e) {\n      if (Ai(t, Xi)) throw new TypeError(Hi);\n      return e.facade = t, Ni(t, Xi, e), e;\n    }, Oi = function (t) {\n      return Ai(t, Xi) ? t[Xi] : {};\n    }, Ci = function (t) {\n      return Ai(t, Xi);\n    };\n  }\n\n  var Gi,\n      Ki,\n      $i,\n      Zi = {\n    set: Ei,\n    get: Oi,\n    has: Ci,\n    enforce: function (t) {\n      return Ci(t) ? Oi(t) : Ei(t, {});\n    },\n    getterFor: function (t) {\n      return function (e) {\n        var i;\n        if (!Fi(e) || (i = Oi(e)).type !== t) throw TypeError(\"Incompatible receiver, \" + t + \" required\");\n        return i;\n      };\n    }\n  },\n      Qi = !s(function () {\n    function t() {}\n\n    return t.prototype.constructor = null, Object.getPrototypeOf(new t()) !== t.prototype;\n  }),\n      Ji = et,\n      to = Q,\n      eo = Qi,\n      io = Ii(\"IE_PROTO\"),\n      oo = Object.prototype,\n      no = eo ? Object.getPrototypeOf : function (t) {\n    return t = to(t), Ji(t, io) ? t[io] : \"function\" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? oo : null;\n  },\n      ro = s,\n      so = no,\n      ao = oe,\n      ho = et,\n      lo = pt(\"iterator\"),\n      co = !1;\n  [].keys && (\"next\" in ($i = [].keys()) ? (Ki = so(so($i))) !== Object.prototype && (Gi = Ki) : co = !0);\n  var uo = null == Gi || ro(function () {\n    var t = {};\n    return Gi[lo].call(t) !== t;\n  });\n  uo && (Gi = {}), uo && !ho(Gi, lo) && ao(Gi, lo, function () {\n    return this;\n  });\n\n  var fo,\n      po = {\n    IteratorPrototype: Gi,\n    BUGGY_SAFARI_ITERATORS: co\n  },\n      vo = Xt,\n      go = Kt,\n      yo = Ae,\n      mo = a ? Object.defineProperties : function (t, e) {\n    go(t);\n\n    for (var i, o = yo(e), n = o.length, r = 0; n > r;) vo.f(t, i = o[r++], e[i]);\n\n    return t;\n  },\n      bo = M(\"document\", \"documentElement\"),\n      wo = Kt,\n      ko = mo,\n      _o = ze,\n      xo = Te,\n      Eo = bo,\n      Oo = Ot,\n      Co = Ii(\"IE_PROTO\"),\n      So = function () {},\n      To = function (t) {\n    return \"<script>\" + t + \"</\" + \"script>\";\n  },\n      Mo = function (t) {\n    t.write(To(\"\")), t.close();\n    var e = t.parentWindow.Object;\n    return t = null, e;\n  },\n      Po = function () {\n    try {\n      fo = new ActiveXObject(\"htmlfile\");\n    } catch (t) {}\n\n    Po = document.domain && fo ? Mo(fo) : function () {\n      var t,\n          e = Oo(\"iframe\");\n      if (e.style) return e.style.display = \"none\", Eo.appendChild(e), e.src = String(\"javascript:\"), (t = e.contentWindow.document).open(), t.write(To(\"document.F=Object\")), t.close(), t.F;\n    }() || Mo(fo);\n\n    for (var t = _o.length; t--;) delete Po.prototype[_o[t]];\n\n    return Po();\n  };\n\n  xo[Co] = !0;\n\n  var Do = Object.create || function (t, e) {\n    var i;\n    return null !== t ? (So.prototype = wo(t), i = new So(), So.prototype = null, i[Co] = t) : i = Po(), void 0 === e ? i : ko(i, e);\n  },\n      Bo = {};\n\n  Bo[pt(\"toStringTag\")] = \"z\";\n\n  var Io = \"[object z]\" === String(Bo),\n      zo = Io,\n      Fo = g,\n      No = pt(\"toStringTag\"),\n      Ao = \"Arguments\" == Fo(function () {\n    return arguments;\n  }()),\n      Ro = zo ? Fo : function (t) {\n    var e, i, o;\n    return void 0 === t ? \"Undefined\" : null === t ? \"Null\" : \"string\" == typeof (i = function (t, e) {\n      try {\n        return t[e];\n      } catch (t) {}\n    }(e = Object(t), No)) ? i : Ao ? Fo(e) : \"Object\" == (o = Fo(e)) && \"function\" == typeof e.callee ? \"Arguments\" : o;\n  },\n      jo = Ro,\n      Lo = Io ? {}.toString : function () {\n    return \"[object \" + jo(this) + \"]\";\n  },\n      Ho = Io,\n      Wo = Xt.f,\n      Vo = oe,\n      qo = et,\n      Uo = Lo,\n      Yo = pt(\"toStringTag\"),\n      Xo = function (t, e, i, o) {\n    if (t) {\n      var n = i ? t : t.prototype;\n      qo(n, Yo) || Wo(n, Yo, {\n        configurable: !0,\n        value: e\n      }), o && !Ho && Vo(n, \"toString\", Uo);\n    }\n  },\n      Go = {},\n      Ko = po.IteratorPrototype,\n      $o = Do,\n      Zo = p,\n      Qo = Xo,\n      Jo = Go,\n      tn = function () {\n    return this;\n  },\n      en = E,\n      on = Kt,\n      nn = function (t) {\n    if (!en(t) && null !== t) throw TypeError(\"Can't set \" + String(t) + \" as a prototype\");\n    return t;\n  },\n      rn = Object.setPrototypeOf || (\"__proto__\" in {} ? function () {\n    var t,\n        e = !1,\n        i = {};\n\n    try {\n      (t = Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set).call(i, []), e = i instanceof Array;\n    } catch (t) {}\n\n    return function (i, o) {\n      return on(i), nn(o), e ? t.call(i, o) : i.__proto__ = o, i;\n    };\n  }() : void 0),\n      sn = oe,\n      an = function (t, e, i, o) {\n    o && o.enumerable ? t[e] = i : sn(t, e, i);\n  },\n      hn = ue,\n      dn = function (t, e, i) {\n    var o = e + \" Iterator\";\n    return t.prototype = $o(Ko, {\n      next: Zo(1, i)\n    }), Qo(t, o, !1, !0), Jo[o] = tn, t;\n  },\n      ln = no,\n      cn = Xo,\n      un = oe,\n      fn = an,\n      pn = Go,\n      vn = po.IteratorPrototype,\n      gn = po.BUGGY_SAFARI_ITERATORS,\n      yn = pt(\"iterator\"),\n      mn = \"keys\",\n      bn = \"values\",\n      wn = \"entries\",\n      kn = function () {\n    return this;\n  },\n      _n = function (t, e, i, o, n, r, s) {\n    dn(i, e, o);\n\n    var a,\n        h,\n        d,\n        l = function (t) {\n      if (t === n && v) return v;\n      if (!gn && t in f) return f[t];\n\n      switch (t) {\n        case mn:\n        case bn:\n        case wn:\n          return function () {\n            return new i(this, t);\n          };\n      }\n\n      return function () {\n        return new i(this);\n      };\n    },\n        c = e + \" Iterator\",\n        u = !1,\n        f = t.prototype,\n        p = f[yn] || f[\"@@iterator\"] || n && f[n],\n        v = !gn && p || l(n),\n        g = \"Array\" == e && f.entries || p;\n\n    if (g && (a = ln(g.call(new t())), vn !== Object.prototype && a.next && (cn(a, c, !0, !0), pn[c] = kn)), n == bn && p && p.name !== bn && (u = !0, v = function () {\n      return p.call(this);\n    }), s && f[yn] !== v && un(f, yn, v), pn[e] = v, n) if (h = {\n      values: l(bn),\n      keys: r ? v : l(mn),\n      entries: l(wn)\n    }, s) for (d in h) (gn || u || !(d in f)) && fn(f, d, h[d]);else hn({\n      target: e,\n      proto: !0,\n      forced: gn || u\n    }, h);\n    return h;\n  },\n      xn = ki.charAt,\n      En = gi,\n      On = Zi,\n      Cn = _n,\n      Sn = \"String Iterator\",\n      Tn = On.set,\n      Mn = On.getterFor(Sn);\n\n  Cn(String, \"String\", function (t) {\n    Tn(this, {\n      type: Sn,\n      string: En(t),\n      index: 0\n    });\n  }, function () {\n    var t,\n        e = Mn(this),\n        i = e.string,\n        o = e.index;\n    return o >= i.length ? {\n      value: void 0,\n      done: !0\n    } : (t = xn(i, o), e.index += t.length, {\n      value: t,\n      done: !1\n    });\n  });\n\n  var Pn = Kt,\n      Dn = function (t) {\n    var e = t.return;\n    if (void 0 !== e) return Pn(e.call(t)).value;\n  },\n      Bn = Kt,\n      In = Dn,\n      zn = Go,\n      Fn = pt(\"iterator\"),\n      Nn = Array.prototype,\n      An = function (t) {\n    return void 0 !== t && (zn.Array === t || Nn[Fn] === t);\n  },\n      Rn = kt,\n      jn = Xt,\n      Ln = p,\n      Hn = function (t, e, i) {\n    var o = Rn(e);\n    o in t ? jn.f(t, o, Ln(0, i)) : t[o] = i;\n  },\n      Wn = Ro,\n      Vn = Go,\n      qn = pt(\"iterator\"),\n      Un = function (t) {\n    if (null != t) return t[qn] || t[\"@@iterator\"] || Vn[Wn(t)];\n  },\n      Yn = Yt,\n      Xn = Q,\n      Gn = function (t, e, i, o) {\n    try {\n      return o ? e(Bn(i)[0], i[1]) : e(i);\n    } catch (e) {\n      throw In(t), e;\n    }\n  },\n      Kn = An,\n      $n = me,\n      Zn = Hn,\n      Qn = Un,\n      Jn = pt(\"iterator\"),\n      tr = !1;\n\n  try {\n    var er = 0,\n        ir = {\n      next: function () {\n        return {\n          done: !!er++\n        };\n      },\n      return: function () {\n        tr = !0;\n      }\n    };\n    ir[Jn] = function () {\n      return this;\n    }, Array.from(ir, function () {\n      throw 2;\n    });\n  } catch (t) {}\n\n  var or = function (t) {\n    var e,\n        i,\n        o,\n        n,\n        r,\n        s,\n        a = Xn(t),\n        h = \"function\" == typeof this ? this : Array,\n        d = arguments.length,\n        l = d > 1 ? arguments[1] : void 0,\n        c = void 0 !== l,\n        u = Qn(a),\n        f = 0;\n    if (c && (l = Yn(l, d > 2 ? arguments[2] : void 0, 2)), null == u || h == Array && Kn(u)) for (i = new h(e = $n(a.length)); e > f; f++) s = c ? l(a[f], f) : a[f], Zn(i, f, s);else for (r = (n = u.call(a)).next, i = new h(); !(o = r.call(n)).done; f++) s = c ? Gn(n, l, [o.value, f], !0) : o.value, Zn(i, f, s);\n    return i.length = f, i;\n  };\n\n  ue({\n    target: \"Array\",\n    stat: !0,\n    forced: !function (t, e) {\n      if (!e && !tr) return !1;\n      var i = !1;\n\n      try {\n        var o = {};\n        o[Jn] = function () {\n          return {\n            next: function () {\n              return {\n                done: i = !0\n              };\n            }\n          };\n        }, t(o);\n      } catch (t) {}\n\n      return i;\n    }(function (t) {\n      Array.from(t);\n    })\n  }, {\n    from: or\n  });\n  var nr = O.Array.from,\n      rr = nr,\n      sr = x,\n      ar = Go,\n      hr = Zi,\n      dr = _n,\n      lr = \"Array Iterator\",\n      cr = hr.set,\n      ur = hr.getterFor(lr);\n  dr(Array, \"Array\", function (t, e) {\n    cr(this, {\n      type: lr,\n      target: sr(t),\n      index: 0,\n      kind: e\n    });\n  }, function () {\n    var t = ur(this),\n        e = t.target,\n        i = t.kind,\n        o = t.index++;\n    return !e || o >= e.length ? (t.target = void 0, {\n      value: void 0,\n      done: !0\n    }) : \"keys\" == i ? {\n      value: o,\n      done: !1\n    } : \"values\" == i ? {\n      value: e[o],\n      done: !1\n    } : {\n      value: [o, e[o]],\n      done: !1\n    };\n  }, \"values\"), ar.Arguments = ar.Array;\n  var fr = Un,\n      pr = {\n    CSSRuleList: 0,\n    CSSStyleDeclaration: 0,\n    CSSValueList: 0,\n    ClientRectList: 0,\n    DOMRectList: 0,\n    DOMStringList: 0,\n    DOMTokenList: 1,\n    DataTransferItemList: 0,\n    FileList: 0,\n    HTMLAllCollection: 0,\n    HTMLCollection: 0,\n    HTMLFormElement: 0,\n    HTMLSelectElement: 0,\n    MediaList: 0,\n    MimeTypeArray: 0,\n    NamedNodeMap: 0,\n    NodeList: 1,\n    PaintRequestList: 0,\n    Plugin: 0,\n    PluginArray: 0,\n    SVGLengthList: 0,\n    SVGNumberList: 0,\n    SVGPathSegList: 0,\n    SVGPointList: 0,\n    SVGStringList: 0,\n    SVGTransformList: 0,\n    SourceBufferList: 0,\n    StyleSheetList: 0,\n    TextTrackCueList: 0,\n    TextTrackList: 0,\n    TouchList: 0\n  },\n      vr = n,\n      gr = Ro,\n      yr = oe,\n      mr = Go,\n      br = pt(\"toStringTag\");\n\n  for (var wr in pr) {\n    var kr = vr[wr],\n        _r = kr && kr.prototype;\n\n    _r && gr(_r) !== br && yr(_r, br, wr), mr[wr] = mr.Array;\n  }\n\n  var xr = fr,\n      Er = g,\n      Or = Array.isArray || function (t) {\n    return \"Array\" == Er(t);\n  },\n      Cr = {},\n      Sr = Ie,\n      Tr = ze.concat(\"length\", \"prototype\");\n\n  Cr.f = Object.getOwnPropertyNames || function (t) {\n    return Sr(t, Tr);\n  };\n\n  var Mr = {},\n      Pr = x,\n      Dr = Cr.f,\n      Br = {}.toString,\n      Ir = \"object\" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];\n\n  Mr.f = function (t) {\n    return Ir && \"[object Window]\" == Br.call(t) ? function (t) {\n      try {\n        return Dr(t);\n      } catch (t) {\n        return Ir.slice();\n      }\n    }(t) : Dr(Pr(t));\n  };\n\n  var zr = {},\n      Fr = pt;\n  zr.f = Fr;\n\n  var Nr = O,\n      Ar = et,\n      Rr = zr,\n      jr = Xt.f,\n      Lr = function (t) {\n    var e = Nr.Symbol || (Nr.Symbol = {});\n    Ar(e, t) || jr(e, t, {\n      value: Rr.f(t)\n    });\n  },\n      Hr = E,\n      Wr = Or,\n      Vr = pt(\"species\"),\n      qr = function (t) {\n    var e;\n    return Wr(t) && (\"function\" != typeof (e = t.constructor) || e !== Array && !Wr(e.prototype) ? Hr(e) && null === (e = e[Vr]) && (e = void 0) : e = void 0), void 0 === e ? Array : e;\n  },\n      Ur = function (t, e) {\n    return new (qr(t))(0 === e ? 0 : e);\n  },\n      Yr = Yt,\n      Xr = b,\n      Gr = Q,\n      Kr = me,\n      $r = Ur,\n      Zr = [].push,\n      Qr = function (t) {\n    var e = 1 == t,\n        i = 2 == t,\n        o = 3 == t,\n        n = 4 == t,\n        r = 6 == t,\n        s = 7 == t,\n        a = 5 == t || r;\n    return function (h, d, l, c) {\n      for (var u, f, p = Gr(h), v = Xr(p), g = Yr(d, l, 3), y = Kr(v.length), m = 0, b = c || $r, w = e ? b(h, y) : i || s ? b(h, 0) : void 0; y > m; m++) if ((a || m in v) && (f = g(u = v[m], m, p), t)) if (e) w[m] = f;else if (f) switch (t) {\n        case 3:\n          return !0;\n\n        case 5:\n          return u;\n\n        case 6:\n          return m;\n\n        case 2:\n          Zr.call(w, u);\n      } else switch (t) {\n        case 4:\n          return !1;\n\n        case 7:\n          Zr.call(w, u);\n      }\n\n      return r ? -1 : o || n ? n : w;\n    };\n  },\n      Jr = {\n    forEach: Qr(0),\n    map: Qr(1),\n    filter: Qr(2),\n    some: Qr(3),\n    every: Qr(4),\n    find: Qr(5),\n    findIndex: Qr(6),\n    filterReject: Qr(7)\n  },\n      ts = ue,\n      es = n,\n      is = M,\n      os = a,\n      ns = L,\n      rs = s,\n      ss = et,\n      as = Or,\n      hs = E,\n      ds = V,\n      ls = Kt,\n      cs = Q,\n      us = x,\n      fs = kt,\n      ps = gi,\n      vs = p,\n      gs = Do,\n      ys = Ae,\n      ms = Cr,\n      bs = Mr,\n      ws = Re,\n      ks = r,\n      _s = Xt,\n      xs = h,\n      Es = oe,\n      Os = an,\n      Cs = U.exports,\n      Ss = Te,\n      Ts = nt,\n      Ms = pt,\n      Ps = zr,\n      Ds = Lr,\n      Bs = Xo,\n      Is = Zi,\n      zs = Jr.forEach,\n      Fs = Ii(\"hidden\"),\n      Ns = \"Symbol\",\n      As = Ms(\"toPrimitive\"),\n      Rs = Is.set,\n      js = Is.getterFor(Ns),\n      Ls = Object.prototype,\n      Hs = es.Symbol,\n      Ws = is(\"JSON\", \"stringify\"),\n      Vs = ks.f,\n      qs = _s.f,\n      Us = bs.f,\n      Ys = xs.f,\n      Xs = Cs(\"symbols\"),\n      Gs = Cs(\"op-symbols\"),\n      Ks = Cs(\"string-to-symbol-registry\"),\n      $s = Cs(\"symbol-to-string-registry\"),\n      Zs = Cs(\"wks\"),\n      Qs = es.QObject,\n      Js = !Qs || !Qs.prototype || !Qs.prototype.findChild,\n      ta = os && rs(function () {\n    return 7 != gs(qs({}, \"a\", {\n      get: function () {\n        return qs(this, \"a\", {\n          value: 7\n        }).a;\n      }\n    })).a;\n  }) ? function (t, e, i) {\n    var o = Vs(Ls, e);\n    o && delete Ls[e], qs(t, e, i), o && t !== Ls && qs(Ls, e, o);\n  } : qs,\n      ea = function (t, e) {\n    var i = Xs[t] = gs(Hs.prototype);\n    return Rs(i, {\n      type: Ns,\n      tag: t,\n      description: e\n    }), os || (i.description = e), i;\n  },\n      ia = function (t, e, i) {\n    t === Ls && ia(Gs, e, i), ls(t);\n    var o = fs(e);\n    return ls(i), ss(Xs, o) ? (i.enumerable ? (ss(t, Fs) && t[Fs][o] && (t[Fs][o] = !1), i = gs(i, {\n      enumerable: vs(0, !1)\n    })) : (ss(t, Fs) || qs(t, Fs, vs(1, {})), t[Fs][o] = !0), ta(t, o, i)) : qs(t, o, i);\n  },\n      oa = function (t, e) {\n    ls(t);\n    var i = us(e),\n        o = ys(i).concat(aa(i));\n    return zs(o, function (e) {\n      os && !na.call(i, e) || ia(t, e, i[e]);\n    }), t;\n  },\n      na = function (t) {\n    var e = fs(t),\n        i = Ys.call(this, e);\n    return !(this === Ls && ss(Xs, e) && !ss(Gs, e)) && (!(i || !ss(this, e) || !ss(Xs, e) || ss(this, Fs) && this[Fs][e]) || i);\n  },\n      ra = function (t, e) {\n    var i = us(t),\n        o = fs(e);\n\n    if (i !== Ls || !ss(Xs, o) || ss(Gs, o)) {\n      var n = Vs(i, o);\n      return !n || !ss(Xs, o) || ss(i, Fs) && i[Fs][o] || (n.enumerable = !0), n;\n    }\n  },\n      sa = function (t) {\n    var e = Us(us(t)),\n        i = [];\n    return zs(e, function (t) {\n      ss(Xs, t) || ss(Ss, t) || i.push(t);\n    }), i;\n  },\n      aa = function (t) {\n    var e = t === Ls,\n        i = Us(e ? Gs : us(t)),\n        o = [];\n    return zs(i, function (t) {\n      !ss(Xs, t) || e && !ss(Ls, t) || o.push(Xs[t]);\n    }), o;\n  };\n\n  (ns || (Os((Hs = function () {\n    if (this instanceof Hs) throw TypeError(\"Symbol is not a constructor\");\n\n    var t = arguments.length && void 0 !== arguments[0] ? ps(arguments[0]) : void 0,\n        e = Ts(t),\n        i = function (t) {\n      this === Ls && i.call(Gs, t), ss(this, Fs) && ss(this[Fs], e) && (this[Fs][e] = !1), ta(this, e, vs(1, t));\n    };\n\n    return os && Js && ta(Ls, e, {\n      configurable: !0,\n      set: i\n    }), ea(e, t);\n  }).prototype, \"toString\", function () {\n    return js(this).tag;\n  }), Os(Hs, \"withoutSetter\", function (t) {\n    return ea(Ts(t), t);\n  }), xs.f = na, _s.f = ia, ks.f = ra, ms.f = bs.f = sa, ws.f = aa, Ps.f = function (t) {\n    return ea(Ms(t), t);\n  }, os && qs(Hs.prototype, \"description\", {\n    configurable: !0,\n    get: function () {\n      return js(this).description;\n    }\n  })), ts({\n    global: !0,\n    wrap: !0,\n    forced: !ns,\n    sham: !ns\n  }, {\n    Symbol: Hs\n  }), zs(ys(Zs), function (t) {\n    Ds(t);\n  }), ts({\n    target: Ns,\n    stat: !0,\n    forced: !ns\n  }, {\n    for: function (t) {\n      var e = ps(t);\n      if (ss(Ks, e)) return Ks[e];\n      var i = Hs(e);\n      return Ks[e] = i, $s[i] = e, i;\n    },\n    keyFor: function (t) {\n      if (!ds(t)) throw TypeError(t + \" is not a symbol\");\n      if (ss($s, t)) return $s[t];\n    },\n    useSetter: function () {\n      Js = !0;\n    },\n    useSimple: function () {\n      Js = !1;\n    }\n  }), ts({\n    target: \"Object\",\n    stat: !0,\n    forced: !ns,\n    sham: !os\n  }, {\n    create: function (t, e) {\n      return void 0 === e ? gs(t) : oa(gs(t), e);\n    },\n    defineProperty: ia,\n    defineProperties: oa,\n    getOwnPropertyDescriptor: ra\n  }), ts({\n    target: \"Object\",\n    stat: !0,\n    forced: !ns\n  }, {\n    getOwnPropertyNames: sa,\n    getOwnPropertySymbols: aa\n  }), ts({\n    target: \"Object\",\n    stat: !0,\n    forced: rs(function () {\n      ws.f(1);\n    })\n  }, {\n    getOwnPropertySymbols: function (t) {\n      return ws.f(cs(t));\n    }\n  }), Ws) && ts({\n    target: \"JSON\",\n    stat: !0,\n    forced: !ns || rs(function () {\n      var t = Hs();\n      return \"[null]\" != Ws([t]) || \"{}\" != Ws({\n        a: t\n      }) || \"{}\" != Ws(Object(t));\n    })\n  }, {\n    stringify: function (t, e, i) {\n      for (var o, n = [t], r = 1; arguments.length > r;) n.push(arguments[r++]);\n\n      if (o = e, (hs(e) || void 0 !== t) && !ds(t)) return as(e) || (e = function (t, e) {\n        if (\"function\" == typeof o && (e = o.call(this, t, e)), !ds(e)) return e;\n      }), n[1] = e, Ws.apply(null, n);\n    }\n  });\n  Hs.prototype[As] || Es(Hs.prototype, As, Hs.prototype.valueOf), Bs(Hs, Ns), Ss[Fs] = !0;\n  var ha = O.Object.getOwnPropertySymbols,\n      da = {\n    exports: {}\n  },\n      la = ue,\n      ca = s,\n      ua = x,\n      fa = r.f,\n      pa = a,\n      va = ca(function () {\n    fa(1);\n  });\n  la({\n    target: \"Object\",\n    stat: !0,\n    forced: !pa || va,\n    sham: !pa\n  }, {\n    getOwnPropertyDescriptor: function (t, e) {\n      return fa(ua(t), e);\n    }\n  });\n\n  var ga = O.Object,\n      ya = da.exports = function (t, e) {\n    return ga.getOwnPropertyDescriptor(t, e);\n  };\n\n  ga.getOwnPropertyDescriptor.sham && (ya.sham = !0);\n\n  var ma = da.exports,\n      ba = ma,\n      wa = Cr,\n      ka = Re,\n      _a = Kt,\n      xa = M(\"Reflect\", \"ownKeys\") || function (t) {\n    var e = wa.f(_a(t)),\n        i = ka.f;\n    return i ? e.concat(i(t)) : e;\n  },\n      Ea = xa,\n      Oa = x,\n      Ca = r,\n      Sa = Hn;\n\n  ue({\n    target: \"Object\",\n    stat: !0,\n    sham: !a\n  }, {\n    getOwnPropertyDescriptors: function (t) {\n      for (var e, i, o = Oa(t), n = Ca.f, r = Ea(o), s = {}, a = 0; r.length > a;) void 0 !== (i = n(o, e = r[a++])) && Sa(s, e, i);\n\n      return s;\n    }\n  });\n  var Ta = O.Object.getOwnPropertyDescriptors,\n      Ma = {\n    exports: {}\n  };\n  ue({\n    target: \"Object\",\n    stat: !0,\n    forced: !a,\n    sham: !a\n  }, {\n    defineProperties: mo\n  });\n\n  var Pa = O.Object,\n      Da = Ma.exports = function (t, e) {\n    return Pa.defineProperties(t, e);\n  };\n\n  Pa.defineProperties.sham && (Da.sham = !0);\n  var Ba = Ma.exports,\n      Ia = {\n    exports: {}\n  };\n  ue({\n    target: \"Object\",\n    stat: !0,\n    forced: !a,\n    sham: !a\n  }, {\n    defineProperty: Xt.f\n  });\n\n  var za = O.Object,\n      Fa = Ia.exports = function (t, e, i) {\n    return za.defineProperty(t, e, i);\n  };\n\n  za.defineProperty.sham && (Fa.sham = !0);\n  var Na = Ia.exports,\n      Aa = Na;\n\n  function Ra(t, e) {\n    if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  var ja = Na;\n\n  function La(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var o = e[i];\n      o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), ja(t, o.key, o);\n    }\n  }\n\n  function Ha(t, e, i) {\n    return e && La(t.prototype, e), i && La(t, i), t;\n  }\n\n  function Wa(t, e, i) {\n    return e in t ? ja(t, e, {\n      value: i,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = i, t;\n  }\n\n  ue({\n    target: \"Array\",\n    stat: !0\n  }, {\n    isArray: Or\n  });\n  var Va = O.Array.isArray,\n      qa = Va;\n\n  var Ua = s,\n      Ya = A,\n      Xa = pt(\"species\"),\n      Ga = function (t) {\n    return Ya >= 51 || !Ua(function () {\n      var e = [];\n      return (e.constructor = {})[Xa] = function () {\n        return {\n          foo: 1\n        };\n      }, 1 !== e[t](Boolean).foo;\n    });\n  },\n      Ka = ue,\n      $a = s,\n      Za = Or,\n      Qa = E,\n      Ja = Q,\n      th = me,\n      eh = Hn,\n      ih = Ur,\n      oh = Ga,\n      nh = A,\n      rh = pt(\"isConcatSpreadable\"),\n      sh = 9007199254740991,\n      ah = \"Maximum allowed index exceeded\",\n      hh = nh >= 51 || !$a(function () {\n    var t = [];\n    return t[rh] = !1, t.concat()[0] !== t;\n  }),\n      dh = oh(\"concat\"),\n      lh = function (t) {\n    if (!Qa(t)) return !1;\n    var e = t[rh];\n    return void 0 !== e ? !!e : Za(t);\n  };\n\n  Ka({\n    target: \"Array\",\n    proto: !0,\n    forced: !hh || !dh\n  }, {\n    concat: function (t) {\n      var e,\n          i,\n          o,\n          n,\n          r,\n          s = Ja(this),\n          a = ih(s, 0),\n          h = 0;\n\n      for (e = -1, o = arguments.length; e < o; e++) if (lh(r = -1 === e ? s : arguments[e])) {\n        if (h + (n = th(r.length)) > sh) throw TypeError(ah);\n\n        for (i = 0; i < n; i++, h++) i in r && eh(a, h, r[i]);\n      } else {\n        if (h >= sh) throw TypeError(ah);\n        eh(a, h++, r);\n      }\n\n      return a.length = h, a;\n    }\n  }), Lr(\"asyncIterator\"), Lr(\"hasInstance\"), Lr(\"isConcatSpreadable\"), Lr(\"iterator\"), Lr(\"match\"), Lr(\"matchAll\"), Lr(\"replace\"), Lr(\"search\"), Lr(\"species\"), Lr(\"split\"), Lr(\"toPrimitive\"), Lr(\"toStringTag\"), Lr(\"unscopables\"), Xo(n.JSON, \"JSON\", !0);\n  var ch = O.Symbol;\n  Lr(\"asyncDispose\"), Lr(\"dispose\"), Lr(\"matcher\"), Lr(\"metadata\"), Lr(\"observable\"), Lr(\"patternMatch\"), Lr(\"replaceAll\");\n  var uh = ch;\n\n  var fh = ue,\n      ph = E,\n      vh = Or,\n      gh = _e,\n      yh = me,\n      mh = x,\n      bh = Hn,\n      wh = pt,\n      kh = Ga(\"slice\"),\n      _h = wh(\"species\"),\n      xh = [].slice,\n      Eh = Math.max;\n\n  fh({\n    target: \"Array\",\n    proto: !0,\n    forced: !kh\n  }, {\n    slice: function (t, e) {\n      var i,\n          o,\n          n,\n          r = mh(this),\n          s = yh(r.length),\n          a = gh(t, s),\n          h = gh(void 0 === e ? s : e, s);\n      if (vh(r) && (\"function\" != typeof (i = r.constructor) || i !== Array && !vh(i.prototype) ? ph(i) && null === (i = i[_h]) && (i = void 0) : i = void 0, i === Array || void 0 === i)) return xh.call(r, a, h);\n\n      for (o = new (void 0 === i ? Array : i)(Eh(h - a, 0)), n = 0; a < h; a++, n++) a in r && bh(o, n, r[a]);\n\n      return o.length = n, o;\n    }\n  });\n\n  var Oh = oi(\"Array\").slice,\n      Ch = Array.prototype,\n      Sh = function (t) {\n    var e = t.slice;\n    return t === Ch || t instanceof Array && e === Ch.slice ? Oh : e;\n  },\n      Th = Sh,\n      Mh = nr;\n\n  function Ph(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var i = 0, o = new Array(e); i < e; i++) o[i] = t[i];\n\n    return o;\n  }\n\n  function Dh(t, e) {\n    var i;\n\n    if (t) {\n      if (\"string\" == typeof t) return Ph(t, e);\n      var o = Th(i = Object.prototype.toString.call(t)).call(i, 8, -1);\n      return \"Object\" === o && t.constructor && (o = t.constructor.name), \"Map\" === o || \"Set\" === o ? Mh(t) : \"Arguments\" === o || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o) ? Ph(t, e) : void 0;\n    }\n  }\n\n  function Bh(t, e) {\n    return function (t) {\n      if (qa(t)) return t;\n    }(t) || function (t, e) {\n      var i = null == t ? null : void 0 !== uh && xr(t) || t[\"@@iterator\"];\n\n      if (null != i) {\n        var o,\n            n,\n            r = [],\n            s = !0,\n            a = !1;\n\n        try {\n          for (i = i.call(t); !(s = (o = i.next()).done) && (r.push(o.value), !e || r.length !== e); s = !0);\n        } catch (t) {\n          a = !0, n = t;\n        } finally {\n          try {\n            s || null == i.return || i.return();\n          } finally {\n            if (a) throw n;\n          }\n        }\n\n        return r;\n      }\n    }(t, e) || Dh(t, e) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n\n  var Ih = zr.f(\"iterator\");\n\n  function zh(t) {\n    return (zh = \"function\" == typeof uh && \"symbol\" == typeof Ih ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof uh && t.constructor === uh && t !== uh.prototype ? \"symbol\" : typeof t;\n    })(t);\n  }\n\n  function Fh(t) {\n    return function (t) {\n      if (qa(t)) return Ph(t);\n    }(t) || function (t) {\n      if (void 0 !== uh && null != xr(t) || null != t[\"@@iterator\"]) return Mh(t);\n    }(t) || Dh(t) || function () {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n\n  var Nh = ch,\n      Ah = oi(\"Array\").concat,\n      Rh = Array.prototype,\n      jh = function (t) {\n    var e = t.concat;\n    return t === Rh || t instanceof Array && e === Rh.concat ? Ah : e;\n  },\n      Lh = Sh;\n\n  ue({\n    target: \"Reflect\",\n    stat: !0\n  }, {\n    ownKeys: xa\n  }), O.Reflect.ownKeys;\n  var Hh = Va,\n      Wh = Jr.map;\n  ue({\n    target: \"Array\",\n    proto: !0,\n    forced: !Ga(\"map\")\n  }, {\n    map: function (t) {\n      return Wh(this, t, arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n\n  var Vh = oi(\"Array\").map,\n      qh = Array.prototype,\n      Uh = function (t) {\n    var e = t.map;\n    return t === qh || t instanceof Array && e === qh.map ? Vh : e;\n  },\n      Yh = Q,\n      Xh = Ae;\n\n  ue({\n    target: \"Object\",\n    stat: !0,\n    forced: s(function () {\n      Xh(1);\n    })\n  }, {\n    keys: function (t) {\n      return Xh(Yh(t));\n    }\n  });\n  var Gh = O.Object.keys;\n  ue({\n    target: \"Date\",\n    stat: !0\n  }, {\n    now: function () {\n      return new Date().getTime();\n    }\n  });\n\n  var Kh = O.Date.now,\n      $h = s,\n      Zh = function (t, e) {\n    var i = [][t];\n    return !!i && $h(function () {\n      i.call(null, e || function () {\n        throw 1;\n      }, 1);\n    });\n  },\n      Qh = Jr.forEach,\n      Jh = Zh(\"forEach\") ? [].forEach : function (t) {\n    return Qh(this, t, arguments.length > 1 ? arguments[1] : void 0);\n  };\n\n  ue({\n    target: \"Array\",\n    proto: !0,\n    forced: [].forEach != Jh\n  }, {\n    forEach: Jh\n  });\n\n  var td = oi(\"Array\").forEach,\n      ed = Ro,\n      id = Array.prototype,\n      od = {\n    DOMTokenList: !0,\n    NodeList: !0\n  },\n      nd = function (t) {\n    var e = t.forEach;\n    return t === id || t instanceof Array && e === id.forEach || od.hasOwnProperty(ed(t)) ? td : e;\n  },\n      rd = Or,\n      sd = [].reverse,\n      ad = [1, 2];\n\n  ue({\n    target: \"Array\",\n    proto: !0,\n    forced: String(ad) === String(ad.reverse())\n  }, {\n    reverse: function () {\n      return rd(this) && (this.length = this.length), sd.call(this);\n    }\n  });\n\n  var hd = oi(\"Array\").reverse,\n      dd = Array.prototype,\n      ld = function (t) {\n    var e = t.reverse;\n    return t === dd || t instanceof Array && e === dd.reverse ? hd : e;\n  },\n      cd = ue,\n      ud = _e,\n      fd = ve,\n      pd = me,\n      vd = Q,\n      gd = Ur,\n      yd = Hn,\n      md = Ga(\"splice\"),\n      bd = Math.max,\n      wd = Math.min,\n      kd = 9007199254740991,\n      _d = \"Maximum allowed length exceeded\";\n\n  cd({\n    target: \"Array\",\n    proto: !0,\n    forced: !md\n  }, {\n    splice: function (t, e) {\n      var i,\n          o,\n          n,\n          r,\n          s,\n          a,\n          h = vd(this),\n          d = pd(h.length),\n          l = ud(t, d),\n          c = arguments.length;\n      if (0 === c ? i = o = 0 : 1 === c ? (i = 0, o = d - l) : (i = c - 2, o = wd(bd(fd(e), 0), d - l)), d + i - o > kd) throw TypeError(_d);\n\n      for (n = gd(h, o), r = 0; r < o; r++) (s = l + r) in h && yd(n, r, h[s]);\n\n      if (n.length = o, i < o) {\n        for (r = l; r < d - o; r++) a = r + i, (s = r + o) in h ? h[a] = h[s] : delete h[a];\n\n        for (r = d; r > d - o + i; r--) delete h[r - 1];\n      } else if (i > o) for (r = d - o; r > l; r--) a = r + i - 1, (s = r + o - 1) in h ? h[a] = h[s] : delete h[a];\n\n      for (r = 0; r < i; r++) h[r + l] = arguments[r + 2];\n\n      return h.length = d - o + i, n;\n    }\n  });\n\n  var xd = oi(\"Array\").splice,\n      Ed = Array.prototype,\n      Od = function (t) {\n    var e = t.splice;\n    return t === Ed || t instanceof Array && e === Ed.splice ? xd : e;\n  },\n      Cd = Se.includes;\n\n  ue({\n    target: \"Array\",\n    proto: !0\n  }, {\n    includes: function (t) {\n      return Cd(this, t, arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n\n  var Sd = oi(\"Array\").includes,\n      Td = E,\n      Md = g,\n      Pd = pt(\"match\"),\n      Dd = function (t) {\n    var e;\n    return Td(t) && (void 0 !== (e = t[Pd]) ? !!e : \"RegExp\" == Md(t));\n  },\n      Bd = pt(\"match\"),\n      Id = function (t) {\n    if (Dd(t)) throw TypeError(\"The method doesn't accept regular expressions\");\n    return t;\n  },\n      zd = w,\n      Fd = gi;\n\n  ue({\n    target: \"String\",\n    proto: !0,\n    forced: !function (t) {\n      var e = /./;\n\n      try {\n        \"/./\"[t](e);\n      } catch (i) {\n        try {\n          return e[Bd] = !1, \"/./\"[t](e);\n        } catch (t) {}\n      }\n\n      return !1;\n    }(\"includes\")\n  }, {\n    includes: function (t) {\n      return !!~Fd(zd(this)).indexOf(Fd(Id(t)), arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n\n  var Nd = oi(\"String\").includes,\n      Ad = Sd,\n      Rd = Nd,\n      jd = Array.prototype,\n      Ld = String.prototype,\n      Hd = function (t) {\n    var e = t.includes;\n    return t === jd || t instanceof Array && e === jd.includes ? Ad : \"string\" == typeof t || t === Ld || t instanceof String && e === Ld.includes ? Rd : e;\n  },\n      Wd = Q,\n      Vd = no,\n      qd = Qi;\n\n  ue({\n    target: \"Object\",\n    stat: !0,\n    forced: s(function () {\n      Vd(1);\n    }),\n    sham: !qd\n  }, {\n    getPrototypeOf: function (t) {\n      return Vd(Wd(t));\n    }\n  });\n  var Ud = O.Object.getPrototypeOf,\n      Yd = Ud,\n      Xd = Jr.filter;\n  ue({\n    target: \"Array\",\n    proto: !0,\n    forced: !Ga(\"filter\")\n  }, {\n    filter: function (t) {\n      return Xd(this, t, arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n\n  var Gd = oi(\"Array\").filter,\n      Kd = Array.prototype,\n      $d = function (t) {\n    var e = t.filter;\n    return t === Kd || t instanceof Array && e === Kd.filter ? Gd : e;\n  },\n      Zd = a,\n      Qd = Ae,\n      Jd = x,\n      tl = h.f,\n      el = function (t) {\n    return function (e) {\n      for (var i, o = Jd(e), n = Qd(o), r = n.length, s = 0, a = []; r > s;) i = n[s++], Zd && !tl.call(o, i) || a.push(t ? [i, o[i]] : o[i]);\n\n      return a;\n    };\n  },\n      il = {\n    entries: el(!0),\n    values: el(!1)\n  }.values;\n\n  ue({\n    target: \"Object\",\n    stat: !0\n  }, {\n    values: function (t) {\n      return il(t);\n    }\n  }), O.Object.values;\n\n  var ol = \"\\t\\n\\v\\f\\r Â áââââââââââââ¯âã\\u2028\\u2029\\ufeff\",\n      nl = w,\n      rl = gi,\n      sl = \"[\\t\\n\\v\\f\\r Â áââââââââââââ¯âã\\u2028\\u2029\\ufeff]\",\n      al = RegExp(\"^\" + sl + sl + \"*\"),\n      hl = RegExp(sl + sl + \"*$\"),\n      dl = function (t) {\n    return function (e) {\n      var i = rl(nl(e));\n      return 1 & t && (i = i.replace(al, \"\")), 2 & t && (i = i.replace(hl, \"\")), i;\n    };\n  },\n      ll = {\n    start: dl(1),\n    end: dl(2),\n    trim: dl(3)\n  },\n      cl = gi,\n      ul = ll.trim,\n      fl = ol,\n      pl = n.parseInt,\n      vl = /^[+-]?0[Xx]/,\n      gl = 8 !== pl(fl + \"08\") || 22 !== pl(fl + \"0x16\") ? function (t, e) {\n    var i = ul(cl(t));\n    return pl(i, e >>> 0 || (vl.test(i) ? 16 : 10));\n  } : pl;\n\n  ue({\n    global: !0,\n    forced: parseInt != gl\n  }, {\n    parseInt: gl\n  });\n\n  var yl = O.parseInt,\n      ml = ue,\n      bl = Se.indexOf,\n      wl = Zh,\n      kl = [].indexOf,\n      _l = !!kl && 1 / [1].indexOf(1, -0) < 0,\n      xl = wl(\"indexOf\");\n\n  ml({\n    target: \"Array\",\n    proto: !0,\n    forced: _l || !xl\n  }, {\n    indexOf: function (t) {\n      return _l ? kl.apply(this, arguments) || 0 : bl(this, t, arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n\n  var El = oi(\"Array\").indexOf,\n      Ol = Array.prototype,\n      Cl = function (t) {\n    var e = t.indexOf;\n    return t === Ol || t instanceof Array && e === Ol.indexOf ? El : e;\n  },\n      Sl = s,\n      Tl = ol,\n      Ml = ll.trim;\n\n  ue({\n    target: \"String\",\n    proto: !0,\n    forced: function (t) {\n      return Sl(function () {\n        return !!Tl[t]() || \"âÂá \" != \"âÂá \"[t]() || Tl[t].name !== t;\n      });\n    }(\"trim\")\n  }, {\n    trim: function () {\n      return Ml(this);\n    }\n  }), oi(\"String\").trim, ue({\n    target: \"Object\",\n    stat: !0,\n    sham: !a\n  }, {\n    create: Do\n  });\n\n  var Pl = O.Object,\n      Dl = function (t, e) {\n    return Pl.create(t, e);\n  },\n      Bl = Dl,\n      Il = ue,\n      zl = s,\n      Fl = M(\"JSON\", \"stringify\"),\n      Nl = /[\\uD800-\\uDFFF]/g,\n      Al = /^[\\uD800-\\uDBFF]$/,\n      Rl = /^[\\uDC00-\\uDFFF]$/,\n      jl = function (t, e, i) {\n    var o = i.charAt(e - 1),\n        n = i.charAt(e + 1);\n    return Al.test(t) && !Rl.test(n) || Rl.test(t) && !Al.test(o) ? \"\\\\u\" + t.charCodeAt(0).toString(16) : t;\n  },\n      Ll = zl(function () {\n    return '\"\\\\udf06\\\\ud834\"' !== Fl(\"\\udf06\\ud834\") || '\"\\\\udead\"' !== Fl(\"\\udead\");\n  });\n\n  Fl && Il({\n    target: \"JSON\",\n    stat: !0,\n    forced: Ll\n  }, {\n    stringify: function (t, e, i) {\n      var o = Fl.apply(null, arguments);\n      return \"string\" == typeof o ? o.replace(Nl, jl) : o;\n    }\n  });\n  var Hl = O;\n  Hl.JSON || (Hl.JSON = {\n    stringify: JSON.stringify\n  });\n\n  var Wl = function (t, e, i) {\n    return Hl.JSON.stringify.apply(null, arguments);\n  },\n      Vl = n,\n      ql = [].slice,\n      Ul = function (t) {\n    return function (e, i) {\n      var o = arguments.length > 2,\n          n = o ? ql.call(arguments, 2) : void 0;\n      return t(o ? function () {\n        (\"function\" == typeof e ? e : Function(e)).apply(this, n);\n      } : e, i);\n    };\n  };\n\n  ue({\n    global: !0,\n    bind: !0,\n    forced: /MSIE .\\./.test(P)\n  }, {\n    setTimeout: Ul(Vl.setTimeout),\n    setInterval: Ul(Vl.setInterval)\n  });\n  var Yl = O.setTimeout,\n      Xl = Q,\n      Gl = _e,\n      Kl = me;\n  ue({\n    target: \"Array\",\n    proto: !0\n  }, {\n    fill: function (t) {\n      for (var e = Xl(this), i = Kl(e.length), o = arguments.length, n = Gl(o > 1 ? arguments[1] : void 0, i), r = o > 2 ? arguments[2] : void 0, s = void 0 === r ? i : Gl(r, i); s > n;) e[n++] = t;\n\n      return e;\n    }\n  });\n\n  var $l = oi(\"Array\").fill,\n      Zl = Array.prototype,\n      Ql = function (t) {\n    var e = t.fill;\n    return t === Zl || t instanceof Array && e === Zl.fill ? $l : e;\n  };\n  /*! Hammer.JS - v2.0.17-rc - 2019-12-16\n  \t * http://naver.github.io/egjs\n  \t *\n  \t * Forked By Naver egjs\n  \t * Copyright (c) hammerjs\n  \t * Licensed under the MIT license */\n\n\n  function Jl() {\n    return (Jl = Object.assign || function (t) {\n      for (var e = 1; e < arguments.length; e++) {\n        var i = arguments[e];\n\n        for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (t[o] = i[o]);\n      }\n\n      return t;\n    }).apply(this, arguments);\n  }\n\n  function tc(t, e) {\n    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n  }\n\n  function ec(t) {\n    if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return t;\n  }\n\n  var ic,\n      oc = \"function\" != typeof Object.assign ? function (t) {\n    if (null == t) throw new TypeError(\"Cannot convert undefined or null to object\");\n\n    for (var e = Object(t), i = 1; i < arguments.length; i++) {\n      var o = arguments[i];\n      if (null != o) for (var n in o) o.hasOwnProperty(n) && (e[n] = o[n]);\n    }\n\n    return e;\n  } : Object.assign,\n      nc = [\"\", \"webkit\", \"Moz\", \"MS\", \"ms\", \"o\"],\n      rc = \"undefined\" == typeof document ? {\n    style: {}\n  } : document.createElement(\"div\"),\n      sc = Math.round,\n      ac = Math.abs,\n      hc = Date.now;\n\n  function dc(t, e) {\n    for (var i, o, n = e[0].toUpperCase() + e.slice(1), r = 0; r < nc.length;) {\n      if ((o = (i = nc[r]) ? i + n : e) in t) return o;\n      r++;\n    }\n  }\n\n  ic = \"undefined\" == typeof window ? {} : window;\n  var lc = dc(rc.style, \"touchAction\"),\n      cc = void 0 !== lc;\n\n  var uc = \"compute\",\n      fc = \"auto\",\n      pc = \"manipulation\",\n      vc = \"none\",\n      gc = \"pan-x\",\n      yc = \"pan-y\",\n      mc = function () {\n    if (!cc) return !1;\n    var t = {},\n        e = ic.CSS && ic.CSS.supports;\n    return [\"auto\", \"manipulation\", \"pan-y\", \"pan-x\", \"pan-x pan-y\", \"none\"].forEach(function (i) {\n      return t[i] = !e || ic.CSS.supports(\"touch-action\", i);\n    }), t;\n  }(),\n      bc = (\"ontouchstart\" in ic),\n      wc = void 0 !== dc(ic, \"PointerEvent\"),\n      kc = bc && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent),\n      _c = \"touch\",\n      xc = \"mouse\",\n      Ec = 16,\n      Oc = 24,\n      Cc = [\"x\", \"y\"],\n      Sc = [\"clientX\", \"clientY\"];\n\n  function Tc(t, e, i) {\n    var o;\n    if (t) if (t.forEach) t.forEach(e, i);else if (void 0 !== t.length) for (o = 0; o < t.length;) e.call(i, t[o], o, t), o++;else for (o in t) t.hasOwnProperty(o) && e.call(i, t[o], o, t);\n  }\n\n  function Mc(t, e) {\n    return \"function\" == typeof t ? t.apply(e && e[0] || void 0, e) : t;\n  }\n\n  function Pc(t, e) {\n    return t.indexOf(e) > -1;\n  }\n\n  var Dc = function () {\n    function t(t, e) {\n      this.manager = t, this.set(e);\n    }\n\n    var e = t.prototype;\n    return e.set = function (t) {\n      t === uc && (t = this.compute()), cc && this.manager.element.style && mc[t] && (this.manager.element.style[lc] = t), this.actions = t.toLowerCase().trim();\n    }, e.update = function () {\n      this.set(this.manager.options.touchAction);\n    }, e.compute = function () {\n      var t = [];\n      return Tc(this.manager.recognizers, function (e) {\n        Mc(e.options.enable, [e]) && (t = t.concat(e.getTouchAction()));\n      }), function (t) {\n        if (Pc(t, vc)) return vc;\n        var e = Pc(t, gc),\n            i = Pc(t, yc);\n        return e && i ? vc : e || i ? e ? gc : yc : Pc(t, pc) ? pc : fc;\n      }(t.join(\" \"));\n    }, e.preventDefaults = function (t) {\n      var e = t.srcEvent,\n          i = t.offsetDirection;\n      if (this.manager.session.prevented) e.preventDefault();else {\n        var o = this.actions,\n            n = Pc(o, vc) && !mc.none,\n            r = Pc(o, yc) && !mc[\"pan-y\"],\n            s = Pc(o, gc) && !mc[\"pan-x\"];\n\n        if (n) {\n          var a = 1 === t.pointers.length,\n              h = t.distance < 2,\n              d = t.deltaTime < 250;\n          if (a && h && d) return;\n        }\n\n        if (!s || !r) return n || r && 6 & i || s && i & Oc ? this.preventSrc(e) : void 0;\n      }\n    }, e.preventSrc = function (t) {\n      this.manager.session.prevented = !0, t.preventDefault();\n    }, t;\n  }();\n\n  function Bc(t, e) {\n    for (; t;) {\n      if (t === e) return !0;\n      t = t.parentNode;\n    }\n\n    return !1;\n  }\n\n  function Ic(t) {\n    var e = t.length;\n    if (1 === e) return {\n      x: sc(t[0].clientX),\n      y: sc(t[0].clientY)\n    };\n\n    for (var i = 0, o = 0, n = 0; n < e;) i += t[n].clientX, o += t[n].clientY, n++;\n\n    return {\n      x: sc(i / e),\n      y: sc(o / e)\n    };\n  }\n\n  function zc(t) {\n    for (var e = [], i = 0; i < t.pointers.length;) e[i] = {\n      clientX: sc(t.pointers[i].clientX),\n      clientY: sc(t.pointers[i].clientY)\n    }, i++;\n\n    return {\n      timeStamp: hc(),\n      pointers: e,\n      center: Ic(e),\n      deltaX: t.deltaX,\n      deltaY: t.deltaY\n    };\n  }\n\n  function Fc(t, e, i) {\n    i || (i = Cc);\n    var o = e[i[0]] - t[i[0]],\n        n = e[i[1]] - t[i[1]];\n    return Math.sqrt(o * o + n * n);\n  }\n\n  function Nc(t, e, i) {\n    i || (i = Cc);\n    var o = e[i[0]] - t[i[0]],\n        n = e[i[1]] - t[i[1]];\n    return 180 * Math.atan2(n, o) / Math.PI;\n  }\n\n  function Ac(t, e) {\n    return t === e ? 1 : ac(t) >= ac(e) ? t < 0 ? 2 : 4 : e < 0 ? 8 : Ec;\n  }\n\n  function Rc(t, e, i) {\n    return {\n      x: e / t || 0,\n      y: i / t || 0\n    };\n  }\n\n  function jc(t, e) {\n    var i = t.session,\n        o = e.pointers,\n        n = o.length;\n    i.firstInput || (i.firstInput = zc(e)), n > 1 && !i.firstMultiple ? i.firstMultiple = zc(e) : 1 === n && (i.firstMultiple = !1);\n    var r = i.firstInput,\n        s = i.firstMultiple,\n        a = s ? s.center : r.center,\n        h = e.center = Ic(o);\n    e.timeStamp = hc(), e.deltaTime = e.timeStamp - r.timeStamp, e.angle = Nc(a, h), e.distance = Fc(a, h), function (t, e) {\n      var i = e.center,\n          o = t.offsetDelta || {},\n          n = t.prevDelta || {},\n          r = t.prevInput || {};\n      1 !== e.eventType && 4 !== r.eventType || (n = t.prevDelta = {\n        x: r.deltaX || 0,\n        y: r.deltaY || 0\n      }, o = t.offsetDelta = {\n        x: i.x,\n        y: i.y\n      }), e.deltaX = n.x + (i.x - o.x), e.deltaY = n.y + (i.y - o.y);\n    }(i, e), e.offsetDirection = Ac(e.deltaX, e.deltaY);\n    var d,\n        l,\n        c = Rc(e.deltaTime, e.deltaX, e.deltaY);\n    e.overallVelocityX = c.x, e.overallVelocityY = c.y, e.overallVelocity = ac(c.x) > ac(c.y) ? c.x : c.y, e.scale = s ? (d = s.pointers, Fc((l = o)[0], l[1], Sc) / Fc(d[0], d[1], Sc)) : 1, e.rotation = s ? function (t, e) {\n      return Nc(e[1], e[0], Sc) + Nc(t[1], t[0], Sc);\n    }(s.pointers, o) : 0, e.maxPointers = i.prevInput ? e.pointers.length > i.prevInput.maxPointers ? e.pointers.length : i.prevInput.maxPointers : e.pointers.length, function (t, e) {\n      var i,\n          o,\n          n,\n          r,\n          s = t.lastInterval || e,\n          a = e.timeStamp - s.timeStamp;\n\n      if (8 !== e.eventType && (a > 25 || void 0 === s.velocity)) {\n        var h = e.deltaX - s.deltaX,\n            d = e.deltaY - s.deltaY,\n            l = Rc(a, h, d);\n        o = l.x, n = l.y, i = ac(l.x) > ac(l.y) ? l.x : l.y, r = Ac(h, d), t.lastInterval = e;\n      } else i = s.velocity, o = s.velocityX, n = s.velocityY, r = s.direction;\n\n      e.velocity = i, e.velocityX = o, e.velocityY = n, e.direction = r;\n    }(i, e);\n    var u,\n        f = t.element,\n        p = e.srcEvent;\n    Bc(u = p.composedPath ? p.composedPath()[0] : p.path ? p.path[0] : p.target, f) && (f = u), e.target = f;\n  }\n\n  function Lc(t, e, i) {\n    var o = i.pointers.length,\n        n = i.changedPointers.length,\n        r = 1 & e && o - n == 0,\n        s = 12 & e && o - n == 0;\n    i.isFirst = !!r, i.isFinal = !!s, r && (t.session = {}), i.eventType = e, jc(t, i), t.emit(\"hammer.input\", i), t.recognize(i), t.session.prevInput = i;\n  }\n\n  function Hc(t) {\n    return t.trim().split(/\\s+/g);\n  }\n\n  function Wc(t, e, i) {\n    Tc(Hc(e), function (e) {\n      t.addEventListener(e, i, !1);\n    });\n  }\n\n  function Vc(t, e, i) {\n    Tc(Hc(e), function (e) {\n      t.removeEventListener(e, i, !1);\n    });\n  }\n\n  function qc(t) {\n    var e = t.ownerDocument || t;\n    return e.defaultView || e.parentWindow || window;\n  }\n\n  var Uc = function () {\n    function t(t, e) {\n      var i = this;\n      this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function (e) {\n        Mc(t.options.enable, [t]) && i.handler(e);\n      }, this.init();\n    }\n\n    var e = t.prototype;\n    return e.handler = function () {}, e.init = function () {\n      this.evEl && Wc(this.element, this.evEl, this.domHandler), this.evTarget && Wc(this.target, this.evTarget, this.domHandler), this.evWin && Wc(qc(this.element), this.evWin, this.domHandler);\n    }, e.destroy = function () {\n      this.evEl && Vc(this.element, this.evEl, this.domHandler), this.evTarget && Vc(this.target, this.evTarget, this.domHandler), this.evWin && Vc(qc(this.element), this.evWin, this.domHandler);\n    }, t;\n  }();\n\n  function Yc(t, e, i) {\n    if (t.indexOf && !i) return t.indexOf(e);\n\n    for (var o = 0; o < t.length;) {\n      if (i && t[o][i] == e || !i && t[o] === e) return o;\n      o++;\n    }\n\n    return -1;\n  }\n\n  var Xc = {\n    pointerdown: 1,\n    pointermove: 2,\n    pointerup: 4,\n    pointercancel: 8,\n    pointerout: 8\n  },\n      Gc = {\n    2: _c,\n    3: \"pen\",\n    4: xc,\n    5: \"kinect\"\n  },\n      Kc = \"pointerdown\",\n      $c = \"pointermove pointerup pointercancel\";\n  ic.MSPointerEvent && !ic.PointerEvent && (Kc = \"MSPointerDown\", $c = \"MSPointerMove MSPointerUp MSPointerCancel\");\n\n  var Zc = function (t) {\n    function e() {\n      var i,\n          o = e.prototype;\n      return o.evEl = Kc, o.evWin = $c, (i = t.apply(this, arguments) || this).store = i.manager.session.pointerEvents = [], i;\n    }\n\n    return tc(e, t), e.prototype.handler = function (t) {\n      var e = this.store,\n          i = !1,\n          o = t.type.toLowerCase().replace(\"ms\", \"\"),\n          n = Xc[o],\n          r = Gc[t.pointerType] || t.pointerType,\n          s = r === _c,\n          a = Yc(e, t.pointerId, \"pointerId\");\n      1 & n && (0 === t.button || s) ? a < 0 && (e.push(t), a = e.length - 1) : 12 & n && (i = !0), a < 0 || (e[a] = t, this.callback(this.manager, n, {\n        pointers: e,\n        changedPointers: [t],\n        pointerType: r,\n        srcEvent: t\n      }), i && e.splice(a, 1));\n    }, e;\n  }(Uc);\n\n  function Qc(t) {\n    return Array.prototype.slice.call(t, 0);\n  }\n\n  function Jc(t, e, i) {\n    for (var o = [], n = [], r = 0; r < t.length;) {\n      var s = e ? t[r][e] : t[r];\n      Yc(n, s) < 0 && o.push(t[r]), n[r] = s, r++;\n    }\n\n    return i && (o = e ? o.sort(function (t, i) {\n      return t[e] > i[e];\n    }) : o.sort()), o;\n  }\n\n  var tu = {\n    touchstart: 1,\n    touchmove: 2,\n    touchend: 4,\n    touchcancel: 8\n  },\n      eu = \"touchstart touchmove touchend touchcancel\",\n      iu = function (t) {\n    function e() {\n      var i;\n      return e.prototype.evTarget = eu, (i = t.apply(this, arguments) || this).targetIds = {}, i;\n    }\n\n    return tc(e, t), e.prototype.handler = function (t) {\n      var e = tu[t.type],\n          i = ou.call(this, t, e);\n      i && this.callback(this.manager, e, {\n        pointers: i[0],\n        changedPointers: i[1],\n        pointerType: _c,\n        srcEvent: t\n      });\n    }, e;\n  }(Uc);\n\n  function ou(t, e) {\n    var i,\n        o,\n        n = Qc(t.touches),\n        r = this.targetIds;\n    if (3 & e && 1 === n.length) return r[n[0].identifier] = !0, [n, n];\n    var s = Qc(t.changedTouches),\n        a = [],\n        h = this.target;\n    if (o = n.filter(function (t) {\n      return Bc(t.target, h);\n    }), 1 === e) for (i = 0; i < o.length;) r[o[i].identifier] = !0, i++;\n\n    for (i = 0; i < s.length;) r[s[i].identifier] && a.push(s[i]), 12 & e && delete r[s[i].identifier], i++;\n\n    return a.length ? [Jc(o.concat(a), \"identifier\", !0), a] : void 0;\n  }\n\n  var nu = {\n    mousedown: 1,\n    mousemove: 2,\n    mouseup: 4\n  },\n      ru = \"mousedown\",\n      su = \"mousemove mouseup\",\n      au = function (t) {\n    function e() {\n      var i,\n          o = e.prototype;\n      return o.evEl = ru, o.evWin = su, (i = t.apply(this, arguments) || this).pressed = !1, i;\n    }\n\n    return tc(e, t), e.prototype.handler = function (t) {\n      var e = nu[t.type];\n      1 & e && 0 === t.button && (this.pressed = !0), 2 & e && 1 !== t.which && (e = 4), this.pressed && (4 & e && (this.pressed = !1), this.callback(this.manager, e, {\n        pointers: [t],\n        changedPointers: [t],\n        pointerType: xc,\n        srcEvent: t\n      }));\n    }, e;\n  }(Uc);\n\n  function hu(t) {\n    var e = t.changedPointers[0];\n\n    if (e.identifier === this.primaryTouch) {\n      var i = {\n        x: e.clientX,\n        y: e.clientY\n      },\n          o = this.lastTouches;\n      this.lastTouches.push(i);\n      setTimeout(function () {\n        var t = o.indexOf(i);\n        t > -1 && o.splice(t, 1);\n      }, 2500);\n    }\n  }\n\n  function du(t, e) {\n    1 & t ? (this.primaryTouch = e.changedPointers[0].identifier, hu.call(this, e)) : 12 & t && hu.call(this, e);\n  }\n\n  function lu(t) {\n    for (var e = t.srcEvent.clientX, i = t.srcEvent.clientY, o = 0; o < this.lastTouches.length; o++) {\n      var n = this.lastTouches[o],\n          r = Math.abs(e - n.x),\n          s = Math.abs(i - n.y);\n      if (r <= 25 && s <= 25) return !0;\n    }\n\n    return !1;\n  }\n\n  var cu = function () {\n    return function (t) {\n      function e(e, i) {\n        var o;\n        return (o = t.call(this, e, i) || this).handler = function (t, e, i) {\n          var n = i.pointerType === _c,\n              r = i.pointerType === xc;\n\n          if (!(r && i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)) {\n            if (n) du.call(ec(ec(o)), e, i);else if (r && lu.call(ec(ec(o)), i)) return;\n            o.callback(t, e, i);\n          }\n        }, o.touch = new iu(o.manager, o.handler), o.mouse = new au(o.manager, o.handler), o.primaryTouch = null, o.lastTouches = [], o;\n      }\n\n      return tc(e, t), e.prototype.destroy = function () {\n        this.touch.destroy(), this.mouse.destroy();\n      }, e;\n    }(Uc);\n  }();\n\n  function uu(t, e, i) {\n    return !!Array.isArray(t) && (Tc(t, i[e], i), !0);\n  }\n\n  var fu = 32,\n      pu = 1;\n\n  function vu(t, e) {\n    var i = e.manager;\n    return i ? i.get(t) : t;\n  }\n\n  function gu(t) {\n    return 16 & t ? \"cancel\" : 8 & t ? \"end\" : 4 & t ? \"move\" : 2 & t ? \"start\" : \"\";\n  }\n\n  var yu = function () {\n    function t(t) {\n      void 0 === t && (t = {}), this.options = Jl({\n        enable: !0\n      }, t), this.id = pu++, this.manager = null, this.state = 1, this.simultaneous = {}, this.requireFail = [];\n    }\n\n    var e = t.prototype;\n    return e.set = function (t) {\n      return oc(this.options, t), this.manager && this.manager.touchAction.update(), this;\n    }, e.recognizeWith = function (t) {\n      if (uu(t, \"recognizeWith\", this)) return this;\n      var e = this.simultaneous;\n      return e[(t = vu(t, this)).id] || (e[t.id] = t, t.recognizeWith(this)), this;\n    }, e.dropRecognizeWith = function (t) {\n      return uu(t, \"dropRecognizeWith\", this) || (t = vu(t, this), delete this.simultaneous[t.id]), this;\n    }, e.requireFailure = function (t) {\n      if (uu(t, \"requireFailure\", this)) return this;\n      var e = this.requireFail;\n      return -1 === Yc(e, t = vu(t, this)) && (e.push(t), t.requireFailure(this)), this;\n    }, e.dropRequireFailure = function (t) {\n      if (uu(t, \"dropRequireFailure\", this)) return this;\n      t = vu(t, this);\n      var e = Yc(this.requireFail, t);\n      return e > -1 && this.requireFail.splice(e, 1), this;\n    }, e.hasRequireFailures = function () {\n      return this.requireFail.length > 0;\n    }, e.canRecognizeWith = function (t) {\n      return !!this.simultaneous[t.id];\n    }, e.emit = function (t) {\n      var e = this,\n          i = this.state;\n\n      function o(i) {\n        e.manager.emit(i, t);\n      }\n\n      i < 8 && o(e.options.event + gu(i)), o(e.options.event), t.additionalEvent && o(t.additionalEvent), i >= 8 && o(e.options.event + gu(i));\n    }, e.tryEmit = function (t) {\n      if (this.canEmit()) return this.emit(t);\n      this.state = fu;\n    }, e.canEmit = function () {\n      for (var t = 0; t < this.requireFail.length;) {\n        if (!(33 & this.requireFail[t].state)) return !1;\n        t++;\n      }\n\n      return !0;\n    }, e.recognize = function (t) {\n      var e = oc({}, t);\n      if (!Mc(this.options.enable, [this, e])) return this.reset(), void (this.state = fu);\n      56 & this.state && (this.state = 1), this.state = this.process(e), 30 & this.state && this.tryEmit(e);\n    }, e.process = function (t) {}, e.getTouchAction = function () {}, e.reset = function () {}, t;\n  }(),\n      mu = function (t) {\n    function e(e) {\n      var i;\n      return void 0 === e && (e = {}), (i = t.call(this, Jl({\n        event: \"tap\",\n        pointers: 1,\n        taps: 1,\n        interval: 300,\n        time: 250,\n        threshold: 9,\n        posThreshold: 10\n      }, e)) || this).pTime = !1, i.pCenter = !1, i._timer = null, i._input = null, i.count = 0, i;\n    }\n\n    tc(e, t);\n    var i = e.prototype;\n    return i.getTouchAction = function () {\n      return [pc];\n    }, i.process = function (t) {\n      var e = this,\n          i = this.options,\n          o = t.pointers.length === i.pointers,\n          n = t.distance < i.threshold,\n          r = t.deltaTime < i.time;\n      if (this.reset(), 1 & t.eventType && 0 === this.count) return this.failTimeout();\n\n      if (n && r && o) {\n        if (4 !== t.eventType) return this.failTimeout();\n        var s = !this.pTime || t.timeStamp - this.pTime < i.interval,\n            a = !this.pCenter || Fc(this.pCenter, t.center) < i.posThreshold;\n        if (this.pTime = t.timeStamp, this.pCenter = t.center, a && s ? this.count += 1 : this.count = 1, this._input = t, 0 === this.count % i.taps) return this.hasRequireFailures() ? (this._timer = setTimeout(function () {\n          e.state = 8, e.tryEmit();\n        }, i.interval), 2) : 8;\n      }\n\n      return fu;\n    }, i.failTimeout = function () {\n      var t = this;\n      return this._timer = setTimeout(function () {\n        t.state = fu;\n      }, this.options.interval), fu;\n    }, i.reset = function () {\n      clearTimeout(this._timer);\n    }, i.emit = function () {\n      8 === this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));\n    }, e;\n  }(yu),\n      bu = function (t) {\n    function e(e) {\n      return void 0 === e && (e = {}), t.call(this, Jl({\n        pointers: 1\n      }, e)) || this;\n    }\n\n    tc(e, t);\n    var i = e.prototype;\n    return i.attrTest = function (t) {\n      var e = this.options.pointers;\n      return 0 === e || t.pointers.length === e;\n    }, i.process = function (t) {\n      var e = this.state,\n          i = t.eventType,\n          o = 6 & e,\n          n = this.attrTest(t);\n      return o && (8 & i || !n) ? 16 | e : o || n ? 4 & i ? 8 | e : 2 & e ? 4 | e : 2 : fu;\n    }, e;\n  }(yu);\n\n  function wu(t) {\n    return t === Ec ? \"down\" : 8 === t ? \"up\" : 2 === t ? \"left\" : 4 === t ? \"right\" : \"\";\n  }\n\n  var ku = function (t) {\n    function e(e) {\n      var i;\n      return void 0 === e && (e = {}), (i = t.call(this, Jl({\n        event: \"pan\",\n        threshold: 10,\n        pointers: 1,\n        direction: 30\n      }, e)) || this).pX = null, i.pY = null, i;\n    }\n\n    tc(e, t);\n    var i = e.prototype;\n    return i.getTouchAction = function () {\n      var t = this.options.direction,\n          e = [];\n      return 6 & t && e.push(yc), t & Oc && e.push(gc), e;\n    }, i.directionTest = function (t) {\n      var e = this.options,\n          i = !0,\n          o = t.distance,\n          n = t.direction,\n          r = t.deltaX,\n          s = t.deltaY;\n      return n & e.direction || (6 & e.direction ? (n = 0 === r ? 1 : r < 0 ? 2 : 4, i = r !== this.pX, o = Math.abs(t.deltaX)) : (n = 0 === s ? 1 : s < 0 ? 8 : Ec, i = s !== this.pY, o = Math.abs(t.deltaY))), t.direction = n, i && o > e.threshold && n & e.direction;\n    }, i.attrTest = function (t) {\n      return bu.prototype.attrTest.call(this, t) && (2 & this.state || !(2 & this.state) && this.directionTest(t));\n    }, i.emit = function (e) {\n      this.pX = e.deltaX, this.pY = e.deltaY;\n      var i = wu(e.direction);\n      i && (e.additionalEvent = this.options.event + i), t.prototype.emit.call(this, e);\n    }, e;\n  }(bu),\n      _u = function (t) {\n    function e(e) {\n      return void 0 === e && (e = {}), t.call(this, Jl({\n        event: \"swipe\",\n        threshold: 10,\n        velocity: .3,\n        direction: 30,\n        pointers: 1\n      }, e)) || this;\n    }\n\n    tc(e, t);\n    var i = e.prototype;\n    return i.getTouchAction = function () {\n      return ku.prototype.getTouchAction.call(this);\n    }, i.attrTest = function (e) {\n      var i,\n          o = this.options.direction;\n      return 30 & o ? i = e.overallVelocity : 6 & o ? i = e.overallVelocityX : o & Oc && (i = e.overallVelocityY), t.prototype.attrTest.call(this, e) && o & e.offsetDirection && e.distance > this.options.threshold && e.maxPointers === this.options.pointers && ac(i) > this.options.velocity && 4 & e.eventType;\n    }, i.emit = function (t) {\n      var e = wu(t.offsetDirection);\n      e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t);\n    }, e;\n  }(bu),\n      xu = function (t) {\n    function e(e) {\n      return void 0 === e && (e = {}), t.call(this, Jl({\n        event: \"pinch\",\n        threshold: 0,\n        pointers: 2\n      }, e)) || this;\n    }\n\n    tc(e, t);\n    var i = e.prototype;\n    return i.getTouchAction = function () {\n      return [vc];\n    }, i.attrTest = function (e) {\n      return t.prototype.attrTest.call(this, e) && (Math.abs(e.scale - 1) > this.options.threshold || 2 & this.state);\n    }, i.emit = function (e) {\n      if (1 !== e.scale) {\n        var i = e.scale < 1 ? \"in\" : \"out\";\n        e.additionalEvent = this.options.event + i;\n      }\n\n      t.prototype.emit.call(this, e);\n    }, e;\n  }(bu),\n      Eu = function (t) {\n    function e(e) {\n      return void 0 === e && (e = {}), t.call(this, Jl({\n        event: \"rotate\",\n        threshold: 0,\n        pointers: 2\n      }, e)) || this;\n    }\n\n    tc(e, t);\n    var i = e.prototype;\n    return i.getTouchAction = function () {\n      return [vc];\n    }, i.attrTest = function (e) {\n      return t.prototype.attrTest.call(this, e) && (Math.abs(e.rotation) > this.options.threshold || 2 & this.state);\n    }, e;\n  }(bu),\n      Ou = function (t) {\n    function e(e) {\n      var i;\n      return void 0 === e && (e = {}), (i = t.call(this, Jl({\n        event: \"press\",\n        pointers: 1,\n        time: 251,\n        threshold: 9\n      }, e)) || this)._timer = null, i._input = null, i;\n    }\n\n    tc(e, t);\n    var i = e.prototype;\n    return i.getTouchAction = function () {\n      return [fc];\n    }, i.process = function (t) {\n      var e = this,\n          i = this.options,\n          o = t.pointers.length === i.pointers,\n          n = t.distance < i.threshold,\n          r = t.deltaTime > i.time;\n      if (this._input = t, !n || !o || 12 & t.eventType && !r) this.reset();else if (1 & t.eventType) this.reset(), this._timer = setTimeout(function () {\n        e.state = 8, e.tryEmit();\n      }, i.time);else if (4 & t.eventType) return 8;\n      return fu;\n    }, i.reset = function () {\n      clearTimeout(this._timer);\n    }, i.emit = function (t) {\n      8 === this.state && (t && 4 & t.eventType ? this.manager.emit(this.options.event + \"up\", t) : (this._input.timeStamp = hc(), this.manager.emit(this.options.event, this._input)));\n    }, e;\n  }(yu),\n      Cu = {\n    domEvents: !1,\n    touchAction: uc,\n    enable: !0,\n    inputTarget: null,\n    inputClass: null,\n    cssProps: {\n      userSelect: \"none\",\n      touchSelect: \"none\",\n      touchCallout: \"none\",\n      contentZooming: \"none\",\n      userDrag: \"none\",\n      tapHighlightColor: \"rgba(0,0,0,0)\"\n    }\n  },\n      Su = [[Eu, {\n    enable: !1\n  }], [xu, {\n    enable: !1\n  }, [\"rotate\"]], [_u, {\n    direction: 6\n  }], [ku, {\n    direction: 6\n  }, [\"swipe\"]], [mu], [mu, {\n    event: \"doubletap\",\n    taps: 2\n  }, [\"tap\"]], [Ou]];\n\n  function Tu(t, e) {\n    var i,\n        o = t.element;\n    o.style && (Tc(t.options.cssProps, function (n, r) {\n      i = dc(o.style, r), e ? (t.oldCssProps[i] = o.style[i], o.style[i] = n) : o.style[i] = t.oldCssProps[i] || \"\";\n    }), e || (t.oldCssProps = {}));\n  }\n\n  var Mu = function () {\n    function t(t, e) {\n      var i,\n          o = this;\n      this.options = oc({}, Cu, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = new ((i = this).options.inputClass || (wc ? Zc : kc ? iu : bc ? cu : au))(i, Lc), this.touchAction = new Dc(this, this.options.touchAction), Tu(this, !0), Tc(this.options.recognizers, function (t) {\n        var e = o.add(new t[0](t[1]));\n        t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3]);\n      }, this);\n    }\n\n    var e = t.prototype;\n    return e.set = function (t) {\n      return oc(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this;\n    }, e.stop = function (t) {\n      this.session.stopped = t ? 2 : 1;\n    }, e.recognize = function (t) {\n      var e = this.session;\n\n      if (!e.stopped) {\n        var i;\n        this.touchAction.preventDefaults(t);\n        var o = this.recognizers,\n            n = e.curRecognizer;\n        (!n || n && 8 & n.state) && (e.curRecognizer = null, n = null);\n\n        for (var r = 0; r < o.length;) i = o[r], 2 === e.stopped || n && i !== n && !i.canRecognizeWith(n) ? i.reset() : i.recognize(t), !n && 14 & i.state && (e.curRecognizer = i, n = i), r++;\n      }\n    }, e.get = function (t) {\n      if (t instanceof yu) return t;\n\n      for (var e = this.recognizers, i = 0; i < e.length; i++) if (e[i].options.event === t) return e[i];\n\n      return null;\n    }, e.add = function (t) {\n      if (uu(t, \"add\", this)) return this;\n      var e = this.get(t.options.event);\n      return e && this.remove(e), this.recognizers.push(t), t.manager = this, this.touchAction.update(), t;\n    }, e.remove = function (t) {\n      if (uu(t, \"remove\", this)) return this;\n      var e = this.get(t);\n\n      if (t) {\n        var i = this.recognizers,\n            o = Yc(i, e);\n        -1 !== o && (i.splice(o, 1), this.touchAction.update());\n      }\n\n      return this;\n    }, e.on = function (t, e) {\n      if (void 0 === t || void 0 === e) return this;\n      var i = this.handlers;\n      return Tc(Hc(t), function (t) {\n        i[t] = i[t] || [], i[t].push(e);\n      }), this;\n    }, e.off = function (t, e) {\n      if (void 0 === t) return this;\n      var i = this.handlers;\n      return Tc(Hc(t), function (t) {\n        e ? i[t] && i[t].splice(Yc(i[t], e), 1) : delete i[t];\n      }), this;\n    }, e.emit = function (t, e) {\n      this.options.domEvents && function (t, e) {\n        var i = document.createEvent(\"Event\");\n        i.initEvent(t, !0, !0), i.gesture = e, e.target.dispatchEvent(i);\n      }(t, e);\n      var i = this.handlers[t] && this.handlers[t].slice();\n\n      if (i && i.length) {\n        e.type = t, e.preventDefault = function () {\n          e.srcEvent.preventDefault();\n        };\n\n        for (var o = 0; o < i.length;) i[o](e), o++;\n      }\n    }, e.destroy = function () {\n      this.element && Tu(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;\n    }, t;\n  }(),\n      Pu = {\n    touchstart: 1,\n    touchmove: 2,\n    touchend: 4,\n    touchcancel: 8\n  },\n      Du = \"touchstart\",\n      Bu = \"touchstart touchmove touchend touchcancel\",\n      Iu = function (t) {\n    function e() {\n      var i,\n          o = e.prototype;\n      return o.evTarget = Du, o.evWin = Bu, (i = t.apply(this, arguments) || this).started = !1, i;\n    }\n\n    return tc(e, t), e.prototype.handler = function (t) {\n      var e = Pu[t.type];\n\n      if (1 === e && (this.started = !0), this.started) {\n        var i = zu.call(this, t, e);\n        12 & e && i[0].length - i[1].length == 0 && (this.started = !1), this.callback(this.manager, e, {\n          pointers: i[0],\n          changedPointers: i[1],\n          pointerType: _c,\n          srcEvent: t\n        });\n      }\n    }, e;\n  }(Uc);\n\n  function zu(t, e) {\n    var i = Qc(t.touches),\n        o = Qc(t.changedTouches);\n    return 12 & e && (i = Jc(i.concat(o), \"identifier\", !0)), [i, o];\n  }\n\n  function Fu(t, e, i) {\n    var o = \"DEPRECATED METHOD: \" + e + \"\\n\" + i + \" AT \\n\";\n    return function () {\n      var e = new Error(\"get-stack-trace\"),\n          i = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, \"\").replace(/^\\s+at\\s+/gm, \"\").replace(/^Object.<anonymous>\\s*\\(/gm, \"{anonymous}()@\") : \"Unknown Stack Trace\",\n          n = window.console && (window.console.warn || window.console.log);\n      return n && n.call(window.console, o, i), t.apply(this, arguments);\n    };\n  }\n\n  var Nu = Fu(function (t, e, i) {\n    for (var o = Object.keys(e), n = 0; n < o.length;) (!i || i && void 0 === t[o[n]]) && (t[o[n]] = e[o[n]]), n++;\n\n    return t;\n  }, \"extend\", \"Use `assign`.\"),\n      Au = Fu(function (t, e) {\n    return Nu(t, e, !0);\n  }, \"merge\", \"Use `assign`.\");\n\n  function Ru(t, e, i) {\n    var o,\n        n = e.prototype;\n    (o = t.prototype = Object.create(n)).constructor = t, o._super = n, i && oc(o, i);\n  }\n\n  function ju(t, e) {\n    return function () {\n      return t.apply(e, arguments);\n    };\n  }\n\n  var Lu = function () {\n    var t = function (t, e) {\n      return void 0 === e && (e = {}), new Mu(t, Jl({\n        recognizers: Su.concat()\n      }, e));\n    };\n\n    return t.VERSION = \"2.0.17-rc\", t.DIRECTION_ALL = 30, t.DIRECTION_DOWN = Ec, t.DIRECTION_LEFT = 2, t.DIRECTION_RIGHT = 4, t.DIRECTION_UP = 8, t.DIRECTION_HORIZONTAL = 6, t.DIRECTION_VERTICAL = Oc, t.DIRECTION_NONE = 1, t.DIRECTION_DOWN = Ec, t.INPUT_START = 1, t.INPUT_MOVE = 2, t.INPUT_END = 4, t.INPUT_CANCEL = 8, t.STATE_POSSIBLE = 1, t.STATE_BEGAN = 2, t.STATE_CHANGED = 4, t.STATE_ENDED = 8, t.STATE_RECOGNIZED = 8, t.STATE_CANCELLED = 16, t.STATE_FAILED = fu, t.Manager = Mu, t.Input = Uc, t.TouchAction = Dc, t.TouchInput = iu, t.MouseInput = au, t.PointerEventInput = Zc, t.TouchMouseInput = cu, t.SingleTouchInput = Iu, t.Recognizer = yu, t.AttrRecognizer = bu, t.Tap = mu, t.Pan = ku, t.Swipe = _u, t.Pinch = xu, t.Rotate = Eu, t.Press = Ou, t.on = Wc, t.off = Vc, t.each = Tc, t.merge = Au, t.extend = Nu, t.bindFn = ju, t.assign = oc, t.inherit = Ru, t.bindFn = ju, t.prefixed = dc, t.toArray = Qc, t.inArray = Yc, t.uniqueArray = Jc, t.splitStr = Hc, t.boolOrFn = Mc, t.hasParent = Bc, t.addEventListeners = Wc, t.removeEventListeners = Vc, t.defaults = oc({}, Cu, {\n      preset: Su\n    }), t;\n  }();\n\n  function Hu(t, e) {\n    var i = void 0 !== Nh && xr(t) || t[\"@@iterator\"];\n\n    if (!i) {\n      if (Hh(t) || (i = function (t, e) {\n        var i;\n        if (!t) return;\n        if (\"string\" == typeof t) return Wu(t, e);\n        var o = Lh(i = Object.prototype.toString.call(t)).call(i, 8, -1);\n        \"Object\" === o && t.constructor && (o = t.constructor.name);\n        if (\"Map\" === o || \"Set\" === o) return rr(t);\n        if (\"Arguments\" === o || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)) return Wu(t, e);\n      }(t)) || e && t && \"number\" == typeof t.length) {\n        i && (t = i);\n\n        var o = 0,\n            n = function () {};\n\n        return {\n          s: n,\n          n: function () {\n            return o >= t.length ? {\n              done: !0\n            } : {\n              done: !1,\n              value: t[o++]\n            };\n          },\n          e: function (t) {\n            throw t;\n          },\n          f: n\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var r,\n        s = !0,\n        a = !1;\n    return {\n      s: function () {\n        i = i.call(t);\n      },\n      n: function () {\n        var t = i.next();\n        return s = t.done, t;\n      },\n      e: function (t) {\n        a = !0, r = t;\n      },\n      f: function () {\n        try {\n          s || null == i.return || i.return();\n        } finally {\n          if (a) throw r;\n        }\n      }\n    };\n  }\n\n  function Wu(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var i = 0, o = new Array(e); i < e; i++) o[i] = t[i];\n\n    return o;\n  }\n\n  function Vu() {\n    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];\n\n    return qu(e.length ? e : [Kh()]);\n  }\n\n  function qu(t) {\n    var e = Bh(function () {\n      for (var t = Uu(), e = t(\" \"), i = t(\" \"), o = t(\" \"), n = 0; n < arguments.length; n++) (e -= t(n < 0 || arguments.length <= n ? void 0 : arguments[n])) < 0 && (e += 1), (i -= t(n < 0 || arguments.length <= n ? void 0 : arguments[n])) < 0 && (i += 1), (o -= t(n < 0 || arguments.length <= n ? void 0 : arguments[n])) < 0 && (o += 1);\n\n      return [e, i, o];\n    }(t), 3),\n        i = e[0],\n        o = e[1],\n        n = e[2],\n        r = 1,\n        s = function () {\n      var t = 2091639 * i + 2.3283064365386963e-10 * r;\n      return i = o, o = n, n = t - (r = 0 | t);\n    };\n\n    return s.uint32 = function () {\n      return 4294967296 * s();\n    }, s.fract53 = function () {\n      return s() + 11102230246251565e-32 * (2097152 * s() | 0);\n    }, s.algorithm = \"Alea\", s.seed = t, s.version = \"0.9\", s;\n  }\n\n  function Uu() {\n    var t = 4022871197;\n    return function (e) {\n      for (var i = e.toString(), o = 0; o < i.length; o++) {\n        var n = .02519603282416938 * (t += i.charCodeAt(o));\n        n -= t = n >>> 0, t = (n *= t) >>> 0, t += 4294967296 * (n -= t);\n      }\n\n      return 2.3283064365386963e-10 * (t >>> 0);\n    };\n  }\n\n  Nh(\"DELETE\");\n  var Yu = \"undefined\" != typeof window ? window.Hammer || Lu : function () {\n    return {\n      on: t = function () {},\n      off: t,\n      destroy: t,\n      emit: t,\n      get: function () {\n        return {\n          set: t\n        };\n      }\n    };\n    var t;\n  };\n\n  function Xu(t) {\n    var e,\n        i = this;\n    this._cleanupQueue = [], this.active = !1, this._dom = {\n      container: t,\n      overlay: document.createElement(\"div\")\n    }, this._dom.overlay.classList.add(\"vis-overlay\"), this._dom.container.appendChild(this._dom.overlay), this._cleanupQueue.push(function () {\n      i._dom.overlay.parentNode.removeChild(i._dom.overlay);\n    });\n    var o = Yu(this._dom.overlay);\n    o.on(\"tap\", si(e = this._onTapOverlay).call(e, this)), this._cleanupQueue.push(function () {\n      o.destroy();\n    });\n    var n = [\"tap\", \"doubletap\", \"press\", \"pinch\", \"pan\", \"panstart\", \"panmove\", \"panend\"];\n    nd(n).call(n, function (t) {\n      o.on(t, function (t) {\n        t.srcEvent.stopPropagation();\n      });\n    }), document && document.body && (this._onClick = function (e) {\n      (function (t, e) {\n        for (; t;) {\n          if (t === e) return !0;\n          t = t.parentNode;\n        }\n\n        return !1;\n      })(e.target, t) || i.deactivate();\n    }, document.body.addEventListener(\"click\", this._onClick), this._cleanupQueue.push(function () {\n      document.body.removeEventListener(\"click\", i._onClick);\n    })), this._escListener = function (t) {\n      (\"key\" in t ? \"Escape\" === t.key : 27 === t.keyCode) && i.deactivate();\n    };\n  }\n\n  pi(Xu.prototype), Xu.current = null, Xu.prototype.destroy = function () {\n    var t, e;\n    this.deactivate();\n    var i,\n        o = Hu(ld(t = Od(e = this._cleanupQueue).call(e, 0)).call(t));\n\n    try {\n      for (o.s(); !(i = o.n()).done;) {\n        (0, i.value)();\n      }\n    } catch (t) {\n      o.e(t);\n    } finally {\n      o.f();\n    }\n  }, Xu.prototype.activate = function () {\n    Xu.current && Xu.current.deactivate(), Xu.current = this, this.active = !0, this._dom.overlay.style.display = \"none\", this._dom.container.classList.add(\"vis-active\"), this.emit(\"change\"), this.emit(\"activate\"), document.body.addEventListener(\"keydown\", this._escListener);\n  }, Xu.prototype.deactivate = function () {\n    this.active = !1, this._dom.overlay.style.display = \"block\", this._dom.container.classList.remove(\"vis-active\"), document.body.removeEventListener(\"keydown\", this._escListener), this.emit(\"change\"), this.emit(\"deactivate\");\n  }, Xu.prototype._onTapOverlay = function (t) {\n    this.activate(), t.srcEvent.stopPropagation();\n  };\n  var Gu = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i,\n      Ku = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i,\n      $u = /^rgb\\( *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *\\)$/i,\n      Zu = /^rgba\\( *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *([01]|0?\\.\\d+) *\\)$/i;\n\n  function Qu(t) {\n    if (t) for (; !0 === t.hasChildNodes();) {\n      var e = t.firstChild;\n      e && (Qu(e), t.removeChild(e));\n    }\n  }\n\n  function Ju(t) {\n    return t instanceof String || \"string\" == typeof t;\n  }\n\n  function tf(t) {\n    return \"object\" === zh(t) && null !== t;\n  }\n\n  function ef(t, e, i, o) {\n    var n = !1;\n    !0 === o && (n = null === e[i] && void 0 !== t[i]), n ? delete t[i] : t[i] = e[i];\n  }\n\n  function of(t, e) {\n    var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n\n    for (var o in t) if (void 0 !== e[o]) if (null === e[o] || \"object\" !== zh(e[o])) ef(t, e, o, i);else {\n      var n = t[o],\n          r = e[o];\n      tf(n) && tf(r) && of(n, r, i);\n    }\n  }\n\n  function nf(t, e, i) {\n    var o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];\n    if (Hh(i)) throw new TypeError(\"Arrays are not supported by deepExtend\");\n\n    for (var n = 0; n < t.length; n++) {\n      var r = t[n];\n      if (Object.prototype.hasOwnProperty.call(i, r)) if (i[r] && i[r].constructor === Object) void 0 === e[r] && (e[r] = {}), e[r].constructor === Object ? sf(e[r], i[r], !1, o) : ef(e, i, r, o);else {\n        if (Hh(i[r])) throw new TypeError(\"Arrays are not supported by deepExtend\");\n        ef(e, i, r, o);\n      }\n    }\n\n    return e;\n  }\n\n  function rf(t, e, i) {\n    var o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];\n    if (Hh(i)) throw new TypeError(\"Arrays are not supported by deepExtend\");\n\n    for (var n in i) if (Object.prototype.hasOwnProperty.call(i, n) && !Hd(t).call(t, n)) if (i[n] && i[n].constructor === Object) void 0 === e[n] && (e[n] = {}), e[n].constructor === Object ? sf(e[n], i[n]) : ef(e, i, n, o);else if (Hh(i[n])) {\n      e[n] = [];\n\n      for (var r = 0; r < i[n].length; r++) e[n].push(i[n][r]);\n    } else ef(e, i, n, o);\n\n    return e;\n  }\n\n  function sf(t, e) {\n    var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n        o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];\n\n    for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n) || !0 === i) if (\"object\" === zh(e[n]) && null !== e[n] && Yd(e[n]) === Object.prototype) void 0 === t[n] ? t[n] = sf({}, e[n], i) : \"object\" === zh(t[n]) && null !== t[n] && Yd(t[n]) === Object.prototype ? sf(t[n], e[n], i) : ef(t, e, n, o);else if (Hh(e[n])) {\n      var r;\n      t[n] = Lh(r = e[n]).call(r);\n    } else ef(t, e, n, o);\n\n    return t;\n  }\n\n  function af(t, e) {\n    var i;\n    return jh(i = []).call(i, Fh(t), [e]);\n  }\n\n  function hf(t) {\n    return Lh(t).call(t);\n  }\n\n  function df(t) {\n    return t.getBoundingClientRect().top;\n  }\n\n  function lf(t, e) {\n    if (Hh(t)) for (var i = t.length, o = 0; o < i; o++) e(t[o], o, t);else for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e(t[n], n, t);\n  }\n\n  function cf(t) {\n    var e;\n\n    switch (t.length) {\n      case 3:\n      case 4:\n        return (e = Ku.exec(t)) ? {\n          r: yl(e[1] + e[1], 16),\n          g: yl(e[2] + e[2], 16),\n          b: yl(e[3] + e[3], 16)\n        } : null;\n\n      case 6:\n      case 7:\n        return (e = Gu.exec(t)) ? {\n          r: yl(e[1], 16),\n          g: yl(e[2], 16),\n          b: yl(e[3], 16)\n        } : null;\n\n      default:\n        return null;\n    }\n  }\n\n  function uf(t, e) {\n    if (Hd(t).call(t, \"rgba\")) return t;\n\n    if (Hd(t).call(t, \"rgb\")) {\n      var i = t.substr(Cl(t).call(t, \"(\") + 1).replace(\")\", \"\").split(\",\");\n      return \"rgba(\" + i[0] + \",\" + i[1] + \",\" + i[2] + \",\" + e + \")\";\n    }\n\n    var o = cf(t);\n    return null == o ? t : \"rgba(\" + o.r + \",\" + o.g + \",\" + o.b + \",\" + e + \")\";\n  }\n\n  function ff(t, e, i) {\n    var o;\n    return \"#\" + Lh(o = ((1 << 24) + (t << 16) + (e << 8) + i).toString(16)).call(o, 1);\n  }\n\n  function pf(t, e) {\n    if (Ju(t)) {\n      var i = t;\n\n      if (bf(i)) {\n        var o,\n            n = Uh(o = i.substr(4).substr(0, i.length - 5).split(\",\")).call(o, function (t) {\n          return yl(t);\n        });\n        i = ff(n[0], n[1], n[2]);\n      }\n\n      if (!0 === mf(i)) {\n        var r = function (t) {\n          var e = cf(t);\n          if (!e) throw new TypeError(\"'\".concat(t, \"' is not a valid color.\"));\n          return vf(e.r, e.g, e.b);\n        }(i),\n            s = {\n          h: r.h,\n          s: .8 * r.s,\n          v: Math.min(1, 1.02 * r.v)\n        },\n            a = {\n          h: r.h,\n          s: Math.min(1, 1.25 * r.s),\n          v: .8 * r.v\n        },\n            h = yf(a.h, a.s, a.v),\n            d = yf(s.h, s.s, s.v);\n\n        return {\n          background: i,\n          border: h,\n          highlight: {\n            background: d,\n            border: h\n          },\n          hover: {\n            background: d,\n            border: h\n          }\n        };\n      }\n\n      return {\n        background: i,\n        border: i,\n        highlight: {\n          background: i,\n          border: i\n        },\n        hover: {\n          background: i,\n          border: i\n        }\n      };\n    }\n\n    return e ? {\n      background: t.background || e.background,\n      border: t.border || e.border,\n      highlight: Ju(t.highlight) ? {\n        border: t.highlight,\n        background: t.highlight\n      } : {\n        background: t.highlight && t.highlight.background || e.highlight.background,\n        border: t.highlight && t.highlight.border || e.highlight.border\n      },\n      hover: Ju(t.hover) ? {\n        border: t.hover,\n        background: t.hover\n      } : {\n        border: t.hover && t.hover.border || e.hover.border,\n        background: t.hover && t.hover.background || e.hover.background\n      }\n    } : {\n      background: t.background || void 0,\n      border: t.border || void 0,\n      highlight: Ju(t.highlight) ? {\n        border: t.highlight,\n        background: t.highlight\n      } : {\n        background: t.highlight && t.highlight.background || void 0,\n        border: t.highlight && t.highlight.border || void 0\n      },\n      hover: Ju(t.hover) ? {\n        border: t.hover,\n        background: t.hover\n      } : {\n        border: t.hover && t.hover.border || void 0,\n        background: t.hover && t.hover.background || void 0\n      }\n    };\n  }\n\n  function vf(t, e, i) {\n    t /= 255, e /= 255, i /= 255;\n    var o = Math.min(t, Math.min(e, i)),\n        n = Math.max(t, Math.max(e, i));\n    return o === n ? {\n      h: 0,\n      s: 0,\n      v: o\n    } : {\n      h: 60 * ((t === o ? 3 : i === o ? 1 : 5) - (t === o ? e - i : i === o ? t - e : i - t) / (n - o)) / 360,\n      s: (n - o) / n,\n      v: n\n    };\n  }\n\n  function gf(t, e, i) {\n    var o,\n        n,\n        r,\n        s = Math.floor(6 * t),\n        a = 6 * t - s,\n        h = i * (1 - e),\n        d = i * (1 - a * e),\n        l = i * (1 - (1 - a) * e);\n\n    switch (s % 6) {\n      case 0:\n        o = i, n = l, r = h;\n        break;\n\n      case 1:\n        o = d, n = i, r = h;\n        break;\n\n      case 2:\n        o = h, n = i, r = l;\n        break;\n\n      case 3:\n        o = h, n = d, r = i;\n        break;\n\n      case 4:\n        o = l, n = h, r = i;\n        break;\n\n      case 5:\n        o = i, n = h, r = d;\n    }\n\n    return {\n      r: Math.floor(255 * o),\n      g: Math.floor(255 * n),\n      b: Math.floor(255 * r)\n    };\n  }\n\n  function yf(t, e, i) {\n    var o = gf(t, e, i);\n    return ff(o.r, o.g, o.b);\n  }\n\n  function mf(t) {\n    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(t);\n  }\n\n  function bf(t) {\n    return $u.test(t);\n  }\n\n  function wf(t) {\n    return Zu.test(t);\n  }\n\n  function kf(t) {\n    if (null === t || \"object\" !== zh(t)) return null;\n    if (t instanceof Element) return t;\n    var e = Bl(t);\n\n    for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && \"object\" == zh(t[i]) && (e[i] = kf(t[i]));\n\n    return e;\n  }\n\n  function _f(t, e, i) {\n    var o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},\n        n = function (t) {\n      return null != t;\n    },\n        r = function (t) {\n      return null !== t && \"object\" === zh(t);\n    },\n        s = function (t) {\n      for (var e in t) if (Object.prototype.hasOwnProperty.call(t, e)) return !1;\n\n      return !0;\n    };\n\n    if (!r(t)) throw new Error(\"Parameter mergeTarget must be an object\");\n    if (!r(e)) throw new Error(\"Parameter options must be an object\");\n    if (!n(i)) throw new Error(\"Parameter option must have a value\");\n    if (!r(o)) throw new Error(\"Parameter globalOptions must be an object\");\n\n    var a = function (t, e, i) {\n      r(t[i]) || (t[i] = {});\n      var o = e[i],\n          n = t[i];\n\n      for (var s in o) Object.prototype.hasOwnProperty.call(o, s) && (n[s] = o[s]);\n    },\n        h = e[i],\n        d = r(o) && !s(o),\n        l = d ? o[i] : void 0,\n        c = l ? l.enabled : void 0;\n\n    if (void 0 !== h) {\n      if (\"boolean\" == typeof h) return r(t[i]) || (t[i] = {}), void (t[i].enabled = h);\n\n      if (null === h && !r(t[i])) {\n        if (!n(l)) return;\n        t[i] = Bl(l);\n      }\n\n      if (r(h)) {\n        var u = !0;\n        void 0 !== h.enabled ? u = h.enabled : void 0 !== c && (u = l.enabled), a(t, e, i), t[i].enabled = u;\n      }\n    }\n  }\n\n  var xf = {\n    linear: function (t) {\n      return t;\n    },\n    easeInQuad: function (t) {\n      return t * t;\n    },\n    easeOutQuad: function (t) {\n      return t * (2 - t);\n    },\n    easeInOutQuad: function (t) {\n      return t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1;\n    },\n    easeInCubic: function (t) {\n      return t * t * t;\n    },\n    easeOutCubic: function (t) {\n      return --t * t * t + 1;\n    },\n    easeInOutCubic: function (t) {\n      return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n    },\n    easeInQuart: function (t) {\n      return t * t * t * t;\n    },\n    easeOutQuart: function (t) {\n      return 1 - --t * t * t * t;\n    },\n    easeInOutQuart: function (t) {\n      return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n    },\n    easeInQuint: function (t) {\n      return t * t * t * t * t;\n    },\n    easeOutQuint: function (t) {\n      return 1 + --t * t * t * t * t;\n    },\n    easeInOutQuint: function (t) {\n      return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n    }\n  };\n\n  function Ef(t, e) {\n    var i;\n    Hh(e) || (e = [e]);\n    var o,\n        n = Hu(t);\n\n    try {\n      for (n.s(); !(o = n.n()).done;) {\n        var r = o.value;\n\n        if (r) {\n          i = r[e[0]];\n\n          for (var s = 1; s < e.length; s++) i && (i = i[e[s]]);\n\n          if (void 0 !== i) break;\n        }\n      }\n    } catch (t) {\n      n.e(t);\n    } finally {\n      n.f();\n    }\n\n    return i;\n  }\n\n  var Of = {\n    black: \"#000000\",\n    navy: \"#000080\",\n    darkblue: \"#00008B\",\n    mediumblue: \"#0000CD\",\n    blue: \"#0000FF\",\n    darkgreen: \"#006400\",\n    green: \"#008000\",\n    teal: \"#008080\",\n    darkcyan: \"#008B8B\",\n    deepskyblue: \"#00BFFF\",\n    darkturquoise: \"#00CED1\",\n    mediumspringgreen: \"#00FA9A\",\n    lime: \"#00FF00\",\n    springgreen: \"#00FF7F\",\n    aqua: \"#00FFFF\",\n    cyan: \"#00FFFF\",\n    midnightblue: \"#191970\",\n    dodgerblue: \"#1E90FF\",\n    lightseagreen: \"#20B2AA\",\n    forestgreen: \"#228B22\",\n    seagreen: \"#2E8B57\",\n    darkslategray: \"#2F4F4F\",\n    limegreen: \"#32CD32\",\n    mediumseagreen: \"#3CB371\",\n    turquoise: \"#40E0D0\",\n    royalblue: \"#4169E1\",\n    steelblue: \"#4682B4\",\n    darkslateblue: \"#483D8B\",\n    mediumturquoise: \"#48D1CC\",\n    indigo: \"#4B0082\",\n    darkolivegreen: \"#556B2F\",\n    cadetblue: \"#5F9EA0\",\n    cornflowerblue: \"#6495ED\",\n    mediumaquamarine: \"#66CDAA\",\n    dimgray: \"#696969\",\n    slateblue: \"#6A5ACD\",\n    olivedrab: \"#6B8E23\",\n    slategray: \"#708090\",\n    lightslategray: \"#778899\",\n    mediumslateblue: \"#7B68EE\",\n    lawngreen: \"#7CFC00\",\n    chartreuse: \"#7FFF00\",\n    aquamarine: \"#7FFFD4\",\n    maroon: \"#800000\",\n    purple: \"#800080\",\n    olive: \"#808000\",\n    gray: \"#808080\",\n    skyblue: \"#87CEEB\",\n    lightskyblue: \"#87CEFA\",\n    blueviolet: \"#8A2BE2\",\n    darkred: \"#8B0000\",\n    darkmagenta: \"#8B008B\",\n    saddlebrown: \"#8B4513\",\n    darkseagreen: \"#8FBC8F\",\n    lightgreen: \"#90EE90\",\n    mediumpurple: \"#9370D8\",\n    darkviolet: \"#9400D3\",\n    palegreen: \"#98FB98\",\n    darkorchid: \"#9932CC\",\n    yellowgreen: \"#9ACD32\",\n    sienna: \"#A0522D\",\n    brown: \"#A52A2A\",\n    darkgray: \"#A9A9A9\",\n    lightblue: \"#ADD8E6\",\n    greenyellow: \"#ADFF2F\",\n    paleturquoise: \"#AFEEEE\",\n    lightsteelblue: \"#B0C4DE\",\n    powderblue: \"#B0E0E6\",\n    firebrick: \"#B22222\",\n    darkgoldenrod: \"#B8860B\",\n    mediumorchid: \"#BA55D3\",\n    rosybrown: \"#BC8F8F\",\n    darkkhaki: \"#BDB76B\",\n    silver: \"#C0C0C0\",\n    mediumvioletred: \"#C71585\",\n    indianred: \"#CD5C5C\",\n    peru: \"#CD853F\",\n    chocolate: \"#D2691E\",\n    tan: \"#D2B48C\",\n    lightgrey: \"#D3D3D3\",\n    palevioletred: \"#D87093\",\n    thistle: \"#D8BFD8\",\n    orchid: \"#DA70D6\",\n    goldenrod: \"#DAA520\",\n    crimson: \"#DC143C\",\n    gainsboro: \"#DCDCDC\",\n    plum: \"#DDA0DD\",\n    burlywood: \"#DEB887\",\n    lightcyan: \"#E0FFFF\",\n    lavender: \"#E6E6FA\",\n    darksalmon: \"#E9967A\",\n    violet: \"#EE82EE\",\n    palegoldenrod: \"#EEE8AA\",\n    lightcoral: \"#F08080\",\n    khaki: \"#F0E68C\",\n    aliceblue: \"#F0F8FF\",\n    honeydew: \"#F0FFF0\",\n    azure: \"#F0FFFF\",\n    sandybrown: \"#F4A460\",\n    wheat: \"#F5DEB3\",\n    beige: \"#F5F5DC\",\n    whitesmoke: \"#F5F5F5\",\n    mintcream: \"#F5FFFA\",\n    ghostwhite: \"#F8F8FF\",\n    salmon: \"#FA8072\",\n    antiquewhite: \"#FAEBD7\",\n    linen: \"#FAF0E6\",\n    lightgoldenrodyellow: \"#FAFAD2\",\n    oldlace: \"#FDF5E6\",\n    red: \"#FF0000\",\n    fuchsia: \"#FF00FF\",\n    magenta: \"#FF00FF\",\n    deeppink: \"#FF1493\",\n    orangered: \"#FF4500\",\n    tomato: \"#FF6347\",\n    hotpink: \"#FF69B4\",\n    coral: \"#FF7F50\",\n    darkorange: \"#FF8C00\",\n    lightsalmon: \"#FFA07A\",\n    orange: \"#FFA500\",\n    lightpink: \"#FFB6C1\",\n    pink: \"#FFC0CB\",\n    gold: \"#FFD700\",\n    peachpuff: \"#FFDAB9\",\n    navajowhite: \"#FFDEAD\",\n    moccasin: \"#FFE4B5\",\n    bisque: \"#FFE4C4\",\n    mistyrose: \"#FFE4E1\",\n    blanchedalmond: \"#FFEBCD\",\n    papayawhip: \"#FFEFD5\",\n    lavenderblush: \"#FFF0F5\",\n    seashell: \"#FFF5EE\",\n    cornsilk: \"#FFF8DC\",\n    lemonchiffon: \"#FFFACD\",\n    floralwhite: \"#FFFAF0\",\n    snow: \"#FFFAFA\",\n    yellow: \"#FFFF00\",\n    lightyellow: \"#FFFFE0\",\n    ivory: \"#FFFFF0\",\n    white: \"#FFFFFF\"\n  },\n      Cf = function () {\n    function t() {\n      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;\n      Ra(this, t), this.pixelRatio = e, this.generated = !1, this.centerCoordinates = {\n        x: 144.5,\n        y: 144.5\n      }, this.r = 289 * .49, this.color = {\n        r: 255,\n        g: 255,\n        b: 255,\n        a: 1\n      }, this.hueCircle = void 0, this.initialColor = {\n        r: 255,\n        g: 255,\n        b: 255,\n        a: 1\n      }, this.previousColor = void 0, this.applied = !1, this.updateCallback = function () {}, this.closeCallback = function () {}, this._create();\n    }\n\n    return Ha(t, [{\n      key: \"insertTo\",\n      value: function (t) {\n        void 0 !== this.hammer && (this.hammer.destroy(), this.hammer = void 0), this.container = t, this.container.appendChild(this.frame), this._bindHammer(), this._setSize();\n      }\n    }, {\n      key: \"setUpdateCallback\",\n      value: function (t) {\n        if (\"function\" != typeof t) throw new Error(\"Function attempted to set as colorPicker update callback is not a function.\");\n        this.updateCallback = t;\n      }\n    }, {\n      key: \"setCloseCallback\",\n      value: function (t) {\n        if (\"function\" != typeof t) throw new Error(\"Function attempted to set as colorPicker closing callback is not a function.\");\n        this.closeCallback = t;\n      }\n    }, {\n      key: \"_isColorString\",\n      value: function (t) {\n        if (\"string\" == typeof t) return Of[t];\n      }\n    }, {\n      key: \"setColor\",\n      value: function (t) {\n        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n\n        if (\"none\" !== t) {\n          var i,\n              o = this._isColorString(t);\n\n          if (void 0 !== o && (t = o), !0 === Ju(t)) {\n            if (!0 === bf(t)) {\n              var n = t.substr(4).substr(0, t.length - 5).split(\",\");\n              i = {\n                r: n[0],\n                g: n[1],\n                b: n[2],\n                a: 1\n              };\n            } else if (!0 === wf(t)) {\n              var r = t.substr(5).substr(0, t.length - 6).split(\",\");\n              i = {\n                r: r[0],\n                g: r[1],\n                b: r[2],\n                a: r[3]\n              };\n            } else if (!0 === mf(t)) {\n              var s = cf(t);\n              i = {\n                r: s.r,\n                g: s.g,\n                b: s.b,\n                a: 1\n              };\n            }\n          } else if (t instanceof Object && void 0 !== t.r && void 0 !== t.g && void 0 !== t.b) {\n            var a = void 0 !== t.a ? t.a : \"1.0\";\n            i = {\n              r: t.r,\n              g: t.g,\n              b: t.b,\n              a: a\n            };\n          }\n\n          if (void 0 === i) throw new Error(\"Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: \" + Wl(t));\n\n          this._setColor(i, e);\n        }\n      }\n    }, {\n      key: \"show\",\n      value: function () {\n        void 0 !== this.closeCallback && (this.closeCallback(), this.closeCallback = void 0), this.applied = !1, this.frame.style.display = \"block\", this._generateHueCircle();\n      }\n    }, {\n      key: \"_hide\",\n      value: function () {\n        var t = this,\n            e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n        !0 === e && (this.previousColor = Ke({}, this.color)), !0 === this.applied && this.updateCallback(this.initialColor), this.frame.style.display = \"none\", Yl(function () {\n          void 0 !== t.closeCallback && (t.closeCallback(), t.closeCallback = void 0);\n        }, 0);\n      }\n    }, {\n      key: \"_save\",\n      value: function () {\n        this.updateCallback(this.color), this.applied = !1, this._hide();\n      }\n    }, {\n      key: \"_apply\",\n      value: function () {\n        this.applied = !0, this.updateCallback(this.color), this._updatePicker(this.color);\n      }\n    }, {\n      key: \"_loadLast\",\n      value: function () {\n        void 0 !== this.previousColor ? this.setColor(this.previousColor, !1) : alert(\"There is no last color to load...\");\n      }\n    }, {\n      key: \"_setColor\",\n      value: function (t) {\n        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n        !0 === e && (this.initialColor = Ke({}, t)), this.color = t;\n        var i = vf(t.r, t.g, t.b),\n            o = 2 * Math.PI,\n            n = this.r * i.s,\n            r = this.centerCoordinates.x + n * Math.sin(o * i.h),\n            s = this.centerCoordinates.y + n * Math.cos(o * i.h);\n        this.colorPickerSelector.style.left = r - .5 * this.colorPickerSelector.clientWidth + \"px\", this.colorPickerSelector.style.top = s - .5 * this.colorPickerSelector.clientHeight + \"px\", this._updatePicker(t);\n      }\n    }, {\n      key: \"_setOpacity\",\n      value: function (t) {\n        this.color.a = t / 100, this._updatePicker(this.color);\n      }\n    }, {\n      key: \"_setBrightness\",\n      value: function (t) {\n        var e = vf(this.color.r, this.color.g, this.color.b);\n        e.v = t / 100;\n        var i = gf(e.h, e.s, e.v);\n        i.a = this.color.a, this.color = i, this._updatePicker();\n      }\n    }, {\n      key: \"_updatePicker\",\n      value: function () {\n        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.color,\n            e = vf(t.r, t.g, t.b),\n            i = this.colorPickerCanvas.getContext(\"2d\");\n        void 0 === this.pixelRation && (this.pixelRatio = (window.devicePixelRatio || 1) / (i.webkitBackingStorePixelRatio || i.mozBackingStorePixelRatio || i.msBackingStorePixelRatio || i.oBackingStorePixelRatio || i.backingStorePixelRatio || 1)), i.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n        var o = this.colorPickerCanvas.clientWidth,\n            n = this.colorPickerCanvas.clientHeight;\n        i.clearRect(0, 0, o, n), i.putImageData(this.hueCircle, 0, 0), i.fillStyle = \"rgba(0,0,0,\" + (1 - e.v) + \")\", i.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r), Ql(i).call(i), this.brightnessRange.value = 100 * e.v, this.opacityRange.value = 100 * t.a, this.initialColorDiv.style.backgroundColor = \"rgba(\" + this.initialColor.r + \",\" + this.initialColor.g + \",\" + this.initialColor.b + \",\" + this.initialColor.a + \")\", this.newColorDiv.style.backgroundColor = \"rgba(\" + this.color.r + \",\" + this.color.g + \",\" + this.color.b + \",\" + this.color.a + \")\";\n      }\n    }, {\n      key: \"_setSize\",\n      value: function () {\n        this.colorPickerCanvas.style.width = \"100%\", this.colorPickerCanvas.style.height = \"100%\", this.colorPickerCanvas.width = 289 * this.pixelRatio, this.colorPickerCanvas.height = 289 * this.pixelRatio;\n      }\n    }, {\n      key: \"_create\",\n      value: function () {\n        var t, e, i, o;\n\n        if (this.frame = document.createElement(\"div\"), this.frame.className = \"vis-color-picker\", this.colorPickerDiv = document.createElement(\"div\"), this.colorPickerSelector = document.createElement(\"div\"), this.colorPickerSelector.className = \"vis-selector\", this.colorPickerDiv.appendChild(this.colorPickerSelector), this.colorPickerCanvas = document.createElement(\"canvas\"), this.colorPickerDiv.appendChild(this.colorPickerCanvas), this.colorPickerCanvas.getContext) {\n          var n = this.colorPickerCanvas.getContext(\"2d\");\n          this.pixelRatio = (window.devicePixelRatio || 1) / (n.webkitBackingStorePixelRatio || n.mozBackingStorePixelRatio || n.msBackingStorePixelRatio || n.oBackingStorePixelRatio || n.backingStorePixelRatio || 1), this.colorPickerCanvas.getContext(\"2d\").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n        } else {\n          var r = document.createElement(\"DIV\");\n          r.style.color = \"red\", r.style.fontWeight = \"bold\", r.style.padding = \"10px\", r.innerText = \"Error: your browser does not support HTML canvas\", this.colorPickerCanvas.appendChild(r);\n        }\n\n        this.colorPickerDiv.className = \"vis-color\", this.opacityDiv = document.createElement(\"div\"), this.opacityDiv.className = \"vis-opacity\", this.brightnessDiv = document.createElement(\"div\"), this.brightnessDiv.className = \"vis-brightness\", this.arrowDiv = document.createElement(\"div\"), this.arrowDiv.className = \"vis-arrow\", this.opacityRange = document.createElement(\"input\");\n\n        try {\n          this.opacityRange.type = \"range\", this.opacityRange.min = \"0\", this.opacityRange.max = \"100\";\n        } catch (t) {}\n\n        this.opacityRange.value = \"100\", this.opacityRange.className = \"vis-range\", this.brightnessRange = document.createElement(\"input\");\n\n        try {\n          this.brightnessRange.type = \"range\", this.brightnessRange.min = \"0\", this.brightnessRange.max = \"100\";\n        } catch (t) {}\n\n        this.brightnessRange.value = \"100\", this.brightnessRange.className = \"vis-range\", this.opacityDiv.appendChild(this.opacityRange), this.brightnessDiv.appendChild(this.brightnessRange);\n        var s = this;\n        this.opacityRange.onchange = function () {\n          s._setOpacity(this.value);\n        }, this.opacityRange.oninput = function () {\n          s._setOpacity(this.value);\n        }, this.brightnessRange.onchange = function () {\n          s._setBrightness(this.value);\n        }, this.brightnessRange.oninput = function () {\n          s._setBrightness(this.value);\n        }, this.brightnessLabel = document.createElement(\"div\"), this.brightnessLabel.className = \"vis-label vis-brightness\", this.brightnessLabel.innerText = \"brightness:\", this.opacityLabel = document.createElement(\"div\"), this.opacityLabel.className = \"vis-label vis-opacity\", this.opacityLabel.innerText = \"opacity:\", this.newColorDiv = document.createElement(\"div\"), this.newColorDiv.className = \"vis-new-color\", this.newColorDiv.innerText = \"new\", this.initialColorDiv = document.createElement(\"div\"), this.initialColorDiv.className = \"vis-initial-color\", this.initialColorDiv.innerText = \"initial\", this.cancelButton = document.createElement(\"div\"), this.cancelButton.className = \"vis-button vis-cancel\", this.cancelButton.innerText = \"cancel\", this.cancelButton.onclick = si(t = this._hide).call(t, this, !1), this.applyButton = document.createElement(\"div\"), this.applyButton.className = \"vis-button vis-apply\", this.applyButton.innerText = \"apply\", this.applyButton.onclick = si(e = this._apply).call(e, this), this.saveButton = document.createElement(\"div\"), this.saveButton.className = \"vis-button vis-save\", this.saveButton.innerText = \"save\", this.saveButton.onclick = si(i = this._save).call(i, this), this.loadButton = document.createElement(\"div\"), this.loadButton.className = \"vis-button vis-load\", this.loadButton.innerText = \"load last\", this.loadButton.onclick = si(o = this._loadLast).call(o, this), this.frame.appendChild(this.colorPickerDiv), this.frame.appendChild(this.arrowDiv), this.frame.appendChild(this.brightnessLabel), this.frame.appendChild(this.brightnessDiv), this.frame.appendChild(this.opacityLabel), this.frame.appendChild(this.opacityDiv), this.frame.appendChild(this.newColorDiv), this.frame.appendChild(this.initialColorDiv), this.frame.appendChild(this.cancelButton), this.frame.appendChild(this.applyButton), this.frame.appendChild(this.saveButton), this.frame.appendChild(this.loadButton);\n      }\n    }, {\n      key: \"_bindHammer\",\n      value: function () {\n        var t = this;\n        this.drag = {}, this.pinch = {}, this.hammer = new Yu(this.colorPickerCanvas), this.hammer.get(\"pinch\").set({\n          enable: !0\n        }), this.hammer.on(\"hammer.input\", function (e) {\n          e.isFirst && t._moveSelector(e);\n        }), this.hammer.on(\"tap\", function (e) {\n          t._moveSelector(e);\n        }), this.hammer.on(\"panstart\", function (e) {\n          t._moveSelector(e);\n        }), this.hammer.on(\"panmove\", function (e) {\n          t._moveSelector(e);\n        }), this.hammer.on(\"panend\", function (e) {\n          t._moveSelector(e);\n        });\n      }\n    }, {\n      key: \"_generateHueCircle\",\n      value: function () {\n        if (!1 === this.generated) {\n          var t = this.colorPickerCanvas.getContext(\"2d\");\n          void 0 === this.pixelRation && (this.pixelRatio = (window.devicePixelRatio || 1) / (t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1)), t.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n          var e,\n              i,\n              o,\n              n,\n              r = this.colorPickerCanvas.clientWidth,\n              s = this.colorPickerCanvas.clientHeight;\n          t.clearRect(0, 0, r, s), this.centerCoordinates = {\n            x: .5 * r,\n            y: .5 * s\n          }, this.r = .49 * r;\n          var a,\n              h = 2 * Math.PI / 360,\n              d = 1 / this.r;\n\n          for (o = 0; o < 360; o++) for (n = 0; n < this.r; n++) e = this.centerCoordinates.x + n * Math.sin(h * o), i = this.centerCoordinates.y + n * Math.cos(h * o), a = gf(.002777777777777778 * o, n * d, 1), t.fillStyle = \"rgb(\" + a.r + \",\" + a.g + \",\" + a.b + \")\", t.fillRect(e - .5, i - .5, 2, 2);\n\n          t.strokeStyle = \"rgba(0,0,0,1)\", t.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r), t.stroke(), this.hueCircle = t.getImageData(0, 0, r, s);\n        }\n\n        this.generated = !0;\n      }\n    }, {\n      key: \"_moveSelector\",\n      value: function (t) {\n        var e = this.colorPickerDiv.getBoundingClientRect(),\n            i = t.center.x - e.left,\n            o = t.center.y - e.top,\n            n = .5 * this.colorPickerDiv.clientHeight,\n            r = .5 * this.colorPickerDiv.clientWidth,\n            s = i - r,\n            a = o - n,\n            h = Math.atan2(s, a),\n            d = .98 * Math.min(Math.sqrt(s * s + a * a), r),\n            l = Math.cos(h) * d + n,\n            c = Math.sin(h) * d + r;\n        this.colorPickerSelector.style.top = l - .5 * this.colorPickerSelector.clientHeight + \"px\", this.colorPickerSelector.style.left = c - .5 * this.colorPickerSelector.clientWidth + \"px\";\n        var u = h / (2 * Math.PI);\n        u = u < 0 ? u + 1 : u;\n        var f = d / this.r,\n            p = vf(this.color.r, this.color.g, this.color.b);\n        p.h = u, p.s = f;\n        var v = gf(p.h, p.s, p.v);\n        v.a = this.color.a, this.color = v, this.initialColorDiv.style.backgroundColor = \"rgba(\" + this.initialColor.r + \",\" + this.initialColor.g + \",\" + this.initialColor.b + \",\" + this.initialColor.a + \")\", this.newColorDiv.style.backgroundColor = \"rgba(\" + this.color.r + \",\" + this.color.g + \",\" + this.color.b + \",\" + this.color.a + \")\";\n      }\n    }]), t;\n  }();\n\n  function Sf() {\n    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];\n\n    if (e.length < 1) throw new TypeError(\"Invalid arguments.\");\n    if (1 === e.length) return document.createTextNode(e[0]);\n    var o = document.createElement(e[0]);\n    return o.appendChild(Sf.apply(void 0, Fh(Lh(e).call(e, 1)))), o;\n  }\n\n  var Tf,\n      Mf = !1,\n      Pf = \"background: #FFeeee; color: #dd0000\",\n      Df = Xu,\n      Bf = function () {\n    function t(e, i, o) {\n      var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,\n          r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : function () {\n        return !1;\n      };\n      Ra(this, t), this.parent = e, this.changedOptions = [], this.container = i, this.allowCreation = !1, this.hideOption = r, this.options = {}, this.initialized = !1, this.popupCounter = 0, this.defaultOptions = {\n        enabled: !1,\n        filter: !0,\n        container: void 0,\n        showButton: !0\n      }, Ke(this.options, this.defaultOptions), this.configureOptions = o, this.moduleOptions = {}, this.domElements = [], this.popupDiv = {}, this.popupLimit = 5, this.popupHistory = {}, this.colorPicker = new Cf(n), this.wrapper = void 0;\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function (t) {\n        if (void 0 !== t) {\n          this.popupHistory = {}, this._removePopup();\n          var e = !0;\n          if (\"string\" == typeof t) this.options.filter = t;else if (Hh(t)) this.options.filter = t.join();else if (\"object\" === zh(t)) {\n            if (null == t) throw new TypeError(\"options cannot be null\");\n            void 0 !== t.container && (this.options.container = t.container), void 0 !== $d(t) && (this.options.filter = $d(t)), void 0 !== t.showButton && (this.options.showButton = t.showButton), void 0 !== t.enabled && (e = t.enabled);\n          } else \"boolean\" == typeof t ? (this.options.filter = !0, e = t) : \"function\" == typeof t && (this.options.filter = t, e = !0);\n          !1 === $d(this.options) && (e = !1), this.options.enabled = e;\n        }\n\n        this._clean();\n      }\n    }, {\n      key: \"setModuleOptions\",\n      value: function (t) {\n        this.moduleOptions = t, !0 === this.options.enabled && (this._clean(), void 0 !== this.options.container && (this.container = this.options.container), this._create());\n      }\n    }, {\n      key: \"_create\",\n      value: function () {\n        this._clean(), this.changedOptions = [];\n        var t = $d(this.options),\n            e = 0,\n            i = !1;\n\n        for (var o in this.configureOptions) Object.prototype.hasOwnProperty.call(this.configureOptions, o) && (this.allowCreation = !1, i = !1, \"function\" == typeof t ? i = (i = t(o, [])) || this._handleObject(this.configureOptions[o], [o], !0) : !0 !== t && -1 === Cl(t).call(t, o) || (i = !0), !1 !== i && (this.allowCreation = !0, e > 0 && this._makeItem([]), this._makeHeader(o), this._handleObject(this.configureOptions[o], [o])), e++);\n\n        this._makeButton(), this._push();\n      }\n    }, {\n      key: \"_push\",\n      value: function () {\n        this.wrapper = document.createElement(\"div\"), this.wrapper.className = \"vis-configuration-wrapper\", this.container.appendChild(this.wrapper);\n\n        for (var t = 0; t < this.domElements.length; t++) this.wrapper.appendChild(this.domElements[t]);\n\n        this._showPopupIfNeeded();\n      }\n    }, {\n      key: \"_clean\",\n      value: function () {\n        for (var t = 0; t < this.domElements.length; t++) this.wrapper.removeChild(this.domElements[t]);\n\n        void 0 !== this.wrapper && (this.container.removeChild(this.wrapper), this.wrapper = void 0), this.domElements = [], this._removePopup();\n      }\n    }, {\n      key: \"_getValue\",\n      value: function (t) {\n        for (var e = this.moduleOptions, i = 0; i < t.length; i++) {\n          if (void 0 === e[t[i]]) {\n            e = void 0;\n            break;\n          }\n\n          e = e[t[i]];\n        }\n\n        return e;\n      }\n    }, {\n      key: \"_makeItem\",\n      value: function (t) {\n        if (!0 === this.allowCreation) {\n          var e = document.createElement(\"div\");\n          e.className = \"vis-configuration vis-config-item vis-config-s\" + t.length;\n\n          for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), n = 1; n < i; n++) o[n - 1] = arguments[n];\n\n          return nd(o).call(o, function (t) {\n            e.appendChild(t);\n          }), this.domElements.push(e), this.domElements.length;\n        }\n\n        return 0;\n      }\n    }, {\n      key: \"_makeHeader\",\n      value: function (t) {\n        var e = document.createElement(\"div\");\n        e.className = \"vis-configuration vis-config-header\", e.innerText = t, this._makeItem([], e);\n      }\n    }, {\n      key: \"_makeLabel\",\n      value: function (t, e) {\n        var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n            o = document.createElement(\"div\");\n\n        if (o.className = \"vis-configuration vis-config-label vis-config-s\" + e.length, !0 === i) {\n          for (; o.firstChild;) o.removeChild(o.firstChild);\n\n          o.appendChild(Sf(\"i\", \"b\", t));\n        } else o.innerText = t + \":\";\n\n        return o;\n      }\n    }, {\n      key: \"_makeDropdown\",\n      value: function (t, e, i) {\n        var o = document.createElement(\"select\");\n        o.className = \"vis-configuration vis-config-select\";\n        var n = 0;\n        void 0 !== e && -1 !== Cl(t).call(t, e) && (n = Cl(t).call(t, e));\n\n        for (var r = 0; r < t.length; r++) {\n          var s = document.createElement(\"option\");\n          s.value = t[r], r === n && (s.selected = \"selected\"), s.innerText = t[r], o.appendChild(s);\n        }\n\n        var a = this;\n\n        o.onchange = function () {\n          a._update(this.value, i);\n        };\n\n        var h = this._makeLabel(i[i.length - 1], i);\n\n        this._makeItem(i, h, o);\n      }\n    }, {\n      key: \"_makeRange\",\n      value: function (t, e, i) {\n        var o = t[0],\n            n = t[1],\n            r = t[2],\n            s = t[3],\n            a = document.createElement(\"input\");\n        a.className = \"vis-configuration vis-config-range\";\n\n        try {\n          a.type = \"range\", a.min = n, a.max = r;\n        } catch (t) {}\n\n        a.step = s;\n        var h = \"\",\n            d = 0;\n\n        if (void 0 !== e) {\n          var l = 1.2;\n          e < 0 && e * l < n ? (a.min = Math.ceil(e * l), d = a.min, h = \"range increased\") : e / l < n && (a.min = Math.ceil(e / l), d = a.min, h = \"range increased\"), e * l > r && 1 !== r && (a.max = Math.ceil(e * l), d = a.max, h = \"range increased\"), a.value = e;\n        } else a.value = o;\n\n        var c = document.createElement(\"input\");\n        c.className = \"vis-configuration vis-config-rangeinput\", c.value = a.value;\n        var u = this;\n        a.onchange = function () {\n          c.value = this.value, u._update(Number(this.value), i);\n        }, a.oninput = function () {\n          c.value = this.value;\n        };\n\n        var f = this._makeLabel(i[i.length - 1], i),\n            p = this._makeItem(i, f, a, c);\n\n        \"\" !== h && this.popupHistory[p] !== d && (this.popupHistory[p] = d, this._setupPopup(h, p));\n      }\n    }, {\n      key: \"_makeButton\",\n      value: function () {\n        var t = this;\n\n        if (!0 === this.options.showButton) {\n          var e = document.createElement(\"div\");\n          e.className = \"vis-configuration vis-config-button\", e.innerText = \"generate options\", e.onclick = function () {\n            t._printOptions();\n          }, e.onmouseover = function () {\n            e.className = \"vis-configuration vis-config-button hover\";\n          }, e.onmouseout = function () {\n            e.className = \"vis-configuration vis-config-button\";\n          }, this.optionsContainer = document.createElement(\"div\"), this.optionsContainer.className = \"vis-configuration vis-config-option-container\", this.domElements.push(this.optionsContainer), this.domElements.push(e);\n        }\n      }\n    }, {\n      key: \"_setupPopup\",\n      value: function (t, e) {\n        var i = this;\n\n        if (!0 === this.initialized && !0 === this.allowCreation && this.popupCounter < this.popupLimit) {\n          var o = document.createElement(\"div\");\n          o.id = \"vis-configuration-popup\", o.className = \"vis-configuration-popup\", o.innerText = t, o.onclick = function () {\n            i._removePopup();\n          }, this.popupCounter += 1, this.popupDiv = {\n            html: o,\n            index: e\n          };\n        }\n      }\n    }, {\n      key: \"_removePopup\",\n      value: function () {\n        void 0 !== this.popupDiv.html && (this.popupDiv.html.parentNode.removeChild(this.popupDiv.html), clearTimeout(this.popupDiv.hideTimeout), clearTimeout(this.popupDiv.deleteTimeout), this.popupDiv = {});\n      }\n    }, {\n      key: \"_showPopupIfNeeded\",\n      value: function () {\n        var t = this;\n\n        if (void 0 !== this.popupDiv.html) {\n          var e = this.domElements[this.popupDiv.index].getBoundingClientRect();\n          this.popupDiv.html.style.left = e.left + \"px\", this.popupDiv.html.style.top = e.top - 30 + \"px\", document.body.appendChild(this.popupDiv.html), this.popupDiv.hideTimeout = Yl(function () {\n            t.popupDiv.html.style.opacity = 0;\n          }, 1500), this.popupDiv.deleteTimeout = Yl(function () {\n            t._removePopup();\n          }, 1800);\n        }\n      }\n    }, {\n      key: \"_makeCheckbox\",\n      value: function (t, e, i) {\n        var o = document.createElement(\"input\");\n        o.type = \"checkbox\", o.className = \"vis-configuration vis-config-checkbox\", o.checked = t, void 0 !== e && (o.checked = e, e !== t && (\"object\" === zh(t) ? e !== t.enabled && this.changedOptions.push({\n          path: i,\n          value: e\n        }) : this.changedOptions.push({\n          path: i,\n          value: e\n        })));\n        var n = this;\n\n        o.onchange = function () {\n          n._update(this.checked, i);\n        };\n\n        var r = this._makeLabel(i[i.length - 1], i);\n\n        this._makeItem(i, r, o);\n      }\n    }, {\n      key: \"_makeTextInput\",\n      value: function (t, e, i) {\n        var o = document.createElement(\"input\");\n        o.type = \"text\", o.className = \"vis-configuration vis-config-text\", o.value = e, e !== t && this.changedOptions.push({\n          path: i,\n          value: e\n        });\n        var n = this;\n\n        o.onchange = function () {\n          n._update(this.value, i);\n        };\n\n        var r = this._makeLabel(i[i.length - 1], i);\n\n        this._makeItem(i, r, o);\n      }\n    }, {\n      key: \"_makeColorField\",\n      value: function (t, e, i) {\n        var o = this,\n            n = t[1],\n            r = document.createElement(\"div\");\n        \"none\" !== (e = void 0 === e ? n : e) ? (r.className = \"vis-configuration vis-config-colorBlock\", r.style.backgroundColor = e) : r.className = \"vis-configuration vis-config-colorBlock none\", e = void 0 === e ? n : e, r.onclick = function () {\n          o._showColorPicker(e, r, i);\n        };\n\n        var s = this._makeLabel(i[i.length - 1], i);\n\n        this._makeItem(i, s, r);\n      }\n    }, {\n      key: \"_showColorPicker\",\n      value: function (t, e, i) {\n        var o = this;\n        e.onclick = function () {}, this.colorPicker.insertTo(e), this.colorPicker.show(), this.colorPicker.setColor(t), this.colorPicker.setUpdateCallback(function (t) {\n          var n = \"rgba(\" + t.r + \",\" + t.g + \",\" + t.b + \",\" + t.a + \")\";\n          e.style.backgroundColor = n, o._update(n, i);\n        }), this.colorPicker.setCloseCallback(function () {\n          e.onclick = function () {\n            o._showColorPicker(t, e, i);\n          };\n        });\n      }\n    }, {\n      key: \"_handleObject\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],\n            i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n            o = !1,\n            n = $d(this.options),\n            r = !1;\n\n        for (var s in t) if (Object.prototype.hasOwnProperty.call(t, s)) {\n          o = !0;\n          var a = t[s],\n              h = af(e, s);\n\n          if (\"function\" == typeof n && !1 === (o = n(s, e)) && !Hh(a) && \"string\" != typeof a && \"boolean\" != typeof a && a instanceof Object && (this.allowCreation = !1, o = this._handleObject(a, h, !0), this.allowCreation = !1 === i), !1 !== o) {\n            r = !0;\n\n            var d = this._getValue(h);\n\n            if (Hh(a)) this._handleArray(a, d, h);else if (\"string\" == typeof a) this._makeTextInput(a, d, h);else if (\"boolean\" == typeof a) this._makeCheckbox(a, d, h);else if (a instanceof Object) {\n              if (!this.hideOption(e, s, this.moduleOptions)) if (void 0 !== a.enabled) {\n                var l = af(h, \"enabled\"),\n                    c = this._getValue(l);\n\n                if (!0 === c) {\n                  var u = this._makeLabel(s, h, !0);\n\n                  this._makeItem(h, u), r = this._handleObject(a, h) || r;\n                } else this._makeCheckbox(a, c, h);\n              } else {\n                var f = this._makeLabel(s, h, !0);\n\n                this._makeItem(h, f), r = this._handleObject(a, h) || r;\n              }\n            } else console.error(\"dont know how to handle\", a, s, h);\n          }\n        }\n\n        return r;\n      }\n    }, {\n      key: \"_handleArray\",\n      value: function (t, e, i) {\n        \"string\" == typeof t[0] && \"color\" === t[0] ? (this._makeColorField(t, e, i), t[1] !== e && this.changedOptions.push({\n          path: i,\n          value: e\n        })) : \"string\" == typeof t[0] ? (this._makeDropdown(t, e, i), t[0] !== e && this.changedOptions.push({\n          path: i,\n          value: e\n        })) : \"number\" == typeof t[0] && (this._makeRange(t, e, i), t[0] !== e && this.changedOptions.push({\n          path: i,\n          value: Number(e)\n        }));\n      }\n    }, {\n      key: \"_update\",\n      value: function (t, e) {\n        var i = this._constructOptions(t, e);\n\n        this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit && this.parent.body.emitter.emit(\"configChange\", i), this.initialized = !0, this.parent.setOptions(i);\n      }\n    }, {\n      key: \"_constructOptions\",\n      value: function (t, e) {\n        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n            o = i;\n        t = \"false\" !== (t = \"true\" === t || t) && t;\n\n        for (var n = 0; n < e.length; n++) \"global\" !== e[n] && (void 0 === o[e[n]] && (o[e[n]] = {}), n !== e.length - 1 ? o = o[e[n]] : o[e[n]] = t);\n\n        return i;\n      }\n    }, {\n      key: \"_printOptions\",\n      value: function () {\n        for (var t = this.getOptions(); this.optionsContainer.firstChild;) this.optionsContainer.removeChild(this.optionsContainer.firstChild);\n\n        this.optionsContainer.appendChild(Sf(\"pre\", \"const options = \" + Wl(t, null, 2)));\n      }\n    }, {\n      key: \"getOptions\",\n      value: function () {\n        for (var t = {}, e = 0; e < this.changedOptions.length; e++) this._constructOptions(this.changedOptions[e].value, this.changedOptions[e].path, t);\n\n        return t;\n      }\n    }]), t;\n  }(),\n      If = Yu,\n      zf = function () {\n    function t(e, i) {\n      Ra(this, t), this.container = e, this.overflowMethod = i || \"cap\", this.x = 0, this.y = 0, this.padding = 5, this.hidden = !1, this.frame = document.createElement(\"div\"), this.frame.className = \"vis-tooltip\", this.container.appendChild(this.frame);\n    }\n\n    return Ha(t, [{\n      key: \"setPosition\",\n      value: function (t, e) {\n        this.x = yl(t), this.y = yl(e);\n      }\n    }, {\n      key: \"setText\",\n      value: function (t) {\n        if (t instanceof Element) {\n          for (; this.frame.firstChild;) this.frame.removeChild(this.frame.firstChild);\n\n          this.frame.appendChild(t);\n        } else this.frame.innerText = t;\n      }\n    }, {\n      key: \"show\",\n      value: function (t) {\n        if (void 0 === t && (t = !0), !0 === t) {\n          var e = this.frame.clientHeight,\n              i = this.frame.clientWidth,\n              o = this.frame.parentNode.clientHeight,\n              n = this.frame.parentNode.clientWidth,\n              r = 0,\n              s = 0;\n\n          if (\"flip\" == this.overflowMethod) {\n            var a = !1,\n                h = !0;\n            this.y - e < this.padding && (h = !1), this.x + i > n - this.padding && (a = !0), r = a ? this.x - i : this.x, s = h ? this.y - e : this.y;\n          } else (s = this.y - e) + e + this.padding > o && (s = o - e - this.padding), s < this.padding && (s = this.padding), (r = this.x) + i + this.padding > n && (r = n - i - this.padding), r < this.padding && (r = this.padding);\n\n          this.frame.style.left = r + \"px\", this.frame.style.top = s + \"px\", this.frame.style.visibility = \"visible\", this.hidden = !1;\n        } else this.hide();\n      }\n    }, {\n      key: \"hide\",\n      value: function () {\n        this.hidden = !0, this.frame.style.left = \"0\", this.frame.style.top = \"0\", this.frame.style.visibility = \"hidden\";\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {\n        this.frame.parentNode.removeChild(this.frame);\n      }\n    }]), t;\n  }(),\n      Ff = Pf,\n      Nf = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, null, [{\n      key: \"validate\",\n      value: function (e, i, o) {\n        Mf = !1, Tf = i;\n        var n = i;\n        return void 0 !== o && (n = i[o]), t.parse(e, n, []), Mf;\n      }\n    }, {\n      key: \"parse\",\n      value: function (e, i, o) {\n        for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.check(n, e, i, o);\n      }\n    }, {\n      key: \"check\",\n      value: function (e, i, o, n) {\n        if (void 0 !== o[e] || void 0 !== o.__any__) {\n          var r = e,\n              s = !0;\n          void 0 === o[e] && void 0 !== o.__any__ && (r = \"__any__\", s = \"object\" === t.getType(i[e]));\n          var a = o[r];\n          s && void 0 !== a.__type__ && (a = a.__type__), t.checkFields(e, i, o, r, a, n);\n        } else t.getSuggestion(e, o, n);\n      }\n    }, {\n      key: \"checkFields\",\n      value: function (e, i, o, n, r, s) {\n        var a = function (i) {\n          console.error(\"%c\" + i + t.printLocation(s, e), Pf);\n        },\n            h = t.getType(i[e]),\n            d = r[h];\n\n        void 0 !== d ? \"array\" === t.getType(d) && -1 === Cl(d).call(d, i[e]) ? (a('Invalid option detected in \"' + e + '\". Allowed values are:' + t.print(d) + ' not \"' + i[e] + '\". '), Mf = !0) : \"object\" === h && \"__any__\" !== n && (s = af(s, e), t.parse(i[e], o[n], s)) : void 0 === r.any && (a('Invalid type received for \"' + e + '\". Expected: ' + t.print(Gh(r)) + \". Received [\" + h + '] \"' + i[e] + '\"'), Mf = !0);\n      }\n    }, {\n      key: \"getType\",\n      value: function (t) {\n        var e = zh(t);\n        return \"object\" === e ? null === t ? \"null\" : t instanceof Boolean ? \"boolean\" : t instanceof Number ? \"number\" : t instanceof String ? \"string\" : Hh(t) ? \"array\" : t instanceof Date ? \"date\" : void 0 !== t.nodeType ? \"dom\" : !0 === t._isAMomentObject ? \"moment\" : \"object\" : \"number\" === e ? \"number\" : \"boolean\" === e ? \"boolean\" : \"string\" === e ? \"string\" : void 0 === e ? \"undefined\" : e;\n      }\n    }, {\n      key: \"getSuggestion\",\n      value: function (e, i, o) {\n        var n,\n            r = t.findInOptions(e, i, o, !1),\n            s = t.findInOptions(e, Tf, [], !0);\n        n = void 0 !== r.indexMatch ? \" in \" + t.printLocation(r.path, e, \"\") + 'Perhaps it was incomplete? Did you mean: \"' + r.indexMatch + '\"?\\n\\n' : s.distance <= 4 && r.distance > s.distance ? \" in \" + t.printLocation(r.path, e, \"\") + \"Perhaps it was misplaced? Matching option found at: \" + t.printLocation(s.path, s.closestMatch, \"\") : r.distance <= 8 ? '. Did you mean \"' + r.closestMatch + '\"?' + t.printLocation(r.path, e) : \". Did you mean one of these: \" + t.print(Gh(i)) + t.printLocation(o, e), console.error('%cUnknown option detected: \"' + e + '\"' + n, Pf), Mf = !0;\n      }\n    }, {\n      key: \"findInOptions\",\n      value: function (e, i, o) {\n        var n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],\n            r = 1e9,\n            s = \"\",\n            a = [],\n            h = e.toLowerCase(),\n            d = void 0;\n\n        for (var l in i) {\n          var c = void 0;\n\n          if (void 0 !== i[l].__type__ && !0 === n) {\n            var u = t.findInOptions(e, i[l], af(o, l));\n            r > u.distance && (s = u.closestMatch, a = u.path, r = u.distance, d = u.indexMatch);\n          } else {\n            var f;\n            -1 !== Cl(f = l.toLowerCase()).call(f, h) && (d = l), r > (c = t.levenshteinDistance(e, l)) && (s = l, a = hf(o), r = c);\n          }\n        }\n\n        return {\n          closestMatch: s,\n          path: a,\n          distance: r,\n          indexMatch: d\n        };\n      }\n    }, {\n      key: \"printLocation\",\n      value: function (t, e) {\n        for (var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : \"Problem value found at: \\n\", o = \"\\n\\n\" + i + \"options = {\\n\", n = 0; n < t.length; n++) {\n          for (var r = 0; r < n + 1; r++) o += \"  \";\n\n          o += t[n] + \": {\\n\";\n        }\n\n        for (var s = 0; s < t.length + 1; s++) o += \"  \";\n\n        o += e + \"\\n\";\n\n        for (var a = 0; a < t.length + 1; a++) {\n          for (var h = 0; h < t.length - a; h++) o += \"  \";\n\n          o += \"}\\n\";\n        }\n\n        return o + \"\\n\\n\";\n      }\n    }, {\n      key: \"print\",\n      value: function (t) {\n        return Wl(t).replace(/(\")|(\\[)|(\\])|(,\"__type__\")/g, \"\").replace(/(,)/g, \", \");\n      }\n    }, {\n      key: \"levenshteinDistance\",\n      value: function (t, e) {\n        if (0 === t.length) return e.length;\n        if (0 === e.length) return t.length;\n        var i,\n            o,\n            n = [];\n\n        for (i = 0; i <= e.length; i++) n[i] = [i];\n\n        for (o = 0; o <= t.length; o++) n[0][o] = o;\n\n        for (i = 1; i <= e.length; i++) for (o = 1; o <= t.length; o++) e.charAt(i - 1) == t.charAt(o - 1) ? n[i][o] = n[i - 1][o - 1] : n[i][o] = Math.min(n[i - 1][o - 1] + 1, Math.min(n[i][o - 1] + 1, n[i - 1][o] + 1));\n\n        return n[e.length][t.length];\n      }\n    }]), t;\n  }();\n\n  function Af(t) {\n    return Uf = t, function () {\n      var t = {};\n      Yf = 0, void (Xf = Uf.charAt(0)), np(), \"strict\" === Gf && (t.strict = !0, np());\n      \"graph\" !== Gf && \"digraph\" !== Gf || (t.type = Gf, np());\n      Kf === Wf && (t.id = Gf, np());\n      if (\"{\" != Gf) throw lp(\"Angle bracket { expected\");\n      if (np(), rp(t), \"}\" != Gf) throw lp(\"Angle bracket } expected\");\n      if (np(), \"\" !== Gf) throw lp(\"End of file expected\");\n      return np(), delete t.node, delete t.edge, delete t.graph, t;\n    }();\n  }\n\n  var Rf = {\n    fontsize: \"font.size\",\n    fontcolor: \"font.color\",\n    labelfontcolor: \"font.color\",\n    fontname: \"font.face\",\n    color: [\"color.border\", \"color.background\"],\n    fillcolor: \"color.background\",\n    tooltip: \"title\",\n    labeltooltip: \"title\"\n  },\n      jf = Bl(Rf);\n  jf.color = \"color.color\", jf.style = \"dashes\";\n  var Lf = 0,\n      Hf = 1,\n      Wf = 2,\n      Vf = 3,\n      qf = {\n    \"{\": !0,\n    \"}\": !0,\n    \"[\": !0,\n    \"]\": !0,\n    \";\": !0,\n    \"=\": !0,\n    \",\": !0,\n    \"->\": !0,\n    \"--\": !0\n  },\n      Uf = \"\",\n      Yf = 0,\n      Xf = \"\",\n      Gf = \"\",\n      Kf = Lf;\n\n  function $f() {\n    Yf++, Xf = Uf.charAt(Yf);\n  }\n\n  function Zf() {\n    return Uf.charAt(Yf + 1);\n  }\n\n  function Qf(t) {\n    var e = t.charCodeAt(0);\n    return e < 47 ? 35 === e || 46 === e : e < 59 ? e > 47 : e < 91 ? e > 64 : e < 96 ? 95 === e : e < 123 && e > 96;\n  }\n\n  function Jf(t, e) {\n    if (t || (t = {}), e) for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);\n    return t;\n  }\n\n  function tp(t, e, i) {\n    for (var o = e.split(\".\"), n = t; o.length;) {\n      var r = o.shift();\n      o.length ? (n[r] || (n[r] = {}), n = n[r]) : n[r] = i;\n    }\n  }\n\n  function ep(t, e) {\n    for (var i, o, n = null, r = [t], s = t; s.parent;) r.push(s.parent), s = s.parent;\n\n    if (s.nodes) for (i = 0, o = s.nodes.length; i < o; i++) if (e.id === s.nodes[i].id) {\n      n = s.nodes[i];\n      break;\n    }\n\n    for (n || (n = {\n      id: e.id\n    }, t.node && (n.attr = Jf(n.attr, t.node))), i = r.length - 1; i >= 0; i--) {\n      var a,\n          h = r[i];\n      h.nodes || (h.nodes = []), -1 === Cl(a = h.nodes).call(a, n) && h.nodes.push(n);\n    }\n\n    e.attr && (n.attr = Jf(n.attr, e.attr));\n  }\n\n  function ip(t, e) {\n    if (t.edges || (t.edges = []), t.edges.push(e), t.edge) {\n      var i = Jf({}, t.edge);\n      e.attr = Jf(i, e.attr);\n    }\n  }\n\n  function op(t, e, i, o, n) {\n    var r = {\n      from: e,\n      to: i,\n      type: o\n    };\n    return t.edge && (r.attr = Jf({}, t.edge)), r.attr = Jf(r.attr || {}, n), null != n && n.hasOwnProperty(\"arrows\") && null != n.arrows && (r.arrows = {\n      to: {\n        enabled: !0,\n        type: n.arrows.type\n      }\n    }, n.arrows = null), r;\n  }\n\n  function np() {\n    for (Kf = Lf, Gf = \"\"; \" \" === Xf || \"\\t\" === Xf || \"\\n\" === Xf || \"\\r\" === Xf;) $f();\n\n    do {\n      var t = !1;\n\n      if (\"#\" === Xf) {\n        for (var e = Yf - 1; \" \" === Uf.charAt(e) || \"\\t\" === Uf.charAt(e);) e--;\n\n        if (\"\\n\" === Uf.charAt(e) || \"\" === Uf.charAt(e)) {\n          for (; \"\" != Xf && \"\\n\" != Xf;) $f();\n\n          t = !0;\n        }\n      }\n\n      if (\"/\" === Xf && \"/\" === Zf()) {\n        for (; \"\" != Xf && \"\\n\" != Xf;) $f();\n\n        t = !0;\n      }\n\n      if (\"/\" === Xf && \"*\" === Zf()) {\n        for (; \"\" != Xf;) {\n          if (\"*\" === Xf && \"/\" === Zf()) {\n            $f(), $f();\n            break;\n          }\n\n          $f();\n        }\n\n        t = !0;\n      }\n\n      for (; \" \" === Xf || \"\\t\" === Xf || \"\\n\" === Xf || \"\\r\" === Xf;) $f();\n    } while (t);\n\n    if (\"\" !== Xf) {\n      var i = Xf + Zf();\n      if (qf[i]) return Kf = Hf, Gf = i, $f(), void $f();\n      if (qf[Xf]) return Kf = Hf, Gf = Xf, void $f();\n\n      if (Qf(Xf) || \"-\" === Xf) {\n        for (Gf += Xf, $f(); Qf(Xf);) Gf += Xf, $f();\n\n        return \"false\" === Gf ? Gf = !1 : \"true\" === Gf ? Gf = !0 : isNaN(Number(Gf)) || (Gf = Number(Gf)), void (Kf = Wf);\n      }\n\n      if ('\"' === Xf) {\n        for ($f(); \"\" != Xf && ('\"' != Xf || '\"' === Xf && '\"' === Zf());) '\"' === Xf ? (Gf += Xf, $f()) : \"\\\\\" === Xf && \"n\" === Zf() ? (Gf += \"\\n\", $f()) : Gf += Xf, $f();\n\n        if ('\"' != Xf) throw lp('End of string \" expected');\n        return $f(), void (Kf = Wf);\n      }\n\n      for (Kf = Vf; \"\" != Xf;) Gf += Xf, $f();\n\n      throw new SyntaxError('Syntax error in part \"' + cp(Gf, 30) + '\"');\n    }\n\n    Kf = Hf;\n  }\n\n  function rp(t) {\n    for (; \"\" !== Gf && \"}\" != Gf;) sp(t), \";\" === Gf && np();\n  }\n\n  function sp(t) {\n    var e = ap(t);\n    if (e) hp(t, e);else if (!function (t) {\n      if (\"node\" === Gf) return np(), t.node = dp(), \"node\";\n      if (\"edge\" === Gf) return np(), t.edge = dp(), \"edge\";\n      if (\"graph\" === Gf) return np(), t.graph = dp(), \"graph\";\n      return null;\n    }(t)) {\n      if (Kf != Wf) throw lp(\"Identifier expected\");\n      var i = Gf;\n\n      if (np(), \"=\" === Gf) {\n        if (np(), Kf != Wf) throw lp(\"Identifier expected\");\n        t[i] = Gf, np();\n      } else !function (t, e) {\n        var i = {\n          id: e\n        },\n            o = dp();\n        o && (i.attr = o);\n        ep(t, i), hp(t, e);\n      }(t, i);\n    }\n  }\n\n  function ap(t) {\n    var e = null;\n\n    if (\"subgraph\" === Gf && ((e = {}).type = \"subgraph\", np(), Kf === Wf && (e.id = Gf, np())), \"{\" === Gf) {\n      if (np(), e || (e = {}), e.parent = t, e.node = t.node, e.edge = t.edge, e.graph = t.graph, rp(e), \"}\" != Gf) throw lp(\"Angle bracket } expected\");\n      np(), delete e.node, delete e.edge, delete e.graph, delete e.parent, t.subgraphs || (t.subgraphs = []), t.subgraphs.push(e);\n    }\n\n    return e;\n  }\n\n  function hp(t, e) {\n    for (; \"->\" === Gf || \"--\" === Gf;) {\n      var i,\n          o = Gf;\n      np();\n      var n = ap(t);\n      if (n) i = n;else {\n        if (Kf != Wf) throw lp(\"Identifier or subgraph expected\");\n        ep(t, {\n          id: i = Gf\n        }), np();\n      }\n      ip(t, op(t, e, i, o, dp())), e = i;\n    }\n  }\n\n  function dp() {\n    for (var t, e, i = null, o = {\n      dashed: !0,\n      solid: !1,\n      dotted: [1, 5]\n    }, n = {\n      dot: \"circle\",\n      box: \"box\",\n      crow: \"crow\",\n      curve: \"curve\",\n      icurve: \"inv_curve\",\n      normal: \"triangle\",\n      inv: \"inv_triangle\",\n      diamond: \"diamond\",\n      tee: \"bar\",\n      vee: \"vee\"\n    }, r = new Array(), s = new Array(); \"[\" === Gf;) {\n      for (np(), i = {}; \"\" !== Gf && \"]\" != Gf;) {\n        if (Kf != Wf) throw lp(\"Attribute name expected\");\n        var a = Gf;\n        if (np(), \"=\" != Gf) throw lp(\"Equal sign = expected\");\n        if (np(), Kf != Wf) throw lp(\"Attribute value expected\");\n        var h = Gf;\n        \"style\" === a && (h = o[h]), \"arrowhead\" === a && (a = \"arrows\", h = {\n          to: {\n            enabled: !0,\n            type: n[h]\n          }\n        }), \"arrowtail\" === a && (a = \"arrows\", h = {\n          from: {\n            enabled: !0,\n            type: n[h]\n          }\n        }), r.push({\n          attr: i,\n          name: a,\n          value: h\n        }), s.push(a), np(), \",\" == Gf && np();\n      }\n\n      if (\"]\" != Gf) throw lp(\"Bracket ] expected\");\n      np();\n    }\n\n    if (Hd(s).call(s, \"dir\")) {\n      var d = {\n        arrows: {}\n      };\n\n      for (t = 0; t < r.length; t++) if (\"arrows\" === r[t].name) {\n        if (null != r[t].value.to) d.arrows.to = t;else {\n          if (null == r[t].value.from) throw lp(\"Invalid value of arrows\");\n          d.arrows.from = t;\n        }\n      } else \"dir\" === r[t].name && (d.dir = t);\n\n      var l,\n          c,\n          u = r[d.dir].value;\n      if (!Hd(s).call(s, \"arrows\")) if (\"both\" === u) r.push({\n        attr: r[d.dir].attr,\n        name: \"arrows\",\n        value: {\n          to: {\n            enabled: !0\n          }\n        }\n      }), d.arrows.to = r.length - 1, r.push({\n        attr: r[d.dir].attr,\n        name: \"arrows\",\n        value: {\n          from: {\n            enabled: !0\n          }\n        }\n      }), d.arrows.from = r.length - 1;else if (\"forward\" === u) r.push({\n        attr: r[d.dir].attr,\n        name: \"arrows\",\n        value: {\n          to: {\n            enabled: !0\n          }\n        }\n      }), d.arrows.to = r.length - 1;else if (\"back\" === u) r.push({\n        attr: r[d.dir].attr,\n        name: \"arrows\",\n        value: {\n          from: {\n            enabled: !0\n          }\n        }\n      }), d.arrows.from = r.length - 1;else {\n        if (\"none\" !== u) throw lp('Invalid dir type \"' + u + '\"');\n        r.push({\n          attr: r[d.dir].attr,\n          name: \"arrows\",\n          value: \"\"\n        }), d.arrows.to = r.length - 1;\n      }\n      if (\"both\" === u) d.arrows.to && d.arrows.from ? (c = r[d.arrows.to].value.to.type, l = r[d.arrows.from].value.from.type, r[d.arrows.to] = {\n        attr: r[d.arrows.to].attr,\n        name: r[d.arrows.to].name,\n        value: {\n          to: {\n            enabled: !0,\n            type: c\n          },\n          from: {\n            enabled: !0,\n            type: l\n          }\n        }\n      }, Od(r).call(r, d.arrows.from, 1)) : d.arrows.to ? (c = r[d.arrows.to].value.to.type, l = \"arrow\", r[d.arrows.to] = {\n        attr: r[d.arrows.to].attr,\n        name: r[d.arrows.to].name,\n        value: {\n          to: {\n            enabled: !0,\n            type: c\n          },\n          from: {\n            enabled: !0,\n            type: l\n          }\n        }\n      }) : d.arrows.from && (c = \"arrow\", l = r[d.arrows.from].value.from.type, r[d.arrows.from] = {\n        attr: r[d.arrows.from].attr,\n        name: r[d.arrows.from].name,\n        value: {\n          to: {\n            enabled: !0,\n            type: c\n          },\n          from: {\n            enabled: !0,\n            type: l\n          }\n        }\n      });else if (\"back\" === u) d.arrows.to && d.arrows.from ? (c = \"\", l = r[d.arrows.from].value.from.type, r[d.arrows.from] = {\n        attr: r[d.arrows.from].attr,\n        name: r[d.arrows.from].name,\n        value: {\n          to: {\n            enabled: !0,\n            type: c\n          },\n          from: {\n            enabled: !0,\n            type: l\n          }\n        }\n      }) : d.arrows.to ? (c = \"\", l = \"arrow\", d.arrows.from = d.arrows.to, r[d.arrows.from] = {\n        attr: r[d.arrows.from].attr,\n        name: r[d.arrows.from].name,\n        value: {\n          to: {\n            enabled: !0,\n            type: c\n          },\n          from: {\n            enabled: !0,\n            type: l\n          }\n        }\n      }) : d.arrows.from && (c = \"\", l = r[d.arrows.from].value.from.type, r[d.arrows.to] = {\n        attr: r[d.arrows.from].attr,\n        name: r[d.arrows.from].name,\n        value: {\n          to: {\n            enabled: !0,\n            type: c\n          },\n          from: {\n            enabled: !0,\n            type: l\n          }\n        }\n      }), r[d.arrows.from] = {\n        attr: r[d.arrows.from].attr,\n        name: r[d.arrows.from].name,\n        value: {\n          from: {\n            enabled: !0,\n            type: r[d.arrows.from].value.from.type\n          }\n        }\n      };else if (\"none\" === u) {\n        var f;\n        r[f = d.arrows.to ? d.arrows.to : d.arrows.from] = {\n          attr: r[f].attr,\n          name: r[f].name,\n          value: \"\"\n        };\n      } else {\n        if (\"forward\" !== u) throw lp('Invalid dir type \"' + u + '\"');\n        d.arrows.to && d.arrows.from || d.arrows.to ? (c = r[d.arrows.to].value.to.type, l = \"\", r[d.arrows.to] = {\n          attr: r[d.arrows.to].attr,\n          name: r[d.arrows.to].name,\n          value: {\n            to: {\n              enabled: !0,\n              type: c\n            },\n            from: {\n              enabled: !0,\n              type: l\n            }\n          }\n        }) : d.arrows.from && (c = \"arrow\", l = \"\", d.arrows.to = d.arrows.from, r[d.arrows.to] = {\n          attr: r[d.arrows.to].attr,\n          name: r[d.arrows.to].name,\n          value: {\n            to: {\n              enabled: !0,\n              type: c\n            },\n            from: {\n              enabled: !0,\n              type: l\n            }\n          }\n        }), r[d.arrows.to] = {\n          attr: r[d.arrows.to].attr,\n          name: r[d.arrows.to].name,\n          value: {\n            to: {\n              enabled: !0,\n              type: r[d.arrows.to].value.to.type\n            }\n          }\n        };\n      }\n      Od(r).call(r, d.dir, 1);\n    }\n\n    if (Hd(s).call(s, \"penwidth\")) {\n      var p = [];\n\n      for (e = r.length, t = 0; t < e; t++) \"width\" !== r[t].name && (\"penwidth\" === r[t].name && (r[t].name = \"width\"), p.push(r[t]));\n\n      r = p;\n    }\n\n    for (e = r.length, t = 0; t < e; t++) tp(r[t].attr, r[t].name, r[t].value);\n\n    return i;\n  }\n\n  function lp(t) {\n    return new SyntaxError(t + ', got \"' + cp(Gf, 30) + '\" (char ' + Yf + \")\");\n  }\n\n  function cp(t, e) {\n    return t.length <= e ? t : t.substr(0, 27) + \"...\";\n  }\n\n  function up(t, e, i) {\n    for (var o = e.split(\".\"), n = o.pop(), r = t, s = 0; s < o.length; s++) {\n      var a = o[s];\n      a in r || (r[a] = {}), r = r[a];\n    }\n\n    return r[n] = i, t;\n  }\n\n  function fp(t, e) {\n    var i = {};\n\n    for (var o in t) if (t.hasOwnProperty(o)) {\n      var n = e[o];\n      Hh(n) ? nd(n).call(n, function (e) {\n        up(i, e, t[o]);\n      }) : up(i, \"string\" == typeof n ? n : o, t[o]);\n    }\n\n    return i;\n  }\n\n  function pp(t) {\n    var e,\n        i = Af(t),\n        o = {\n      nodes: [],\n      edges: [],\n      options: {}\n    };\n    i.nodes && nd(e = i.nodes).call(e, function (t) {\n      var e = {\n        id: t.id,\n        label: String(t.label || t.id)\n      };\n      Jf(e, fp(t.attr, Rf)), e.image && (e.shape = \"image\"), o.nodes.push(e);\n    });\n\n    if (i.edges) {\n      var n,\n          r = function (t) {\n        var e = {\n          from: t.from,\n          to: t.to\n        };\n        return Jf(e, fp(t.attr, jf)), null == e.arrows && \"->\" === t.type && (e.arrows = \"to\"), e;\n      };\n\n      nd(n = i.edges).call(n, function (t) {\n        var e, i, n, s, a, h, d;\n        (e = t.from instanceof Object ? t.from.nodes : {\n          id: t.from\n        }, i = t.to instanceof Object ? t.to.nodes : {\n          id: t.to\n        }, t.from instanceof Object && t.from.edges) && nd(n = t.from.edges).call(n, function (t) {\n          var e = r(t);\n          o.edges.push(e);\n        });\n        (a = i, h = function (e, i) {\n          var n = op(o, e.id, i.id, t.type, t.attr),\n              s = r(n);\n          o.edges.push(s);\n        }, Hh(s = e) ? nd(s).call(s, function (t) {\n          Hh(a) ? nd(a).call(a, function (e) {\n            h(t, e);\n          }) : h(t, a);\n        }) : Hh(a) ? nd(a).call(a, function (t) {\n          h(s, t);\n        }) : h(s, a), t.to instanceof Object && t.to.edges) && nd(d = t.to.edges).call(d, function (t) {\n          var e = r(t);\n          o.edges.push(e);\n        });\n      });\n    }\n\n    return i.attr && (o.options = i.attr), o;\n  }\n\n  var vp = Object.freeze({\n    __proto__: null,\n    parseDOT: Af,\n    DOTToGraph: pp\n  });\n\n  function gp(t, e) {\n    var i,\n        o = {\n      edges: {\n        inheritColor: !1\n      },\n      nodes: {\n        fixed: !1,\n        parseColor: !1\n      }\n    };\n    null != e && (null != e.fixed && (o.nodes.fixed = e.fixed), null != e.parseColor && (o.nodes.parseColor = e.parseColor), null != e.inheritColor && (o.edges.inheritColor = e.inheritColor));\n    var n = t.edges,\n        r = Uh(n).call(n, function (t) {\n      var e = {\n        from: t.source,\n        id: t.id,\n        to: t.target\n      };\n      return null != t.attributes && (e.attributes = t.attributes), null != t.label && (e.label = t.label), null != t.attributes && null != t.attributes.title && (e.title = t.attributes.title), \"Directed\" === t.type && (e.arrows = \"to\"), t.color && !1 === o.edges.inheritColor && (e.color = t.color), e;\n    });\n    return {\n      nodes: Uh(i = t.nodes).call(i, function (t) {\n        var e = {\n          id: t.id,\n          fixed: o.nodes.fixed && null != t.x && null != t.y\n        };\n        return null != t.attributes && (e.attributes = t.attributes), null != t.label && (e.label = t.label), null != t.size && (e.size = t.size), null != t.attributes && null != t.attributes.title && (e.title = t.attributes.title), null != t.title && (e.title = t.title), null != t.x && (e.x = t.x), null != t.y && (e.y = t.y), null != t.color && (!0 === o.nodes.parseColor ? e.color = t.color : e.color = {\n          background: t.color,\n          border: t.color,\n          highlight: {\n            background: t.color,\n            border: t.color\n          },\n          hover: {\n            background: t.color,\n            border: t.color\n          }\n        }), e;\n      }),\n      edges: r\n    };\n  }\n\n  var yp = Object.freeze({\n    __proto__: null,\n    parseGephi: gp\n  }),\n      mp = Object.freeze({\n    __proto__: null,\n    en: {\n      addDescription: \"Click in an empty space to place a new node.\",\n      addEdge: \"Add Edge\",\n      addNode: \"Add Node\",\n      back: \"Back\",\n      close: \"Close\",\n      createEdgeError: \"Cannot link edges to a cluster.\",\n      del: \"Delete selected\",\n      deleteClusterError: \"Clusters cannot be deleted.\",\n      edgeDescription: \"Click on a node and drag the edge to another node to connect them.\",\n      edit: \"Edit\",\n      editClusterError: \"Clusters cannot be edited.\",\n      editEdge: \"Edit Edge\",\n      editEdgeDescription: \"Click on the control points and drag them to a node to connect to it.\",\n      editNode: \"Edit Node\"\n    },\n    de: {\n      addDescription: \"Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.\",\n      addEdge: \"Kante hinzufÃ¼gen\",\n      addNode: \"Knoten hinzufÃ¼gen\",\n      back: \"ZurÃ¼ck\",\n      close: \"SchlieÃen\",\n      createEdgeError: \"Es ist nicht mÃ¶glich, Kanten mit Clustern zu verbinden.\",\n      del: \"LÃ¶sche Auswahl\",\n      deleteClusterError: \"Cluster kÃ¶nnen nicht gelÃ¶scht werden.\",\n      edgeDescription: \"Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.\",\n      edit: \"Editieren\",\n      editClusterError: \"Cluster kÃ¶nnen nicht editiert werden.\",\n      editEdge: \"Kante editieren\",\n      editEdgeDescription: \"Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.\",\n      editNode: \"Knoten editieren\"\n    },\n    es: {\n      addDescription: \"Haga clic en un lugar vacÃ­o para colocar un nuevo nodo.\",\n      addEdge: \"AÃ±adir arista\",\n      addNode: \"AÃ±adir nodo\",\n      back: \"AtrÃ¡s\",\n      close: \"Cerrar\",\n      createEdgeError: \"No se puede conectar una arista a un grupo.\",\n      del: \"Eliminar selecciÃ³n\",\n      deleteClusterError: \"No es posible eliminar grupos.\",\n      edgeDescription: \"Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.\",\n      edit: \"Editar\",\n      editClusterError: \"No es posible editar grupos.\",\n      editEdge: \"Editar arista\",\n      editEdgeDescription: \"Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.\",\n      editNode: \"Editar nodo\"\n    },\n    it: {\n      addDescription: \"Clicca per aggiungere un nuovo nodo\",\n      addEdge: \"Aggiungi un vertice\",\n      addNode: \"Aggiungi un nodo\",\n      back: \"Indietro\",\n      close: \"Chiudere\",\n      createEdgeError: \"Non si possono collegare vertici ad un cluster\",\n      del: \"Cancella la selezione\",\n      deleteClusterError: \"I cluster non possono essere cancellati\",\n      edgeDescription: \"Clicca su un nodo e trascinalo ad un altro nodo per connetterli.\",\n      edit: \"Modifica\",\n      editClusterError: \"I clusters non possono essere modificati.\",\n      editEdge: \"Modifica il vertice\",\n      editEdgeDescription: \"Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.\",\n      editNode: \"Modifica il nodo\"\n    },\n    nl: {\n      addDescription: \"Klik op een leeg gebied om een nieuwe node te maken.\",\n      addEdge: \"Link toevoegen\",\n      addNode: \"Node toevoegen\",\n      back: \"Terug\",\n      close: \"Sluiten\",\n      createEdgeError: \"Kan geen link maken naar een cluster.\",\n      del: \"Selectie verwijderen\",\n      deleteClusterError: \"Clusters kunnen niet worden verwijderd.\",\n      edgeDescription: \"Klik op een node en sleep de link naar een andere node om ze te verbinden.\",\n      edit: \"Wijzigen\",\n      editClusterError: \"Clusters kunnen niet worden aangepast.\",\n      editEdge: \"Link wijzigen\",\n      editEdgeDescription: \"Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.\",\n      editNode: \"Node wijzigen\"\n    },\n    pt: {\n      addDescription: \"Clique em um espaÃ§o em branco para adicionar um novo nÃ³\",\n      addEdge: \"Adicionar aresta\",\n      addNode: \"Adicionar nÃ³\",\n      back: \"Voltar\",\n      close: \"Fechar\",\n      createEdgeError: \"NÃ£o foi possÃ­vel linkar arestas a um cluster.\",\n      del: \"Remover selecionado\",\n      deleteClusterError: \"Clusters nÃ£o puderam ser removidos.\",\n      edgeDescription: \"Clique em um nÃ³ e arraste a aresta atÃ© outro nÃ³ para conectÃ¡-los\",\n      edit: \"Editar\",\n      editClusterError: \"Clusters nÃ£o puderam ser editados.\",\n      editEdge: \"Editar aresta\",\n      editEdgeDescription: \"Clique nos pontos de controle e os arraste para um nÃ³ para conectÃ¡-los\",\n      editNode: \"Editar nÃ³\"\n    },\n    ru: {\n      addDescription: \"ÐÐ»Ð¸ÐºÐ½Ð¸ÑÐµ Ð² ÑÐ²Ð¾Ð±Ð¾Ð´Ð½Ð¾Ðµ Ð¼ÐµÑÑÐ¾, ÑÑÐ¾Ð±Ñ Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ Ð½Ð¾Ð²ÑÐ¹ ÑÐ·ÐµÐ».\",\n      addEdge: \"ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ ÑÐµÐ±ÑÐ¾\",\n      addNode: \"ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ ÑÐ·ÐµÐ»\",\n      back: \"ÐÐ°Ð·Ð°Ð´\",\n      close: \"ÐÐ°ÐºÑÑÐ²Ð°ÑÑ\",\n      createEdgeError: \"ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸ÑÑ ÑÐµÐ±ÑÐ° Ð² ÐºÐ»Ð°ÑÑÐµÑ.\",\n      del: \"Ð£Ð´Ð°Ð»Ð¸ÑÑ Ð²ÑÐ±ÑÐ°Ð½Ð½Ð¾Ðµ\",\n      deleteClusterError: \"ÐÐ»Ð°ÑÑÐµÑÑ Ð½Ðµ Ð¼Ð¾Ð³ÑÑ Ð±ÑÑÑ ÑÐ´Ð°Ð»ÐµÐ½Ñ\",\n      edgeDescription: \"ÐÐ»Ð¸ÐºÐ½Ð¸ÑÐµ Ð½Ð° ÑÐ·ÐµÐ» Ð¸ Ð¿ÑÐ¾ÑÑÐ½Ð¸ÑÐµ ÑÐµÐ±ÑÐ¾ Ðº Ð´ÑÑÐ³Ð¾Ð¼Ñ ÑÐ·Ð»Ñ, ÑÑÐ¾Ð±Ñ ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸ÑÑ Ð¸Ñ.\",\n      edit: \"Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ\",\n      editClusterError: \"ÐÐ»Ð°ÑÑÐµÑÑ Ð½ÐµÐ´Ð¾ÑÑÑÐ¿Ð½Ñ Ð´Ð»Ñ ÑÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ.\",\n      editEdge: \"Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐµÐ±ÑÐ¾\",\n      editEdgeDescription: \"ÐÐ»Ð¸ÐºÐ½Ð¸ÑÐµ Ð½Ð° ÐºÐ¾Ð½ÑÑÐ¾Ð»ÑÐ½ÑÐµ ÑÐ¾ÑÐºÐ¸ Ð¸ Ð¿ÐµÑÐµÑÐ°ÑÐ¸ÑÐµ Ð¸Ñ Ð² ÑÐ·ÐµÐ», ÑÑÐ¾Ð±Ñ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ¸ÑÑÑÑ Ðº Ð½ÐµÐ¼Ñ.\",\n      editNode: \"Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ·ÐµÐ»\"\n    },\n    cn: {\n      addDescription: \"åå»ç©ºç½å¤æ¾ç½®æ°èç¹ã\",\n      addEdge: \"æ·»å è¿æ¥çº¿\",\n      addNode: \"æ·»å èç¹\",\n      back: \"è¿å\",\n      close: \"éé\",\n      createEdgeError: \"æ æ³å°è¿æ¥çº¿è¿æ¥å°ç¾¤éã\",\n      del: \"å é¤éå®\",\n      deleteClusterError: \"æ æ³å é¤ç¾¤éã\",\n      edgeDescription: \"åå»æä¸ªèç¹å¹¶å°è¯¥è¿æ¥çº¿æå¨å°å¦ä¸ä¸ªèç¹ä»¥è¿æ¥å®ä»¬ã\",\n      edit: \"ç¼è¾\",\n      editClusterError: \"æ æ³ç¼è¾ç¾¤éã\",\n      editEdge: \"ç¼è¾è¿æ¥çº¿\",\n      editEdgeDescription: \"åå»æ§å¶èç¹å¹¶å°å®ä»¬æå°èç¹ä¸è¿æ¥ã\",\n      editNode: \"ç¼è¾èç¹\"\n    },\n    uk: {\n      addDescription: \"KÐ»ÑÐºÐ½ÑÑÑ Ð½Ð° Ð²ÑÐ»ÑÐ½Ðµ Ð¼ÑÑÑÐµ, ÑÐ¾Ð± Ð´Ð¾Ð´Ð°ÑÐ¸ Ð½Ð¾Ð²Ð¸Ð¹ Ð²ÑÐ·Ð¾Ð».\",\n      addEdge: \"ÐÐ¾Ð´Ð°ÑÐ¸ ÐºÑÐ°Ð¹\",\n      addNode: \"ÐÐ¾Ð´Ð°ÑÐ¸ Ð²ÑÐ·Ð¾Ð»\",\n      back: \"ÐÐ°Ð·Ð°Ð´\",\n      close: \"ÐÐ°ÐºÑÐ¸ÑÐ¸\",\n      createEdgeError: \"ÐÐµ Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð¾Ð±'ÑÐ´Ð½Ð°ÑÐ¸ ÐºÑÐ°Ñ Ð² Ð³ÑÑÐ¿Ñ.\",\n      del: \"ÐÐ¸Ð´Ð°Ð»Ð¸ÑÐ¸ Ð¾Ð±ÑÐ°Ð½Ðµ\",\n      deleteClusterError: \"ÐÑÑÐ¿Ð¸ Ð½Ðµ Ð¼Ð¾Ð¶ÑÑÑ Ð±ÑÑÐ¸ Ð²Ð¸Ð´Ð°Ð»ÐµÐ½Ñ.\",\n      edgeDescription: \"ÐÐ»ÑÐºÐ½ÑÑÑ Ð½Ð° Ð²ÑÐ·Ð¾Ð» Ñ Ð¿ÐµÑÐµÑÑÐ³Ð½ÑÑÑ ÐºÑÐ°Ð¹ Ð´Ð¾ ÑÐ½ÑÐ¾Ð³Ð¾ Ð²ÑÐ·Ð»Ð°, ÑÐ¾Ð± ÑÑ Ð·'ÑÐ´Ð½Ð°ÑÐ¸.\",\n      edit: \"Ð ÐµÐ´Ð°Ð³ÑÐ²Ð°ÑÐ¸\",\n      editClusterError: \"ÐÑÑÐ¿Ð¸ Ð½ÐµÐ´Ð¾ÑÑÑÐ¿Ð½Ñ Ð´Ð»Ñ ÑÐµÐ´Ð°Ð³ÑÐ²Ð°Ð½Ð½Ñ.\",\n      editEdge: \"Ð ÐµÐ´Ð°Ð³ÑÐ²Ð°ÑÐ¸ ÐºÑÐ°Ð¹\",\n      editEdgeDescription: \"ÐÐ»ÑÐºÐ½ÑÑÑ Ð½Ð° ÐºÐ¾Ð½ÑÑÐ¾Ð»ÑÐ½Ñ ÑÐ¾ÑÐºÐ¸ Ñ Ð¿ÐµÑÐµÑÑÐ³Ð½ÑÑÑ ÑÑ Ñ Ð²ÑÐ·Ð¾Ð», ÑÐ¾Ð± Ð¿ÑÐ´ÐºÐ»ÑÑÐ¸ÑÐ¸ÑÑ Ð´Ð¾ Ð½ÑÐ¾Ð³Ð¾.\",\n      editNode: \"Ð ÐµÐ´Ð°Ð³ÑÐ²Ð°ÑÐ¸ Ð²ÑÐ·Ð¾Ð»\"\n    },\n    fr: {\n      addDescription: \"Cliquez dans un endroit vide pour placer un nÅud.\",\n      addEdge: \"Ajouter un lien\",\n      addNode: \"Ajouter un nÅud\",\n      back: \"Retour\",\n      close: \"Fermer\",\n      createEdgeError: \"Impossible de crÃ©er un lien vers un cluster.\",\n      del: \"Effacer la sÃ©lection\",\n      deleteClusterError: \"Les clusters ne peuvent pas Ãªtre effacÃ©s.\",\n      edgeDescription: \"Cliquez sur un nÅud et glissez le lien vers un autre nÅud pour les connecter.\",\n      edit: \"Ãditer\",\n      editClusterError: \"Les clusters ne peuvent pas Ãªtre Ã©ditÃ©s.\",\n      editEdge: \"Ãditer le lien\",\n      editEdgeDescription: \"Cliquez sur les points de contrÃ´le et glissez-les pour connecter un nÅud.\",\n      editNode: \"Ãditer le nÅud\"\n    },\n    cs: {\n      addDescription: \"KluknutÃ­m do prÃ¡zdnÃ©ho prostoru mÅ¯Å¾ete pÅidat novÃ½ vrchol.\",\n      addEdge: \"PÅidat hranu\",\n      addNode: \"PÅidat vrchol\",\n      back: \"ZpÄt\",\n      close: \"ZavÅÃ­t\",\n      createEdgeError: \"Nelze pÅipojit hranu ke shluku.\",\n      del: \"Smazat vÃ½bÄr\",\n      deleteClusterError: \"Nelze mazat shluky.\",\n      edgeDescription: \"PÅetaÅ¾enÃ­m z jednoho vrcholu do druhÃ©ho mÅ¯Å¾ete spojit tyto vrcholy novou hranou.\",\n      edit: \"Upravit\",\n      editClusterError: \"Nelze upravovat shluky.\",\n      editEdge: \"Upravit hranu\",\n      editEdgeDescription: \"PÅetaÅ¾enÃ­m kontrolnÃ­ho vrcholu hrany ji mÅ¯Å¾ete pÅipojit k jinÃ©mu vrcholu.\",\n      editNode: \"Upravit vrchol\"\n    }\n  });\n\n  var bp = function () {\n    function t() {\n      Ra(this, t), this.NUM_ITERATIONS = 4, this.image = new Image(), this.canvas = document.createElement(\"canvas\");\n    }\n\n    return Ha(t, [{\n      key: \"init\",\n      value: function () {\n        if (!this.initialized()) {\n          this.src = this.image.src;\n          var t = this.image.width,\n              e = this.image.height;\n          this.width = t, this.height = e;\n          var i = Math.floor(e / 2),\n              o = Math.floor(e / 4),\n              n = Math.floor(e / 8),\n              r = Math.floor(e / 16),\n              s = Math.floor(t / 2),\n              a = Math.floor(t / 4),\n              h = Math.floor(t / 8),\n              d = Math.floor(t / 16);\n          this.canvas.width = 3 * a, this.canvas.height = i, this.coordinates = [[0, 0, s, i], [s, 0, a, o], [s, o, h, n], [5 * h, o, d, r]], this._fillMipMap();\n        }\n      }\n    }, {\n      key: \"initialized\",\n      value: function () {\n        return void 0 !== this.coordinates;\n      }\n    }, {\n      key: \"_fillMipMap\",\n      value: function () {\n        var t = this.canvas.getContext(\"2d\"),\n            e = this.coordinates[0];\n        t.drawImage(this.image, e[0], e[1], e[2], e[3]);\n\n        for (var i = 1; i < this.NUM_ITERATIONS; i++) {\n          var o = this.coordinates[i - 1],\n              n = this.coordinates[i];\n          t.drawImage(this.canvas, o[0], o[1], o[2], o[3], n[0], n[1], n[2], n[3]);\n        }\n      }\n    }, {\n      key: \"drawImageAtPosition\",\n      value: function (t, e, i, o, n, r) {\n        if (this.initialized()) if (e > 2) {\n          e *= .5;\n\n          for (var s = 0; e > 2 && s < this.NUM_ITERATIONS;) e *= .5, s += 1;\n\n          s >= this.NUM_ITERATIONS && (s = this.NUM_ITERATIONS - 1);\n          var a = this.coordinates[s];\n          t.drawImage(this.canvas, a[0], a[1], a[2], a[3], i, o, n, r);\n        } else t.drawImage(this.image, i, o, n, r);\n      }\n    }]), t;\n  }(),\n      wp = function () {\n    function t(e) {\n      Ra(this, t), this.images = {}, this.imageBroken = {}, this.callback = e;\n    }\n\n    return Ha(t, [{\n      key: \"_tryloadBrokenUrl\",\n      value: function (t, e, i) {\n        void 0 !== t && void 0 !== i && (void 0 !== e ? (i.image.onerror = function () {\n          console.error(\"Could not load brokenImage:\", e);\n        }, i.image.src = e) : console.warn(\"No broken url image defined\"));\n      }\n    }, {\n      key: \"_redrawWithImage\",\n      value: function (t) {\n        this.callback && this.callback(t);\n      }\n    }, {\n      key: \"load\",\n      value: function (t, e) {\n        var i = this,\n            o = this.images[t];\n        if (o) return o;\n        var n = new bp();\n        return this.images[t] = n, n.image.onload = function () {\n          i._fixImageCoordinates(n.image), n.init(), i._redrawWithImage(n);\n        }, n.image.onerror = function () {\n          console.error(\"Could not load image:\", t), i._tryloadBrokenUrl(t, e, n);\n        }, n.image.src = t, n;\n      }\n    }, {\n      key: \"_fixImageCoordinates\",\n      value: function (t) {\n        0 === t.width && (document.body.appendChild(t), t.width = t.offsetWidth, t.height = t.offsetHeight, document.body.removeChild(t));\n      }\n    }]), t;\n  }(),\n      kp = {\n    exports: {}\n  },\n      _p = !s(function () {\n    return Object.isExtensible(Object.preventExtensions({}));\n  }),\n      xp = ue,\n      Ep = Te,\n      Op = E,\n      Cp = et,\n      Sp = Xt.f,\n      Tp = Cr,\n      Mp = Mr,\n      Pp = _p,\n      Dp = !1,\n      Bp = nt(\"meta\"),\n      Ip = 0,\n      zp = Object.isExtensible || function () {\n    return !0;\n  },\n      Fp = function (t) {\n    Sp(t, Bp, {\n      value: {\n        objectID: \"O\" + Ip++,\n        weakData: {}\n      }\n    });\n  },\n      Np = kp.exports = {\n    enable: function () {\n      Np.enable = function () {}, Dp = !0;\n      var t = Tp.f,\n          e = [].splice,\n          i = {};\n      i[Bp] = 1, t(i).length && (Tp.f = function (i) {\n        for (var o = t(i), n = 0, r = o.length; n < r; n++) if (o[n] === Bp) {\n          e.call(o, n, 1);\n          break;\n        }\n\n        return o;\n      }, xp({\n        target: \"Object\",\n        stat: !0,\n        forced: !0\n      }, {\n        getOwnPropertyNames: Mp.f\n      }));\n    },\n    fastKey: function (t, e) {\n      if (!Op(t)) return \"symbol\" == typeof t ? t : (\"string\" == typeof t ? \"S\" : \"P\") + t;\n\n      if (!Cp(t, Bp)) {\n        if (!zp(t)) return \"F\";\n        if (!e) return \"E\";\n        Fp(t);\n      }\n\n      return t[Bp].objectID;\n    },\n    getWeakData: function (t, e) {\n      if (!Cp(t, Bp)) {\n        if (!zp(t)) return !0;\n        if (!e) return !1;\n        Fp(t);\n      }\n\n      return t[Bp].weakData;\n    },\n    onFreeze: function (t) {\n      return Pp && Dp && zp(t) && !Cp(t, Bp) && Fp(t), t;\n    }\n  };\n\n  Ep[Bp] = !0;\n\n  var Ap = Kt,\n      Rp = An,\n      jp = me,\n      Lp = Yt,\n      Hp = Un,\n      Wp = Dn,\n      Vp = function (t, e) {\n    this.stopped = t, this.result = e;\n  },\n      qp = function (t, e, i) {\n    var o,\n        n,\n        r,\n        s,\n        a,\n        h,\n        d,\n        l = i && i.that,\n        c = !(!i || !i.AS_ENTRIES),\n        u = !(!i || !i.IS_ITERATOR),\n        f = !(!i || !i.INTERRUPTED),\n        p = Lp(e, l, 1 + c + f),\n        v = function (t) {\n      return o && Wp(o), new Vp(!0, t);\n    },\n        g = function (t) {\n      return c ? (Ap(t), f ? p(t[0], t[1], v) : p(t[0], t[1])) : f ? p(t, v) : p(t);\n    };\n\n    if (u) o = t;else {\n      if (\"function\" != typeof (n = Hp(t))) throw TypeError(\"Target is not iterable\");\n\n      if (Rp(n)) {\n        for (r = 0, s = jp(t.length); s > r; r++) if ((a = g(t[r])) && a instanceof Vp) return a;\n\n        return new Vp(!1);\n      }\n\n      o = n.call(t);\n    }\n\n    for (h = o.next; !(d = h.call(o)).done;) {\n      try {\n        a = g(d.value);\n      } catch (t) {\n        throw Wp(o), t;\n      }\n\n      if (\"object\" == typeof a && a && a instanceof Vp) return a;\n    }\n\n    return new Vp(!1);\n  },\n      Up = function (t, e, i) {\n    if (!(t instanceof e)) throw TypeError(\"Incorrect \" + (i ? i + \" \" : \"\") + \"invocation\");\n    return t;\n  },\n      Yp = ue,\n      Xp = n,\n      Gp = kp.exports,\n      Kp = s,\n      $p = oe,\n      Zp = qp,\n      Qp = Up,\n      Jp = E,\n      tv = Xo,\n      ev = Xt.f,\n      iv = Jr.forEach,\n      ov = a,\n      nv = Zi.set,\n      rv = Zi.getterFor,\n      sv = function (t, e, i) {\n    var o,\n        n = -1 !== t.indexOf(\"Map\"),\n        r = -1 !== t.indexOf(\"Weak\"),\n        s = n ? \"set\" : \"add\",\n        a = Xp[t],\n        h = a && a.prototype,\n        d = {};\n\n    if (ov && \"function\" == typeof a && (r || h.forEach && !Kp(function () {\n      new a().entries().next();\n    }))) {\n      o = e(function (e, i) {\n        nv(Qp(e, o, t), {\n          type: t,\n          collection: new a()\n        }), null != i && Zp(i, e[s], {\n          that: e,\n          AS_ENTRIES: n\n        });\n      });\n      var l = rv(t);\n      iv([\"add\", \"clear\", \"delete\", \"forEach\", \"get\", \"has\", \"set\", \"keys\", \"values\", \"entries\"], function (t) {\n        var e = \"add\" == t || \"set\" == t;\n        !(t in h) || r && \"clear\" == t || $p(o.prototype, t, function (i, o) {\n          var n = l(this).collection;\n          if (!e && r && !Jp(i)) return \"get\" == t && void 0;\n          var s = n[t](0 === i ? 0 : i, o);\n          return e ? this : s;\n        });\n      }), r || ev(o.prototype, \"size\", {\n        configurable: !0,\n        get: function () {\n          return l(this).collection.size;\n        }\n      });\n    } else o = i.getConstructor(e, t, n, s), Gp.enable();\n\n    return tv(o, t, !1, !0), d[t] = o, Yp({\n      global: !0,\n      forced: !0\n    }, d), r || i.setStrong(o, t, n), o;\n  },\n      av = an,\n      hv = function (t, e, i) {\n    for (var o in e) i && i.unsafe && t[o] ? t[o] = e[o] : av(t, o, e[o], i);\n\n    return t;\n  },\n      dv = M,\n      lv = Xt,\n      cv = a,\n      uv = pt(\"species\"),\n      fv = Xt.f,\n      pv = Do,\n      vv = hv,\n      gv = Yt,\n      yv = Up,\n      mv = qp,\n      bv = _n,\n      wv = function (t) {\n    var e = dv(t),\n        i = lv.f;\n    cv && e && !e[uv] && i(e, uv, {\n      configurable: !0,\n      get: function () {\n        return this;\n      }\n    });\n  },\n      kv = a,\n      _v = kp.exports.fastKey,\n      xv = Zi.set,\n      Ev = Zi.getterFor,\n      Ov = {\n    getConstructor: function (t, e, i, o) {\n      var n = t(function (t, r) {\n        yv(t, n, e), xv(t, {\n          type: e,\n          index: pv(null),\n          first: void 0,\n          last: void 0,\n          size: 0\n        }), kv || (t.size = 0), null != r && mv(r, t[o], {\n          that: t,\n          AS_ENTRIES: i\n        });\n      }),\n          r = Ev(e),\n          s = function (t, e, i) {\n        var o,\n            n,\n            s = r(t),\n            h = a(t, e);\n        return h ? h.value = i : (s.last = h = {\n          index: n = _v(e, !0),\n          key: e,\n          value: i,\n          previous: o = s.last,\n          next: void 0,\n          removed: !1\n        }, s.first || (s.first = h), o && (o.next = h), kv ? s.size++ : t.size++, \"F\" !== n && (s.index[n] = h)), t;\n      },\n          a = function (t, e) {\n        var i,\n            o = r(t),\n            n = _v(e);\n\n        if (\"F\" !== n) return o.index[n];\n\n        for (i = o.first; i; i = i.next) if (i.key == e) return i;\n      };\n\n      return vv(n.prototype, {\n        clear: function () {\n          for (var t = r(this), e = t.index, i = t.first; i;) i.removed = !0, i.previous && (i.previous = i.previous.next = void 0), delete e[i.index], i = i.next;\n\n          t.first = t.last = void 0, kv ? t.size = 0 : this.size = 0;\n        },\n        delete: function (t) {\n          var e = this,\n              i = r(e),\n              o = a(e, t);\n\n          if (o) {\n            var n = o.next,\n                s = o.previous;\n            delete i.index[o.index], o.removed = !0, s && (s.next = n), n && (n.previous = s), i.first == o && (i.first = n), i.last == o && (i.last = s), kv ? i.size-- : e.size--;\n          }\n\n          return !!o;\n        },\n        forEach: function (t) {\n          for (var e, i = r(this), o = gv(t, arguments.length > 1 ? arguments[1] : void 0, 3); e = e ? e.next : i.first;) for (o(e.value, e.key, this); e && e.removed;) e = e.previous;\n        },\n        has: function (t) {\n          return !!a(this, t);\n        }\n      }), vv(n.prototype, i ? {\n        get: function (t) {\n          var e = a(this, t);\n          return e && e.value;\n        },\n        set: function (t, e) {\n          return s(this, 0 === t ? 0 : t, e);\n        }\n      } : {\n        add: function (t) {\n          return s(this, t = 0 === t ? 0 : t, t);\n        }\n      }), kv && fv(n.prototype, \"size\", {\n        get: function () {\n          return r(this).size;\n        }\n      }), n;\n    },\n    setStrong: function (t, e, i) {\n      var o = e + \" Iterator\",\n          n = Ev(e),\n          r = Ev(o);\n      bv(t, e, function (t, e) {\n        xv(this, {\n          type: o,\n          target: t,\n          state: n(t),\n          kind: e,\n          last: void 0\n        });\n      }, function () {\n        for (var t = r(this), e = t.kind, i = t.last; i && i.removed;) i = i.previous;\n\n        return t.target && (t.last = i = i ? i.next : t.state.first) ? \"keys\" == e ? {\n          value: i.key,\n          done: !1\n        } : \"values\" == e ? {\n          value: i.value,\n          done: !1\n        } : {\n          value: [i.key, i.value],\n          done: !1\n        } : (t.target = void 0, {\n          value: void 0,\n          done: !0\n        });\n      }, i ? \"entries\" : \"values\", !i, !0), wv(e);\n    }\n  };\n\n  sv(\"Map\", function (t) {\n    return function () {\n      return t(this, arguments.length ? arguments[0] : void 0);\n    };\n  }, Ov);\n\n  var Cv = O.Map,\n      Sv = function () {\n    function t() {\n      Ra(this, t), this.clear(), this._defaultIndex = 0, this._groupIndex = 0, this._defaultGroups = [{\n        border: \"#2B7CE9\",\n        background: \"#97C2FC\",\n        highlight: {\n          border: \"#2B7CE9\",\n          background: \"#D2E5FF\"\n        },\n        hover: {\n          border: \"#2B7CE9\",\n          background: \"#D2E5FF\"\n        }\n      }, {\n        border: \"#FFA500\",\n        background: \"#FFFF00\",\n        highlight: {\n          border: \"#FFA500\",\n          background: \"#FFFFA3\"\n        },\n        hover: {\n          border: \"#FFA500\",\n          background: \"#FFFFA3\"\n        }\n      }, {\n        border: \"#FA0A10\",\n        background: \"#FB7E81\",\n        highlight: {\n          border: \"#FA0A10\",\n          background: \"#FFAFB1\"\n        },\n        hover: {\n          border: \"#FA0A10\",\n          background: \"#FFAFB1\"\n        }\n      }, {\n        border: \"#41A906\",\n        background: \"#7BE141\",\n        highlight: {\n          border: \"#41A906\",\n          background: \"#A1EC76\"\n        },\n        hover: {\n          border: \"#41A906\",\n          background: \"#A1EC76\"\n        }\n      }, {\n        border: \"#E129F0\",\n        background: \"#EB7DF4\",\n        highlight: {\n          border: \"#E129F0\",\n          background: \"#F0B3F5\"\n        },\n        hover: {\n          border: \"#E129F0\",\n          background: \"#F0B3F5\"\n        }\n      }, {\n        border: \"#7C29F0\",\n        background: \"#AD85E4\",\n        highlight: {\n          border: \"#7C29F0\",\n          background: \"#D3BDF0\"\n        },\n        hover: {\n          border: \"#7C29F0\",\n          background: \"#D3BDF0\"\n        }\n      }, {\n        border: \"#C37F00\",\n        background: \"#FFA807\",\n        highlight: {\n          border: \"#C37F00\",\n          background: \"#FFCA66\"\n        },\n        hover: {\n          border: \"#C37F00\",\n          background: \"#FFCA66\"\n        }\n      }, {\n        border: \"#4220FB\",\n        background: \"#6E6EFD\",\n        highlight: {\n          border: \"#4220FB\",\n          background: \"#9B9BFD\"\n        },\n        hover: {\n          border: \"#4220FB\",\n          background: \"#9B9BFD\"\n        }\n      }, {\n        border: \"#FD5A77\",\n        background: \"#FFC0CB\",\n        highlight: {\n          border: \"#FD5A77\",\n          background: \"#FFD1D9\"\n        },\n        hover: {\n          border: \"#FD5A77\",\n          background: \"#FFD1D9\"\n        }\n      }, {\n        border: \"#4AD63A\",\n        background: \"#C2FABC\",\n        highlight: {\n          border: \"#4AD63A\",\n          background: \"#E6FFE3\"\n        },\n        hover: {\n          border: \"#4AD63A\",\n          background: \"#E6FFE3\"\n        }\n      }, {\n        border: \"#990000\",\n        background: \"#EE0000\",\n        highlight: {\n          border: \"#BB0000\",\n          background: \"#FF3333\"\n        },\n        hover: {\n          border: \"#BB0000\",\n          background: \"#FF3333\"\n        }\n      }, {\n        border: \"#FF6000\",\n        background: \"#FF6000\",\n        highlight: {\n          border: \"#FF6000\",\n          background: \"#FF6000\"\n        },\n        hover: {\n          border: \"#FF6000\",\n          background: \"#FF6000\"\n        }\n      }, {\n        border: \"#97C2FC\",\n        background: \"#2B7CE9\",\n        highlight: {\n          border: \"#D2E5FF\",\n          background: \"#2B7CE9\"\n        },\n        hover: {\n          border: \"#D2E5FF\",\n          background: \"#2B7CE9\"\n        }\n      }, {\n        border: \"#399605\",\n        background: \"#255C03\",\n        highlight: {\n          border: \"#399605\",\n          background: \"#255C03\"\n        },\n        hover: {\n          border: \"#399605\",\n          background: \"#255C03\"\n        }\n      }, {\n        border: \"#B70054\",\n        background: \"#FF007E\",\n        highlight: {\n          border: \"#B70054\",\n          background: \"#FF007E\"\n        },\n        hover: {\n          border: \"#B70054\",\n          background: \"#FF007E\"\n        }\n      }, {\n        border: \"#AD85E4\",\n        background: \"#7C29F0\",\n        highlight: {\n          border: \"#D3BDF0\",\n          background: \"#7C29F0\"\n        },\n        hover: {\n          border: \"#D3BDF0\",\n          background: \"#7C29F0\"\n        }\n      }, {\n        border: \"#4557FA\",\n        background: \"#000EA1\",\n        highlight: {\n          border: \"#6E6EFD\",\n          background: \"#000EA1\"\n        },\n        hover: {\n          border: \"#6E6EFD\",\n          background: \"#000EA1\"\n        }\n      }, {\n        border: \"#FFC0CB\",\n        background: \"#FD5A77\",\n        highlight: {\n          border: \"#FFD1D9\",\n          background: \"#FD5A77\"\n        },\n        hover: {\n          border: \"#FFD1D9\",\n          background: \"#FD5A77\"\n        }\n      }, {\n        border: \"#C2FABC\",\n        background: \"#74D66A\",\n        highlight: {\n          border: \"#E6FFE3\",\n          background: \"#74D66A\"\n        },\n        hover: {\n          border: \"#E6FFE3\",\n          background: \"#74D66A\"\n        }\n      }, {\n        border: \"#EE0000\",\n        background: \"#990000\",\n        highlight: {\n          border: \"#FF3333\",\n          background: \"#BB0000\"\n        },\n        hover: {\n          border: \"#FF3333\",\n          background: \"#BB0000\"\n        }\n      }], this.options = {}, this.defaultOptions = {\n        useDefaultGroups: !0\n      }, Ke(this.options, this.defaultOptions);\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function (t) {\n        var e = [\"useDefaultGroups\"];\n        if (void 0 !== t) for (var i in t) if (Object.prototype.hasOwnProperty.call(t, i) && -1 === Cl(e).call(e, i)) {\n          var o = t[i];\n          this.add(i, o);\n        }\n      }\n    }, {\n      key: \"clear\",\n      value: function () {\n        this._groups = new Cv(), this._groupNames = [];\n      }\n    }, {\n      key: \"get\",\n      value: function (t) {\n        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],\n            i = this._groups.get(t);\n\n        if (void 0 === i && e) if (!1 === this.options.useDefaultGroups && this._groupNames.length > 0) {\n          var o = this._groupIndex % this._groupNames.length;\n          ++this._groupIndex, (i = {}).color = this._groups.get(this._groupNames[o]), this._groups.set(t, i);\n        } else {\n          var n = this._defaultIndex % this._defaultGroups.length;\n          this._defaultIndex++, (i = {}).color = this._defaultGroups[n], this._groups.set(t, i);\n        }\n        return i;\n      }\n    }, {\n      key: \"add\",\n      value: function (t, e) {\n        return this._groups.has(t) || this._groupNames.push(t), this._groups.set(t, e), e;\n      }\n    }]), t;\n  }();\n\n  ue({\n    target: \"Number\",\n    stat: !0\n  }, {\n    isNaN: function (t) {\n      return t != t;\n    }\n  });\n  var Tv = O.Number.isNaN,\n      Mv = n.isFinite;\n  ue({\n    target: \"Number\",\n    stat: !0\n  }, {\n    isFinite: Number.isFinite || function (t) {\n      return \"number\" == typeof t && Mv(t);\n    }\n  });\n  var Pv = O.Number.isFinite,\n      Dv = Jr.some;\n  ue({\n    target: \"Array\",\n    proto: !0,\n    forced: !Zh(\"some\")\n  }, {\n    some: function (t) {\n      return Dv(this, t, arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n\n  var Bv = oi(\"Array\").some,\n      Iv = Array.prototype,\n      zv = function (t) {\n    var e = t.some;\n    return t === Iv || t instanceof Array && e === Iv.some ? Bv : e;\n  },\n      Fv = gi,\n      Nv = ll.trim,\n      Av = n.parseFloat,\n      Rv = 1 / Av(\"\\t\\n\\v\\f\\r Â áââââââââââââ¯âã\\u2028\\u2029\\ufeff-0\") != -1 / 0 ? function (t) {\n    var e = Nv(Fv(t)),\n        i = Av(e);\n    return 0 === i && \"-\" == e.charAt(0) ? -0 : i;\n  } : Av;\n\n  ue({\n    global: !0,\n    forced: parseFloat != Rv\n  }, {\n    parseFloat: Rv\n  });\n  var jv = O.parseFloat,\n      Lv = ue,\n      Hv = s,\n      Wv = Mr.f;\n  Lv({\n    target: \"Object\",\n    stat: !0,\n    forced: Hv(function () {\n      return !Object.getOwnPropertyNames(1);\n    })\n  }, {\n    getOwnPropertyNames: Wv\n  });\n\n  var Vv = O.Object,\n      qv = function (t) {\n    return Vv.getOwnPropertyNames(t);\n  };\n\n  function Uv(t, e) {\n    var i = [\"node\", \"edge\", \"label\"],\n        o = !0,\n        n = Ef(e, \"chosen\");\n    if (\"boolean\" == typeof n) o = n;else if (\"object\" === zh(n)) {\n      if (-1 === Cl(i).call(i, t)) throw new Error(\"choosify: subOption '\" + t + \"' should be one of '\" + i.join(\"', '\") + \"'\");\n      var r = Ef(e, [\"chosen\", t]);\n      \"boolean\" != typeof r && \"function\" != typeof r || (o = r);\n    }\n    return o;\n  }\n\n  function Yv(t, e, i) {\n    if (t.width <= 0 || t.height <= 0) return !1;\n\n    if (void 0 !== i) {\n      var o = {\n        x: e.x - i.x,\n        y: e.y - i.y\n      };\n\n      if (0 !== i.angle) {\n        var n = -i.angle;\n        e = {\n          x: Math.cos(n) * o.x - Math.sin(n) * o.y,\n          y: Math.sin(n) * o.x + Math.cos(n) * o.y\n        };\n      } else e = o;\n    }\n\n    var r = t.x + t.width,\n        s = t.y + t.width;\n    return t.left < e.x && r > e.x && t.top < e.y && s > e.y;\n  }\n\n  function Xv(t) {\n    return \"string\" == typeof t && \"\" !== t;\n  }\n\n  function Gv(t, e, i, o) {\n    var n = o.x,\n        r = o.y;\n\n    if (\"function\" == typeof o.distanceToBorder) {\n      var s = o.distanceToBorder(t, e),\n          a = Math.sin(e) * s,\n          h = Math.cos(e) * s;\n      h === s ? (n += s, r = o.y) : a === s ? (n = o.x, r -= s) : (n += h, r -= a);\n    } else o.shape.width > o.shape.height ? (n = o.x + .5 * o.shape.width, r = o.y - i) : (n = o.x + i, r = o.y - .5 * o.shape.height);\n\n    return {\n      x: n,\n      y: r\n    };\n  }\n\n  var Kv = oi(\"Array\").values,\n      $v = Ro,\n      Zv = Array.prototype,\n      Qv = {\n    DOMTokenList: !0,\n    NodeList: !0\n  },\n      Jv = function (t) {\n    var e = t.values;\n    return t === Zv || t instanceof Array && e === Zv.values || Qv.hasOwnProperty($v(t)) ? Kv : e;\n  },\n      tg = function () {\n    function t(e) {\n      Ra(this, t), this.measureText = e, this.current = 0, this.width = 0, this.height = 0, this.lines = [];\n    }\n\n    return Ha(t, [{\n      key: \"_add\",\n      value: function (t, e) {\n        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : \"normal\";\n        void 0 === this.lines[t] && (this.lines[t] = {\n          width: 0,\n          height: 0,\n          blocks: []\n        });\n        var o = e;\n        void 0 !== e && \"\" !== e || (o = \" \");\n        var n = this.measureText(o, i),\n            r = Ke({}, Jv(n));\n        r.text = e, r.width = n.width, r.mod = i, void 0 !== e && \"\" !== e || (r.width = 0), this.lines[t].blocks.push(r), this.lines[t].width += r.width;\n      }\n    }, {\n      key: \"curWidth\",\n      value: function () {\n        var t = this.lines[this.current];\n        return void 0 === t ? 0 : t.width;\n      }\n    }, {\n      key: \"append\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"normal\";\n\n        this._add(this.current, t, e);\n      }\n    }, {\n      key: \"newLine\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"normal\";\n        this._add(this.current, t, e), this.current++;\n      }\n    }, {\n      key: \"determineLineHeights\",\n      value: function () {\n        for (var t = 0; t < this.lines.length; t++) {\n          var e = this.lines[t],\n              i = 0;\n          if (void 0 !== e.blocks) for (var o = 0; o < e.blocks.length; o++) {\n            var n = e.blocks[o];\n            i < n.height && (i = n.height);\n          }\n          e.height = i;\n        }\n      }\n    }, {\n      key: \"determineLabelSize\",\n      value: function () {\n        for (var t = 0, e = 0, i = 0; i < this.lines.length; i++) {\n          var o = this.lines[i];\n          o.width > t && (t = o.width), e += o.height;\n        }\n\n        this.width = t, this.height = e;\n      }\n    }, {\n      key: \"removeEmptyBlocks\",\n      value: function () {\n        for (var t = [], e = 0; e < this.lines.length; e++) {\n          var i = this.lines[e];\n\n          if (0 !== i.blocks.length && (e !== this.lines.length - 1 || 0 !== i.width)) {\n            var o = {};\n            Ke(o, i), o.blocks = [];\n\n            for (var n = void 0, r = [], s = 0; s < i.blocks.length; s++) {\n              var a = i.blocks[s];\n              0 !== a.width ? r.push(a) : void 0 === n && (n = a);\n            }\n\n            0 === r.length && void 0 !== n && r.push(n), o.blocks = r, t.push(o);\n          }\n        }\n\n        return t;\n      }\n    }, {\n      key: \"finalize\",\n      value: function () {\n        this.determineLineHeights(), this.determineLabelSize();\n        var t = this.removeEmptyBlocks();\n        return {\n          width: this.width,\n          height: this.height,\n          lines: t\n        };\n      }\n    }]), t;\n  }(),\n      eg = {\n    \"<b>\": /<b>/,\n    \"<i>\": /<i>/,\n    \"<code>\": /<code>/,\n    \"</b>\": /<\\/b>/,\n    \"</i>\": /<\\/i>/,\n    \"</code>\": /<\\/code>/,\n    \"*\": /\\*/,\n    _: /_/,\n    \"`\": /`/,\n    afterBold: /[^*]/,\n    afterItal: /[^_]/,\n    afterMono: /[^`]/\n  },\n      ig = function () {\n    function t(e) {\n      Ra(this, t), this.text = e, this.bold = !1, this.ital = !1, this.mono = !1, this.spacing = !1, this.position = 0, this.buffer = \"\", this.modStack = [], this.blocks = [];\n    }\n\n    return Ha(t, [{\n      key: \"mod\",\n      value: function () {\n        return 0 === this.modStack.length ? \"normal\" : this.modStack[0];\n      }\n    }, {\n      key: \"modName\",\n      value: function () {\n        return 0 === this.modStack.length ? \"normal\" : \"mono\" === this.modStack[0] ? \"mono\" : this.bold && this.ital ? \"boldital\" : this.bold ? \"bold\" : this.ital ? \"ital\" : void 0;\n      }\n    }, {\n      key: \"emitBlock\",\n      value: function () {\n        this.spacing && (this.add(\" \"), this.spacing = !1), this.buffer.length > 0 && (this.blocks.push({\n          text: this.buffer,\n          mod: this.modName()\n        }), this.buffer = \"\");\n      }\n    }, {\n      key: \"add\",\n      value: function (t) {\n        \" \" === t && (this.spacing = !0), this.spacing && (this.buffer += \" \", this.spacing = !1), \" \" != t && (this.buffer += t);\n      }\n    }, {\n      key: \"parseWS\",\n      value: function (t) {\n        return !!/[ \\t]/.test(t) && (this.mono ? this.add(t) : this.spacing = !0, !0);\n      }\n    }, {\n      key: \"setTag\",\n      value: function (t) {\n        this.emitBlock(), this[t] = !0, this.modStack.unshift(t);\n      }\n    }, {\n      key: \"unsetTag\",\n      value: function (t) {\n        this.emitBlock(), this[t] = !1, this.modStack.shift();\n      }\n    }, {\n      key: \"parseStartTag\",\n      value: function (t, e) {\n        return !(this.mono || this[t] || !this.match(e)) && (this.setTag(t), !0);\n      }\n    }, {\n      key: \"match\",\n      value: function (t) {\n        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],\n            i = this.prepareRegExp(t),\n            o = Bh(i, 2),\n            n = o[0],\n            r = o[1],\n            s = n.test(this.text.substr(this.position, r));\n        return s && e && (this.position += r - 1), s;\n      }\n    }, {\n      key: \"parseEndTag\",\n      value: function (t, e, i) {\n        var o = this.mod() === t;\n        return !(!(o = \"mono\" === t ? o && this.mono : o && !this.mono) || !this.match(e)) && (void 0 !== i ? (this.position === this.text.length - 1 || this.match(i, !1)) && this.unsetTag(t) : this.unsetTag(t), !0);\n      }\n    }, {\n      key: \"replace\",\n      value: function (t, e) {\n        return !!this.match(t) && (this.add(e), this.position += length - 1, !0);\n      }\n    }, {\n      key: \"prepareRegExp\",\n      value: function (t) {\n        var e, i;\n        if (t instanceof RegExp) i = t, e = 1;else {\n          var o = eg[t];\n          i = void 0 !== o ? o : new RegExp(t), e = t.length;\n        }\n        return [i, e];\n      }\n    }]), t;\n  }(),\n      og = function () {\n    function t(e, i, o, n) {\n      var r = this;\n      Ra(this, t), this.ctx = e, this.parent = i, this.selected = o, this.hover = n;\n      this.lines = new tg(function (t, i) {\n        if (void 0 === t) return 0;\n        var s = r.parent.getFormattingValues(e, o, n, i),\n            a = 0;\n        \"\" !== t && (a = r.ctx.measureText(t).width);\n        return {\n          width: a,\n          values: s\n        };\n      });\n    }\n\n    return Ha(t, [{\n      key: \"process\",\n      value: function (t) {\n        if (!Xv(t)) return this.lines.finalize();\n        var e = this.parent.fontOptions;\n        t = (t = t.replace(/\\r\\n/g, \"\\n\")).replace(/\\r/g, \"\\n\");\n        var i = String(t).split(\"\\n\"),\n            o = i.length;\n        if (e.multi) for (var n = 0; n < o; n++) {\n          var r = this.splitBlocks(i[n], e.multi);\n          if (void 0 !== r) if (0 !== r.length) {\n            if (e.maxWdt > 0) for (var s = 0; s < r.length; s++) {\n              var a = r[s].mod,\n                  h = r[s].text;\n              this.splitStringIntoLines(h, a, !0);\n            } else for (var d = 0; d < r.length; d++) {\n              var l = r[d].mod,\n                  c = r[d].text;\n              this.lines.append(c, l);\n            }\n            this.lines.newLine();\n          } else this.lines.newLine(\"\");\n        } else if (e.maxWdt > 0) for (var u = 0; u < o; u++) this.splitStringIntoLines(i[u]);else for (var f = 0; f < o; f++) this.lines.newLine(i[f]);\n        return this.lines.finalize();\n      }\n    }, {\n      key: \"decodeMarkupSystem\",\n      value: function (t) {\n        var e = \"none\";\n        return \"markdown\" === t || \"md\" === t ? e = \"markdown\" : !0 !== t && \"html\" !== t || (e = \"html\"), e;\n      }\n    }, {\n      key: \"splitHtmlBlocks\",\n      value: function (t) {\n        for (var e = new ig(t), i = function (t) {\n          return !!/&/.test(t) && (e.replace(e.text, \"&lt;\", \"<\") || e.replace(e.text, \"&amp;\", \"&\") || e.add(\"&\"), !0);\n        }; e.position < e.text.length;) {\n          var o = e.text.charAt(e.position);\n          e.parseWS(o) || /</.test(o) && (e.parseStartTag(\"bold\", \"<b>\") || e.parseStartTag(\"ital\", \"<i>\") || e.parseStartTag(\"mono\", \"<code>\") || e.parseEndTag(\"bold\", \"</b>\") || e.parseEndTag(\"ital\", \"</i>\") || e.parseEndTag(\"mono\", \"</code>\")) || i(o) || e.add(o), e.position++;\n        }\n\n        return e.emitBlock(), e.blocks;\n      }\n    }, {\n      key: \"splitMarkdownBlocks\",\n      value: function (t) {\n        for (var e = this, i = new ig(t), o = !0, n = function (t) {\n          return !!/\\\\/.test(t) && (i.position < e.text.length + 1 && (i.position++, t = e.text.charAt(i.position), / \\t/.test(t) ? i.spacing = !0 : (i.add(t), o = !1)), !0);\n        }; i.position < i.text.length;) {\n          var r = i.text.charAt(i.position);\n          i.parseWS(r) || n(r) || (o || i.spacing) && (i.parseStartTag(\"bold\", \"*\") || i.parseStartTag(\"ital\", \"_\") || i.parseStartTag(\"mono\", \"`\")) || i.parseEndTag(\"bold\", \"*\", \"afterBold\") || i.parseEndTag(\"ital\", \"_\", \"afterItal\") || i.parseEndTag(\"mono\", \"`\", \"afterMono\") || (i.add(r), o = !1), i.position++;\n        }\n\n        return i.emitBlock(), i.blocks;\n      }\n    }, {\n      key: \"splitBlocks\",\n      value: function (t, e) {\n        var i = this.decodeMarkupSystem(e);\n        return \"none\" === i ? [{\n          text: t,\n          mod: \"normal\"\n        }] : \"markdown\" === i ? this.splitMarkdownBlocks(t) : \"html\" === i ? this.splitHtmlBlocks(t) : void 0;\n      }\n    }, {\n      key: \"overMaxWidth\",\n      value: function (t) {\n        var e = this.ctx.measureText(t).width;\n        return this.lines.curWidth() + e > this.parent.fontOptions.maxWdt;\n      }\n    }, {\n      key: \"getLongestFit\",\n      value: function (t) {\n        for (var e = \"\", i = 0; i < t.length;) {\n          var o = e + (\"\" === e ? \"\" : \" \") + t[i];\n          if (this.overMaxWidth(o)) break;\n          e = o, i++;\n        }\n\n        return i;\n      }\n    }, {\n      key: \"getLongestFitWord\",\n      value: function (t) {\n        for (var e = 0; e < t.length && !this.overMaxWidth(Lh(t).call(t, 0, e));) e++;\n\n        return e;\n      }\n    }, {\n      key: \"splitStringIntoLines\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"normal\",\n            i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n        this.parent.getFormattingValues(this.ctx, this.selected, this.hover, e);\n\n        for (var o = (t = (t = t.replace(/^( +)/g, \"$1\\r\")).replace(/([^\\r][^ ]*)( +)/g, \"$1\\r$2\\r\")).split(\"\\r\"); o.length > 0;) {\n          var n = this.getLongestFit(o);\n\n          if (0 === n) {\n            var r = o[0],\n                s = this.getLongestFitWord(r);\n            this.lines.newLine(Lh(r).call(r, 0, s), e), o[0] = Lh(r).call(r, s);\n          } else {\n            var a = n;\n            \" \" === o[n - 1] ? n-- : \" \" === o[a] && a++;\n            var h = Lh(o).call(o, 0, n).join(\"\");\n            n == o.length && i ? this.lines.append(h, e) : this.lines.newLine(h, e), o = Lh(o).call(o, a);\n          }\n        }\n      }\n    }]), t;\n  }(),\n      ng = [\"bold\", \"ital\", \"boldital\", \"mono\"],\n      rg = function () {\n    function t(e, i) {\n      var o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n      Ra(this, t), this.body = e, this.pointToSelf = !1, this.baseSize = void 0, this.fontOptions = {}, this.setOptions(i), this.size = {\n        top: 0,\n        left: 0,\n        width: 0,\n        height: 0,\n        yLine: 0\n      }, this.isEdgeLabel = o;\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function (t) {\n        if (this.elementOptions = t, this.initFontOptions(t.font), Xv(t.label) ? this.labelDirty = !0 : t.label = void 0, void 0 !== t.font && null !== t.font) if (\"string\" == typeof t.font) this.baseSize = this.fontOptions.size;else if (\"object\" === zh(t.font)) {\n          var e = t.font.size;\n          void 0 !== e && (this.baseSize = e);\n        }\n      }\n    }, {\n      key: \"initFontOptions\",\n      value: function (e) {\n        var i = this;\n        lf(ng, function (t) {\n          i.fontOptions[t] = {};\n        }), t.parseFontString(this.fontOptions, e) ? this.fontOptions.vadjust = 0 : lf(e, function (t, e) {\n          null != t && \"object\" !== zh(t) && (i.fontOptions[e] = t);\n        });\n      }\n    }, {\n      key: \"constrain\",\n      value: function (t) {\n        var e = {\n          constrainWidth: !1,\n          maxWdt: -1,\n          minWdt: -1,\n          constrainHeight: !1,\n          minHgt: -1,\n          valign: \"middle\"\n        },\n            i = Ef(t, \"widthConstraint\");\n        if (\"number\" == typeof i) e.maxWdt = Number(i), e.minWdt = Number(i);else if (\"object\" === zh(i)) {\n          var o = Ef(t, [\"widthConstraint\", \"maximum\"]);\n          \"number\" == typeof o && (e.maxWdt = Number(o));\n          var n = Ef(t, [\"widthConstraint\", \"minimum\"]);\n          \"number\" == typeof n && (e.minWdt = Number(n));\n        }\n        var r = Ef(t, \"heightConstraint\");\n        if (\"number\" == typeof r) e.minHgt = Number(r);else if (\"object\" === zh(r)) {\n          var s = Ef(t, [\"heightConstraint\", \"minimum\"]);\n          \"number\" == typeof s && (e.minHgt = Number(s));\n          var a = Ef(t, [\"heightConstraint\", \"valign\"]);\n          \"string\" == typeof a && (\"top\" !== a && \"bottom\" !== a || (e.valign = a));\n        }\n        return e;\n      }\n    }, {\n      key: \"update\",\n      value: function (t, e) {\n        this.setOptions(t, !0), this.propagateFonts(e), sf(this.fontOptions, this.constrain(e)), this.fontOptions.chooser = Uv(\"label\", e);\n      }\n    }, {\n      key: \"adjustSizes\",\n      value: function (t) {\n        var e = t ? t.right + t.left : 0;\n        this.fontOptions.constrainWidth && (this.fontOptions.maxWdt -= e, this.fontOptions.minWdt -= e);\n        var i = t ? t.top + t.bottom : 0;\n        this.fontOptions.constrainHeight && (this.fontOptions.minHgt -= i);\n      }\n    }, {\n      key: \"addFontOptionsToPile\",\n      value: function (t, e) {\n        for (var i = 0; i < e.length; ++i) this.addFontToPile(t, e[i]);\n      }\n    }, {\n      key: \"addFontToPile\",\n      value: function (t, e) {\n        if (void 0 !== e && void 0 !== e.font && null !== e.font) {\n          var i = e.font;\n          t.push(i);\n        }\n      }\n    }, {\n      key: \"getBasicOptions\",\n      value: function (e) {\n        for (var i = {}, o = 0; o < e.length; ++o) {\n          var n = e[o],\n              r = {};\n          t.parseFontString(r, n) && (n = r), lf(n, function (t, e) {\n            void 0 !== t && (Object.prototype.hasOwnProperty.call(i, e) || (-1 !== Cl(ng).call(ng, e) ? i[e] = {} : i[e] = t));\n          });\n        }\n\n        return i;\n      }\n    }, {\n      key: \"getFontOption\",\n      value: function (e, i, o) {\n        for (var n, r = 0; r < e.length; ++r) {\n          var s = e[r];\n\n          if (Object.prototype.hasOwnProperty.call(s, i)) {\n            if (null == (n = s[i])) continue;\n            var a = {};\n            if (t.parseFontString(a, n) && (n = a), Object.prototype.hasOwnProperty.call(n, o)) return n[o];\n          }\n        }\n\n        if (Object.prototype.hasOwnProperty.call(this.fontOptions, o)) return this.fontOptions[o];\n        throw new Error(\"Did not find value for multi-font for property: '\" + o + \"'\");\n      }\n    }, {\n      key: \"getFontOptions\",\n      value: function (t, e) {\n        for (var i = {}, o = [\"color\", \"size\", \"face\", \"mod\", \"vadjust\"], n = 0; n < o.length; ++n) {\n          var r = o[n];\n          i[r] = this.getFontOption(t, e, r);\n        }\n\n        return i;\n      }\n    }, {\n      key: \"propagateFonts\",\n      value: function (t) {\n        var e = this,\n            i = [];\n        this.addFontOptionsToPile(i, t), this.fontOptions = this.getBasicOptions(i);\n\n        for (var o = function (t) {\n          var o = ng[t],\n              n = e.fontOptions[o];\n          lf(e.getFontOptions(i, o), function (t, e) {\n            n[e] = t;\n          }), n.size = Number(n.size), n.vadjust = Number(n.vadjust);\n        }, n = 0; n < ng.length; ++n) o(n);\n      }\n    }, {\n      key: \"draw\",\n      value: function (t, e, i, o, n) {\n        var r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : \"middle\";\n\n        if (void 0 !== this.elementOptions.label) {\n          var s = this.fontOptions.size * this.body.view.scale;\n          this.elementOptions.label && s < this.elementOptions.scaling.label.drawThreshold - 1 || (s >= this.elementOptions.scaling.label.maxVisible && (s = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale), this.calculateLabelSize(t, o, n, e, i, r), this._drawBackground(t), this._drawText(t, e, this.size.yLine, r, s));\n        }\n      }\n    }, {\n      key: \"_drawBackground\",\n      value: function (t) {\n        if (void 0 !== this.fontOptions.background && \"none\" !== this.fontOptions.background) {\n          t.fillStyle = this.fontOptions.background;\n          var e = this.getSize();\n          t.fillRect(e.left, e.top, e.width, e.height);\n        }\n      }\n    }, {\n      key: \"_drawText\",\n      value: function (t, e, i) {\n        var o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : \"middle\",\n            n = arguments.length > 4 ? arguments[4] : void 0,\n            r = this._setAlignment(t, e, i, o),\n            s = Bh(r, 2);\n\n        e = s[0], i = s[1], t.textAlign = \"left\", e -= this.size.width / 2, this.fontOptions.valign && this.size.height > this.size.labelHeight && (\"top\" === this.fontOptions.valign && (i -= (this.size.height - this.size.labelHeight) / 2), \"bottom\" === this.fontOptions.valign && (i += (this.size.height - this.size.labelHeight) / 2));\n\n        for (var a = 0; a < this.lineCount; a++) {\n          var h = this.lines[a];\n\n          if (h && h.blocks) {\n            var d = 0;\n            this.isEdgeLabel || \"center\" === this.fontOptions.align ? d += (this.size.width - h.width) / 2 : \"right\" === this.fontOptions.align && (d += this.size.width - h.width);\n\n            for (var l = 0; l < h.blocks.length; l++) {\n              var c = h.blocks[l];\n              t.font = c.font;\n\n              var u = this._getColor(c.color, n, c.strokeColor),\n                  f = Bh(u, 2),\n                  p = f[0],\n                  v = f[1];\n\n              c.strokeWidth > 0 && (t.lineWidth = c.strokeWidth, t.strokeStyle = v, t.lineJoin = \"round\"), t.fillStyle = p, c.strokeWidth > 0 && t.strokeText(c.text, e + d, i + c.vadjust), t.fillText(c.text, e + d, i + c.vadjust), d += c.width;\n            }\n\n            i += h.height;\n          }\n        }\n      }\n    }, {\n      key: \"_setAlignment\",\n      value: function (t, e, i, o) {\n        if (this.isEdgeLabel && \"horizontal\" !== this.fontOptions.align && !1 === this.pointToSelf) {\n          e = 0, i = 0;\n          \"top\" === this.fontOptions.align ? (t.textBaseline = \"alphabetic\", i -= 4) : \"bottom\" === this.fontOptions.align ? (t.textBaseline = \"hanging\", i += 4) : t.textBaseline = \"middle\";\n        } else t.textBaseline = o;\n\n        return [e, i];\n      }\n    }, {\n      key: \"_getColor\",\n      value: function (t, e, i) {\n        var o = t || \"#000000\",\n            n = i || \"#ffffff\";\n\n        if (e <= this.elementOptions.scaling.label.drawThreshold) {\n          var r = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - e)));\n          o = uf(o, r), n = uf(n, r);\n        }\n\n        return [o, n];\n      }\n    }, {\n      key: \"getTextSize\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n            i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n        return this._processLabel(t, e, i), {\n          width: this.size.width,\n          height: this.size.height,\n          lineCount: this.lineCount\n        };\n      }\n    }, {\n      key: \"getSize\",\n      value: function () {\n        var t = this.size.left,\n            e = this.size.top - 1;\n\n        if (this.isEdgeLabel) {\n          var i = .5 * -this.size.width;\n\n          switch (this.fontOptions.align) {\n            case \"middle\":\n              t = i, e = .5 * -this.size.height;\n              break;\n\n            case \"top\":\n              t = i, e = -(this.size.height + 2);\n              break;\n\n            case \"bottom\":\n              t = i, e = 2;\n          }\n        }\n\n        return {\n          left: t,\n          top: e,\n          width: this.size.width,\n          height: this.size.height\n        };\n      }\n    }, {\n      key: \"calculateLabelSize\",\n      value: function (t, e, i) {\n        var o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,\n            n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,\n            r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : \"middle\";\n        this._processLabel(t, e, i), this.size.left = o - .5 * this.size.width, this.size.top = n - .5 * this.size.height, this.size.yLine = n + .5 * (1 - this.lineCount) * this.fontOptions.size, \"hanging\" === r && (this.size.top += .5 * this.fontOptions.size, this.size.top += 4, this.size.yLine += 4);\n      }\n    }, {\n      key: \"getFormattingValues\",\n      value: function (t, e, i, o) {\n        var n = function (t, e, i) {\n          return \"normal\" === e ? \"mod\" === i ? \"\" : t[i] : void 0 !== t[e][i] ? t[e][i] : t[i];\n        },\n            r = {\n          color: n(this.fontOptions, o, \"color\"),\n          size: n(this.fontOptions, o, \"size\"),\n          face: n(this.fontOptions, o, \"face\"),\n          mod: n(this.fontOptions, o, \"mod\"),\n          vadjust: n(this.fontOptions, o, \"vadjust\"),\n          strokeWidth: this.fontOptions.strokeWidth,\n          strokeColor: this.fontOptions.strokeColor\n        };\n\n        (e || i) && (\"normal\" === o && !0 === this.fontOptions.chooser && this.elementOptions.labelHighlightBold ? r.mod = \"bold\" : \"function\" == typeof this.fontOptions.chooser && this.fontOptions.chooser(r, this.elementOptions.id, e, i));\n        var s = \"\";\n        return void 0 !== r.mod && \"\" !== r.mod && (s += r.mod + \" \"), s += r.size + \"px \" + r.face, t.font = s.replace(/\"/g, \"\"), r.font = t.font, r.height = r.size, r;\n      }\n    }, {\n      key: \"differentState\",\n      value: function (t, e) {\n        return t !== this.selectedState || e !== this.hoverState;\n      }\n    }, {\n      key: \"_processLabelText\",\n      value: function (t, e, i, o) {\n        return new og(t, this, e, i).process(o);\n      }\n    }, {\n      key: \"_processLabel\",\n      value: function (t, e, i) {\n        if (!1 !== this.labelDirty || this.differentState(e, i)) {\n          var o = this._processLabelText(t, e, i, this.elementOptions.label);\n\n          this.fontOptions.minWdt > 0 && o.width < this.fontOptions.minWdt && (o.width = this.fontOptions.minWdt), this.size.labelHeight = o.height, this.fontOptions.minHgt > 0 && o.height < this.fontOptions.minHgt && (o.height = this.fontOptions.minHgt), this.lines = o.lines, this.lineCount = o.lines.length, this.size.width = o.width, this.size.height = o.height, this.selectedState = e, this.hoverState = i, this.labelDirty = !1;\n        }\n      }\n    }, {\n      key: \"visible\",\n      value: function () {\n        return 0 !== this.size.width && 0 !== this.size.height && void 0 !== this.elementOptions.label && !(this.fontOptions.size * this.body.view.scale < this.elementOptions.scaling.label.drawThreshold - 1);\n      }\n    }], [{\n      key: \"parseFontString\",\n      value: function (t, e) {\n        if (!e || \"string\" != typeof e) return !1;\n        var i = e.split(\" \");\n        return t.size = +i[0].replace(\"px\", \"\"), t.face = i[1], t.color = i[2], !0;\n      }\n    }]), t;\n  }(),\n      sg = ue,\n      ag = qt,\n      hg = Kt,\n      dg = E,\n      lg = Do,\n      cg = ei,\n      ug = s,\n      fg = M(\"Reflect\", \"construct\"),\n      pg = ug(function () {\n    function t() {}\n\n    return !(fg(function () {}, [], t) instanceof t);\n  }),\n      vg = !ug(function () {\n    fg(function () {});\n  }),\n      gg = pg || vg;\n\n  sg({\n    target: \"Reflect\",\n    stat: !0,\n    forced: gg,\n    sham: gg\n  }, {\n    construct: function (t, e) {\n      ag(t), hg(e);\n      var i = arguments.length < 3 ? t : ag(arguments[2]);\n      if (vg && !pg) return fg(t, e, i);\n\n      if (t == i) {\n        switch (e.length) {\n          case 0:\n            return new t();\n\n          case 1:\n            return new t(e[0]);\n\n          case 2:\n            return new t(e[0], e[1]);\n\n          case 3:\n            return new t(e[0], e[1], e[2]);\n\n          case 4:\n            return new t(e[0], e[1], e[2], e[3]);\n        }\n\n        var o = [null];\n        return o.push.apply(o, e), new (cg.apply(t, o))();\n      }\n\n      var n = i.prototype,\n          r = lg(dg(n) ? n : Object.prototype),\n          s = Function.apply.call(t, r, e);\n      return dg(s) ? s : r;\n    }\n  });\n  var yg = O.Reflect.construct,\n      mg = Dl;\n  ue({\n    target: \"Object\",\n    stat: !0\n  }, {\n    setPrototypeOf: rn\n  });\n  var bg = O.Object.setPrototypeOf;\n\n  function wg(t, e) {\n    return (wg = bg || function (t, e) {\n      return t.__proto__ = e, t;\n    })(t, e);\n  }\n\n  function kg(t, e) {\n    if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n    t.prototype = mg(e && e.prototype, {\n      constructor: {\n        value: t,\n        writable: !0,\n        configurable: !0\n      }\n    }), e && wg(t, e);\n  }\n\n  function _g(t, e) {\n    if (e && (\"object\" === zh(e) || \"function\" == typeof e)) return e;\n    if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n    return function (t) {\n      if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return t;\n    }(t);\n  }\n\n  var xg = Ud;\n\n  function Eg(t) {\n    return (Eg = bg ? xg : function (t) {\n      return t.__proto__ || xg(t);\n    })(t);\n  }\n\n  var Og = function () {\n    function t(e, i, o) {\n      Ra(this, t), this.body = i, this.labelModule = o, this.setOptions(e), this.top = void 0, this.left = void 0, this.height = void 0, this.width = void 0, this.radius = void 0, this.margin = void 0, this.refreshNeeded = !0, this.boundingBox = {\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      };\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function (t) {\n        this.options = t;\n      }\n    }, {\n      key: \"_setMargins\",\n      value: function (t) {\n        this.margin = {}, this.options.margin && (\"object\" == zh(this.options.margin) ? (this.margin.top = this.options.margin.top, this.margin.right = this.options.margin.right, this.margin.bottom = this.options.margin.bottom, this.margin.left = this.options.margin.left) : (this.margin.top = this.options.margin, this.margin.right = this.options.margin, this.margin.bottom = this.options.margin, this.margin.left = this.options.margin)), t.adjustSizes(this.margin);\n      }\n    }, {\n      key: \"_distanceToBorder\",\n      value: function (t, e) {\n        var i = this.options.borderWidth;\n        return t && this.resize(t), Math.min(Math.abs(this.width / 2 / Math.cos(e)), Math.abs(this.height / 2 / Math.sin(e))) + i;\n      }\n    }, {\n      key: \"enableShadow\",\n      value: function (t, e) {\n        e.shadow && (t.shadowColor = e.shadowColor, t.shadowBlur = e.shadowSize, t.shadowOffsetX = e.shadowX, t.shadowOffsetY = e.shadowY);\n      }\n    }, {\n      key: \"disableShadow\",\n      value: function (t, e) {\n        e.shadow && (t.shadowColor = \"rgba(0,0,0,0)\", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0);\n      }\n    }, {\n      key: \"enableBorderDashes\",\n      value: function (t, e) {\n        if (!1 !== e.borderDashes) if (void 0 !== t.setLineDash) {\n          var i = e.borderDashes;\n          !0 === i && (i = [5, 15]), t.setLineDash(i);\n        } else console.warn(\"setLineDash is not supported in this browser. The dashed borders cannot be used.\"), this.options.shapeProperties.borderDashes = !1, e.borderDashes = !1;\n      }\n    }, {\n      key: \"disableBorderDashes\",\n      value: function (t, e) {\n        !1 !== e.borderDashes && (void 0 !== t.setLineDash ? t.setLineDash([0]) : (console.warn(\"setLineDash is not supported in this browser. The dashed borders cannot be used.\"), this.options.shapeProperties.borderDashes = !1, e.borderDashes = !1));\n      }\n    }, {\n      key: \"needsRefresh\",\n      value: function (t, e) {\n        return !0 === this.refreshNeeded ? (this.refreshNeeded = !1, !0) : void 0 === this.width || this.labelModule.differentState(t, e);\n      }\n    }, {\n      key: \"initContextForDraw\",\n      value: function (t, e) {\n        var i = e.borderWidth / this.body.view.scale;\n        t.lineWidth = Math.min(this.width, i), t.strokeStyle = e.borderColor, t.fillStyle = e.color;\n      }\n    }, {\n      key: \"performStroke\",\n      value: function (t, e) {\n        var i = e.borderWidth / this.body.view.scale;\n        t.save(), i > 0 && (this.enableBorderDashes(t, e), t.stroke(), this.disableBorderDashes(t, e)), t.restore();\n      }\n    }, {\n      key: \"performFill\",\n      value: function (t, e) {\n        t.save(), t.fillStyle = e.color, this.enableShadow(t, e), Ql(t).call(t), this.disableShadow(t, e), t.restore(), this.performStroke(t, e);\n      }\n    }, {\n      key: \"_addBoundingBoxMargin\",\n      value: function (t) {\n        this.boundingBox.left -= t, this.boundingBox.top -= t, this.boundingBox.bottom += t, this.boundingBox.right += t;\n      }\n    }, {\n      key: \"_updateBoundingBox\",\n      value: function (t, e, i, o, n) {\n        void 0 !== i && this.resize(i, o, n), this.left = t - this.width / 2, this.top = e - this.height / 2, this.boundingBox.left = this.left, this.boundingBox.top = this.top, this.boundingBox.bottom = this.top + this.height, this.boundingBox.right = this.left + this.width;\n      }\n    }, {\n      key: \"updateBoundingBox\",\n      value: function (t, e, i, o, n) {\n        this._updateBoundingBox(t, e, i, o, n);\n      }\n    }, {\n      key: \"getDimensionsFromLabel\",\n      value: function (t, e, i) {\n        this.textSize = this.labelModule.getTextSize(t, e, i);\n        var o = this.textSize.width,\n            n = this.textSize.height;\n        return 0 === o && (o = 14, n = 14), {\n          width: o,\n          height: n\n        };\n      }\n    }]), t;\n  }();\n\n  function Cg(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Sg = function (t) {\n    kg(i, t);\n    var e = Cg(i);\n\n    function i(t, o, n) {\n      var r;\n      return Ra(this, i), (r = e.call(this, t, o, n))._setMargins(n), r;\n    }\n\n    return Ha(i, [{\n      key: \"resize\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,\n            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;\n\n        if (this.needsRefresh(e, i)) {\n          var o = this.getDimensionsFromLabel(t, e, i);\n          this.width = o.width + this.margin.right + this.margin.left, this.height = o.height + this.margin.top + this.margin.bottom, this.radius = this.width / 2;\n        }\n      }\n    }, {\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        this.resize(t, o, n), this.left = e - this.width / 2, this.top = i - this.height / 2, this.initContextForDraw(t, r), hi(t, this.left, this.top, this.width, this.height, r.borderRadius), this.performFill(t, r), this.updateBoundingBox(e, i, t, o, n), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, o, n);\n      }\n    }, {\n      key: \"updateBoundingBox\",\n      value: function (t, e, i, o, n) {\n        this._updateBoundingBox(t, e, i, o, n);\n\n        var r = this.options.shapeProperties.borderRadius;\n\n        this._addBoundingBoxMargin(r);\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t, e) {\n        t && this.resize(t);\n        var i = this.options.borderWidth;\n        return Math.min(Math.abs(this.width / 2 / Math.cos(e)), Math.abs(this.height / 2 / Math.sin(e))) + i;\n      }\n    }]), i;\n  }(Og);\n\n  function Tg(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Mg = function (t) {\n    kg(i, t);\n    var e = Tg(i);\n\n    function i(t, o, n) {\n      var r;\n      return Ra(this, i), (r = e.call(this, t, o, n)).labelOffset = 0, r.selected = !1, r;\n    }\n\n    return Ha(i, [{\n      key: \"setOptions\",\n      value: function (t, e, i) {\n        this.options = t, void 0 === e && void 0 === i || this.setImages(e, i);\n      }\n    }, {\n      key: \"setImages\",\n      value: function (t, e) {\n        e && this.selected ? (this.imageObj = e, this.imageObjAlt = t) : (this.imageObj = t, this.imageObjAlt = e);\n      }\n    }, {\n      key: \"switchImages\",\n      value: function (t) {\n        var e = t && !this.selected || !t && this.selected;\n\n        if (this.selected = t, void 0 !== this.imageObjAlt && e) {\n          var i = this.imageObj;\n          this.imageObj = this.imageObjAlt, this.imageObjAlt = i;\n        }\n      }\n    }, {\n      key: \"_getImagePadding\",\n      value: function () {\n        var t = {\n          top: 0,\n          right: 0,\n          bottom: 0,\n          left: 0\n        };\n\n        if (this.options.imagePadding) {\n          var e = this.options.imagePadding;\n          \"object\" == zh(e) ? (t.top = e.top, t.right = e.right, t.bottom = e.bottom, t.left = e.left) : (t.top = e, t.right = e, t.bottom = e, t.left = e);\n        }\n\n        return t;\n      }\n    }, {\n      key: \"_resizeImage\",\n      value: function () {\n        var t, e;\n\n        if (!1 === this.options.shapeProperties.useImageSize) {\n          var i = 1,\n              o = 1;\n          this.imageObj.width && this.imageObj.height && (this.imageObj.width > this.imageObj.height ? i = this.imageObj.width / this.imageObj.height : o = this.imageObj.height / this.imageObj.width), t = 2 * this.options.size * i, e = 2 * this.options.size * o;\n        } else {\n          var n = this._getImagePadding();\n\n          t = this.imageObj.width + n.left + n.right, e = this.imageObj.height + n.top + n.bottom;\n        }\n\n        this.width = t, this.height = e, this.radius = .5 * this.width;\n      }\n    }, {\n      key: \"_drawRawCircle\",\n      value: function (t, e, i, o) {\n        this.initContextForDraw(t, o), ai(t, e, i, o.size), this.performFill(t, o);\n      }\n    }, {\n      key: \"_drawImageAtPosition\",\n      value: function (t, e) {\n        if (0 != this.imageObj.width) {\n          t.globalAlpha = void 0 !== e.opacity ? e.opacity : 1, this.enableShadow(t, e);\n          var i = 1;\n          !0 === this.options.shapeProperties.interpolation && (i = this.imageObj.width / this.width / this.body.view.scale);\n\n          var o = this._getImagePadding(),\n              n = this.left + o.left,\n              r = this.top + o.top,\n              s = this.width - o.left - o.right,\n              a = this.height - o.top - o.bottom;\n\n          this.imageObj.drawImageAtPosition(t, i, n, r, s, a), this.disableShadow(t, e);\n        }\n      }\n    }, {\n      key: \"_drawImageLabel\",\n      value: function (t, e, i, o, n) {\n        var r = 0;\n\n        if (void 0 !== this.height) {\n          r = .5 * this.height;\n          var s = this.labelModule.getTextSize(t, o, n);\n          s.lineCount >= 1 && (r += s.height / 2);\n        }\n\n        var a = i + r;\n        this.options.label && (this.labelOffset = r), this.labelModule.draw(t, e, a, o, n, \"hanging\");\n      }\n    }]), i;\n  }(Og);\n\n  function Pg(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Dg = function (t) {\n    kg(i, t);\n    var e = Pg(i);\n\n    function i(t, o, n) {\n      var r;\n      return Ra(this, i), (r = e.call(this, t, o, n))._setMargins(n), r;\n    }\n\n    return Ha(i, [{\n      key: \"resize\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,\n            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;\n\n        if (this.needsRefresh(e, i)) {\n          var o = this.getDimensionsFromLabel(t, e, i),\n              n = Math.max(o.width + this.margin.right + this.margin.left, o.height + this.margin.top + this.margin.bottom);\n          this.options.size = n / 2, this.width = n, this.height = n, this.radius = this.width / 2;\n        }\n      }\n    }, {\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        this.resize(t, o, n), this.left = e - this.width / 2, this.top = i - this.height / 2, this._drawRawCircle(t, e, i, r), this.updateBoundingBox(e, i), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, i, o, n);\n      }\n    }, {\n      key: \"updateBoundingBox\",\n      value: function (t, e) {\n        this.boundingBox.top = e - this.options.size, this.boundingBox.left = t - this.options.size, this.boundingBox.right = t + this.options.size, this.boundingBox.bottom = e + this.options.size;\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t) {\n        return t && this.resize(t), .5 * this.width;\n      }\n    }]), i;\n  }(Mg);\n\n  function Bg(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Ig = function (t) {\n    kg(i, t);\n    var e = Bg(i);\n\n    function i(t, o, n, r, s) {\n      var a;\n      return Ra(this, i), (a = e.call(this, t, o, n)).setImages(r, s), a;\n    }\n\n    return Ha(i, [{\n      key: \"resize\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,\n            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover,\n            o = void 0 === this.imageObj.src || void 0 === this.imageObj.width || void 0 === this.imageObj.height;\n\n        if (o) {\n          var n = 2 * this.options.size;\n          return this.width = n, this.height = n, void (this.radius = .5 * this.width);\n        }\n\n        this.needsRefresh(e, i) && this._resizeImage();\n      }\n    }, {\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        this.switchImages(o), this.resize();\n        var s = e,\n            a = i;\n        \"top-left\" === this.options.shapeProperties.coordinateOrigin ? (this.left = e, this.top = i, s += this.width / 2, a += this.height / 2) : (this.left = e - this.width / 2, this.top = i - this.height / 2), this._drawRawCircle(t, s, a, r), t.save(), t.clip(), this._drawImageAtPosition(t, r), t.restore(), this._drawImageLabel(t, s, a, o, n), this.updateBoundingBox(e, i);\n      }\n    }, {\n      key: \"updateBoundingBox\",\n      value: function (t, e) {\n        \"top-left\" === this.options.shapeProperties.coordinateOrigin ? (this.boundingBox.top = e, this.boundingBox.left = t, this.boundingBox.right = t + 2 * this.options.size, this.boundingBox.bottom = e + 2 * this.options.size) : (this.boundingBox.top = e - this.options.size, this.boundingBox.left = t - this.options.size, this.boundingBox.right = t + this.options.size, this.boundingBox.bottom = e + this.options.size), this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t) {\n        return t && this.resize(t), .5 * this.width;\n      }\n    }]), i;\n  }(Mg);\n\n  function zg(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Fg = function (t) {\n    kg(i, t);\n    var e = zg(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"resize\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,\n            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover,\n            o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {\n          size: this.options.size\n        };\n\n        if (this.needsRefresh(e, i)) {\n          var n, r;\n          this.labelModule.getTextSize(t, e, i);\n          var s = 2 * o.size;\n          this.width = null !== (n = this.customSizeWidth) && void 0 !== n ? n : s, this.height = null !== (r = this.customSizeHeight) && void 0 !== r ? r : s, this.radius = .5 * this.width;\n        }\n      }\n    }, {\n      key: \"_drawShape\",\n      value: function (t, e, i, o, n, r, s, a) {\n        var h,\n            d = this;\n        return this.resize(t, r, s, a), this.left = o - this.width / 2, this.top = n - this.height / 2, this.initContextForDraw(t, a), (h = e, Object.prototype.hasOwnProperty.call(ui, h) ? ui[h] : function (t) {\n          for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), o = 1; o < e; o++) i[o - 1] = arguments[o];\n\n          CanvasRenderingContext2D.prototype[h].call(t, i);\n        })(t, o, n, a.size), this.performFill(t, a), void 0 !== this.options.icon && void 0 !== this.options.icon.code && (t.font = (r ? \"bold \" : \"\") + this.height / 2 + \"px \" + (this.options.icon.face || \"FontAwesome\"), t.fillStyle = this.options.icon.color || \"black\", t.textAlign = \"center\", t.textBaseline = \"middle\", t.fillText(this.options.icon.code, o, n)), {\n          drawExternalLabel: function () {\n            if (void 0 !== d.options.label) {\n              d.labelModule.calculateLabelSize(t, r, s, o, n, \"hanging\");\n              var e = n + .5 * d.height + .5 * d.labelModule.size.height;\n              d.labelModule.draw(t, o, e, r, s, \"hanging\");\n            }\n\n            d.updateBoundingBox(o, n);\n          }\n        };\n      }\n    }, {\n      key: \"updateBoundingBox\",\n      value: function (t, e) {\n        this.boundingBox.top = e - this.options.size, this.boundingBox.left = t - this.options.size, this.boundingBox.right = t + this.options.size, this.boundingBox.bottom = e + this.options.size, void 0 !== this.options.label && this.labelModule.size.width > 0 && (this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height));\n      }\n    }]), i;\n  }(Og);\n\n  function Ng(t, e) {\n    var i = Gh(t);\n\n    if (ha) {\n      var o = ha(t);\n      e && (o = $d(o).call(o, function (e) {\n        return ba(t, e).enumerable;\n      })), i.push.apply(i, o);\n    }\n\n    return i;\n  }\n\n  function Ag(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i,\n          o = null != arguments[e] ? arguments[e] : {};\n      if (e % 2) nd(i = Ng(Object(o), !0)).call(i, function (e) {\n        Wa(t, e, o[e]);\n      });else if (Ta) Ba(t, Ta(o));else {\n        var n;\n        nd(n = Ng(Object(o))).call(n, function (e) {\n          Aa(t, e, ba(o, e));\n        });\n      }\n    }\n\n    return t;\n  }\n\n  function Rg(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var jg = function (t) {\n    kg(i, t);\n    var e = Rg(i);\n\n    function i(t, o, n, r) {\n      var s;\n      return Ra(this, i), (s = e.call(this, t, o, n, r)).ctxRenderer = r, s;\n    }\n\n    return Ha(i, [{\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        this.resize(t, o, n, r), this.left = e - this.width / 2, this.top = i - this.height / 2, t.save();\n        var s = this.ctxRenderer({\n          ctx: t,\n          id: this.options.id,\n          x: e,\n          y: i,\n          state: {\n            selected: o,\n            hover: n\n          },\n          style: Ag({}, r),\n          label: this.options.label\n        });\n\n        if (null != s.drawNode && s.drawNode(), t.restore(), s.drawExternalLabel) {\n          var a = s.drawExternalLabel;\n\n          s.drawExternalLabel = function () {\n            t.save(), a(), t.restore();\n          };\n        }\n\n        return s.nodeDimensions && (this.customSizeWidth = s.nodeDimensions.width, this.customSizeHeight = s.nodeDimensions.height), s;\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t, e) {\n        return this._distanceToBorder(t, e);\n      }\n    }]), i;\n  }(Fg);\n\n  function Lg(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Hg = function (t) {\n    kg(i, t);\n    var e = Lg(i);\n\n    function i(t, o, n) {\n      var r;\n      return Ra(this, i), (r = e.call(this, t, o, n))._setMargins(n), r;\n    }\n\n    return Ha(i, [{\n      key: \"resize\",\n      value: function (t, e, i) {\n        if (this.needsRefresh(e, i)) {\n          var o = this.getDimensionsFromLabel(t, e, i).width + this.margin.right + this.margin.left;\n          this.width = o, this.height = o, this.radius = this.width / 2;\n        }\n      }\n    }, {\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        this.resize(t, o, n), this.left = e - this.width / 2, this.top = i - this.height / 2, this.initContextForDraw(t, r), li(t, e - this.width / 2, i - this.height / 2, this.width, this.height), this.performFill(t, r), this.updateBoundingBox(e, i, t, o, n), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, o, n);\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t, e) {\n        return this._distanceToBorder(t, e);\n      }\n    }]), i;\n  }(Og);\n\n  function Wg(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Vg = function (t) {\n    kg(i, t);\n    var e = Wg(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        return this._drawShape(t, \"diamond\", 4, e, i, o, n, r);\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t, e) {\n        return this._distanceToBorder(t, e);\n      }\n    }]), i;\n  }(Fg);\n\n  function qg(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Ug = function (t) {\n    kg(i, t);\n    var e = qg(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        return this._drawShape(t, \"circle\", 2, e, i, o, n, r);\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t) {\n        return t && this.resize(t), this.options.size;\n      }\n    }]), i;\n  }(Fg);\n\n  function Yg(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Xg = function (t) {\n    kg(i, t);\n    var e = Yg(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"resize\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,\n            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover;\n\n        if (this.needsRefresh(e, i)) {\n          var o = this.getDimensionsFromLabel(t, e, i);\n          this.height = 2 * o.height, this.width = o.width + o.height, this.radius = .5 * this.width;\n        }\n      }\n    }, {\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        this.resize(t, o, n), this.left = e - .5 * this.width, this.top = i - .5 * this.height, this.initContextForDraw(t, r), di(t, this.left, this.top, this.width, this.height), this.performFill(t, r), this.updateBoundingBox(e, i, t, o, n), this.labelModule.draw(t, e, i, o, n);\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t, e) {\n        t && this.resize(t);\n        var i = .5 * this.width,\n            o = .5 * this.height,\n            n = Math.sin(e) * i,\n            r = Math.cos(e) * o;\n        return i * o / Math.sqrt(n * n + r * r);\n      }\n    }]), i;\n  }(Og);\n\n  function Gg(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Kg = function (t) {\n    kg(i, t);\n    var e = Gg(i);\n\n    function i(t, o, n) {\n      var r;\n      return Ra(this, i), (r = e.call(this, t, o, n))._setMargins(n), r;\n    }\n\n    return Ha(i, [{\n      key: \"resize\",\n      value: function (t, e, i) {\n        this.needsRefresh(e, i) && (this.iconSize = {\n          width: Number(this.options.icon.size),\n          height: Number(this.options.icon.size)\n        }, this.width = this.iconSize.width + this.margin.right + this.margin.left, this.height = this.iconSize.height + this.margin.top + this.margin.bottom, this.radius = .5 * this.width);\n      }\n    }, {\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        var s = this;\n        return this.resize(t, o, n), this.options.icon.size = this.options.icon.size || 50, this.left = e - this.width / 2, this.top = i - this.height / 2, this._icon(t, e, i, o, n, r), {\n          drawExternalLabel: function () {\n            if (void 0 !== s.options.label) {\n              s.labelModule.draw(t, s.left + s.iconSize.width / 2 + s.margin.left, i + s.height / 2 + 5, o);\n            }\n\n            s.updateBoundingBox(e, i);\n          }\n        };\n      }\n    }, {\n      key: \"updateBoundingBox\",\n      value: function (t, e) {\n        if (this.boundingBox.top = e - .5 * this.options.icon.size, this.boundingBox.left = t - .5 * this.options.icon.size, this.boundingBox.right = t + .5 * this.options.icon.size, this.boundingBox.bottom = e + .5 * this.options.icon.size, void 0 !== this.options.label && this.labelModule.size.width > 0) {\n          this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + 5);\n        }\n      }\n    }, {\n      key: \"_icon\",\n      value: function (t, e, i, o, n, r) {\n        var s = Number(this.options.icon.size);\n        void 0 !== this.options.icon.code ? (t.font = [null != this.options.icon.weight ? this.options.icon.weight : o ? \"bold\" : \"\", (null != this.options.icon.weight && o ? 5 : 0) + s + \"px\", this.options.icon.face].join(\" \"), t.fillStyle = this.options.icon.color || \"black\", t.textAlign = \"center\", t.textBaseline = \"middle\", this.enableShadow(t, r), t.fillText(this.options.icon.code, e, i), this.disableShadow(t, r)) : console.error(\"When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.\");\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t, e) {\n        return this._distanceToBorder(t, e);\n      }\n    }]), i;\n  }(Og);\n\n  function $g(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Zg = function (t) {\n    kg(i, t);\n    var e = $g(i);\n\n    function i(t, o, n, r, s) {\n      var a;\n      return Ra(this, i), (a = e.call(this, t, o, n)).setImages(r, s), a;\n    }\n\n    return Ha(i, [{\n      key: \"resize\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.selected,\n            i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.hover,\n            o = void 0 === this.imageObj.src || void 0 === this.imageObj.width || void 0 === this.imageObj.height;\n\n        if (o) {\n          var n = 2 * this.options.size;\n          return this.width = n, void (this.height = n);\n        }\n\n        this.needsRefresh(e, i) && this._resizeImage();\n      }\n    }, {\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        t.save(), this.switchImages(o), this.resize();\n        var s = e,\n            a = i;\n\n        if (\"top-left\" === this.options.shapeProperties.coordinateOrigin ? (this.left = e, this.top = i, s += this.width / 2, a += this.height / 2) : (this.left = e - this.width / 2, this.top = i - this.height / 2), !0 === this.options.shapeProperties.useBorderWithImage) {\n          var h = this.options.borderWidth,\n              d = this.options.borderWidthSelected || 2 * this.options.borderWidth,\n              l = (o ? d : h) / this.body.view.scale;\n          t.lineWidth = Math.min(this.width, l), t.beginPath();\n          var c = o ? this.options.color.highlight.border : n ? this.options.color.hover.border : this.options.color.border,\n              u = o ? this.options.color.highlight.background : n ? this.options.color.hover.background : this.options.color.background;\n          void 0 !== r.opacity && (c = uf(c, r.opacity), u = uf(u, r.opacity)), t.strokeStyle = c, t.fillStyle = u, t.rect(this.left - .5 * t.lineWidth, this.top - .5 * t.lineWidth, this.width + t.lineWidth, this.height + t.lineWidth), Ql(t).call(t), this.performStroke(t, r), t.closePath();\n        }\n\n        this._drawImageAtPosition(t, r), this._drawImageLabel(t, s, a, o, n), this.updateBoundingBox(e, i), t.restore();\n      }\n    }, {\n      key: \"updateBoundingBox\",\n      value: function (t, e) {\n        this.resize(), \"top-left\" === this.options.shapeProperties.coordinateOrigin ? (this.left = t, this.top = e) : (this.left = t - this.width / 2, this.top = e - this.height / 2), this.boundingBox.left = this.left, this.boundingBox.top = this.top, this.boundingBox.bottom = this.top + this.height, this.boundingBox.right = this.left + this.width, void 0 !== this.options.label && this.labelModule.size.width > 0 && (this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left), this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width), this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset));\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t, e) {\n        return this._distanceToBorder(t, e);\n      }\n    }]), i;\n  }(Mg);\n\n  function Qg(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Jg = function (t) {\n    kg(i, t);\n    var e = Qg(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        return this._drawShape(t, \"square\", 2, e, i, o, n, r);\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t, e) {\n        return this._distanceToBorder(t, e);\n      }\n    }]), i;\n  }(Fg);\n\n  function ty(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var ey = function (t) {\n    kg(i, t);\n    var e = ty(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        return this._drawShape(t, \"hexagon\", 4, e, i, o, n, r);\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t, e) {\n        return this._distanceToBorder(t, e);\n      }\n    }]), i;\n  }(Fg);\n\n  function iy(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var oy = function (t) {\n    kg(i, t);\n    var e = iy(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        return this._drawShape(t, \"star\", 4, e, i, o, n, r);\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t, e) {\n        return this._distanceToBorder(t, e);\n      }\n    }]), i;\n  }(Fg);\n\n  function ny(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var ry = function (t) {\n    kg(i, t);\n    var e = ny(i);\n\n    function i(t, o, n) {\n      var r;\n      return Ra(this, i), (r = e.call(this, t, o, n))._setMargins(n), r;\n    }\n\n    return Ha(i, [{\n      key: \"resize\",\n      value: function (t, e, i) {\n        this.needsRefresh(e, i) && (this.textSize = this.labelModule.getTextSize(t, e, i), this.width = this.textSize.width + this.margin.right + this.margin.left, this.height = this.textSize.height + this.margin.top + this.margin.bottom, this.radius = .5 * this.width);\n      }\n    }, {\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        this.resize(t, o, n), this.left = e - this.width / 2, this.top = i - this.height / 2, this.enableShadow(t, r), this.labelModule.draw(t, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, o, n), this.disableShadow(t, r), this.updateBoundingBox(e, i, t, o, n);\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t, e) {\n        return this._distanceToBorder(t, e);\n      }\n    }]), i;\n  }(Og);\n\n  function sy(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var ay = function (t) {\n    kg(i, t);\n    var e = sy(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        return this._drawShape(t, \"triangle\", 3, e, i, o, n, r);\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t, e) {\n        return this._distanceToBorder(t, e);\n      }\n    }]), i;\n  }(Fg);\n\n  function hy(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var dy = function (t) {\n    kg(i, t);\n    var e = hy(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"draw\",\n      value: function (t, e, i, o, n, r) {\n        return this._drawShape(t, \"triangleDown\", 3, e, i, o, n, r);\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t, e) {\n        return this._distanceToBorder(t, e);\n      }\n    }]), i;\n  }(Fg);\n\n  function ly(t, e) {\n    var i = Gh(t);\n\n    if (ha) {\n      var o = ha(t);\n      e && (o = $d(o).call(o, function (e) {\n        return ba(t, e).enumerable;\n      })), i.push.apply(i, o);\n    }\n\n    return i;\n  }\n\n  function cy(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i,\n          o = null != arguments[e] ? arguments[e] : {};\n      if (e % 2) nd(i = ly(Object(o), !0)).call(i, function (e) {\n        Wa(t, e, o[e]);\n      });else if (Ta) Ba(t, Ta(o));else {\n        var n;\n        nd(n = ly(Object(o))).call(n, function (e) {\n          Aa(t, e, ba(o, e));\n        });\n      }\n    }\n\n    return t;\n  }\n\n  var uy = function () {\n    function t(e, i, o, n, r, s) {\n      Ra(this, t), this.options = kf(r), this.globalOptions = r, this.defaultOptions = s, this.body = i, this.edges = [], this.id = void 0, this.imagelist = o, this.grouplist = n, this.x = void 0, this.y = void 0, this.baseSize = this.options.size, this.baseFontSize = this.options.font.size, this.predefinedPosition = !1, this.selected = !1, this.hover = !1, this.labelModule = new rg(this.body, this.options, !1), this.setOptions(e);\n    }\n\n    return Ha(t, [{\n      key: \"attachEdge\",\n      value: function (t) {\n        var e;\n        -1 === Cl(e = this.edges).call(e, t) && this.edges.push(t);\n      }\n    }, {\n      key: \"detachEdge\",\n      value: function (t) {\n        var e,\n            i,\n            o = Cl(e = this.edges).call(e, t);\n        -1 != o && Od(i = this.edges).call(i, o, 1);\n      }\n    }, {\n      key: \"setOptions\",\n      value: function (e) {\n        var i = this.options.shape;\n\n        if (e) {\n          if (void 0 !== e.color && (this._localColor = e.color), void 0 !== e.id && (this.id = e.id), void 0 === this.id) throw new Error(\"Node must have an id\");\n          t.checkMass(e, this.id), void 0 !== e.x && (null === e.x ? (this.x = void 0, this.predefinedPosition = !1) : (this.x = yl(e.x), this.predefinedPosition = !0)), void 0 !== e.y && (null === e.y ? (this.y = void 0, this.predefinedPosition = !1) : (this.y = yl(e.y), this.predefinedPosition = !0)), void 0 !== e.size && (this.baseSize = e.size), void 0 !== e.value && (e.value = jv(e.value)), t.parseOptions(this.options, e, !0, this.globalOptions, this.grouplist);\n          var o = [e, this.options, this.defaultOptions];\n          return this.chooser = Uv(\"node\", o), this._load_images(), this.updateLabelModule(e), void 0 !== e.opacity && t.checkOpacity(e.opacity) && (this.options.opacity = e.opacity), this.updateShape(i), void 0 !== e.hidden || void 0 !== e.physics;\n        }\n      }\n    }, {\n      key: \"_load_images\",\n      value: function () {\n        if ((\"circularImage\" === this.options.shape || \"image\" === this.options.shape) && void 0 === this.options.image) throw new Error(\"Option image must be defined for node type '\" + this.options.shape + \"'\");\n\n        if (void 0 !== this.options.image) {\n          if (void 0 === this.imagelist) throw new Error(\"Internal Error: No images provided\");\n          if (\"string\" == typeof this.options.image) this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);else {\n            if (void 0 === this.options.image.unselected) throw new Error(\"No unselected image provided\");\n            this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id), void 0 !== this.options.image.selected ? this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id) : this.imageObjAlt = void 0;\n          }\n        }\n      }\n    }, {\n      key: \"getFormattingValues\",\n      value: function () {\n        var t = {\n          color: this.options.color.background,\n          opacity: this.options.opacity,\n          borderWidth: this.options.borderWidth,\n          borderColor: this.options.color.border,\n          size: this.options.size,\n          borderDashes: this.options.shapeProperties.borderDashes,\n          borderRadius: this.options.shapeProperties.borderRadius,\n          shadow: this.options.shadow.enabled,\n          shadowColor: this.options.shadow.color,\n          shadowSize: this.options.shadow.size,\n          shadowX: this.options.shadow.x,\n          shadowY: this.options.shadow.y\n        };\n\n        if (this.selected || this.hover ? !0 === this.chooser ? this.selected ? (null != this.options.borderWidthSelected ? t.borderWidth = this.options.borderWidthSelected : t.borderWidth *= 2, t.color = this.options.color.highlight.background, t.borderColor = this.options.color.highlight.border, t.shadow = this.options.shadow.enabled) : this.hover && (t.color = this.options.color.hover.background, t.borderColor = this.options.color.hover.border, t.shadow = this.options.shadow.enabled) : \"function\" == typeof this.chooser && (this.chooser(t, this.options.id, this.selected, this.hover), !1 === t.shadow && (t.shadowColor === this.options.shadow.color && t.shadowSize === this.options.shadow.size && t.shadowX === this.options.shadow.x && t.shadowY === this.options.shadow.y || (t.shadow = !0))) : t.shadow = this.options.shadow.enabled, void 0 !== this.options.opacity) {\n          var e = this.options.opacity;\n          t.borderColor = uf(t.borderColor, e), t.color = uf(t.color, e), t.shadowColor = uf(t.shadowColor, e);\n        }\n\n        return t;\n      }\n    }, {\n      key: \"updateLabelModule\",\n      value: function (e) {\n        void 0 !== this.options.label && null !== this.options.label || (this.options.label = \"\"), t.updateGroupOptions(this.options, cy(cy({}, e), {}, {\n          color: e && e.color || this._localColor || void 0\n        }), this.grouplist);\n        var i = this.grouplist.get(this.options.group, !1),\n            o = [e, this.options, i, this.globalOptions, this.defaultOptions];\n        this.labelModule.update(this.options, o), void 0 !== this.labelModule.baseSize && (this.baseFontSize = this.labelModule.baseSize);\n      }\n    }, {\n      key: \"updateShape\",\n      value: function (t) {\n        if (t === this.options.shape && this.shape) this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);else switch (this.options.shape) {\n          case \"box\":\n            this.shape = new Sg(this.options, this.body, this.labelModule);\n            break;\n\n          case \"circle\":\n            this.shape = new Dg(this.options, this.body, this.labelModule);\n            break;\n\n          case \"circularImage\":\n            this.shape = new Ig(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);\n            break;\n\n          case \"custom\":\n            this.shape = new jg(this.options, this.body, this.labelModule, this.options.ctxRenderer);\n            break;\n\n          case \"database\":\n            this.shape = new Hg(this.options, this.body, this.labelModule);\n            break;\n\n          case \"diamond\":\n            this.shape = new Vg(this.options, this.body, this.labelModule);\n            break;\n\n          case \"dot\":\n            this.shape = new Ug(this.options, this.body, this.labelModule);\n            break;\n\n          case \"ellipse\":\n            this.shape = new Xg(this.options, this.body, this.labelModule);\n            break;\n\n          case \"icon\":\n            this.shape = new Kg(this.options, this.body, this.labelModule);\n            break;\n\n          case \"image\":\n            this.shape = new Zg(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);\n            break;\n\n          case \"square\":\n            this.shape = new Jg(this.options, this.body, this.labelModule);\n            break;\n\n          case \"hexagon\":\n            this.shape = new ey(this.options, this.body, this.labelModule);\n            break;\n\n          case \"star\":\n            this.shape = new oy(this.options, this.body, this.labelModule);\n            break;\n\n          case \"text\":\n            this.shape = new ry(this.options, this.body, this.labelModule);\n            break;\n\n          case \"triangle\":\n            this.shape = new ay(this.options, this.body, this.labelModule);\n            break;\n\n          case \"triangleDown\":\n            this.shape = new dy(this.options, this.body, this.labelModule);\n            break;\n\n          default:\n            this.shape = new Xg(this.options, this.body, this.labelModule);\n        }\n        this.needsRefresh();\n      }\n    }, {\n      key: \"select\",\n      value: function () {\n        this.selected = !0, this.needsRefresh();\n      }\n    }, {\n      key: \"unselect\",\n      value: function () {\n        this.selected = !1, this.needsRefresh();\n      }\n    }, {\n      key: \"needsRefresh\",\n      value: function () {\n        this.shape.refreshNeeded = !0;\n      }\n    }, {\n      key: \"getTitle\",\n      value: function () {\n        return this.options.title;\n      }\n    }, {\n      key: \"distanceToBorder\",\n      value: function (t, e) {\n        return this.shape.distanceToBorder(t, e);\n      }\n    }, {\n      key: \"isFixed\",\n      value: function () {\n        return this.options.fixed.x && this.options.fixed.y;\n      }\n    }, {\n      key: \"isSelected\",\n      value: function () {\n        return this.selected;\n      }\n    }, {\n      key: \"getValue\",\n      value: function () {\n        return this.options.value;\n      }\n    }, {\n      key: \"getLabelSize\",\n      value: function () {\n        return this.labelModule.size();\n      }\n    }, {\n      key: \"setValueRange\",\n      value: function (t, e, i) {\n        if (void 0 !== this.options.value) {\n          var o = this.options.scaling.customScalingFunction(t, e, i, this.options.value),\n              n = this.options.scaling.max - this.options.scaling.min;\n\n          if (!0 === this.options.scaling.label.enabled) {\n            var r = this.options.scaling.label.max - this.options.scaling.label.min;\n            this.options.font.size = this.options.scaling.label.min + o * r;\n          }\n\n          this.options.size = this.options.scaling.min + o * n;\n        } else this.options.size = this.baseSize, this.options.font.size = this.baseFontSize;\n\n        this.updateLabelModule();\n      }\n    }, {\n      key: \"draw\",\n      value: function (t) {\n        var e = this.getFormattingValues();\n        return this.shape.draw(t, this.x, this.y, this.selected, this.hover, e) || {};\n      }\n    }, {\n      key: \"updateBoundingBox\",\n      value: function (t) {\n        this.shape.updateBoundingBox(this.x, this.y, t);\n      }\n    }, {\n      key: \"resize\",\n      value: function (t) {\n        var e = this.getFormattingValues();\n        this.shape.resize(t, this.selected, this.hover, e);\n      }\n    }, {\n      key: \"getItemsOnPoint\",\n      value: function (t) {\n        var e = [];\n        return this.labelModule.visible() && Yv(this.labelModule.getSize(), t) && e.push({\n          nodeId: this.id,\n          labelId: 0\n        }), Yv(this.shape.boundingBox, t) && e.push({\n          nodeId: this.id\n        }), e;\n      }\n    }, {\n      key: \"isOverlappingWith\",\n      value: function (t) {\n        return this.shape.left < t.right && this.shape.left + this.shape.width > t.left && this.shape.top < t.bottom && this.shape.top + this.shape.height > t.top;\n      }\n    }, {\n      key: \"isBoundingBoxOverlappingWith\",\n      value: function (t) {\n        return this.shape.boundingBox.left < t.right && this.shape.boundingBox.right > t.left && this.shape.boundingBox.top < t.bottom && this.shape.boundingBox.bottom > t.top;\n      }\n    }], [{\n      key: \"checkOpacity\",\n      value: function (t) {\n        return 0 <= t && t <= 1;\n      }\n    }, {\n      key: \"checkCoordinateOrigin\",\n      value: function (t) {\n        return void 0 === t || \"center\" === t || \"top-left\" === t;\n      }\n    }, {\n      key: \"updateGroupOptions\",\n      value: function (e, i, o) {\n        var n;\n\n        if (void 0 !== o) {\n          var r = e.group;\n          if (void 0 !== i && void 0 !== i.group && r !== i.group) throw new Error(\"updateGroupOptions: group values in options don't match.\");\n\n          if (\"number\" == typeof r || \"string\" == typeof r && \"\" != r) {\n            var s = o.get(r);\n            void 0 !== s.opacity && void 0 === i.opacity && (t.checkOpacity(s.opacity) || (console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + s.opacity), s.opacity = void 0));\n            var a = $d(n = qv(i)).call(n, function (t) {\n              return null != i[t];\n            });\n            a.push(\"font\"), rf(a, e, s), e.color = pf(e.color);\n          }\n        }\n      }\n    }, {\n      key: \"parseOptions\",\n      value: function (e, i) {\n        var o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n            n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},\n            r = arguments.length > 4 ? arguments[4] : void 0,\n            s = [\"color\", \"fixed\", \"shadow\"];\n\n        if (rf(s, e, i, o), t.checkMass(i), void 0 !== e.opacity && (t.checkOpacity(e.opacity) || (console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + e.opacity), e.opacity = void 0)), void 0 !== i.opacity && (t.checkOpacity(i.opacity) || (console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + i.opacity), i.opacity = void 0)), i.shapeProperties && !t.checkCoordinateOrigin(i.shapeProperties.coordinateOrigin) && console.error(\"Invalid option for node coordinateOrigin, found: \" + i.shapeProperties.coordinateOrigin), _f(e, i, \"shadow\", n), void 0 !== i.color && null !== i.color) {\n          var a = pf(i.color);\n          of(e.color, a);\n        } else !0 === o && null === i.color && (e.color = kf(n.color));\n\n        void 0 !== i.fixed && null !== i.fixed && (\"boolean\" == typeof i.fixed ? (e.fixed.x = i.fixed, e.fixed.y = i.fixed) : (void 0 !== i.fixed.x && \"boolean\" == typeof i.fixed.x && (e.fixed.x = i.fixed.x), void 0 !== i.fixed.y && \"boolean\" == typeof i.fixed.y && (e.fixed.y = i.fixed.y))), !0 === o && null === i.font && (e.font = kf(n.font)), t.updateGroupOptions(e, i, r), void 0 !== i.scaling && _f(e.scaling, i.scaling, \"label\", n.scaling);\n      }\n    }, {\n      key: \"checkMass\",\n      value: function (t, e) {\n        if (void 0 !== t.mass && t.mass <= 0) {\n          var i = \"\";\n          void 0 !== e && (i = \" in node id: \" + e), console.error(\"%cNegative or zero mass disallowed\" + i + \", setting mass to 1.\", Ff), t.mass = 1;\n        }\n      }\n    }]), t;\n  }();\n\n  function fy(t, e) {\n    var i = void 0 !== Nh && xr(t) || t[\"@@iterator\"];\n\n    if (!i) {\n      if (Hh(t) || (i = function (t, e) {\n        var i;\n        if (!t) return;\n        if (\"string\" == typeof t) return py(t, e);\n        var o = Lh(i = Object.prototype.toString.call(t)).call(i, 8, -1);\n        \"Object\" === o && t.constructor && (o = t.constructor.name);\n        if (\"Map\" === o || \"Set\" === o) return rr(t);\n        if (\"Arguments\" === o || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)) return py(t, e);\n      }(t)) || e && t && \"number\" == typeof t.length) {\n        i && (t = i);\n\n        var o = 0,\n            n = function () {};\n\n        return {\n          s: n,\n          n: function () {\n            return o >= t.length ? {\n              done: !0\n            } : {\n              done: !1,\n              value: t[o++]\n            };\n          },\n          e: function (t) {\n            throw t;\n          },\n          f: n\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var r,\n        s = !0,\n        a = !1;\n    return {\n      s: function () {\n        i = i.call(t);\n      },\n      n: function () {\n        var t = i.next();\n        return s = t.done, t;\n      },\n      e: function (t) {\n        a = !0, r = t;\n      },\n      f: function () {\n        try {\n          s || null == i.return || i.return();\n        } finally {\n          if (a) throw r;\n        }\n      }\n    };\n  }\n\n  function py(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var i = 0, o = new Array(e); i < e; i++) o[i] = t[i];\n\n    return o;\n  }\n\n  var vy = function () {\n    function t(e, i, o, n) {\n      var r,\n          s = this;\n      if (Ra(this, t), this.body = e, this.images = i, this.groups = o, this.layoutEngine = n, this.body.functions.createNode = si(r = this.create).call(r, this), this.nodesListeners = {\n        add: function (t, e) {\n          s.add(e.items);\n        },\n        update: function (t, e) {\n          s.update(e.items, e.data, e.oldData);\n        },\n        remove: function (t, e) {\n          s.remove(e.items);\n        }\n      }, this.defaultOptions = {\n        borderWidth: 1,\n        borderWidthSelected: void 0,\n        brokenImage: void 0,\n        color: {\n          border: \"#2B7CE9\",\n          background: \"#97C2FC\",\n          highlight: {\n            border: \"#2B7CE9\",\n            background: \"#D2E5FF\"\n          },\n          hover: {\n            border: \"#2B7CE9\",\n            background: \"#D2E5FF\"\n          }\n        },\n        opacity: void 0,\n        fixed: {\n          x: !1,\n          y: !1\n        },\n        font: {\n          color: \"#343434\",\n          size: 14,\n          face: \"arial\",\n          background: \"none\",\n          strokeWidth: 0,\n          strokeColor: \"#ffffff\",\n          align: \"center\",\n          vadjust: 0,\n          multi: !1,\n          bold: {\n            mod: \"bold\"\n          },\n          boldital: {\n            mod: \"bold italic\"\n          },\n          ital: {\n            mod: \"italic\"\n          },\n          mono: {\n            mod: \"\",\n            size: 15,\n            face: \"monospace\",\n            vadjust: 2\n          }\n        },\n        group: void 0,\n        hidden: !1,\n        icon: {\n          face: \"FontAwesome\",\n          code: void 0,\n          size: 50,\n          color: \"#2B7CE9\"\n        },\n        image: void 0,\n        imagePadding: {\n          top: 0,\n          right: 0,\n          bottom: 0,\n          left: 0\n        },\n        label: void 0,\n        labelHighlightBold: !0,\n        level: void 0,\n        margin: {\n          top: 5,\n          right: 5,\n          bottom: 5,\n          left: 5\n        },\n        mass: 1,\n        physics: !0,\n        scaling: {\n          min: 10,\n          max: 30,\n          label: {\n            enabled: !1,\n            min: 14,\n            max: 30,\n            maxVisible: 30,\n            drawThreshold: 5\n          },\n          customScalingFunction: function (t, e, i, o) {\n            if (e === t) return .5;\n            var n = 1 / (e - t);\n            return Math.max(0, (o - t) * n);\n          }\n        },\n        shadow: {\n          enabled: !1,\n          color: \"rgba(0,0,0,0.5)\",\n          size: 10,\n          x: 5,\n          y: 5\n        },\n        shape: \"ellipse\",\n        shapeProperties: {\n          borderDashes: !1,\n          borderRadius: 6,\n          interpolation: !0,\n          useImageSize: !1,\n          useBorderWithImage: !1,\n          coordinateOrigin: \"center\"\n        },\n        size: 25,\n        title: void 0,\n        value: void 0,\n        x: void 0,\n        y: void 0\n      }, this.defaultOptions.mass <= 0) throw \"Internal error: mass in defaultOptions of NodesHandler may not be zero or negative\";\n      this.options = kf(this.defaultOptions), this.bindEventListeners();\n    }\n\n    return Ha(t, [{\n      key: \"bindEventListeners\",\n      value: function () {\n        var t,\n            e,\n            i = this;\n        this.body.emitter.on(\"refreshNodes\", si(t = this.refresh).call(t, this)), this.body.emitter.on(\"refresh\", si(e = this.refresh).call(e, this)), this.body.emitter.on(\"destroy\", function () {\n          lf(i.nodesListeners, function (t, e) {\n            i.body.data.nodes && i.body.data.nodes.off(e, t);\n          }), delete i.body.functions.createNode, delete i.nodesListeners.add, delete i.nodesListeners.update, delete i.nodesListeners.remove, delete i.nodesListeners;\n        });\n      }\n    }, {\n      key: \"setOptions\",\n      value: function (t) {\n        if (void 0 !== t) {\n          if (uy.parseOptions(this.options, t), void 0 !== t.opacity && (Tv(t.opacity) || !Pv(t.opacity) || t.opacity < 0 || t.opacity > 1 ? console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + t.opacity) : this.options.opacity = t.opacity), void 0 !== t.shape) for (var e in this.body.nodes) Object.prototype.hasOwnProperty.call(this.body.nodes, e) && this.body.nodes[e].updateShape();\n          if (void 0 !== t.font || void 0 !== t.widthConstraint || void 0 !== t.heightConstraint) for (var i = 0, o = Gh(this.body.nodes); i < o.length; i++) {\n            var n = o[i];\n            this.body.nodes[n].updateLabelModule(), this.body.nodes[n].needsRefresh();\n          }\n          if (void 0 !== t.size) for (var r in this.body.nodes) Object.prototype.hasOwnProperty.call(this.body.nodes, r) && this.body.nodes[r].needsRefresh();\n          void 0 === t.hidden && void 0 === t.physics || this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }, {\n      key: \"setData\",\n      value: function (t) {\n        var i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n            o = this.body.data.nodes;\n        if (e.isDataViewLike(\"id\", t)) this.body.data.nodes = t;else if (Hh(t)) this.body.data.nodes = new e.DataSet(), this.body.data.nodes.add(t);else {\n          if (t) throw new TypeError(\"Array or DataSet expected\");\n          this.body.data.nodes = new e.DataSet();\n        }\n\n        if (o && lf(this.nodesListeners, function (t, e) {\n          o.off(e, t);\n        }), this.body.nodes = {}, this.body.data.nodes) {\n          var n = this;\n          lf(this.nodesListeners, function (t, e) {\n            n.body.data.nodes.on(e, t);\n          });\n          var r = this.body.data.nodes.getIds();\n          this.add(r, !0);\n        }\n\n        !1 === i && this.body.emitter.emit(\"_dataChanged\");\n      }\n    }, {\n      key: \"add\",\n      value: function (t) {\n        for (var e, i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], o = [], n = 0; n < t.length; n++) {\n          e = t[n];\n          var r = this.body.data.nodes.get(e),\n              s = this.create(r);\n          o.push(s), this.body.nodes[e] = s;\n        }\n\n        this.layoutEngine.positionInitially(o), !1 === i && this.body.emitter.emit(\"_dataChanged\");\n      }\n    }, {\n      key: \"update\",\n      value: function (t, e, i) {\n        for (var o = this.body.nodes, n = !1, r = 0; r < t.length; r++) {\n          var s = t[r],\n              a = o[s],\n              h = e[r];\n          void 0 !== a ? a.setOptions(h) && (n = !0) : (n = !0, a = this.create(h), o[s] = a);\n        }\n\n        n || void 0 === i || (n = zv(e).call(e, function (t, e) {\n          var o = i[e];\n          return o && o.level !== t.level;\n        })), !0 === n ? this.body.emitter.emit(\"_dataChanged\") : this.body.emitter.emit(\"_dataUpdated\");\n      }\n    }, {\n      key: \"remove\",\n      value: function (t) {\n        for (var e = this.body.nodes, i = 0; i < t.length; i++) {\n          delete e[t[i]];\n        }\n\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }, {\n      key: \"create\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : uy;\n        return new e(t, this.body, this.images, this.groups, this.options, this.defaultOptions);\n      }\n    }, {\n      key: \"refresh\",\n      value: function () {\n        var t = this,\n            e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n        lf(this.body.nodes, function (i, o) {\n          var n = t.body.data.nodes.get(o);\n          void 0 !== n && (!0 === e && i.setOptions({\n            x: null,\n            y: null\n          }), i.setOptions({\n            fixed: !1\n          }), i.setOptions(n));\n        });\n      }\n    }, {\n      key: \"getPositions\",\n      value: function (t) {\n        var e = {};\n\n        if (void 0 !== t) {\n          if (!0 === Hh(t)) {\n            for (var i = 0; i < t.length; i++) if (void 0 !== this.body.nodes[t[i]]) {\n              var o = this.body.nodes[t[i]];\n              e[t[i]] = {\n                x: Math.round(o.x),\n                y: Math.round(o.y)\n              };\n            }\n          } else if (void 0 !== this.body.nodes[t]) {\n            var n = this.body.nodes[t];\n            e[t] = {\n              x: Math.round(n.x),\n              y: Math.round(n.y)\n            };\n          }\n        } else for (var r = 0; r < this.body.nodeIndices.length; r++) {\n          var s = this.body.nodes[this.body.nodeIndices[r]];\n          e[this.body.nodeIndices[r]] = {\n            x: Math.round(s.x),\n            y: Math.round(s.y)\n          };\n        }\n\n        return e;\n      }\n    }, {\n      key: \"getPosition\",\n      value: function (t) {\n        if (null == t) throw new TypeError(\"No id was specified for getPosition method.\");\n        if (null == this.body.nodes[t]) throw new ReferenceError(\"NodeId provided for getPosition does not exist. Provided: \".concat(t));\n        return {\n          x: Math.round(this.body.nodes[t].x),\n          y: Math.round(this.body.nodes[t].y)\n        };\n      }\n    }, {\n      key: \"storePositions\",\n      value: function () {\n        var t,\n            e = [],\n            i = this.body.data.nodes.getDataSet(),\n            o = fy(i.get());\n\n        try {\n          for (o.s(); !(t = o.n()).done;) {\n            var n = t.value,\n                r = n.id,\n                s = this.body.nodes[r],\n                a = Math.round(s.x),\n                h = Math.round(s.y);\n            n.x === a && n.y === h || e.push({\n              id: r,\n              x: a,\n              y: h\n            });\n          }\n        } catch (t) {\n          o.e(t);\n        } finally {\n          o.f();\n        }\n\n        i.update(e);\n      }\n    }, {\n      key: \"getBoundingBox\",\n      value: function (t) {\n        if (void 0 !== this.body.nodes[t]) return this.body.nodes[t].shape.boundingBox;\n      }\n    }, {\n      key: \"getConnectedNodes\",\n      value: function (t, e) {\n        var i = [];\n        if (void 0 !== this.body.nodes[t]) for (var o = this.body.nodes[t], n = {}, r = 0; r < o.edges.length; r++) {\n          var s = o.edges[r];\n          \"to\" !== e && s.toId == o.id ? void 0 === n[s.fromId] && (i.push(s.fromId), n[s.fromId] = !0) : \"from\" !== e && s.fromId == o.id && void 0 === n[s.toId] && (i.push(s.toId), n[s.toId] = !0);\n        }\n        return i;\n      }\n    }, {\n      key: \"getConnectedEdges\",\n      value: function (t) {\n        var e = [];\n        if (void 0 !== this.body.nodes[t]) for (var i = this.body.nodes[t], o = 0; o < i.edges.length; o++) e.push(i.edges[o].id);else console.error(\"NodeId provided for getConnectedEdges does not exist. Provided: \", t);\n        return e;\n      }\n    }, {\n      key: \"moveNode\",\n      value: function (t, e, i) {\n        var o = this;\n        void 0 !== this.body.nodes[t] ? (this.body.nodes[t].x = Number(e), this.body.nodes[t].y = Number(i), Yl(function () {\n          o.body.emitter.emit(\"startSimulation\");\n        }, 0)) : console.error(\"Node id supplied to moveNode does not exist. Provided: \", t);\n      }\n    }]), t;\n  }(),\n      gy = E,\n      yy = Kt,\n      my = et,\n      by = r,\n      wy = no;\n\n  ue({\n    target: \"Reflect\",\n    stat: !0\n  }, {\n    get: function t(e, i) {\n      var o,\n          n,\n          r = arguments.length < 3 ? e : arguments[2];\n      return yy(e) === r ? e[i] : (o = by.f(e, i)) ? my(o, \"value\") ? o.value : void 0 === o.get ? void 0 : o.get.call(r) : gy(n = wy(e)) ? t(n, i, r) : void 0;\n    }\n  });\n  var ky = O.Reflect.get,\n      _y = ma;\n\n  function xy(t, e, i) {\n    return (xy = \"undefined\" != typeof Reflect && ky ? ky : function (t, e, i) {\n      var o = function (t, e) {\n        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Eg(t)););\n\n        return t;\n      }(t, e);\n\n      if (o) {\n        var n = _y(o, e);\n\n        return n.get ? n.get.call(i) : n.value;\n      }\n    })(t, e, i || t);\n  }\n\n  var Ey = ue,\n      Oy = Math.hypot,\n      Cy = Math.abs,\n      Sy = Math.sqrt;\n  Ey({\n    target: \"Math\",\n    stat: !0,\n    forced: !!Oy && Oy(1 / 0, NaN) !== 1 / 0\n  }, {\n    hypot: function (t, e) {\n      for (var i, o, n = 0, r = 0, s = arguments.length, a = 0; r < s;) a < (i = Cy(arguments[r++])) ? (n = n * (o = a / i) * o + 1, a = i) : n += i > 0 ? (o = i / a) * o : i;\n\n      return a === 1 / 0 ? 1 / 0 : a * Sy(n);\n    }\n  });\n  var Ty = O.Math.hypot;\n\n  function My(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Py = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, null, [{\n      key: \"transform\",\n      value: function (t, e) {\n        Hh(t) || (t = [t]);\n\n        for (var i = e.point.x, o = e.point.y, n = e.angle, r = e.length, s = 0; s < t.length; ++s) {\n          var a = t[s],\n              h = a.x * Math.cos(n) - a.y * Math.sin(n),\n              d = a.x * Math.sin(n) + a.y * Math.cos(n);\n          a.x = i + r * h, a.y = o + r * d;\n        }\n      }\n    }, {\n      key: \"drawPath\",\n      value: function (t, e) {\n        t.beginPath(), t.moveTo(e[0].x, e[0].y);\n\n        for (var i = 1; i < e.length; ++i) t.lineTo(e[i].x, e[i].y);\n\n        t.closePath();\n      }\n    }]), t;\n  }(),\n      Dy = function (t) {\n    kg(i, t);\n    var e = My(i);\n\n    function i() {\n      return Ra(this, i), e.apply(this, arguments);\n    }\n\n    return Ha(i, null, [{\n      key: \"draw\",\n      value: function (t, e) {\n        if (e.image) {\n          t.save(), t.translate(e.point.x, e.point.y), t.rotate(Math.PI / 2 + e.angle);\n          var i = null != e.imageWidth ? e.imageWidth : e.image.width,\n              o = null != e.imageHeight ? e.imageHeight : e.image.height;\n          e.image.drawImageAtPosition(t, 1, -i / 2, 0, i, o), t.restore();\n        }\n\n        return !1;\n      }\n    }]), i;\n  }(Py),\n      By = function (t) {\n    kg(i, t);\n    var e = My(i);\n\n    function i() {\n      return Ra(this, i), e.apply(this, arguments);\n    }\n\n    return Ha(i, null, [{\n      key: \"draw\",\n      value: function (t, e) {\n        var i = [{\n          x: 0,\n          y: 0\n        }, {\n          x: -1,\n          y: .3\n        }, {\n          x: -.9,\n          y: 0\n        }, {\n          x: -1,\n          y: -.3\n        }];\n        return Py.transform(i, e), Py.drawPath(t, i), !0;\n      }\n    }]), i;\n  }(Py),\n      Iy = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, null, [{\n      key: \"draw\",\n      value: function (t, e) {\n        var i = [{\n          x: -1,\n          y: 0\n        }, {\n          x: 0,\n          y: .3\n        }, {\n          x: -.4,\n          y: 0\n        }, {\n          x: 0,\n          y: -.3\n        }];\n        return Py.transform(i, e), Py.drawPath(t, i), !0;\n      }\n    }]), t;\n  }(),\n      zy = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, null, [{\n      key: \"draw\",\n      value: function (t, e) {\n        var i = {\n          x: -.4,\n          y: 0\n        };\n        Py.transform(i, e), t.strokeStyle = t.fillStyle, t.fillStyle = \"rgba(0, 0, 0, 0)\";\n        var o = Math.PI,\n            n = e.angle - o / 2,\n            r = e.angle + o / 2;\n        return t.beginPath(), t.arc(i.x, i.y, .4 * e.length, n, r, !1), t.stroke(), !0;\n      }\n    }]), t;\n  }(),\n      Fy = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, null, [{\n      key: \"draw\",\n      value: function (t, e) {\n        var i = {\n          x: -.3,\n          y: 0\n        };\n        Py.transform(i, e), t.strokeStyle = t.fillStyle, t.fillStyle = \"rgba(0, 0, 0, 0)\";\n        var o = Math.PI,\n            n = e.angle + o / 2,\n            r = e.angle + 3 * o / 2;\n        return t.beginPath(), t.arc(i.x, i.y, .4 * e.length, n, r, !1), t.stroke(), !0;\n      }\n    }]), t;\n  }(),\n      Ny = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, null, [{\n      key: \"draw\",\n      value: function (t, e) {\n        var i = [{\n          x: .02,\n          y: 0\n        }, {\n          x: -1,\n          y: .3\n        }, {\n          x: -1,\n          y: -.3\n        }];\n        return Py.transform(i, e), Py.drawPath(t, i), !0;\n      }\n    }]), t;\n  }(),\n      Ay = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, null, [{\n      key: \"draw\",\n      value: function (t, e) {\n        var i = [{\n          x: 0,\n          y: .3\n        }, {\n          x: 0,\n          y: -.3\n        }, {\n          x: -1,\n          y: 0\n        }];\n        return Py.transform(i, e), Py.drawPath(t, i), !0;\n      }\n    }]), t;\n  }(),\n      Ry = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, null, [{\n      key: \"draw\",\n      value: function (t, e) {\n        var i = {\n          x: -.4,\n          y: 0\n        };\n        return Py.transform(i, e), ai(t, i.x, i.y, .4 * e.length), !0;\n      }\n    }]), t;\n  }(),\n      jy = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, null, [{\n      key: \"draw\",\n      value: function (t, e) {\n        var i = [{\n          x: 0,\n          y: .5\n        }, {\n          x: 0,\n          y: -.5\n        }, {\n          x: -.15,\n          y: -.5\n        }, {\n          x: -.15,\n          y: .5\n        }];\n        return Py.transform(i, e), Py.drawPath(t, i), !0;\n      }\n    }]), t;\n  }(),\n      Ly = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, null, [{\n      key: \"draw\",\n      value: function (t, e) {\n        var i = [{\n          x: 0,\n          y: .3\n        }, {\n          x: 0,\n          y: -.3\n        }, {\n          x: -.6,\n          y: -.3\n        }, {\n          x: -.6,\n          y: .3\n        }];\n        return Py.transform(i, e), Py.drawPath(t, i), !0;\n      }\n    }]), t;\n  }(),\n      Hy = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, null, [{\n      key: \"draw\",\n      value: function (t, e) {\n        var i = [{\n          x: 0,\n          y: 0\n        }, {\n          x: -.5,\n          y: -.3\n        }, {\n          x: -1,\n          y: 0\n        }, {\n          x: -.5,\n          y: .3\n        }];\n        return Py.transform(i, e), Py.drawPath(t, i), !0;\n      }\n    }]), t;\n  }(),\n      Wy = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, null, [{\n      key: \"draw\",\n      value: function (t, e) {\n        var i = [{\n          x: -1,\n          y: .3\n        }, {\n          x: -.5,\n          y: 0\n        }, {\n          x: -1,\n          y: -.3\n        }, {\n          x: 0,\n          y: 0\n        }];\n        return Py.transform(i, e), Py.drawPath(t, i), !0;\n      }\n    }]), t;\n  }(),\n      Vy = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, null, [{\n      key: \"draw\",\n      value: function (t, e) {\n        var i;\n\n        switch (e.type && (i = e.type.toLowerCase()), i) {\n          case \"image\":\n            return Dy.draw(t, e);\n\n          case \"circle\":\n            return Ry.draw(t, e);\n\n          case \"box\":\n            return Ly.draw(t, e);\n\n          case \"crow\":\n            return Iy.draw(t, e);\n\n          case \"curve\":\n            return zy.draw(t, e);\n\n          case \"diamond\":\n            return Hy.draw(t, e);\n\n          case \"inv_curve\":\n            return Fy.draw(t, e);\n\n          case \"triangle\":\n            return Ny.draw(t, e);\n\n          case \"inv_triangle\":\n            return Ay.draw(t, e);\n\n          case \"bar\":\n            return jy.draw(t, e);\n\n          case \"vee\":\n            return Wy.draw(t, e);\n\n          case \"arrow\":\n          default:\n            return By.draw(t, e);\n        }\n      }\n    }]), t;\n  }();\n\n  function qy(t, e) {\n    var i = Gh(t);\n\n    if (ha) {\n      var o = ha(t);\n      e && (o = $d(o).call(o, function (e) {\n        return ba(t, e).enumerable;\n      })), i.push.apply(i, o);\n    }\n\n    return i;\n  }\n\n  function Uy(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i,\n          o = null != arguments[e] ? arguments[e] : {};\n      if (e % 2) nd(i = qy(Object(o), !0)).call(i, function (e) {\n        Wa(t, e, o[e]);\n      });else if (Ta) Ba(t, Ta(o));else {\n        var n;\n        nd(n = qy(Object(o))).call(n, function (e) {\n          Aa(t, e, ba(o, e));\n        });\n      }\n    }\n\n    return t;\n  }\n\n  var Yy = function () {\n    function t(e, i, o) {\n      Ra(this, t), this._body = i, this._labelModule = o, this.color = {}, this.colorDirty = !0, this.hoverWidth = 1.5, this.selectionWidth = 2, this.setOptions(e), this.fromPoint = this.from, this.toPoint = this.to;\n    }\n\n    return Ha(t, [{\n      key: \"connect\",\n      value: function () {\n        this.from = this._body.nodes[this.options.from], this.to = this._body.nodes[this.options.to];\n      }\n    }, {\n      key: \"cleanup\",\n      value: function () {\n        return !1;\n      }\n    }, {\n      key: \"setOptions\",\n      value: function (t) {\n        this.options = t, this.from = this._body.nodes[this.options.from], this.to = this._body.nodes[this.options.to], this.id = this.options.id;\n      }\n    }, {\n      key: \"drawLine\",\n      value: function (t, e, i, o) {\n        var n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : this.getViaNode();\n        t.strokeStyle = this.getColor(t, e), t.lineWidth = e.width, !1 !== e.dashes ? this._drawDashedLine(t, e, n) : this._drawLine(t, e, n);\n      }\n    }, {\n      key: \"_drawLine\",\n      value: function (t, e, i, o, n) {\n        if (this.from != this.to) this._line(t, e, i, o, n);else {\n          var r = Bh(this._getCircleData(t), 3),\n              s = r[0],\n              a = r[1],\n              h = r[2];\n\n          this._circle(t, e, s, a, h);\n        }\n      }\n    }, {\n      key: \"_drawDashedLine\",\n      value: function (t, e, i, o, n) {\n        t.lineCap = \"round\";\n        var r = Hh(e.dashes) ? e.dashes : [5, 5];\n\n        if (void 0 !== t.setLineDash) {\n          if (t.save(), t.setLineDash(r), t.lineDashOffset = 0, this.from != this.to) this._line(t, e, i);else {\n            var s = Bh(this._getCircleData(t), 3),\n                a = s[0],\n                h = s[1],\n                d = s[2];\n\n            this._circle(t, e, a, h, d);\n          }\n          t.setLineDash([0]), t.lineDashOffset = 0, t.restore();\n        } else {\n          if (this.from != this.to) ci(t, this.from.x, this.from.y, this.to.x, this.to.y, r);else {\n            var l = Bh(this._getCircleData(t), 3),\n                c = l[0],\n                u = l[1],\n                f = l[2];\n\n            this._circle(t, e, c, u, f);\n          }\n          this.enableShadow(t, e), t.stroke(), this.disableShadow(t, e);\n        }\n      }\n    }, {\n      key: \"findBorderPosition\",\n      value: function (t, e, i) {\n        return this.from != this.to ? this._findBorderPosition(t, e, i) : this._findBorderPositionCircle(t, e, i);\n      }\n    }, {\n      key: \"findBorderPositions\",\n      value: function (t) {\n        if (this.from != this.to) return {\n          from: this._findBorderPosition(this.from, t),\n          to: this._findBorderPosition(this.to, t)\n        };\n        var e,\n            i = Bh(Lh(e = this._getCircleData(t)).call(e, 0, 2), 2),\n            o = i[0],\n            n = i[1];\n        return {\n          from: this._findBorderPositionCircle(this.from, t, {\n            x: o,\n            y: n,\n            low: .25,\n            high: .6,\n            direction: -1\n          }),\n          to: this._findBorderPositionCircle(this.from, t, {\n            x: o,\n            y: n,\n            low: .6,\n            high: .8,\n            direction: 1\n          })\n        };\n      }\n    }, {\n      key: \"_getCircleData\",\n      value: function (t) {\n        var e = this.options.selfReference.size;\n        void 0 !== t && void 0 === this.from.shape.width && this.from.shape.resize(t);\n        var i = Gv(t, this.options.selfReference.angle, e, this.from);\n        return [i.x, i.y, e];\n      }\n    }, {\n      key: \"_pointOnCircle\",\n      value: function (t, e, i, o) {\n        var n = 2 * o * Math.PI;\n        return {\n          x: t + i * Math.cos(n),\n          y: e - i * Math.sin(n)\n        };\n      }\n    }, {\n      key: \"_findBorderPositionCircle\",\n      value: function (t, e, i) {\n        var o,\n            n = i.x,\n            r = i.y,\n            s = i.low,\n            a = i.high,\n            h = i.direction,\n            d = this.options.selfReference.size,\n            l = .5 * (s + a),\n            c = 0;\n        !0 === this.options.arrowStrikethrough && (-1 === h ? c = this.options.endPointOffset.from : 1 === h && (c = this.options.endPointOffset.to));\n        var u = 0;\n\n        do {\n          l = .5 * (s + a), o = this._pointOnCircle(n, r, d, l);\n          var f = Math.atan2(t.y - o.y, t.x - o.x),\n              p = t.distanceToBorder(e, f) + c - Math.sqrt(Math.pow(o.x - t.x, 2) + Math.pow(o.y - t.y, 2));\n          if (Math.abs(p) < .05) break;\n          p > 0 ? h > 0 ? s = l : a = l : h > 0 ? a = l : s = l, ++u;\n        } while (s <= a && u < 10);\n\n        return Uy(Uy({}, o), {}, {\n          t: l\n        });\n      }\n    }, {\n      key: \"getLineWidth\",\n      value: function (t, e) {\n        return !0 === t ? Math.max(this.selectionWidth, .3 / this._body.view.scale) : !0 === e ? Math.max(this.hoverWidth, .3 / this._body.view.scale) : Math.max(this.options.width, .3 / this._body.view.scale);\n      }\n    }, {\n      key: \"getColor\",\n      value: function (t, e) {\n        if (!1 !== e.inheritsColor) {\n          if (\"both\" === e.inheritsColor && this.from.id !== this.to.id) {\n            var i = t.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y),\n                o = this.from.options.color.highlight.border,\n                n = this.to.options.color.highlight.border;\n            return !1 === this.from.selected && !1 === this.to.selected ? (o = uf(this.from.options.color.border, e.opacity), n = uf(this.to.options.color.border, e.opacity)) : !0 === this.from.selected && !1 === this.to.selected ? n = this.to.options.color.border : !1 === this.from.selected && !0 === this.to.selected && (o = this.from.options.color.border), i.addColorStop(0, o), i.addColorStop(1, n), i;\n          }\n\n          return \"to\" === e.inheritsColor ? uf(this.to.options.color.border, e.opacity) : uf(this.from.options.color.border, e.opacity);\n        }\n\n        return uf(e.color, e.opacity);\n      }\n    }, {\n      key: \"_circle\",\n      value: function (t, e, i, o, n) {\n        this.enableShadow(t, e);\n        var r = 0,\n            s = 2 * Math.PI;\n\n        if (!this.options.selfReference.renderBehindTheNode) {\n          var a = this.options.selfReference.angle,\n              h = this.options.selfReference.angle + Math.PI,\n              d = this._findBorderPositionCircle(this.from, t, {\n            x: i,\n            y: o,\n            low: a,\n            high: h,\n            direction: -1\n          }),\n              l = this._findBorderPositionCircle(this.from, t, {\n            x: i,\n            y: o,\n            low: a,\n            high: h,\n            direction: 1\n          });\n\n          r = Math.atan2(d.y - o, d.x - i), s = Math.atan2(l.y - o, l.x - i);\n        }\n\n        t.beginPath(), t.arc(i, o, n, r, s, !1), t.stroke(), this.disableShadow(t, e);\n      }\n    }, {\n      key: \"getDistanceToEdge\",\n      value: function (t, e, i, o, n, r) {\n        if (this.from != this.to) return this._getDistanceToEdge(t, e, i, o, n, r);\n        var s = Bh(this._getCircleData(void 0), 3),\n            a = s[0],\n            h = s[1],\n            d = s[2],\n            l = a - n,\n            c = h - r;\n        return Math.abs(Math.sqrt(l * l + c * c) - d);\n      }\n    }, {\n      key: \"_getDistanceToLine\",\n      value: function (t, e, i, o, n, r) {\n        var s = i - t,\n            a = o - e,\n            h = ((n - t) * s + (r - e) * a) / (s * s + a * a);\n        h > 1 ? h = 1 : h < 0 && (h = 0);\n        var d = t + h * s - n,\n            l = e + h * a - r;\n        return Math.sqrt(d * d + l * l);\n      }\n    }, {\n      key: \"getArrowData\",\n      value: function (t, e, i, o, n, r) {\n        var s,\n            a,\n            h,\n            d,\n            l,\n            c,\n            u,\n            f = r.width;\n        \"from\" === e ? (h = this.from, d = this.to, l = r.fromArrowScale < 0, c = Math.abs(r.fromArrowScale), u = r.fromArrowType) : \"to\" === e ? (h = this.to, d = this.from, l = r.toArrowScale < 0, c = Math.abs(r.toArrowScale), u = r.toArrowType) : (h = this.to, d = this.from, l = r.middleArrowScale < 0, c = Math.abs(r.middleArrowScale), u = r.middleArrowType);\n        var p = 15 * c + 3 * f;\n\n        if (h != d) {\n          var v = p / Ty(h.x - d.x, h.y - d.y);\n          if (\"middle\" !== e) {\n            if (!0 === this.options.smooth.enabled) {\n              var g = this._findBorderPosition(h, t, {\n                via: i\n              }),\n                  y = this.getPoint(g.t + v * (\"from\" === e ? 1 : -1), i);\n\n              s = Math.atan2(g.y - y.y, g.x - y.x), a = g;\n            } else s = Math.atan2(h.y - d.y, h.x - d.x), a = this._findBorderPosition(h, t);\n          } else {\n            var m = (l ? -v : v) / 2,\n                b = this.getPoint(.5 + m, i),\n                w = this.getPoint(.5 - m, i);\n            s = Math.atan2(b.y - w.y, b.x - w.x), a = this.getPoint(.5, i);\n          }\n        } else {\n          var k = Bh(this._getCircleData(t), 3),\n              _ = k[0],\n              x = k[1],\n              E = k[2];\n\n          if (\"from\" === e) {\n            var O = this.options.selfReference.angle,\n                C = this.options.selfReference.angle + Math.PI,\n                S = this._findBorderPositionCircle(this.from, t, {\n              x: _,\n              y: x,\n              low: O,\n              high: C,\n              direction: -1\n            });\n\n            s = -2 * S.t * Math.PI + 1.5 * Math.PI + .1 * Math.PI, a = S;\n          } else if (\"to\" === e) {\n            var T = this.options.selfReference.angle,\n                M = this.options.selfReference.angle + Math.PI,\n                P = this._findBorderPositionCircle(this.from, t, {\n              x: _,\n              y: x,\n              low: T,\n              high: M,\n              direction: 1\n            });\n\n            s = -2 * P.t * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI, a = P;\n          } else {\n            var D = this.options.selfReference.angle / (2 * Math.PI);\n            a = this._pointOnCircle(_, x, E, D), s = -2 * D * Math.PI + 1.5 * Math.PI + .1 * Math.PI;\n          }\n        }\n\n        return {\n          point: a,\n          core: {\n            x: a.x - .9 * p * Math.cos(s),\n            y: a.y - .9 * p * Math.sin(s)\n          },\n          angle: s,\n          length: p,\n          type: u\n        };\n      }\n    }, {\n      key: \"drawArrowHead\",\n      value: function (t, e, i, o, n) {\n        t.strokeStyle = this.getColor(t, e), t.fillStyle = t.strokeStyle, t.lineWidth = e.width, Vy.draw(t, n) && (this.enableShadow(t, e), Ql(t).call(t), this.disableShadow(t, e));\n      }\n    }, {\n      key: \"enableShadow\",\n      value: function (t, e) {\n        !0 === e.shadow && (t.shadowColor = e.shadowColor, t.shadowBlur = e.shadowSize, t.shadowOffsetX = e.shadowX, t.shadowOffsetY = e.shadowY);\n      }\n    }, {\n      key: \"disableShadow\",\n      value: function (t, e) {\n        !0 === e.shadow && (t.shadowColor = \"rgba(0,0,0,0)\", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0);\n      }\n    }, {\n      key: \"drawBackground\",\n      value: function (t, e) {\n        if (!1 !== e.background) {\n          var i = {\n            strokeStyle: t.strokeStyle,\n            lineWidth: t.lineWidth,\n            dashes: t.dashes\n          };\n          t.strokeStyle = e.backgroundColor, t.lineWidth = e.backgroundSize, this.setStrokeDashed(t, e.backgroundDashes), t.stroke(), t.strokeStyle = i.strokeStyle, t.lineWidth = i.lineWidth, t.dashes = i.dashes, this.setStrokeDashed(t, e.dashes);\n        }\n      }\n    }, {\n      key: \"setStrokeDashed\",\n      value: function (t, e) {\n        if (!1 !== e) {\n          if (void 0 !== t.setLineDash) {\n            var i = Hh(e) ? e : [5, 5];\n            t.setLineDash(i);\n          } else console.warn(\"setLineDash is not supported in this browser. The dashed stroke cannot be used.\");\n        } else void 0 !== t.setLineDash ? t.setLineDash([]) : console.warn(\"setLineDash is not supported in this browser. The dashed stroke cannot be used.\");\n      }\n    }]), t;\n  }();\n\n  function Xy(t, e) {\n    var i = Gh(t);\n\n    if (ha) {\n      var o = ha(t);\n      e && (o = $d(o).call(o, function (e) {\n        return ba(t, e).enumerable;\n      })), i.push.apply(i, o);\n    }\n\n    return i;\n  }\n\n  function Gy(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var i,\n          o = null != arguments[e] ? arguments[e] : {};\n      if (e % 2) nd(i = Xy(Object(o), !0)).call(i, function (e) {\n        Wa(t, e, o[e]);\n      });else if (Ta) Ba(t, Ta(o));else {\n        var n;\n        nd(n = Xy(Object(o))).call(n, function (e) {\n          Aa(t, e, ba(o, e));\n        });\n      }\n    }\n\n    return t;\n  }\n\n  function Ky(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var $y = function (t) {\n    kg(i, t);\n    var e = Ky(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"_findBorderPositionBezier\",\n      value: function (t, e) {\n        var i,\n            o,\n            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this._getViaCoordinates(),\n            r = 10,\n            s = .2,\n            a = !1,\n            h = 1,\n            d = 0,\n            l = this.to,\n            c = this.options.endPointOffset ? this.options.endPointOffset.to : 0;\n        t.id === this.from.id && (l = this.from, a = !0, c = this.options.endPointOffset ? this.options.endPointOffset.from : 0), !1 === this.options.arrowStrikethrough && (c = 0);\n        var u = 0;\n\n        do {\n          o = .5 * (d + h), i = this.getPoint(o, n);\n          var f = Math.atan2(l.y - i.y, l.x - i.x),\n              p = l.distanceToBorder(e, f) + c,\n              v = Math.sqrt(Math.pow(i.x - l.x, 2) + Math.pow(i.y - l.y, 2)),\n              g = p - v;\n          if (Math.abs(g) < s) break;\n          g < 0 ? !1 === a ? d = o : h = o : !1 === a ? h = o : d = o, ++u;\n        } while (d <= h && u < r);\n\n        return Gy(Gy({}, i), {}, {\n          t: o\n        });\n      }\n    }, {\n      key: \"_getDistanceToBezierEdge\",\n      value: function (t, e, i, o, n, r, s) {\n        var a,\n            h,\n            d,\n            l,\n            c,\n            u = 1e9,\n            f = t,\n            p = e;\n\n        for (h = 1; h < 10; h++) d = .1 * h, l = Math.pow(1 - d, 2) * t + 2 * d * (1 - d) * s.x + Math.pow(d, 2) * i, c = Math.pow(1 - d, 2) * e + 2 * d * (1 - d) * s.y + Math.pow(d, 2) * o, h > 0 && (u = (a = this._getDistanceToLine(f, p, l, c, n, r)) < u ? a : u), f = l, p = c;\n\n        return u;\n      }\n    }, {\n      key: \"_bezierCurve\",\n      value: function (t, e, i, o) {\n        t.beginPath(), t.moveTo(this.fromPoint.x, this.fromPoint.y), null != i && null != i.x ? null != o && null != o.x ? t.bezierCurveTo(i.x, i.y, o.x, o.y, this.toPoint.x, this.toPoint.y) : t.quadraticCurveTo(i.x, i.y, this.toPoint.x, this.toPoint.y) : t.lineTo(this.toPoint.x, this.toPoint.y), this.drawBackground(t, e), this.enableShadow(t, e), t.stroke(), this.disableShadow(t, e);\n      }\n    }, {\n      key: \"getViaNode\",\n      value: function () {\n        return this._getViaCoordinates();\n      }\n    }]), i;\n  }(Yy);\n\n  function Zy(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Qy = function (t) {\n    kg(i, t);\n    var e = Zy(i);\n\n    function i(t, o, n) {\n      var r;\n      return Ra(this, i), (r = e.call(this, t, o, n)).via = r.via, r._boundFunction = function () {\n        r.positionBezierNode();\n      }, r._body.emitter.on(\"_repositionBezierNodes\", r._boundFunction), r;\n    }\n\n    return Ha(i, [{\n      key: \"setOptions\",\n      value: function (t) {\n        xy(Eg(i.prototype), \"setOptions\", this).call(this, t);\n        var e = !1;\n        this.options.physics !== t.physics && (e = !0), this.options = t, this.id = this.options.id, this.from = this._body.nodes[this.options.from], this.to = this._body.nodes[this.options.to], this.setupSupportNode(), this.connect(), !0 === e && (this.via.setOptions({\n          physics: this.options.physics\n        }), this.positionBezierNode());\n      }\n    }, {\n      key: \"connect\",\n      value: function () {\n        this.from = this._body.nodes[this.options.from], this.to = this._body.nodes[this.options.to], void 0 === this.from || void 0 === this.to || !1 === this.options.physics || this.from.id === this.to.id ? this.via.setOptions({\n          physics: !1\n        }) : this.via.setOptions({\n          physics: !0\n        });\n      }\n    }, {\n      key: \"cleanup\",\n      value: function () {\n        return this._body.emitter.off(\"_repositionBezierNodes\", this._boundFunction), void 0 !== this.via && (delete this._body.nodes[this.via.id], this.via = void 0, !0);\n      }\n    }, {\n      key: \"setupSupportNode\",\n      value: function () {\n        if (void 0 === this.via) {\n          var t = \"edgeId:\" + this.id,\n              e = this._body.functions.createNode({\n            id: t,\n            shape: \"circle\",\n            physics: !0,\n            hidden: !0\n          });\n\n          this._body.nodes[t] = e, this.via = e, this.via.parentEdgeId = this.id, this.positionBezierNode();\n        }\n      }\n    }, {\n      key: \"positionBezierNode\",\n      value: function () {\n        void 0 !== this.via && void 0 !== this.from && void 0 !== this.to ? (this.via.x = .5 * (this.from.x + this.to.x), this.via.y = .5 * (this.from.y + this.to.y)) : void 0 !== this.via && (this.via.x = 0, this.via.y = 0);\n      }\n    }, {\n      key: \"_line\",\n      value: function (t, e, i) {\n        this._bezierCurve(t, e, i);\n      }\n    }, {\n      key: \"_getViaCoordinates\",\n      value: function () {\n        return this.via;\n      }\n    }, {\n      key: \"getViaNode\",\n      value: function () {\n        return this.via;\n      }\n    }, {\n      key: \"getPoint\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.via;\n\n        if (this.from === this.to) {\n          var i = this._getCircleData(),\n              o = Bh(i, 3),\n              n = o[0],\n              r = o[1],\n              s = o[2],\n              a = 2 * Math.PI * (1 - t);\n\n          return {\n            x: n + s * Math.sin(a),\n            y: r + s - s * (1 - Math.cos(a))\n          };\n        }\n\n        return {\n          x: Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * e.x + Math.pow(t, 2) * this.toPoint.x,\n          y: Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * e.y + Math.pow(t, 2) * this.toPoint.y\n        };\n      }\n    }, {\n      key: \"_findBorderPosition\",\n      value: function (t, e) {\n        return this._findBorderPositionBezier(t, e, this.via);\n      }\n    }, {\n      key: \"_getDistanceToEdge\",\n      value: function (t, e, i, o, n, r) {\n        return this._getDistanceToBezierEdge(t, e, i, o, n, r, this.via);\n      }\n    }]), i;\n  }($y);\n\n  function Jy(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var tm = function (t) {\n    kg(i, t);\n    var e = Jy(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"_line\",\n      value: function (t, e, i) {\n        this._bezierCurve(t, e, i);\n      }\n    }, {\n      key: \"getViaNode\",\n      value: function () {\n        return this._getViaCoordinates();\n      }\n    }, {\n      key: \"_getViaCoordinates\",\n      value: function () {\n        var t,\n            e,\n            i = this.options.smooth.roundness,\n            o = this.options.smooth.type,\n            n = Math.abs(this.from.x - this.to.x),\n            r = Math.abs(this.from.y - this.to.y);\n\n        if (\"discrete\" === o || \"diagonalCross\" === o) {\n          var s, a;\n          s = a = n <= r ? i * r : i * n, this.from.x > this.to.x && (s = -s), this.from.y >= this.to.y && (a = -a);\n          var h = this.from.x + s,\n              d = this.from.y + a;\n          return \"discrete\" === o && (n <= r ? h = n < i * r ? this.from.x : h : d = r < i * n ? this.from.y : d), {\n            x: h,\n            y: d\n          };\n        }\n\n        if (\"straightCross\" === o) {\n          var l = (1 - i) * n,\n              c = (1 - i) * r;\n          return n <= r ? (l = 0, this.from.y < this.to.y && (c = -c)) : (this.from.x < this.to.x && (l = -l), c = 0), {\n            x: this.to.x + l,\n            y: this.to.y + c\n          };\n        }\n\n        if (\"horizontal\" === o) {\n          var u = (1 - i) * n;\n          return this.from.x < this.to.x && (u = -u), {\n            x: this.to.x + u,\n            y: this.from.y\n          };\n        }\n\n        if (\"vertical\" === o) {\n          var f = (1 - i) * r;\n          return this.from.y < this.to.y && (f = -f), {\n            x: this.from.x,\n            y: this.to.y + f\n          };\n        }\n\n        if (\"curvedCW\" === o) {\n          n = this.to.x - this.from.x, r = this.from.y - this.to.y;\n          var p = Math.sqrt(n * n + r * r),\n              v = Math.PI,\n              g = (Math.atan2(r, n) + (.5 * i + .5) * v) % (2 * v);\n          return {\n            x: this.from.x + (.5 * i + .5) * p * Math.sin(g),\n            y: this.from.y + (.5 * i + .5) * p * Math.cos(g)\n          };\n        }\n\n        if (\"curvedCCW\" === o) {\n          n = this.to.x - this.from.x, r = this.from.y - this.to.y;\n          var y = Math.sqrt(n * n + r * r),\n              m = Math.PI,\n              b = (Math.atan2(r, n) + (.5 * -i + .5) * m) % (2 * m);\n          return {\n            x: this.from.x + (.5 * i + .5) * y * Math.sin(b),\n            y: this.from.y + (.5 * i + .5) * y * Math.cos(b)\n          };\n        }\n\n        t = e = n <= r ? i * r : i * n, this.from.x > this.to.x && (t = -t), this.from.y >= this.to.y && (e = -e);\n        var w = this.from.x + t,\n            k = this.from.y + e;\n        return n <= r ? w = this.from.x <= this.to.x ? this.to.x < w ? this.to.x : w : this.to.x > w ? this.to.x : w : k = this.from.y >= this.to.y ? this.to.y > k ? this.to.y : k : this.to.y < k ? this.to.y : k, {\n          x: w,\n          y: k\n        };\n      }\n    }, {\n      key: \"_findBorderPosition\",\n      value: function (t, e) {\n        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n        return this._findBorderPositionBezier(t, e, i.via);\n      }\n    }, {\n      key: \"_getDistanceToEdge\",\n      value: function (t, e, i, o, n, r) {\n        var s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : this._getViaCoordinates();\n        return this._getDistanceToBezierEdge(t, e, i, o, n, r, s);\n      }\n    }, {\n      key: \"getPoint\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._getViaCoordinates(),\n            i = t,\n            o = Math.pow(1 - i, 2) * this.fromPoint.x + 2 * i * (1 - i) * e.x + Math.pow(i, 2) * this.toPoint.x,\n            n = Math.pow(1 - i, 2) * this.fromPoint.y + 2 * i * (1 - i) * e.y + Math.pow(i, 2) * this.toPoint.y;\n        return {\n          x: o,\n          y: n\n        };\n      }\n    }]), i;\n  }($y);\n\n  function em(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  function im(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var om = function (t) {\n    kg(i, t);\n    var e = im(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"_line\",\n      value: function (t, e, i) {\n        var o = i[0],\n            n = i[1];\n\n        this._bezierCurve(t, e, o, n);\n      }\n    }, {\n      key: \"_getViaCoordinates\",\n      value: function () {\n        var t,\n            e,\n            i,\n            o,\n            n = this.from.x - this.to.x,\n            r = this.from.y - this.to.y,\n            s = this.options.smooth.roundness;\n        return (Math.abs(n) > Math.abs(r) || !0 === this.options.smooth.forceDirection || \"horizontal\" === this.options.smooth.forceDirection) && \"vertical\" !== this.options.smooth.forceDirection ? (e = this.from.y, o = this.to.y, t = this.from.x - s * n, i = this.to.x + s * n) : (e = this.from.y - s * r, o = this.to.y + s * r, t = this.from.x, i = this.to.x), [{\n          x: t,\n          y: e\n        }, {\n          x: i,\n          y: o\n        }];\n      }\n    }, {\n      key: \"getViaNode\",\n      value: function () {\n        return this._getViaCoordinates();\n      }\n    }, {\n      key: \"_findBorderPosition\",\n      value: function (t, e) {\n        return this._findBorderPositionBezier(t, e);\n      }\n    }, {\n      key: \"_getDistanceToEdge\",\n      value: function (t, e, i, o, n, r) {\n        var s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : this._getViaCoordinates(),\n            a = Bh(s, 2),\n            h = a[0],\n            d = a[1];\n        return this._getDistanceToBezierEdge2(t, e, i, o, n, r, h, d);\n      }\n    }, {\n      key: \"getPoint\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._getViaCoordinates(),\n            i = Bh(e, 2),\n            o = i[0],\n            n = i[1],\n            r = t,\n            s = [Math.pow(1 - r, 3), 3 * r * Math.pow(1 - r, 2), 3 * Math.pow(r, 2) * (1 - r), Math.pow(r, 3)],\n            a = s[0] * this.fromPoint.x + s[1] * o.x + s[2] * n.x + s[3] * this.toPoint.x,\n            h = s[0] * this.fromPoint.y + s[1] * o.y + s[2] * n.y + s[3] * this.toPoint.y;\n        return {\n          x: a,\n          y: h\n        };\n      }\n    }]), i;\n  }(function (t) {\n    kg(i, t);\n    var e = em(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"_getDistanceToBezierEdge2\",\n      value: function (t, e, i, o, n, r, s, a) {\n        for (var h = 1e9, d = t, l = e, c = [0, 0, 0, 0], u = 1; u < 10; u++) {\n          var f = .1 * u;\n          c[0] = Math.pow(1 - f, 3), c[1] = 3 * f * Math.pow(1 - f, 2), c[2] = 3 * Math.pow(f, 2) * (1 - f), c[3] = Math.pow(f, 3);\n          var p = c[0] * t + c[1] * s.x + c[2] * a.x + c[3] * i,\n              v = c[0] * e + c[1] * s.y + c[2] * a.y + c[3] * o;\n\n          if (u > 0) {\n            var g = this._getDistanceToLine(d, l, p, v, n, r);\n\n            h = g < h ? g : h;\n          }\n\n          d = p, l = v;\n        }\n\n        return h;\n      }\n    }]), i;\n  }($y));\n\n  function nm(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var rm = function (t) {\n    kg(i, t);\n    var e = nm(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"_line\",\n      value: function (t, e) {\n        t.beginPath(), t.moveTo(this.fromPoint.x, this.fromPoint.y), t.lineTo(this.toPoint.x, this.toPoint.y), this.enableShadow(t, e), t.stroke(), this.disableShadow(t, e);\n      }\n    }, {\n      key: \"getViaNode\",\n      value: function () {}\n    }, {\n      key: \"getPoint\",\n      value: function (t) {\n        return {\n          x: (1 - t) * this.fromPoint.x + t * this.toPoint.x,\n          y: (1 - t) * this.fromPoint.y + t * this.toPoint.y\n        };\n      }\n    }, {\n      key: \"_findBorderPosition\",\n      value: function (t, e) {\n        var i = this.to,\n            o = this.from;\n        t.id === this.from.id && (i = this.from, o = this.to);\n        var n = Math.atan2(i.y - o.y, i.x - o.x),\n            r = i.x - o.x,\n            s = i.y - o.y,\n            a = Math.sqrt(r * r + s * s),\n            h = (a - t.distanceToBorder(e, n)) / a;\n        return {\n          x: (1 - h) * o.x + h * i.x,\n          y: (1 - h) * o.y + h * i.y,\n          t: 0\n        };\n      }\n    }, {\n      key: \"_getDistanceToEdge\",\n      value: function (t, e, i, o, n, r) {\n        return this._getDistanceToLine(t, e, i, o, n, r);\n      }\n    }]), i;\n  }(Yy),\n      sm = function () {\n    function t(e, i, o, n, r) {\n      if (Ra(this, t), void 0 === i) throw new Error(\"No body provided\");\n      this.options = kf(n), this.globalOptions = n, this.defaultOptions = r, this.body = i, this.imagelist = o, this.id = void 0, this.fromId = void 0, this.toId = void 0, this.selected = !1, this.hover = !1, this.labelDirty = !0, this.baseWidth = this.options.width, this.baseFontSize = this.options.font.size, this.from = void 0, this.to = void 0, this.edgeType = void 0, this.connected = !1, this.labelModule = new rg(this.body, this.options, !0), this.setOptions(e);\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function (e) {\n        if (e) {\n          var i = void 0 !== e.physics && this.options.physics !== e.physics || void 0 !== e.hidden && (this.options.hidden || !1) !== (e.hidden || !1) || void 0 !== e.from && this.options.from !== e.from || void 0 !== e.to && this.options.to !== e.to;\n          t.parseOptions(this.options, e, !0, this.globalOptions), void 0 !== e.id && (this.id = e.id), void 0 !== e.from && (this.fromId = e.from), void 0 !== e.to && (this.toId = e.to), void 0 !== e.title && (this.title = e.title), void 0 !== e.value && (e.value = jv(e.value));\n          var o = [e, this.options, this.defaultOptions];\n          return this.chooser = Uv(\"edge\", o), this.updateLabelModule(e), i = this.updateEdgeType() || i, this._setInteractionWidths(), this.connect(), i;\n        }\n      }\n    }, {\n      key: \"getFormattingValues\",\n      value: function () {\n        var t = !0 === this.options.arrows.to || !0 === this.options.arrows.to.enabled,\n            e = !0 === this.options.arrows.from || !0 === this.options.arrows.from.enabled,\n            i = !0 === this.options.arrows.middle || !0 === this.options.arrows.middle.enabled,\n            o = this.options.color.inherit,\n            n = {\n          toArrow: t,\n          toArrowScale: this.options.arrows.to.scaleFactor,\n          toArrowType: this.options.arrows.to.type,\n          toArrowSrc: this.options.arrows.to.src,\n          toArrowImageWidth: this.options.arrows.to.imageWidth,\n          toArrowImageHeight: this.options.arrows.to.imageHeight,\n          middleArrow: i,\n          middleArrowScale: this.options.arrows.middle.scaleFactor,\n          middleArrowType: this.options.arrows.middle.type,\n          middleArrowSrc: this.options.arrows.middle.src,\n          middleArrowImageWidth: this.options.arrows.middle.imageWidth,\n          middleArrowImageHeight: this.options.arrows.middle.imageHeight,\n          fromArrow: e,\n          fromArrowScale: this.options.arrows.from.scaleFactor,\n          fromArrowType: this.options.arrows.from.type,\n          fromArrowSrc: this.options.arrows.from.src,\n          fromArrowImageWidth: this.options.arrows.from.imageWidth,\n          fromArrowImageHeight: this.options.arrows.from.imageHeight,\n          arrowStrikethrough: this.options.arrowStrikethrough,\n          color: o ? void 0 : this.options.color.color,\n          inheritsColor: o,\n          opacity: this.options.color.opacity,\n          hidden: this.options.hidden,\n          length: this.options.length,\n          shadow: this.options.shadow.enabled,\n          shadowColor: this.options.shadow.color,\n          shadowSize: this.options.shadow.size,\n          shadowX: this.options.shadow.x,\n          shadowY: this.options.shadow.y,\n          dashes: this.options.dashes,\n          width: this.options.width,\n          background: this.options.background.enabled,\n          backgroundColor: this.options.background.color,\n          backgroundSize: this.options.background.size,\n          backgroundDashes: this.options.background.dashes\n        };\n        if (this.selected || this.hover) {\n          if (!0 === this.chooser) {\n            if (this.selected) {\n              var r = this.options.selectionWidth;\n              \"function\" == typeof r ? n.width = r(n.width) : \"number\" == typeof r && (n.width += r), n.width = Math.max(n.width, .3 / this.body.view.scale), n.color = this.options.color.highlight, n.shadow = this.options.shadow.enabled;\n            } else if (this.hover) {\n              var s = this.options.hoverWidth;\n              \"function\" == typeof s ? n.width = s(n.width) : \"number\" == typeof s && (n.width += s), n.width = Math.max(n.width, .3 / this.body.view.scale), n.color = this.options.color.hover, n.shadow = this.options.shadow.enabled;\n            }\n          } else \"function\" == typeof this.chooser && (this.chooser(n, this.options.id, this.selected, this.hover), void 0 !== n.color && (n.inheritsColor = !1), !1 === n.shadow && (n.shadowColor === this.options.shadow.color && n.shadowSize === this.options.shadow.size && n.shadowX === this.options.shadow.x && n.shadowY === this.options.shadow.y || (n.shadow = !0)));\n        } else n.shadow = this.options.shadow.enabled, n.width = Math.max(n.width, .3 / this.body.view.scale);\n        return n;\n      }\n    }, {\n      key: \"updateLabelModule\",\n      value: function (t) {\n        var e = [t, this.options, this.globalOptions, this.defaultOptions];\n        this.labelModule.update(this.options, e), void 0 !== this.labelModule.baseSize && (this.baseFontSize = this.labelModule.baseSize);\n      }\n    }, {\n      key: \"updateEdgeType\",\n      value: function () {\n        var t = this.options.smooth,\n            e = !1,\n            i = !0;\n        return void 0 !== this.edgeType && ((this.edgeType instanceof Qy && !0 === t.enabled && \"dynamic\" === t.type || this.edgeType instanceof om && !0 === t.enabled && \"cubicBezier\" === t.type || this.edgeType instanceof tm && !0 === t.enabled && \"dynamic\" !== t.type && \"cubicBezier\" !== t.type || this.edgeType instanceof rm && !1 === t.type.enabled) && (i = !1), !0 === i && (e = this.cleanup())), !0 === i ? !0 === t.enabled ? \"dynamic\" === t.type ? (e = !0, this.edgeType = new Qy(this.options, this.body, this.labelModule)) : \"cubicBezier\" === t.type ? this.edgeType = new om(this.options, this.body, this.labelModule) : this.edgeType = new tm(this.options, this.body, this.labelModule) : this.edgeType = new rm(this.options, this.body, this.labelModule) : this.edgeType.setOptions(this.options), e;\n      }\n    }, {\n      key: \"connect\",\n      value: function () {\n        this.disconnect(), this.from = this.body.nodes[this.fromId] || void 0, this.to = this.body.nodes[this.toId] || void 0, this.connected = void 0 !== this.from && void 0 !== this.to, !0 === this.connected ? (this.from.attachEdge(this), this.to.attachEdge(this)) : (this.from && this.from.detachEdge(this), this.to && this.to.detachEdge(this)), this.edgeType.connect();\n      }\n    }, {\n      key: \"disconnect\",\n      value: function () {\n        this.from && (this.from.detachEdge(this), this.from = void 0), this.to && (this.to.detachEdge(this), this.to = void 0), this.connected = !1;\n      }\n    }, {\n      key: \"getTitle\",\n      value: function () {\n        return this.title;\n      }\n    }, {\n      key: \"isSelected\",\n      value: function () {\n        return this.selected;\n      }\n    }, {\n      key: \"getValue\",\n      value: function () {\n        return this.options.value;\n      }\n    }, {\n      key: \"setValueRange\",\n      value: function (t, e, i) {\n        if (void 0 !== this.options.value) {\n          var o = this.options.scaling.customScalingFunction(t, e, i, this.options.value),\n              n = this.options.scaling.max - this.options.scaling.min;\n\n          if (!0 === this.options.scaling.label.enabled) {\n            var r = this.options.scaling.label.max - this.options.scaling.label.min;\n            this.options.font.size = this.options.scaling.label.min + o * r;\n          }\n\n          this.options.width = this.options.scaling.min + o * n;\n        } else this.options.width = this.baseWidth, this.options.font.size = this.baseFontSize;\n\n        this._setInteractionWidths(), this.updateLabelModule();\n      }\n    }, {\n      key: \"_setInteractionWidths\",\n      value: function () {\n        \"function\" == typeof this.options.hoverWidth ? this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width) : this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width, \"function\" == typeof this.options.selectionWidth ? this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width) : this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;\n      }\n    }, {\n      key: \"draw\",\n      value: function (t) {\n        var e = this.getFormattingValues();\n\n        if (!e.hidden) {\n          var i = this.edgeType.getViaNode();\n          this.edgeType.drawLine(t, e, this.selected, this.hover, i), this.drawLabel(t, i);\n        }\n      }\n    }, {\n      key: \"drawArrows\",\n      value: function (t) {\n        var e = this.getFormattingValues();\n\n        if (!e.hidden) {\n          var i = this.edgeType.getViaNode(),\n              o = {};\n          this.edgeType.fromPoint = this.edgeType.from, this.edgeType.toPoint = this.edgeType.to, e.fromArrow && (o.from = this.edgeType.getArrowData(t, \"from\", i, this.selected, this.hover, e), !1 === e.arrowStrikethrough && (this.edgeType.fromPoint = o.from.core), e.fromArrowSrc && (o.from.image = this.imagelist.load(e.fromArrowSrc)), e.fromArrowImageWidth && (o.from.imageWidth = e.fromArrowImageWidth), e.fromArrowImageHeight && (o.from.imageHeight = e.fromArrowImageHeight)), e.toArrow && (o.to = this.edgeType.getArrowData(t, \"to\", i, this.selected, this.hover, e), !1 === e.arrowStrikethrough && (this.edgeType.toPoint = o.to.core), e.toArrowSrc && (o.to.image = this.imagelist.load(e.toArrowSrc)), e.toArrowImageWidth && (o.to.imageWidth = e.toArrowImageWidth), e.toArrowImageHeight && (o.to.imageHeight = e.toArrowImageHeight)), e.middleArrow && (o.middle = this.edgeType.getArrowData(t, \"middle\", i, this.selected, this.hover, e), e.middleArrowSrc && (o.middle.image = this.imagelist.load(e.middleArrowSrc)), e.middleArrowImageWidth && (o.middle.imageWidth = e.middleArrowImageWidth), e.middleArrowImageHeight && (o.middle.imageHeight = e.middleArrowImageHeight)), e.fromArrow && this.edgeType.drawArrowHead(t, e, this.selected, this.hover, o.from), e.middleArrow && this.edgeType.drawArrowHead(t, e, this.selected, this.hover, o.middle), e.toArrow && this.edgeType.drawArrowHead(t, e, this.selected, this.hover, o.to);\n        }\n      }\n    }, {\n      key: \"drawLabel\",\n      value: function (t, e) {\n        if (void 0 !== this.options.label) {\n          var i,\n              o = this.from,\n              n = this.to;\n\n          if (this.labelModule.differentState(this.selected, this.hover) && this.labelModule.getTextSize(t, this.selected, this.hover), o.id != n.id) {\n            this.labelModule.pointToSelf = !1, i = this.edgeType.getPoint(.5, e), t.save();\n\n            var r = this._getRotation(t);\n\n            0 != r.angle && (t.translate(r.x, r.y), t.rotate(r.angle)), this.labelModule.draw(t, i.x, i.y, this.selected, this.hover), t.restore();\n          } else {\n            this.labelModule.pointToSelf = !0;\n            var s = Gv(t, this.options.selfReference.angle, this.options.selfReference.size, o);\n            i = this._pointOnCircle(s.x, s.y, this.options.selfReference.size, this.options.selfReference.angle), this.labelModule.draw(t, i.x, i.y, this.selected, this.hover);\n          }\n        }\n      }\n    }, {\n      key: \"getItemsOnPoint\",\n      value: function (t) {\n        var e = [];\n\n        if (this.labelModule.visible()) {\n          var i = this._getRotation();\n\n          Yv(this.labelModule.getSize(), t, i) && e.push({\n            edgeId: this.id,\n            labelId: 0\n          });\n        }\n\n        var o = {\n          left: t.x,\n          top: t.y\n        };\n        return this.isOverlappingWith(o) && e.push({\n          edgeId: this.id\n        }), e;\n      }\n    }, {\n      key: \"isOverlappingWith\",\n      value: function (t) {\n        if (this.connected) {\n          var e = this.from.x,\n              i = this.from.y,\n              o = this.to.x,\n              n = this.to.y,\n              r = t.left,\n              s = t.top;\n          return this.edgeType.getDistanceToEdge(e, i, o, n, r, s) < 10;\n        }\n\n        return !1;\n      }\n    }, {\n      key: \"_getRotation\",\n      value: function (t) {\n        var e = this.edgeType.getViaNode(),\n            i = this.edgeType.getPoint(.5, e);\n        void 0 !== t && this.labelModule.calculateLabelSize(t, this.selected, this.hover, i.x, i.y);\n        var o = {\n          x: i.x,\n          y: this.labelModule.size.yLine,\n          angle: 0\n        };\n        if (!this.labelModule.visible()) return o;\n        if (\"horizontal\" === this.options.font.align) return o;\n        var n = this.from.y - this.to.y,\n            r = this.from.x - this.to.x,\n            s = Math.atan2(n, r);\n        return (s < -1 && r < 0 || s > 0 && r < 0) && (s += Math.PI), o.angle = s, o;\n      }\n    }, {\n      key: \"_pointOnCircle\",\n      value: function (t, e, i, o) {\n        return {\n          x: t + i * Math.cos(o),\n          y: e - i * Math.sin(o)\n        };\n      }\n    }, {\n      key: \"select\",\n      value: function () {\n        this.selected = !0;\n      }\n    }, {\n      key: \"unselect\",\n      value: function () {\n        this.selected = !1;\n      }\n    }, {\n      key: \"cleanup\",\n      value: function () {\n        return this.edgeType.cleanup();\n      }\n    }, {\n      key: \"remove\",\n      value: function () {\n        this.cleanup(), this.disconnect(), delete this.body.edges[this.id];\n      }\n    }, {\n      key: \"endPointsValid\",\n      value: function () {\n        return void 0 !== this.body.nodes[this.fromId] && void 0 !== this.body.nodes[this.toId];\n      }\n    }], [{\n      key: \"parseOptions\",\n      value: function (t, e) {\n        var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n            o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},\n            n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],\n            r = [\"endPointOffset\", \"arrowStrikethrough\", \"id\", \"from\", \"hidden\", \"hoverWidth\", \"labelHighlightBold\", \"length\", \"line\", \"opacity\", \"physics\", \"scaling\", \"selectionWidth\", \"selfReferenceSize\", \"selfReference\", \"to\", \"title\", \"value\", \"width\", \"font\", \"chosen\", \"widthConstraint\"];\n        if (nf(r, t, e, i), void 0 !== e.endPointOffset && void 0 !== e.endPointOffset.from && (Pv(e.endPointOffset.from) ? t.endPointOffset.from = e.endPointOffset.from : (t.endPointOffset.from = void 0 !== o.endPointOffset.from ? o.endPointOffset.from : 0, console.error(\"endPointOffset.from is not a valid number\"))), void 0 !== e.endPointOffset && void 0 !== e.endPointOffset.to && (Pv(e.endPointOffset.to) ? t.endPointOffset.to = e.endPointOffset.to : (t.endPointOffset.to = void 0 !== o.endPointOffset.to ? o.endPointOffset.to : 0, console.error(\"endPointOffset.to is not a valid number\"))), Xv(e.label) ? t.label = e.label : Xv(t.label) || (t.label = void 0), _f(t, e, \"smooth\", o), _f(t, e, \"shadow\", o), _f(t, e, \"background\", o), void 0 !== e.dashes && null !== e.dashes ? t.dashes = e.dashes : !0 === i && null === e.dashes && (t.dashes = Bl(o.dashes)), void 0 !== e.scaling && null !== e.scaling ? (void 0 !== e.scaling.min && (t.scaling.min = e.scaling.min), void 0 !== e.scaling.max && (t.scaling.max = e.scaling.max), _f(t.scaling, e.scaling, \"label\", o.scaling)) : !0 === i && null === e.scaling && (t.scaling = Bl(o.scaling)), void 0 !== e.arrows && null !== e.arrows) {\n          if (\"string\" == typeof e.arrows) {\n            var s = e.arrows.toLowerCase();\n            t.arrows.to.enabled = -1 != Cl(s).call(s, \"to\"), t.arrows.middle.enabled = -1 != Cl(s).call(s, \"middle\"), t.arrows.from.enabled = -1 != Cl(s).call(s, \"from\");\n          } else {\n            if (\"object\" !== zh(e.arrows)) throw new Error(\"The arrow newOptions can only be an object or a string. Refer to the documentation. You used:\" + Wl(e.arrows));\n            _f(t.arrows, e.arrows, \"to\", o.arrows), _f(t.arrows, e.arrows, \"middle\", o.arrows), _f(t.arrows, e.arrows, \"from\", o.arrows);\n          }\n        } else !0 === i && null === e.arrows && (t.arrows = Bl(o.arrows));\n\n        if (void 0 !== e.color && null !== e.color) {\n          var a = Ju(e.color) ? {\n            color: e.color,\n            highlight: e.color,\n            hover: e.color,\n            inherit: !1,\n            opacity: 1\n          } : e.color,\n              h = t.color;\n          if (n) sf(h, o.color, !1, i);else for (var d in h) Object.prototype.hasOwnProperty.call(h, d) && delete h[d];\n          if (Ju(h)) h.color = h, h.highlight = h, h.hover = h, h.inherit = !1, void 0 === a.opacity && (h.opacity = 1);else {\n            var l = !1;\n            void 0 !== a.color && (h.color = a.color, l = !0), void 0 !== a.highlight && (h.highlight = a.highlight, l = !0), void 0 !== a.hover && (h.hover = a.hover, l = !0), void 0 !== a.inherit && (h.inherit = a.inherit), void 0 !== a.opacity && (h.opacity = Math.min(1, Math.max(0, a.opacity))), !0 === l ? h.inherit = !1 : void 0 === h.inherit && (h.inherit = \"from\");\n          }\n        } else !0 === i && null === e.color && (t.color = kf(o.color));\n\n        !0 === i && null === e.font && (t.font = kf(o.font)), Object.prototype.hasOwnProperty.call(e, \"selfReferenceSize\") && (console.warn(\"The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}\"), t.selfReference.size = e.selfReferenceSize);\n      }\n    }]), t;\n  }(),\n      am = function () {\n    function t(e, i, o) {\n      var n,\n          r = this;\n      Ra(this, t), this.body = e, this.images = i, this.groups = o, this.body.functions.createEdge = si(n = this.create).call(n, this), this.edgesListeners = {\n        add: function (t, e) {\n          r.add(e.items);\n        },\n        update: function (t, e) {\n          r.update(e.items);\n        },\n        remove: function (t, e) {\n          r.remove(e.items);\n        }\n      }, this.options = {}, this.defaultOptions = {\n        arrows: {\n          to: {\n            enabled: !1,\n            scaleFactor: 1,\n            type: \"arrow\"\n          },\n          middle: {\n            enabled: !1,\n            scaleFactor: 1,\n            type: \"arrow\"\n          },\n          from: {\n            enabled: !1,\n            scaleFactor: 1,\n            type: \"arrow\"\n          }\n        },\n        endPointOffset: {\n          from: 0,\n          to: 0\n        },\n        arrowStrikethrough: !0,\n        color: {\n          color: \"#848484\",\n          highlight: \"#848484\",\n          hover: \"#848484\",\n          inherit: \"from\",\n          opacity: 1\n        },\n        dashes: !1,\n        font: {\n          color: \"#343434\",\n          size: 14,\n          face: \"arial\",\n          background: \"none\",\n          strokeWidth: 2,\n          strokeColor: \"#ffffff\",\n          align: \"horizontal\",\n          multi: !1,\n          vadjust: 0,\n          bold: {\n            mod: \"bold\"\n          },\n          boldital: {\n            mod: \"bold italic\"\n          },\n          ital: {\n            mod: \"italic\"\n          },\n          mono: {\n            mod: \"\",\n            size: 15,\n            face: \"courier new\",\n            vadjust: 2\n          }\n        },\n        hidden: !1,\n        hoverWidth: 1.5,\n        label: void 0,\n        labelHighlightBold: !0,\n        length: void 0,\n        physics: !0,\n        scaling: {\n          min: 1,\n          max: 15,\n          label: {\n            enabled: !0,\n            min: 14,\n            max: 30,\n            maxVisible: 30,\n            drawThreshold: 5\n          },\n          customScalingFunction: function (t, e, i, o) {\n            if (e === t) return .5;\n            var n = 1 / (e - t);\n            return Math.max(0, (o - t) * n);\n          }\n        },\n        selectionWidth: 1.5,\n        selfReference: {\n          size: 20,\n          angle: Math.PI / 4,\n          renderBehindTheNode: !0\n        },\n        shadow: {\n          enabled: !1,\n          color: \"rgba(0,0,0,0.5)\",\n          size: 10,\n          x: 5,\n          y: 5\n        },\n        background: {\n          enabled: !1,\n          color: \"rgba(111,111,111,1)\",\n          size: 10,\n          dashes: !1\n        },\n        smooth: {\n          enabled: !0,\n          type: \"dynamic\",\n          forceDirection: \"none\",\n          roundness: .5\n        },\n        title: void 0,\n        width: 1,\n        value: void 0\n      }, sf(this.options, this.defaultOptions), this.bindEventListeners();\n    }\n\n    return Ha(t, [{\n      key: \"bindEventListeners\",\n      value: function () {\n        var t,\n            e,\n            i = this;\n        this.body.emitter.on(\"_forceDisableDynamicCurves\", function (t) {\n          var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n          \"dynamic\" === t && (t = \"continuous\");\n          var o = !1;\n\n          for (var n in i.body.edges) if (Object.prototype.hasOwnProperty.call(i.body.edges, n)) {\n            var r = i.body.edges[n],\n                s = i.body.data.edges.get(n);\n\n            if (null != s) {\n              var a = s.smooth;\n              void 0 !== a && !0 === a.enabled && \"dynamic\" === a.type && (void 0 === t ? r.setOptions({\n                smooth: !1\n              }) : r.setOptions({\n                smooth: {\n                  type: t\n                }\n              }), o = !0);\n            }\n          }\n\n          !0 === e && !0 === o && i.body.emitter.emit(\"_dataChanged\");\n        }), this.body.emitter.on(\"_dataUpdated\", function () {\n          i.reconnectEdges();\n        }), this.body.emitter.on(\"refreshEdges\", si(t = this.refresh).call(t, this)), this.body.emitter.on(\"refresh\", si(e = this.refresh).call(e, this)), this.body.emitter.on(\"destroy\", function () {\n          lf(i.edgesListeners, function (t, e) {\n            i.body.data.edges && i.body.data.edges.off(e, t);\n          }), delete i.body.functions.createEdge, delete i.edgesListeners.add, delete i.edgesListeners.update, delete i.edgesListeners.remove, delete i.edgesListeners;\n        });\n      }\n    }, {\n      key: \"setOptions\",\n      value: function (t) {\n        if (void 0 !== t) {\n          sm.parseOptions(this.options, t, !0, this.defaultOptions, !0);\n          var e = !1;\n          if (void 0 !== t.smooth) for (var i in this.body.edges) Object.prototype.hasOwnProperty.call(this.body.edges, i) && (e = this.body.edges[i].updateEdgeType() || e);\n          if (void 0 !== t.font) for (var o in this.body.edges) Object.prototype.hasOwnProperty.call(this.body.edges, o) && this.body.edges[o].updateLabelModule();\n          void 0 === t.hidden && void 0 === t.physics && !0 !== e || this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }, {\n      key: \"setData\",\n      value: function (t) {\n        var i = this,\n            o = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n            n = this.body.data.edges;\n        if (e.isDataViewLike(\"id\", t)) this.body.data.edges = t;else if (Hh(t)) this.body.data.edges = new e.DataSet(), this.body.data.edges.add(t);else {\n          if (t) throw new TypeError(\"Array or DataSet expected\");\n          this.body.data.edges = new e.DataSet();\n        }\n\n        if (n && lf(this.edgesListeners, function (t, e) {\n          n.off(e, t);\n        }), this.body.edges = {}, this.body.data.edges) {\n          lf(this.edgesListeners, function (t, e) {\n            i.body.data.edges.on(e, t);\n          });\n          var r = this.body.data.edges.getIds();\n          this.add(r, !0);\n        }\n\n        this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\"), !1 === o && this.body.emitter.emit(\"_dataChanged\");\n      }\n    }, {\n      key: \"add\",\n      value: function (t) {\n        for (var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i = this.body.edges, o = this.body.data.edges, n = 0; n < t.length; n++) {\n          var r = t[n],\n              s = i[r];\n          s && s.disconnect();\n          var a = o.get(r, {\n            showInternalIds: !0\n          });\n          i[r] = this.create(a);\n        }\n\n        this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\"), !1 === e && this.body.emitter.emit(\"_dataChanged\");\n      }\n    }, {\n      key: \"update\",\n      value: function (t) {\n        for (var e = this.body.edges, i = this.body.data.edges, o = !1, n = 0; n < t.length; n++) {\n          var r = t[n],\n              s = i.get(r),\n              a = e[r];\n          void 0 !== a ? (a.disconnect(), o = a.setOptions(s) || o, a.connect()) : (this.body.edges[r] = this.create(s), o = !0);\n        }\n\n        !0 === o ? (this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\"), this.body.emitter.emit(\"_dataChanged\")) : this.body.emitter.emit(\"_dataUpdated\");\n      }\n    }, {\n      key: \"remove\",\n      value: function (t) {\n        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n\n        if (0 !== t.length) {\n          var i = this.body.edges;\n          lf(t, function (t) {\n            var e = i[t];\n            void 0 !== e && e.remove();\n          }), e && this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }, {\n      key: \"refresh\",\n      value: function () {\n        var t = this;\n        lf(this.body.edges, function (e, i) {\n          var o = t.body.data.edges.get(i);\n          void 0 !== o && e.setOptions(o);\n        });\n      }\n    }, {\n      key: \"create\",\n      value: function (t) {\n        return new sm(t, this.body, this.images, this.options, this.defaultOptions);\n      }\n    }, {\n      key: \"reconnectEdges\",\n      value: function () {\n        var t,\n            e = this.body.nodes,\n            i = this.body.edges;\n\n        for (t in e) Object.prototype.hasOwnProperty.call(e, t) && (e[t].edges = []);\n\n        for (t in i) if (Object.prototype.hasOwnProperty.call(i, t)) {\n          var o = i[t];\n          o.from = null, o.to = null, o.connect();\n        }\n      }\n    }, {\n      key: \"getConnectedNodes\",\n      value: function (t) {\n        var e = [];\n\n        if (void 0 !== this.body.edges[t]) {\n          var i = this.body.edges[t];\n          void 0 !== i.fromId && e.push(i.fromId), void 0 !== i.toId && e.push(i.toId);\n        }\n\n        return e;\n      }\n    }, {\n      key: \"_updateState\",\n      value: function () {\n        this._addMissingEdges(), this._removeInvalidEdges();\n      }\n    }, {\n      key: \"_removeInvalidEdges\",\n      value: function () {\n        var t = this,\n            e = [];\n        lf(this.body.edges, function (i, o) {\n          var n = t.body.nodes[i.toId],\n              r = t.body.nodes[i.fromId];\n          void 0 !== n && !0 === n.isCluster || void 0 !== r && !0 === r.isCluster || void 0 !== n && void 0 !== r || e.push(o);\n        }), this.remove(e, !1);\n      }\n    }, {\n      key: \"_addMissingEdges\",\n      value: function () {\n        var t = this.body.data.edges;\n\n        if (null != t) {\n          var e = this.body.edges,\n              i = [];\n          nd(t).call(t, function (t, o) {\n            void 0 === e[o] && i.push(o);\n          }), this.add(i, !0);\n        }\n      }\n    }]), t;\n  }(),\n      hm = function () {\n    function t(e, i, o) {\n      Ra(this, t), this.body = e, this.physicsBody = i, this.barnesHutTree, this.setOptions(o), this._rng = Vu(\"BARNES HUT SOLVER\");\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function (t) {\n        this.options = t, this.thetaInversed = 1 / this.options.theta, this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));\n      }\n    }, {\n      key: \"solve\",\n      value: function () {\n        if (0 !== this.options.gravitationalConstant && this.physicsBody.physicsNodeIndices.length > 0) {\n          var t,\n              e = this.body.nodes,\n              i = this.physicsBody.physicsNodeIndices,\n              o = i.length,\n              n = this._formBarnesHutTree(e, i);\n\n          this.barnesHutTree = n;\n\n          for (var r = 0; r < o; r++) (t = e[i[r]]).options.mass > 0 && this._getForceContributions(n.root, t);\n        }\n      }\n    }, {\n      key: \"_getForceContributions\",\n      value: function (t, e) {\n        this._getForceContribution(t.children.NW, e), this._getForceContribution(t.children.NE, e), this._getForceContribution(t.children.SW, e), this._getForceContribution(t.children.SE, e);\n      }\n    }, {\n      key: \"_getForceContribution\",\n      value: function (t, e) {\n        if (t.childrenCount > 0) {\n          var i = t.centerOfMass.x - e.x,\n              o = t.centerOfMass.y - e.y,\n              n = Math.sqrt(i * i + o * o);\n          n * t.calcSize > this.thetaInversed ? this._calculateForces(n, i, o, e, t) : 4 === t.childrenCount ? this._getForceContributions(t, e) : t.children.data.id != e.id && this._calculateForces(n, i, o, e, t);\n        }\n      }\n    }, {\n      key: \"_calculateForces\",\n      value: function (t, e, i, o, n) {\n        0 === t && (e = t = .1), this.overlapAvoidanceFactor < 1 && o.shape.radius && (t = Math.max(.1 + this.overlapAvoidanceFactor * o.shape.radius, t - o.shape.radius));\n        var r = this.options.gravitationalConstant * n.mass * o.options.mass / Math.pow(t, 3),\n            s = e * r,\n            a = i * r;\n        this.physicsBody.forces[o.id].x += s, this.physicsBody.forces[o.id].y += a;\n      }\n    }, {\n      key: \"_formBarnesHutTree\",\n      value: function (t, e) {\n        for (var i, o = e.length, n = t[e[0]].x, r = t[e[0]].y, s = t[e[0]].x, a = t[e[0]].y, h = 1; h < o; h++) {\n          var d = t[e[h]],\n              l = d.x,\n              c = d.y;\n          d.options.mass > 0 && (l < n && (n = l), l > s && (s = l), c < r && (r = c), c > a && (a = c));\n        }\n\n        var u = Math.abs(s - n) - Math.abs(a - r);\n        u > 0 ? (r -= .5 * u, a += .5 * u) : (n += .5 * u, s -= .5 * u);\n        var f = Math.max(1e-5, Math.abs(s - n)),\n            p = .5 * f,\n            v = .5 * (n + s),\n            g = .5 * (r + a),\n            y = {\n          root: {\n            centerOfMass: {\n              x: 0,\n              y: 0\n            },\n            mass: 0,\n            range: {\n              minX: v - p,\n              maxX: v + p,\n              minY: g - p,\n              maxY: g + p\n            },\n            size: f,\n            calcSize: 1 / f,\n            children: {\n              data: null\n            },\n            maxWidth: 0,\n            level: 0,\n            childrenCount: 4\n          }\n        };\n\n        this._splitBranch(y.root);\n\n        for (var m = 0; m < o; m++) (i = t[e[m]]).options.mass > 0 && this._placeInTree(y.root, i);\n\n        return y;\n      }\n    }, {\n      key: \"_updateBranchMass\",\n      value: function (t, e) {\n        var i = t.centerOfMass,\n            o = t.mass + e.options.mass,\n            n = 1 / o;\n        i.x = i.x * t.mass + e.x * e.options.mass, i.x *= n, i.y = i.y * t.mass + e.y * e.options.mass, i.y *= n, t.mass = o;\n        var r = Math.max(Math.max(e.height, e.radius), e.width);\n        t.maxWidth = t.maxWidth < r ? r : t.maxWidth;\n      }\n    }, {\n      key: \"_placeInTree\",\n      value: function (t, e, i) {\n        1 == i && void 0 !== i || this._updateBranchMass(t, e);\n        var o,\n            n = t.children.NW.range;\n        o = n.maxX > e.x ? n.maxY > e.y ? \"NW\" : \"SW\" : n.maxY > e.y ? \"NE\" : \"SE\", this._placeInRegion(t, e, o);\n      }\n    }, {\n      key: \"_placeInRegion\",\n      value: function (t, e, i) {\n        var o = t.children[i];\n\n        switch (o.childrenCount) {\n          case 0:\n            o.children.data = e, o.childrenCount = 1, this._updateBranchMass(o, e);\n            break;\n\n          case 1:\n            o.children.data.x === e.x && o.children.data.y === e.y ? (e.x += this._rng(), e.y += this._rng()) : (this._splitBranch(o), this._placeInTree(o, e));\n            break;\n\n          case 4:\n            this._placeInTree(o, e);\n\n        }\n      }\n    }, {\n      key: \"_splitBranch\",\n      value: function (t) {\n        var e = null;\n        1 === t.childrenCount && (e = t.children.data, t.mass = 0, t.centerOfMass.x = 0, t.centerOfMass.y = 0), t.childrenCount = 4, t.children.data = null, this._insertRegion(t, \"NW\"), this._insertRegion(t, \"NE\"), this._insertRegion(t, \"SW\"), this._insertRegion(t, \"SE\"), null != e && this._placeInTree(t, e);\n      }\n    }, {\n      key: \"_insertRegion\",\n      value: function (t, e) {\n        var i,\n            o,\n            n,\n            r,\n            s = .5 * t.size;\n\n        switch (e) {\n          case \"NW\":\n            i = t.range.minX, o = t.range.minX + s, n = t.range.minY, r = t.range.minY + s;\n            break;\n\n          case \"NE\":\n            i = t.range.minX + s, o = t.range.maxX, n = t.range.minY, r = t.range.minY + s;\n            break;\n\n          case \"SW\":\n            i = t.range.minX, o = t.range.minX + s, n = t.range.minY + s, r = t.range.maxY;\n            break;\n\n          case \"SE\":\n            i = t.range.minX + s, o = t.range.maxX, n = t.range.minY + s, r = t.range.maxY;\n        }\n\n        t.children[e] = {\n          centerOfMass: {\n            x: 0,\n            y: 0\n          },\n          mass: 0,\n          range: {\n            minX: i,\n            maxX: o,\n            minY: n,\n            maxY: r\n          },\n          size: .5 * t.size,\n          calcSize: 2 * t.calcSize,\n          children: {\n            data: null\n          },\n          maxWidth: 0,\n          level: t.level + 1,\n          childrenCount: 0\n        };\n      }\n    }, {\n      key: \"_debug\",\n      value: function (t, e) {\n        void 0 !== this.barnesHutTree && (t.lineWidth = 1, this._drawBranch(this.barnesHutTree.root, t, e));\n      }\n    }, {\n      key: \"_drawBranch\",\n      value: function (t, e, i) {\n        void 0 === i && (i = \"#FF0000\"), 4 === t.childrenCount && (this._drawBranch(t.children.NW, e), this._drawBranch(t.children.NE, e), this._drawBranch(t.children.SE, e), this._drawBranch(t.children.SW, e)), e.strokeStyle = i, e.beginPath(), e.moveTo(t.range.minX, t.range.minY), e.lineTo(t.range.maxX, t.range.minY), e.stroke(), e.beginPath(), e.moveTo(t.range.maxX, t.range.minY), e.lineTo(t.range.maxX, t.range.maxY), e.stroke(), e.beginPath(), e.moveTo(t.range.maxX, t.range.maxY), e.lineTo(t.range.minX, t.range.maxY), e.stroke(), e.beginPath(), e.moveTo(t.range.minX, t.range.maxY), e.lineTo(t.range.minX, t.range.minY), e.stroke();\n      }\n    }]), t;\n  }(),\n      dm = function () {\n    function t(e, i, o) {\n      Ra(this, t), this._rng = Vu(\"REPULSION SOLVER\"), this.body = e, this.physicsBody = i, this.setOptions(o);\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function (t) {\n        this.options = t;\n      }\n    }, {\n      key: \"solve\",\n      value: function () {\n        for (var t, e, i, o, n, r, s, a, h = this.body.nodes, d = this.physicsBody.physicsNodeIndices, l = this.physicsBody.forces, c = this.options.nodeDistance, u = -2 / 3 / c, f = 0; f < d.length - 1; f++) {\n          s = h[d[f]];\n\n          for (var p = f + 1; p < d.length; p++) t = (a = h[d[p]]).x - s.x, e = a.y - s.y, 0 === (i = Math.sqrt(t * t + e * e)) && (t = i = .1 * this._rng()), i < 2 * c && (r = i < .5 * c ? 1 : u * i + 1.3333333333333333, o = t * (r /= i), n = e * r, l[s.id].x -= o, l[s.id].y -= n, l[a.id].x += o, l[a.id].y += n);\n        }\n      }\n    }]), t;\n  }(),\n      lm = function () {\n    function t(e, i, o) {\n      Ra(this, t), this.body = e, this.physicsBody = i, this.setOptions(o);\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function (t) {\n        this.options = t, this.overlapAvoidanceFactor = Math.max(0, Math.min(1, this.options.avoidOverlap || 0));\n      }\n    }, {\n      key: \"solve\",\n      value: function () {\n        for (var t = this.body.nodes, e = this.physicsBody.physicsNodeIndices, i = this.physicsBody.forces, o = this.options.nodeDistance, n = 0; n < e.length - 1; n++) for (var r = t[e[n]], s = n + 1; s < e.length; s++) {\n          var a = t[e[s]];\n\n          if (r.level === a.level) {\n            var h = o + this.overlapAvoidanceFactor * ((r.shape.radius || 0) / 2 + (a.shape.radius || 0) / 2),\n                d = a.x - r.x,\n                l = a.y - r.y,\n                c = Math.sqrt(d * d + l * l),\n                u = void 0;\n            u = c < h ? -Math.pow(.05 * c, 2) + Math.pow(.05 * h, 2) : 0, 0 !== c && (u /= c);\n            var f = d * u,\n                p = l * u;\n            i[r.id].x -= f, i[r.id].y -= p, i[a.id].x += f, i[a.id].y += p;\n          }\n        }\n      }\n    }]), t;\n  }(),\n      cm = function () {\n    function t(e, i, o) {\n      Ra(this, t), this.body = e, this.physicsBody = i, this.setOptions(o);\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function (t) {\n        this.options = t;\n      }\n    }, {\n      key: \"solve\",\n      value: function () {\n        for (var t, e, i, o, n, r = this.physicsBody.physicsEdgeIndices, s = this.body.edges, a = 0; a < r.length; a++) !0 === (e = s[r[a]]).connected && e.toId !== e.fromId && void 0 !== this.body.nodes[e.toId] && void 0 !== this.body.nodes[e.fromId] && (void 0 !== e.edgeType.via ? (t = void 0 === e.options.length ? this.options.springLength : e.options.length, i = e.to, o = e.edgeType.via, n = e.from, this._calculateSpringForce(i, o, .5 * t), this._calculateSpringForce(o, n, .5 * t)) : (t = void 0 === e.options.length ? 1.5 * this.options.springLength : e.options.length, this._calculateSpringForce(e.from, e.to, t)));\n      }\n    }, {\n      key: \"_calculateSpringForce\",\n      value: function (t, e, i) {\n        var o = t.x - e.x,\n            n = t.y - e.y,\n            r = Math.max(Math.sqrt(o * o + n * n), .01),\n            s = this.options.springConstant * (i - r) / r,\n            a = o * s,\n            h = n * s;\n        void 0 !== this.physicsBody.forces[t.id] && (this.physicsBody.forces[t.id].x += a, this.physicsBody.forces[t.id].y += h), void 0 !== this.physicsBody.forces[e.id] && (this.physicsBody.forces[e.id].x -= a, this.physicsBody.forces[e.id].y -= h);\n      }\n    }]), t;\n  }(),\n      um = function () {\n    function t(e, i, o) {\n      Ra(this, t), this.body = e, this.physicsBody = i, this.setOptions(o);\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function (t) {\n        this.options = t;\n      }\n    }, {\n      key: \"solve\",\n      value: function () {\n        for (var t, e, i, o, n, r, s, a, h, d, l = this.body.edges, c = .5, u = this.physicsBody.physicsEdgeIndices, f = this.physicsBody.physicsNodeIndices, p = this.physicsBody.forces, v = 0; v < f.length; v++) {\n          var g = f[v];\n          p[g].springFx = 0, p[g].springFy = 0;\n        }\n\n        for (var y = 0; y < u.length; y++) !0 === (e = l[u[y]]).connected && (t = void 0 === e.options.length ? this.options.springLength : e.options.length, i = e.from.x - e.to.x, o = e.from.y - e.to.y, a = 0 === (a = Math.sqrt(i * i + o * o)) ? .01 : a, n = i * (s = this.options.springConstant * (t - a) / a), r = o * s, e.to.level != e.from.level ? (void 0 !== p[e.toId] && (p[e.toId].springFx -= n, p[e.toId].springFy -= r), void 0 !== p[e.fromId] && (p[e.fromId].springFx += n, p[e.fromId].springFy += r)) : (void 0 !== p[e.toId] && (p[e.toId].x -= c * n, p[e.toId].y -= c * r), void 0 !== p[e.fromId] && (p[e.fromId].x += c * n, p[e.fromId].y += c * r)));\n\n        s = 1;\n\n        for (var m = 0; m < f.length; m++) {\n          var b = f[m];\n          h = Math.min(s, Math.max(-s, p[b].springFx)), d = Math.min(s, Math.max(-s, p[b].springFy)), p[b].x += h, p[b].y += d;\n        }\n\n        for (var w = 0, k = 0, _ = 0; _ < f.length; _++) {\n          var x = f[_];\n          w += p[x].x, k += p[x].y;\n        }\n\n        for (var E = w / f.length, O = k / f.length, C = 0; C < f.length; C++) {\n          var S = f[C];\n          p[S].x -= E, p[S].y -= O;\n        }\n      }\n    }]), t;\n  }(),\n      fm = function () {\n    function t(e, i, o) {\n      Ra(this, t), this.body = e, this.physicsBody = i, this.setOptions(o);\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function (t) {\n        this.options = t;\n      }\n    }, {\n      key: \"solve\",\n      value: function () {\n        for (var t, e, i, o, n = this.body.nodes, r = this.physicsBody.physicsNodeIndices, s = this.physicsBody.forces, a = 0; a < r.length; a++) {\n          t = -(o = n[r[a]]).x, e = -o.y, i = Math.sqrt(t * t + e * e), this._calculateForces(i, t, e, s, o);\n        }\n      }\n    }, {\n      key: \"_calculateForces\",\n      value: function (t, e, i, o, n) {\n        var r = 0 === t ? 0 : this.options.centralGravity / t;\n        o[n.id].x = e * r, o[n.id].y = i * r;\n      }\n    }]), t;\n  }();\n\n  function pm(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var vm = function (t) {\n    kg(i, t);\n    var e = pm(i);\n\n    function i(t, o, n) {\n      var r;\n      return Ra(this, i), (r = e.call(this, t, o, n))._rng = Vu(\"FORCE ATLAS 2 BASED REPULSION SOLVER\"), r;\n    }\n\n    return Ha(i, [{\n      key: \"_calculateForces\",\n      value: function (t, e, i, o, n) {\n        0 === t && (e = t = .1 * this._rng()), this.overlapAvoidanceFactor < 1 && o.shape.radius && (t = Math.max(.1 + this.overlapAvoidanceFactor * o.shape.radius, t - o.shape.radius));\n        var r = o.edges.length + 1,\n            s = this.options.gravitationalConstant * n.mass * o.options.mass * r / Math.pow(t, 2),\n            a = e * s,\n            h = i * s;\n        this.physicsBody.forces[o.id].x += a, this.physicsBody.forces[o.id].y += h;\n      }\n    }]), i;\n  }(hm);\n\n  function gm(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var ym,\n      mm = function (t) {\n    kg(i, t);\n    var e = gm(i);\n\n    function i(t, o, n) {\n      return Ra(this, i), e.call(this, t, o, n);\n    }\n\n    return Ha(i, [{\n      key: \"_calculateForces\",\n      value: function (t, e, i, o, n) {\n        if (t > 0) {\n          var r = n.edges.length + 1,\n              s = this.options.centralGravity * r * n.options.mass;\n          o[n.id].x = e * s, o[n.id].y = i * s;\n        }\n      }\n    }]), i;\n  }(fm),\n      bm = function () {\n    function t(e) {\n      Ra(this, t), this.body = e, this.physicsBody = {\n        physicsNodeIndices: [],\n        physicsEdgeIndices: [],\n        forces: {},\n        velocities: {}\n      }, this.physicsEnabled = !0, this.simulationInterval = 1e3 / 60, this.requiresTimeout = !0, this.previousStates = {}, this.referenceState = {}, this.freezeCache = {}, this.renderTimer = void 0, this.adaptiveTimestep = !1, this.adaptiveTimestepEnabled = !1, this.adaptiveCounter = 0, this.adaptiveInterval = 3, this.stabilized = !1, this.startedStabilization = !1, this.stabilizationIterations = 0, this.ready = !1, this.options = {}, this.defaultOptions = {\n        enabled: !0,\n        barnesHut: {\n          theta: .5,\n          gravitationalConstant: -2e3,\n          centralGravity: .3,\n          springLength: 95,\n          springConstant: .04,\n          damping: .09,\n          avoidOverlap: 0\n        },\n        forceAtlas2Based: {\n          theta: .5,\n          gravitationalConstant: -50,\n          centralGravity: .01,\n          springConstant: .08,\n          springLength: 100,\n          damping: .4,\n          avoidOverlap: 0\n        },\n        repulsion: {\n          centralGravity: .2,\n          springLength: 200,\n          springConstant: .05,\n          nodeDistance: 100,\n          damping: .09,\n          avoidOverlap: 0\n        },\n        hierarchicalRepulsion: {\n          centralGravity: 0,\n          springLength: 100,\n          springConstant: .01,\n          nodeDistance: 120,\n          damping: .09\n        },\n        maxVelocity: 50,\n        minVelocity: .75,\n        solver: \"barnesHut\",\n        stabilization: {\n          enabled: !0,\n          iterations: 1e3,\n          updateInterval: 50,\n          onlyDynamicEdges: !1,\n          fit: !0\n        },\n        timestep: .5,\n        adaptiveTimestep: !0,\n        wind: {\n          x: 0,\n          y: 0\n        }\n      }, Ke(this.options, this.defaultOptions), this.timestep = .5, this.layoutFailed = !1, this.bindEventListeners();\n    }\n\n    return Ha(t, [{\n      key: \"bindEventListeners\",\n      value: function () {\n        var t = this;\n        this.body.emitter.on(\"initPhysics\", function () {\n          t.initPhysics();\n        }), this.body.emitter.on(\"_layoutFailed\", function () {\n          t.layoutFailed = !0;\n        }), this.body.emitter.on(\"resetPhysics\", function () {\n          t.stopSimulation(), t.ready = !1;\n        }), this.body.emitter.on(\"disablePhysics\", function () {\n          t.physicsEnabled = !1, t.stopSimulation();\n        }), this.body.emitter.on(\"restorePhysics\", function () {\n          t.setOptions(t.options), !0 === t.ready && t.startSimulation();\n        }), this.body.emitter.on(\"startSimulation\", function () {\n          !0 === t.ready && t.startSimulation();\n        }), this.body.emitter.on(\"stopSimulation\", function () {\n          t.stopSimulation();\n        }), this.body.emitter.on(\"destroy\", function () {\n          t.stopSimulation(!1), t.body.emitter.off();\n        }), this.body.emitter.on(\"_dataChanged\", function () {\n          t.updatePhysicsData();\n        });\n      }\n    }, {\n      key: \"setOptions\",\n      value: function (t) {\n        if (void 0 !== t) if (!1 === t) this.options.enabled = !1, this.physicsEnabled = !1, this.stopSimulation();else if (!0 === t) this.options.enabled = !0, this.physicsEnabled = !0, this.startSimulation();else {\n          this.physicsEnabled = !0, rf([\"stabilization\"], this.options, t), _f(this.options, t, \"stabilization\"), void 0 === t.enabled && (this.options.enabled = !0), !1 === this.options.enabled && (this.physicsEnabled = !1, this.stopSimulation());\n          var e = this.options.wind;\n          e && ((\"number\" != typeof e.x || Tv(e.x)) && (e.x = 0), (\"number\" != typeof e.y || Tv(e.y)) && (e.y = 0)), this.timestep = this.options.timestep;\n        }\n        this.init();\n      }\n    }, {\n      key: \"init\",\n      value: function () {\n        var t;\n        \"forceAtlas2Based\" === this.options.solver ? (t = this.options.forceAtlas2Based, this.nodesSolver = new vm(this.body, this.physicsBody, t), this.edgesSolver = new cm(this.body, this.physicsBody, t), this.gravitySolver = new mm(this.body, this.physicsBody, t)) : \"repulsion\" === this.options.solver ? (t = this.options.repulsion, this.nodesSolver = new dm(this.body, this.physicsBody, t), this.edgesSolver = new cm(this.body, this.physicsBody, t), this.gravitySolver = new fm(this.body, this.physicsBody, t)) : \"hierarchicalRepulsion\" === this.options.solver ? (t = this.options.hierarchicalRepulsion, this.nodesSolver = new lm(this.body, this.physicsBody, t), this.edgesSolver = new um(this.body, this.physicsBody, t), this.gravitySolver = new fm(this.body, this.physicsBody, t)) : (t = this.options.barnesHut, this.nodesSolver = new hm(this.body, this.physicsBody, t), this.edgesSolver = new cm(this.body, this.physicsBody, t), this.gravitySolver = new fm(this.body, this.physicsBody, t)), this.modelOptions = t;\n      }\n    }, {\n      key: \"initPhysics\",\n      value: function () {\n        !0 === this.physicsEnabled && !0 === this.options.enabled ? !0 === this.options.stabilization.enabled ? this.stabilize() : (this.stabilized = !1, this.ready = !0, this.body.emitter.emit(\"fit\", {}, this.layoutFailed), this.startSimulation()) : (this.ready = !0, this.body.emitter.emit(\"fit\"));\n      }\n    }, {\n      key: \"startSimulation\",\n      value: function () {\n        var t;\n        !0 === this.physicsEnabled && !0 === this.options.enabled ? (this.stabilized = !1, this.adaptiveTimestep = !1, this.body.emitter.emit(\"_resizeNodes\"), void 0 === this.viewFunction && (this.viewFunction = si(t = this.simulationStep).call(t, this), this.body.emitter.on(\"initRedraw\", this.viewFunction), this.body.emitter.emit(\"_startRendering\"))) : this.body.emitter.emit(\"_redraw\");\n      }\n    }, {\n      key: \"stopSimulation\",\n      value: function () {\n        var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n        this.stabilized = !0, !0 === t && this._emitStabilized(), void 0 !== this.viewFunction && (this.body.emitter.off(\"initRedraw\", this.viewFunction), this.viewFunction = void 0, !0 === t && this.body.emitter.emit(\"_stopRendering\"));\n      }\n    }, {\n      key: \"simulationStep\",\n      value: function () {\n        var t = Kh();\n        this.physicsTick(), (Kh() - t < .4 * this.simulationInterval || !0 === this.runDoubleSpeed) && !1 === this.stabilized && (this.physicsTick(), this.runDoubleSpeed = !0), !0 === this.stabilized && this.stopSimulation();\n      }\n    }, {\n      key: \"_emitStabilized\",\n      value: function () {\n        var t = this,\n            e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.stabilizationIterations;\n        (this.stabilizationIterations > 1 || !0 === this.startedStabilization) && Yl(function () {\n          t.body.emitter.emit(\"stabilized\", {\n            iterations: e\n          }), t.startedStabilization = !1, t.stabilizationIterations = 0;\n        }, 0);\n      }\n    }, {\n      key: \"physicsStep\",\n      value: function () {\n        this.gravitySolver.solve(), this.nodesSolver.solve(), this.edgesSolver.solve(), this.moveNodes();\n      }\n    }, {\n      key: \"adjustTimeStep\",\n      value: function () {\n        !0 === this._evaluateStepQuality() ? this.timestep = 1.2 * this.timestep : this.timestep / 1.2 < this.options.timestep ? this.timestep = this.options.timestep : (this.adaptiveCounter = -1, this.timestep = Math.max(this.options.timestep, this.timestep / 1.2));\n      }\n    }, {\n      key: \"physicsTick\",\n      value: function () {\n        if (this._startStabilizing(), !0 !== this.stabilized) {\n          if (!0 === this.adaptiveTimestep && !0 === this.adaptiveTimestepEnabled) this.adaptiveCounter % this.adaptiveInterval == 0 ? (this.timestep = 2 * this.timestep, this.physicsStep(), this.revert(), this.timestep = .5 * this.timestep, this.physicsStep(), this.physicsStep(), this.adjustTimeStep()) : this.physicsStep(), this.adaptiveCounter += 1;else this.timestep = this.options.timestep, this.physicsStep();\n          !0 === this.stabilized && this.revert(), this.stabilizationIterations++;\n        }\n      }\n    }, {\n      key: \"updatePhysicsData\",\n      value: function () {\n        this.physicsBody.forces = {}, this.physicsBody.physicsNodeIndices = [], this.physicsBody.physicsEdgeIndices = [];\n        var t = this.body.nodes,\n            e = this.body.edges;\n\n        for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && !0 === t[i].options.physics && this.physicsBody.physicsNodeIndices.push(t[i].id);\n\n        for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && !0 === e[o].options.physics && this.physicsBody.physicsEdgeIndices.push(e[o].id);\n\n        for (var n = 0; n < this.physicsBody.physicsNodeIndices.length; n++) {\n          var r = this.physicsBody.physicsNodeIndices[n];\n          this.physicsBody.forces[r] = {\n            x: 0,\n            y: 0\n          }, void 0 === this.physicsBody.velocities[r] && (this.physicsBody.velocities[r] = {\n            x: 0,\n            y: 0\n          });\n        }\n\n        for (var s in this.physicsBody.velocities) void 0 === t[s] && delete this.physicsBody.velocities[s];\n      }\n    }, {\n      key: \"revert\",\n      value: function () {\n        var t = Gh(this.previousStates),\n            e = this.body.nodes,\n            i = this.physicsBody.velocities;\n        this.referenceState = {};\n\n        for (var o = 0; o < t.length; o++) {\n          var n = t[o];\n          void 0 !== e[n] ? !0 === e[n].options.physics && (this.referenceState[n] = {\n            positions: {\n              x: e[n].x,\n              y: e[n].y\n            }\n          }, i[n].x = this.previousStates[n].vx, i[n].y = this.previousStates[n].vy, e[n].x = this.previousStates[n].x, e[n].y = this.previousStates[n].y) : delete this.previousStates[n];\n        }\n      }\n    }, {\n      key: \"_evaluateStepQuality\",\n      value: function () {\n        var t,\n            e,\n            i = this.body.nodes,\n            o = this.referenceState;\n\n        for (var n in this.referenceState) if (Object.prototype.hasOwnProperty.call(this.referenceState, n) && void 0 !== i[n] && (t = i[n].x - o[n].positions.x, e = i[n].y - o[n].positions.y, Math.sqrt(Math.pow(t, 2) + Math.pow(e, 2)) > .3)) return !1;\n\n        return !0;\n      }\n    }, {\n      key: \"moveNodes\",\n      value: function () {\n        for (var t = this.physicsBody.physicsNodeIndices, e = 0, i = 0, o = 0; o < t.length; o++) {\n          var n = t[o],\n              r = this._performStep(n);\n\n          e = Math.max(e, r), i += r;\n        }\n\n        this.adaptiveTimestepEnabled = i / t.length < 5, this.stabilized = e < this.options.minVelocity;\n      }\n    }, {\n      key: \"calculateComponentVelocity\",\n      value: function (t, e, i) {\n        t += (e - this.modelOptions.damping * t) / i * this.timestep;\n        var o = this.options.maxVelocity || 1e9;\n        return Math.abs(t) > o && (t = t > 0 ? o : -o), t;\n      }\n    }, {\n      key: \"_performStep\",\n      value: function (t) {\n        var e = this.body.nodes[t],\n            i = this.physicsBody.forces[t];\n        this.options.wind && (i.x += this.options.wind.x, i.y += this.options.wind.y);\n        var o = this.physicsBody.velocities[t];\n        return this.previousStates[t] = {\n          x: e.x,\n          y: e.y,\n          vx: o.x,\n          vy: o.y\n        }, !1 === e.options.fixed.x ? (o.x = this.calculateComponentVelocity(o.x, i.x, e.options.mass), e.x += o.x * this.timestep) : (i.x = 0, o.x = 0), !1 === e.options.fixed.y ? (o.y = this.calculateComponentVelocity(o.y, i.y, e.options.mass), e.y += o.y * this.timestep) : (i.y = 0, o.y = 0), Math.sqrt(Math.pow(o.x, 2) + Math.pow(o.y, 2));\n      }\n    }, {\n      key: \"_freezeNodes\",\n      value: function () {\n        var t = this.body.nodes;\n\n        for (var e in t) if (Object.prototype.hasOwnProperty.call(t, e) && t[e].x && t[e].y) {\n          var i = t[e].options.fixed;\n          this.freezeCache[e] = {\n            x: i.x,\n            y: i.y\n          }, i.x = !0, i.y = !0;\n        }\n      }\n    }, {\n      key: \"_restoreFrozenNodes\",\n      value: function () {\n        var t = this.body.nodes;\n\n        for (var e in t) Object.prototype.hasOwnProperty.call(t, e) && void 0 !== this.freezeCache[e] && (t[e].options.fixed.x = this.freezeCache[e].x, t[e].options.fixed.y = this.freezeCache[e].y);\n\n        this.freezeCache = {};\n      }\n    }, {\n      key: \"stabilize\",\n      value: function () {\n        var t = this,\n            e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.options.stabilization.iterations;\n        \"number\" != typeof e && (e = this.options.stabilization.iterations, console.error(\"The stabilize method needs a numeric amount of iterations. Switching to default: \", e)), 0 !== this.physicsBody.physicsNodeIndices.length ? (this.adaptiveTimestep = this.options.adaptiveTimestep, this.body.emitter.emit(\"_resizeNodes\"), this.stopSimulation(), this.stabilized = !1, this.body.emitter.emit(\"_blockRedraw\"), this.targetIterations = e, !0 === this.options.stabilization.onlyDynamicEdges && this._freezeNodes(), this.stabilizationIterations = 0, Yl(function () {\n          return t._stabilizationBatch();\n        }, 0)) : this.ready = !0;\n      }\n    }, {\n      key: \"_startStabilizing\",\n      value: function () {\n        return !0 !== this.startedStabilization && (this.body.emitter.emit(\"startStabilizing\"), this.startedStabilization = !0, !0);\n      }\n    }, {\n      key: \"_stabilizationBatch\",\n      value: function () {\n        var t = this,\n            e = function () {\n          return !1 === t.stabilized && t.stabilizationIterations < t.targetIterations;\n        },\n            i = function () {\n          t.body.emitter.emit(\"stabilizationProgress\", {\n            iterations: t.stabilizationIterations,\n            total: t.targetIterations\n          });\n        };\n\n        this._startStabilizing() && i();\n\n        for (var o, n = 0; e() && n < this.options.stabilization.updateInterval;) this.physicsTick(), n++;\n\n        (i(), e()) ? Yl(si(o = this._stabilizationBatch).call(o, this), 0) : this._finalizeStabilization();\n      }\n    }, {\n      key: \"_finalizeStabilization\",\n      value: function () {\n        this.body.emitter.emit(\"_allowRedraw\"), !0 === this.options.stabilization.fit && this.body.emitter.emit(\"fit\"), !0 === this.options.stabilization.onlyDynamicEdges && this._restoreFrozenNodes(), this.body.emitter.emit(\"stabilizationIterationsDone\"), this.body.emitter.emit(\"_requestRedraw\"), !0 === this.stabilized ? this._emitStabilized() : this.startSimulation(), this.ready = !0;\n      }\n    }, {\n      key: \"_drawForces\",\n      value: function (t) {\n        for (var e = 0; e < this.physicsBody.physicsNodeIndices.length; e++) {\n          var i = this.physicsBody.physicsNodeIndices[e],\n              o = this.body.nodes[i],\n              n = this.physicsBody.forces[i],\n              r = Math.sqrt(Math.pow(n.x, 2) + Math.pow(n.x, 2)),\n              s = Math.min(Math.max(5, r), 15),\n              a = 3 * s,\n              h = yf((180 - 180 * Math.min(1, Math.max(0, .03 * r))) / 360, 1, 1),\n              d = {\n            x: o.x + 20 * n.x,\n            y: o.y + 20 * n.y\n          };\n          t.lineWidth = s, t.strokeStyle = h, t.beginPath(), t.moveTo(o.x, o.y), t.lineTo(d.x, d.y), t.stroke();\n          var l = Math.atan2(n.y, n.x);\n          t.fillStyle = h, Vy.draw(t, {\n            type: \"arrow\",\n            point: d,\n            angle: l,\n            length: a\n          }), Ql(t).call(t);\n        }\n      }\n    }]), t;\n  }(),\n      wm = new Uint8Array(16);\n\n  function km() {\n    if (!ym && !(ym = \"undefined\" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || \"undefined\" != typeof msCrypto && \"function\" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n    return ym(wm);\n  }\n\n  var _m = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\n\n  function xm(t) {\n    return \"string\" == typeof t && _m.test(t);\n  }\n\n  for (var Em = [], Om = 0; Om < 256; ++Om) Em.push((Om + 256).toString(16).substr(1));\n\n  function Cm(t, e, i) {\n    var o = (t = t || {}).random || (t.rng || km)();\n\n    if (o[6] = 15 & o[6] | 64, o[8] = 63 & o[8] | 128, e) {\n      i = i || 0;\n\n      for (var n = 0; n < 16; ++n) e[i + n] = o[n];\n\n      return e;\n    }\n\n    return function (t) {\n      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n          i = (Em[t[e + 0]] + Em[t[e + 1]] + Em[t[e + 2]] + Em[t[e + 3]] + \"-\" + Em[t[e + 4]] + Em[t[e + 5]] + \"-\" + Em[t[e + 6]] + Em[t[e + 7]] + \"-\" + Em[t[e + 8]] + Em[t[e + 9]] + \"-\" + Em[t[e + 10]] + Em[t[e + 11]] + Em[t[e + 12]] + Em[t[e + 13]] + Em[t[e + 14]] + Em[t[e + 15]]).toLowerCase();\n      if (!xm(i)) throw TypeError(\"Stringified UUID is invalid\");\n      return i;\n    }(o);\n  }\n\n  var Sm = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, null, [{\n      key: \"getRange\",\n      value: function (t) {\n        var e,\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],\n            o = 1e9,\n            n = -1e9,\n            r = 1e9,\n            s = -1e9;\n        if (i.length > 0) for (var a = 0; a < i.length; a++) r > (e = t[i[a]]).shape.boundingBox.left && (r = e.shape.boundingBox.left), s < e.shape.boundingBox.right && (s = e.shape.boundingBox.right), o > e.shape.boundingBox.top && (o = e.shape.boundingBox.top), n < e.shape.boundingBox.bottom && (n = e.shape.boundingBox.bottom);\n        return 1e9 === r && -1e9 === s && 1e9 === o && -1e9 === n && (o = 0, n = 0, r = 0, s = 0), {\n          minX: r,\n          maxX: s,\n          minY: o,\n          maxY: n\n        };\n      }\n    }, {\n      key: \"getRangeCore\",\n      value: function (t) {\n        var e,\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],\n            o = 1e9,\n            n = -1e9,\n            r = 1e9,\n            s = -1e9;\n        if (i.length > 0) for (var a = 0; a < i.length; a++) r > (e = t[i[a]]).x && (r = e.x), s < e.x && (s = e.x), o > e.y && (o = e.y), n < e.y && (n = e.y);\n        return 1e9 === r && -1e9 === s && 1e9 === o && -1e9 === n && (o = 0, n = 0, r = 0, s = 0), {\n          minX: r,\n          maxX: s,\n          minY: o,\n          maxY: n\n        };\n      }\n    }, {\n      key: \"findCenter\",\n      value: function (t) {\n        return {\n          x: .5 * (t.maxX + t.minX),\n          y: .5 * (t.maxY + t.minY)\n        };\n      }\n    }, {\n      key: \"cloneOptions\",\n      value: function (t, e) {\n        var i = {};\n        return void 0 === e || \"node\" === e ? (sf(i, t.options, !0), i.x = t.x, i.y = t.y, i.amountOfConnections = t.edges.length) : sf(i, t.options, !0), i;\n      }\n    }]), t;\n  }();\n\n  function Tm(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Mm = function (t) {\n    kg(i, t);\n    var e = Tm(i);\n\n    function i(t, o, n, r, s, a) {\n      var h;\n      return Ra(this, i), (h = e.call(this, t, o, n, r, s, a)).isCluster = !0, h.containedNodes = {}, h.containedEdges = {}, h;\n    }\n\n    return Ha(i, [{\n      key: \"_openChildCluster\",\n      value: function (t) {\n        var e = this,\n            i = this.body.nodes[t];\n        if (void 0 === this.containedNodes[t]) throw new Error(\"node with id: \" + t + \" not in current cluster\");\n        if (!i.isCluster) throw new Error(\"node with id: \" + t + \" is not a cluster\");\n        delete this.containedNodes[t], lf(i.edges, function (t) {\n          delete e.containedEdges[t.id];\n        }), lf(i.containedNodes, function (t, i) {\n          e.containedNodes[i] = t;\n        }), i.containedNodes = {}, lf(i.containedEdges, function (t, i) {\n          e.containedEdges[i] = t;\n        }), i.containedEdges = {}, lf(i.edges, function (t) {\n          lf(e.edges, function (i) {\n            var o,\n                n,\n                r = Cl(o = i.clusteringEdgeReplacingIds).call(o, t.id);\n            -1 !== r && (lf(t.clusteringEdgeReplacingIds, function (t) {\n              i.clusteringEdgeReplacingIds.push(t), e.body.edges[t].edgeReplacedById = i.id;\n            }), Od(n = i.clusteringEdgeReplacingIds).call(n, r, 1));\n          });\n        }), i.edges = [];\n      }\n    }]), i;\n  }(uy),\n      Pm = function () {\n    function t(e) {\n      var i = this;\n      Ra(this, t), this.body = e, this.clusteredNodes = {}, this.clusteredEdges = {}, this.options = {}, this.defaultOptions = {}, Ke(this.options, this.defaultOptions), this.body.emitter.on(\"_resetData\", function () {\n        i.clusteredNodes = {}, i.clusteredEdges = {};\n      });\n    }\n\n    return Ha(t, [{\n      key: \"clusterByHubsize\",\n      value: function (t, e) {\n        void 0 === t ? t = this._getHubSize() : \"object\" === zh(t) && (e = this._checkOptions(t), t = this._getHubSize());\n\n        for (var i = [], o = 0; o < this.body.nodeIndices.length; o++) {\n          var n = this.body.nodes[this.body.nodeIndices[o]];\n          n.edges.length >= t && i.push(n.id);\n        }\n\n        for (var r = 0; r < i.length; r++) this.clusterByConnection(i[r], e, !0);\n\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }, {\n      key: \"cluster\",\n      value: function () {\n        var t = this,\n            e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n            i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n        if (void 0 === e.joinCondition) throw new Error(\"Cannot call clusterByNodeData without a joinCondition function in the options.\");\n        e = this._checkOptions(e);\n        var o = {},\n            n = {};\n        lf(this.body.nodes, function (i, r) {\n          i.options && !0 === e.joinCondition(i.options) && (o[r] = i, lf(i.edges, function (e) {\n            void 0 === t.clusteredEdges[e.id] && (n[e.id] = e);\n          }));\n        }), this._cluster(o, n, e, i);\n      }\n    }, {\n      key: \"clusterByEdgeCount\",\n      value: function (t, e) {\n        var i = this,\n            o = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];\n        e = this._checkOptions(e);\n\n        for (var n, r, s, a = [], h = {}, d = function (o) {\n          var d = {},\n              l = {},\n              c = i.body.nodeIndices[o],\n              u = i.body.nodes[c];\n\n          if (void 0 === h[c]) {\n            s = 0, r = [];\n\n            for (var f = 0; f < u.edges.length; f++) n = u.edges[f], void 0 === i.clusteredEdges[n.id] && (n.toId !== n.fromId && s++, r.push(n));\n\n            if (s === t) {\n              for (var p = function (t) {\n                if (void 0 === e.joinCondition || null === e.joinCondition) return !0;\n                var i = Sm.cloneOptions(t);\n                return e.joinCondition(i);\n              }, v = !0, g = 0; g < r.length; g++) {\n                n = r[g];\n\n                var y = i._getConnectedId(n, c);\n\n                if (!p(u)) {\n                  v = !1;\n                  break;\n                }\n\n                l[n.id] = n, d[c] = u, d[y] = i.body.nodes[y], h[c] = !0;\n              }\n\n              if (Gh(d).length > 0 && Gh(l).length > 0 && !0 === v) {\n                var m = function () {\n                  for (var t = 0; t < a.length; ++t) for (var e in d) if (void 0 !== a[t].nodes[e]) return a[t];\n                }();\n\n                if (void 0 !== m) {\n                  for (var b in d) void 0 === m.nodes[b] && (m.nodes[b] = d[b]);\n\n                  for (var w in l) void 0 === m.edges[w] && (m.edges[w] = l[w]);\n                } else a.push({\n                  nodes: d,\n                  edges: l\n                });\n              }\n            }\n          }\n        }, l = 0; l < this.body.nodeIndices.length; l++) d(l);\n\n        for (var c = 0; c < a.length; c++) this._cluster(a[c].nodes, a[c].edges, e, !1);\n\n        !0 === o && this.body.emitter.emit(\"_dataChanged\");\n      }\n    }, {\n      key: \"clusterOutliers\",\n      value: function (t) {\n        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n        this.clusterByEdgeCount(1, t, e);\n      }\n    }, {\n      key: \"clusterBridges\",\n      value: function (t) {\n        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n        this.clusterByEdgeCount(2, t, e);\n      }\n    }, {\n      key: \"clusterByConnection\",\n      value: function (t, e) {\n        var i,\n            o = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];\n        if (void 0 === t) throw new Error(\"No nodeId supplied to clusterByConnection!\");\n        if (void 0 === this.body.nodes[t]) throw new Error(\"The nodeId given to clusterByConnection does not exist!\");\n        var n = this.body.nodes[t];\n        void 0 === (e = this._checkOptions(e, n)).clusterNodeProperties.x && (e.clusterNodeProperties.x = n.x), void 0 === e.clusterNodeProperties.y && (e.clusterNodeProperties.y = n.y), void 0 === e.clusterNodeProperties.fixed && (e.clusterNodeProperties.fixed = {}, e.clusterNodeProperties.fixed.x = n.options.fixed.x, e.clusterNodeProperties.fixed.y = n.options.fixed.y);\n        var r = {},\n            s = {},\n            a = n.id,\n            h = Sm.cloneOptions(n);\n        r[a] = n;\n\n        for (var d = 0; d < n.edges.length; d++) {\n          var l = n.edges[d];\n\n          if (void 0 === this.clusteredEdges[l.id]) {\n            var c = this._getConnectedId(l, a);\n\n            if (void 0 === this.clusteredNodes[c]) if (c !== a) {\n              if (void 0 === e.joinCondition) s[l.id] = l, r[c] = this.body.nodes[c];else {\n                var u = Sm.cloneOptions(this.body.nodes[c]);\n                !0 === e.joinCondition(h, u) && (s[l.id] = l, r[c] = this.body.nodes[c]);\n              }\n            } else s[l.id] = l;\n          }\n        }\n\n        var f = Uh(i = Gh(r)).call(i, function (t) {\n          return r[t].id;\n        });\n\n        for (var p in r) if (Object.prototype.hasOwnProperty.call(r, p)) for (var v = r[p], g = 0; g < v.edges.length; g++) {\n          var y = v.edges[g];\n          Cl(f).call(f, this._getConnectedId(y, v.id)) > -1 && (s[y.id] = y);\n        }\n\n        this._cluster(r, s, e, o);\n      }\n    }, {\n      key: \"_createClusterEdges\",\n      value: function (t, e, i, o) {\n        for (var n, r, s, a, h, d, l = Gh(t), c = [], u = 0; u < l.length; u++) {\n          s = t[r = l[u]];\n\n          for (var f = 0; f < s.edges.length; f++) n = s.edges[f], void 0 === this.clusteredEdges[n.id] && (n.toId == n.fromId ? e[n.id] = n : n.toId == r ? (a = i.id, d = h = n.fromId) : (a = n.toId, h = i.id, d = a), void 0 === t[d] && c.push({\n            edge: n,\n            fromId: h,\n            toId: a\n          }));\n        }\n\n        for (var p = [], v = function (t) {\n          for (var e = 0; e < p.length; e++) {\n            var i = p[e],\n                o = t.fromId === i.fromId && t.toId === i.toId,\n                n = t.fromId === i.toId && t.toId === i.fromId;\n            if (o || n) return i;\n          }\n\n          return null;\n        }, g = 0; g < c.length; g++) {\n          var y = c[g],\n              m = y.edge,\n              b = v(y);\n          null === b ? (b = this._createClusteredEdge(y.fromId, y.toId, m, o), p.push(b)) : b.clusteringEdgeReplacingIds.push(m.id), this.body.edges[m.id].edgeReplacedById = b.id, this._backupEdgeOptions(m), m.setOptions({\n            physics: !1\n          });\n        }\n      }\n    }, {\n      key: \"_checkOptions\",\n      value: function () {\n        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n        return void 0 === t.clusterEdgeProperties && (t.clusterEdgeProperties = {}), void 0 === t.clusterNodeProperties && (t.clusterNodeProperties = {}), t;\n      }\n    }, {\n      key: \"_cluster\",\n      value: function (t, e, i) {\n        var o = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],\n            n = [];\n\n        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && void 0 !== this.clusteredNodes[r] && n.push(r);\n\n        for (var s = 0; s < n.length; ++s) delete t[n[s]];\n\n        if (0 != Gh(t).length && (1 != Gh(t).length || 1 == i.clusterNodeProperties.allowSingleNodeCluster)) {\n          var a = sf({}, i.clusterNodeProperties);\n\n          if (void 0 !== i.processProperties) {\n            var h = [];\n\n            for (var d in t) if (Object.prototype.hasOwnProperty.call(t, d)) {\n              var l = Sm.cloneOptions(t[d]);\n              h.push(l);\n            }\n\n            var c = [];\n\n            for (var u in e) if (Object.prototype.hasOwnProperty.call(e, u) && \"clusterEdge:\" !== u.substr(0, 12)) {\n              var f = Sm.cloneOptions(e[u], \"edge\");\n              c.push(f);\n            }\n\n            if (!(a = i.processProperties(a, h, c))) throw new Error(\"The processProperties function does not return properties!\");\n          }\n\n          void 0 === a.id && (a.id = \"cluster:\" + Cm());\n          var p = a.id;\n          void 0 === a.label && (a.label = \"cluster\");\n          var v = void 0;\n          void 0 === a.x && (v = this._getClusterPosition(t), a.x = v.x), void 0 === a.y && (void 0 === v && (v = this._getClusterPosition(t)), a.y = v.y), a.id = p;\n          var g = this.body.functions.createNode(a, Mm);\n          g.containedNodes = t, g.containedEdges = e, g.clusterEdgeProperties = i.clusterEdgeProperties, this.body.nodes[a.id] = g, this._clusterEdges(t, e, a, i.clusterEdgeProperties), a.id = void 0, !0 === o && this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }, {\n      key: \"_backupEdgeOptions\",\n      value: function (t) {\n        void 0 === this.clusteredEdges[t.id] && (this.clusteredEdges[t.id] = {\n          physics: t.options.physics\n        });\n      }\n    }, {\n      key: \"_restoreEdge\",\n      value: function (t) {\n        var e = this.clusteredEdges[t.id];\n        void 0 !== e && (t.setOptions({\n          physics: e.physics\n        }), delete this.clusteredEdges[t.id]);\n      }\n    }, {\n      key: \"isCluster\",\n      value: function (t) {\n        return void 0 !== this.body.nodes[t] ? !0 === this.body.nodes[t].isCluster : (console.error(\"Node does not exist.\"), !1);\n      }\n    }, {\n      key: \"_getClusterPosition\",\n      value: function (t) {\n        for (var e, i = Gh(t), o = t[i[0]].x, n = t[i[0]].x, r = t[i[0]].y, s = t[i[0]].y, a = 1; a < i.length; a++) o = (e = t[i[a]]).x < o ? e.x : o, n = e.x > n ? e.x : n, r = e.y < r ? e.y : r, s = e.y > s ? e.y : s;\n\n        return {\n          x: .5 * (o + n),\n          y: .5 * (r + s)\n        };\n      }\n    }, {\n      key: \"openCluster\",\n      value: function (t, e) {\n        var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];\n        if (void 0 === t) throw new Error(\"No clusterNodeId supplied to openCluster.\");\n        var o = this.body.nodes[t];\n        if (void 0 === o) throw new Error(\"The clusterNodeId supplied to openCluster does not exist.\");\n        if (!0 !== o.isCluster || void 0 === o.containedNodes || void 0 === o.containedEdges) throw new Error(\"The node:\" + t + \" is not a valid cluster.\");\n        var n = this.findNode(t),\n            r = Cl(n).call(n, t) - 1;\n\n        if (r >= 0) {\n          var s = n[r],\n              a = this.body.nodes[s];\n          return a._openChildCluster(t), delete this.body.nodes[t], void (!0 === i && this.body.emitter.emit(\"_dataChanged\"));\n        }\n\n        var h = o.containedNodes,\n            d = o.containedEdges;\n\n        if (void 0 !== e && void 0 !== e.releaseFunction && \"function\" == typeof e.releaseFunction) {\n          var l = {},\n              c = {\n            x: o.x,\n            y: o.y\n          };\n\n          for (var u in h) if (Object.prototype.hasOwnProperty.call(h, u)) {\n            var f = this.body.nodes[u];\n            l[u] = {\n              x: f.x,\n              y: f.y\n            };\n          }\n\n          var p = e.releaseFunction(c, l);\n\n          for (var v in h) if (Object.prototype.hasOwnProperty.call(h, v)) {\n            var g = this.body.nodes[v];\n            void 0 !== p[v] && (g.x = void 0 === p[v].x ? o.x : p[v].x, g.y = void 0 === p[v].y ? o.y : p[v].y);\n          }\n        } else lf(h, function (t) {\n          !1 === t.options.fixed.x && (t.x = o.x), !1 === t.options.fixed.y && (t.y = o.y);\n        });\n\n        for (var y in h) if (Object.prototype.hasOwnProperty.call(h, y)) {\n          var m = this.body.nodes[y];\n          m.vx = o.vx, m.vy = o.vy, m.setOptions({\n            physics: !0\n          }), delete this.clusteredNodes[y];\n        }\n\n        for (var b = [], w = 0; w < o.edges.length; w++) b.push(o.edges[w]);\n\n        for (var k = 0; k < b.length; k++) {\n          for (var _ = b[k], x = this._getConnectedId(_, t), E = this.clusteredNodes[x], O = 0; O < _.clusteringEdgeReplacingIds.length; O++) {\n            var C = _.clusteringEdgeReplacingIds[O],\n                S = this.body.edges[C];\n            if (void 0 !== S) if (void 0 !== E) {\n              var T = this.body.nodes[E.clusterId];\n              T.containedEdges[S.id] = S, delete d[S.id];\n              var M = S.fromId,\n                  P = S.toId;\n              S.toId == x ? P = E.clusterId : M = E.clusterId, this._createClusteredEdge(M, P, S, T.clusterEdgeProperties, {\n                hidden: !1,\n                physics: !0\n              });\n            } else this._restoreEdge(S);\n          }\n\n          _.remove();\n        }\n\n        for (var D in d) Object.prototype.hasOwnProperty.call(d, D) && this._restoreEdge(d[D]);\n\n        delete this.body.nodes[t], !0 === i && this.body.emitter.emit(\"_dataChanged\");\n      }\n    }, {\n      key: \"getNodesInCluster\",\n      value: function (t) {\n        var e = [];\n\n        if (!0 === this.isCluster(t)) {\n          var i = this.body.nodes[t].containedNodes;\n\n          for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && e.push(this.body.nodes[o].id);\n        }\n\n        return e;\n      }\n    }, {\n      key: \"findNode\",\n      value: function (t) {\n        for (var e, i = [], o = 0; void 0 !== this.clusteredNodes[t] && o < 100;) {\n          if (void 0 === (e = this.body.nodes[t])) return [];\n          i.push(e.id), t = this.clusteredNodes[t].clusterId, o++;\n        }\n\n        return void 0 === (e = this.body.nodes[t]) ? [] : (i.push(e.id), ld(i).call(i), i);\n      }\n    }, {\n      key: \"updateClusteredNode\",\n      value: function (t, e) {\n        if (void 0 === t) throw new Error(\"No clusteredNodeId supplied to updateClusteredNode.\");\n        if (void 0 === e) throw new Error(\"No newOptions supplied to updateClusteredNode.\");\n        if (void 0 === this.body.nodes[t]) throw new Error(\"The clusteredNodeId supplied to updateClusteredNode does not exist.\");\n        this.body.nodes[t].setOptions(e), this.body.emitter.emit(\"_dataChanged\");\n      }\n    }, {\n      key: \"updateEdge\",\n      value: function (t, e) {\n        if (void 0 === t) throw new Error(\"No startEdgeId supplied to updateEdge.\");\n        if (void 0 === e) throw new Error(\"No newOptions supplied to updateEdge.\");\n        if (void 0 === this.body.edges[t]) throw new Error(\"The startEdgeId supplied to updateEdge does not exist.\");\n\n        for (var i = this.getClusteredEdges(t), o = 0; o < i.length; o++) {\n          this.body.edges[i[o]].setOptions(e);\n        }\n\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }, {\n      key: \"getClusteredEdges\",\n      value: function (t) {\n        for (var e = [], i = 0; void 0 !== t && void 0 !== this.body.edges[t] && i < 100;) e.push(this.body.edges[t].id), t = this.body.edges[t].edgeReplacedById, i++;\n\n        return ld(e).call(e), e;\n      }\n    }, {\n      key: \"getBaseEdge\",\n      value: function (t) {\n        return this.getBaseEdges(t)[0];\n      }\n    }, {\n      key: \"getBaseEdges\",\n      value: function (t) {\n        for (var e = [t], i = [], o = [], n = 0; e.length > 0 && n < 100;) {\n          var r = e.pop();\n\n          if (void 0 !== r) {\n            var s = this.body.edges[r];\n\n            if (void 0 !== s) {\n              n++;\n              var a = s.clusteringEdgeReplacingIds;\n              if (void 0 === a) o.push(r);else for (var h = 0; h < a.length; ++h) {\n                var d = a[h];\n                -1 === Cl(e).call(e, a) && -1 === Cl(i).call(i, a) && e.push(d);\n              }\n              i.push(r);\n            }\n          }\n        }\n\n        return o;\n      }\n    }, {\n      key: \"_getConnectedId\",\n      value: function (t, e) {\n        return t.toId != e ? t.toId : (t.fromId, t.fromId);\n      }\n    }, {\n      key: \"_getHubSize\",\n      value: function () {\n        for (var t = 0, e = 0, i = 0, o = 0, n = 0; n < this.body.nodeIndices.length; n++) {\n          var r = this.body.nodes[this.body.nodeIndices[n]];\n          r.edges.length > o && (o = r.edges.length), t += r.edges.length, e += Math.pow(r.edges.length, 2), i += 1;\n        }\n\n        t /= i;\n        var s = (e /= i) - Math.pow(t, 2),\n            a = Math.sqrt(s),\n            h = Math.floor(t + 2 * a);\n        return h > o && (h = o), h;\n      }\n    }, {\n      key: \"_createClusteredEdge\",\n      value: function (t, e, i, o, n) {\n        var r = Sm.cloneOptions(i, \"edge\");\n        sf(r, o), r.from = t, r.to = e, r.id = \"clusterEdge:\" + Cm(), void 0 !== n && sf(r, n);\n        var s = this.body.functions.createEdge(r);\n        return s.clusteringEdgeReplacingIds = [i.id], s.connect(), this.body.edges[s.id] = s, s;\n      }\n    }, {\n      key: \"_clusterEdges\",\n      value: function (t, e, i, o) {\n        if (e instanceof sm) {\n          var n = e,\n              r = {};\n          r[n.id] = n, e = r;\n        }\n\n        if (t instanceof uy) {\n          var s = t,\n              a = {};\n          a[s.id] = s, t = a;\n        }\n\n        if (null == i) throw new Error(\"_clusterEdges: parameter clusterNode required\");\n\n        for (var h in void 0 === o && (o = i.clusterEdgeProperties), this._createClusterEdges(t, e, i, o), e) if (Object.prototype.hasOwnProperty.call(e, h) && void 0 !== this.body.edges[h]) {\n          var d = this.body.edges[h];\n          this._backupEdgeOptions(d), d.setOptions({\n            physics: !1\n          });\n        }\n\n        for (var l in t) Object.prototype.hasOwnProperty.call(t, l) && (this.clusteredNodes[l] = {\n          clusterId: i.id,\n          node: this.body.nodes[l]\n        }, this.body.nodes[l].setOptions({\n          physics: !1\n        }));\n      }\n    }, {\n      key: \"_getClusterNodeForNode\",\n      value: function (t) {\n        if (void 0 !== t) {\n          var e = this.clusteredNodes[t];\n\n          if (void 0 !== e) {\n            var i = e.clusterId;\n            if (void 0 !== i) return this.body.nodes[i];\n          }\n        }\n      }\n    }, {\n      key: \"_filter\",\n      value: function (t, e) {\n        var i = [];\n        return lf(t, function (t) {\n          e(t) && i.push(t);\n        }), i;\n      }\n    }, {\n      key: \"_updateState\",\n      value: function () {\n        var t,\n            e = this,\n            i = [],\n            o = {},\n            n = function (t) {\n          lf(e.body.nodes, function (e) {\n            !0 === e.isCluster && t(e);\n          });\n        };\n\n        for (t in this.clusteredNodes) {\n          if (Object.prototype.hasOwnProperty.call(this.clusteredNodes, t)) void 0 === this.body.nodes[t] && i.push(t);\n        }\n\n        n(function (t) {\n          for (var e = 0; e < i.length; e++) delete t.containedNodes[i[e]];\n        });\n\n        for (var r = 0; r < i.length; r++) delete this.clusteredNodes[i[r]];\n\n        lf(this.clusteredEdges, function (t) {\n          var i = e.body.edges[t];\n          void 0 !== i && i.endPointsValid() || (o[t] = t);\n        }), n(function (t) {\n          lf(t.containedEdges, function (t, e) {\n            t.endPointsValid() || o[e] || (o[e] = e);\n          });\n        }), lf(this.body.edges, function (t, i) {\n          var n = !0,\n              r = t.clusteringEdgeReplacingIds;\n\n          if (void 0 !== r) {\n            var s = 0;\n            lf(r, function (t) {\n              var i = e.body.edges[t];\n              void 0 !== i && i.endPointsValid() && (s += 1);\n            }), n = s > 0;\n          }\n\n          t.endPointsValid() && n || (o[i] = i);\n        }), n(function (t) {\n          lf(o, function (i) {\n            delete t.containedEdges[i], lf(t.edges, function (n, r) {\n              n.id !== i ? n.clusteringEdgeReplacingIds = e._filter(n.clusteringEdgeReplacingIds, function (t) {\n                return !o[t];\n              }) : t.edges[r] = null;\n            }), t.edges = e._filter(t.edges, function (t) {\n              return null !== t;\n            });\n          });\n        }), lf(o, function (t) {\n          delete e.clusteredEdges[t];\n        }), lf(o, function (t) {\n          delete e.body.edges[t];\n        }), lf(Gh(this.body.edges), function (t) {\n          var i = e.body.edges[t],\n              o = e._isClusteredNode(i.fromId) || e._isClusteredNode(i.toId);\n\n          if (o !== e._isClusteredEdge(i.id)) if (o) {\n            var n = e._getClusterNodeForNode(i.fromId);\n\n            void 0 !== n && e._clusterEdges(e.body.nodes[i.fromId], i, n);\n\n            var r = e._getClusterNodeForNode(i.toId);\n\n            void 0 !== r && e._clusterEdges(e.body.nodes[i.toId], i, r);\n          } else delete e._clusterEdges[t], e._restoreEdge(i);\n        });\n\n        for (var s = !1, a = !0, h = function () {\n          var t = [];\n          n(function (e) {\n            var i = Gh(e.containedNodes).length,\n                o = !0 === e.options.allowSingleNodeCluster;\n            (o && i < 1 || !o && i < 2) && t.push(e.id);\n          });\n\n          for (var i = 0; i < t.length; ++i) e.openCluster(t[i], {}, !1);\n\n          a = t.length > 0, s = s || a;\n        }; a;) h();\n\n        s && this._updateState();\n      }\n    }, {\n      key: \"_isClusteredNode\",\n      value: function (t) {\n        return void 0 !== this.clusteredNodes[t];\n      }\n    }, {\n      key: \"_isClusteredEdge\",\n      value: function (t) {\n        return void 0 !== this.clusteredEdges[t];\n      }\n    }]), t;\n  }();\n\n  function Dm(t, e) {\n    var i = void 0 !== Nh && xr(t) || t[\"@@iterator\"];\n\n    if (!i) {\n      if (Hh(t) || (i = function (t, e) {\n        var i;\n        if (!t) return;\n        if (\"string\" == typeof t) return Bm(t, e);\n        var o = Lh(i = Object.prototype.toString.call(t)).call(i, 8, -1);\n        \"Object\" === o && t.constructor && (o = t.constructor.name);\n        if (\"Map\" === o || \"Set\" === o) return rr(t);\n        if (\"Arguments\" === o || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)) return Bm(t, e);\n      }(t)) || e && t && \"number\" == typeof t.length) {\n        i && (t = i);\n\n        var o = 0,\n            n = function () {};\n\n        return {\n          s: n,\n          n: function () {\n            return o >= t.length ? {\n              done: !0\n            } : {\n              done: !1,\n              value: t[o++]\n            };\n          },\n          e: function (t) {\n            throw t;\n          },\n          f: n\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var r,\n        s = !0,\n        a = !1;\n    return {\n      s: function () {\n        i = i.call(t);\n      },\n      n: function () {\n        var t = i.next();\n        return s = t.done, t;\n      },\n      e: function (t) {\n        a = !0, r = t;\n      },\n      f: function () {\n        try {\n          s || null == i.return || i.return();\n        } finally {\n          if (a) throw r;\n        }\n      }\n    };\n  }\n\n  function Bm(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var i = 0, o = new Array(e); i < e; i++) o[i] = t[i];\n\n    return o;\n  }\n\n  var Im = function () {\n    function t(e, i) {\n      var o;\n      Ra(this, t), void 0 !== window && (o = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame), window.requestAnimationFrame = void 0 === o ? function (t) {\n        t();\n      } : o, this.body = e, this.canvas = i, this.redrawRequested = !1, this.renderTimer = void 0, this.requiresTimeout = !0, this.renderingActive = !1, this.renderRequests = 0, this.allowRedraw = !0, this.dragging = !1, this.zooming = !1, this.options = {}, this.defaultOptions = {\n        hideEdgesOnDrag: !1,\n        hideEdgesOnZoom: !1,\n        hideNodesOnDrag: !1\n      }, Ke(this.options, this.defaultOptions), this._determineBrowserMethod(), this.bindEventListeners();\n    }\n\n    return Ha(t, [{\n      key: \"bindEventListeners\",\n      value: function () {\n        var t,\n            e = this;\n        this.body.emitter.on(\"dragStart\", function () {\n          e.dragging = !0;\n        }), this.body.emitter.on(\"dragEnd\", function () {\n          e.dragging = !1;\n        }), this.body.emitter.on(\"zoom\", function () {\n          e.zooming = !0, window.clearTimeout(e.zoomTimeoutId), e.zoomTimeoutId = Yl(function () {\n            var t;\n            e.zooming = !1, si(t = e._requestRedraw).call(t, e)();\n          }, 250);\n        }), this.body.emitter.on(\"_resizeNodes\", function () {\n          e._resizeNodes();\n        }), this.body.emitter.on(\"_redraw\", function () {\n          !1 === e.renderingActive && e._redraw();\n        }), this.body.emitter.on(\"_blockRedraw\", function () {\n          e.allowRedraw = !1;\n        }), this.body.emitter.on(\"_allowRedraw\", function () {\n          e.allowRedraw = !0, e.redrawRequested = !1;\n        }), this.body.emitter.on(\"_requestRedraw\", si(t = this._requestRedraw).call(t, this)), this.body.emitter.on(\"_startRendering\", function () {\n          e.renderRequests += 1, e.renderingActive = !0, e._startRendering();\n        }), this.body.emitter.on(\"_stopRendering\", function () {\n          e.renderRequests -= 1, e.renderingActive = e.renderRequests > 0, e.renderTimer = void 0;\n        }), this.body.emitter.on(\"destroy\", function () {\n          e.renderRequests = 0, e.allowRedraw = !1, e.renderingActive = !1, !0 === e.requiresTimeout ? clearTimeout(e.renderTimer) : window.cancelAnimationFrame(e.renderTimer), e.body.emitter.off();\n        });\n      }\n    }, {\n      key: \"setOptions\",\n      value: function (t) {\n        if (void 0 !== t) {\n          nf([\"hideEdgesOnDrag\", \"hideEdgesOnZoom\", \"hideNodesOnDrag\"], this.options, t);\n        }\n      }\n    }, {\n      key: \"_requestNextFrame\",\n      value: function (t, e) {\n        if (\"undefined\" != typeof window) {\n          var i,\n              o = window;\n          return !0 === this.requiresTimeout ? i = Yl(t, e) : o.requestAnimationFrame && (i = o.requestAnimationFrame(t)), i;\n        }\n      }\n    }, {\n      key: \"_startRendering\",\n      value: function () {\n        var t;\n        !0 === this.renderingActive && void 0 === this.renderTimer && (this.renderTimer = this._requestNextFrame(si(t = this._renderStep).call(t, this), this.simulationInterval));\n      }\n    }, {\n      key: \"_renderStep\",\n      value: function () {\n        !0 === this.renderingActive && (this.renderTimer = void 0, !0 === this.requiresTimeout && this._startRendering(), this._redraw(), !1 === this.requiresTimeout && this._startRendering());\n      }\n    }, {\n      key: \"redraw\",\n      value: function () {\n        this.body.emitter.emit(\"setSize\"), this._redraw();\n      }\n    }, {\n      key: \"_requestRedraw\",\n      value: function () {\n        var t = this;\n        !0 !== this.redrawRequested && !1 === this.renderingActive && !0 === this.allowRedraw && (this.redrawRequested = !0, this._requestNextFrame(function () {\n          t._redraw(!1);\n        }, 0));\n      }\n    }, {\n      key: \"_redraw\",\n      value: function () {\n        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n\n        if (!0 === this.allowRedraw) {\n          this.body.emitter.emit(\"initRedraw\"), this.redrawRequested = !1;\n          var e = {\n            drawExternalLabels: null\n          };\n          0 !== this.canvas.frame.canvas.width && 0 !== this.canvas.frame.canvas.height || this.canvas.setSize(), this.canvas.setTransform();\n          var i = this.canvas.getContext(),\n              o = this.canvas.frame.canvas.clientWidth,\n              n = this.canvas.frame.canvas.clientHeight;\n          if (i.clearRect(0, 0, o, n), 0 === this.canvas.frame.clientWidth) return;\n\n          if (i.save(), i.translate(this.body.view.translation.x, this.body.view.translation.y), i.scale(this.body.view.scale, this.body.view.scale), i.beginPath(), this.body.emitter.emit(\"beforeDrawing\", i), i.closePath(), !1 === t && (!1 === this.dragging || !0 === this.dragging && !1 === this.options.hideEdgesOnDrag) && (!1 === this.zooming || !0 === this.zooming && !1 === this.options.hideEdgesOnZoom) && this._drawEdges(i), !1 === this.dragging || !0 === this.dragging && !1 === this.options.hideNodesOnDrag) {\n            var r = this._drawNodes(i, t),\n                s = r.drawExternalLabels;\n\n            e.drawExternalLabels = s;\n          }\n\n          !1 === t && (!1 === this.dragging || !0 === this.dragging && !1 === this.options.hideEdgesOnDrag) && (!1 === this.zooming || !0 === this.zooming && !1 === this.options.hideEdgesOnZoom) && this._drawArrows(i), null != e.drawExternalLabels && e.drawExternalLabels(), !1 === t && this._drawSelectionBox(i), i.beginPath(), this.body.emitter.emit(\"afterDrawing\", i), i.closePath(), i.restore(), !0 === t && i.clearRect(0, 0, o, n);\n        }\n      }\n    }, {\n      key: \"_resizeNodes\",\n      value: function () {\n        this.canvas.setTransform();\n        var t = this.canvas.getContext();\n        t.save(), t.translate(this.body.view.translation.x, this.body.view.translation.y), t.scale(this.body.view.scale, this.body.view.scale);\n        var e,\n            i = this.body.nodes;\n\n        for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && ((e = i[o]).resize(t), e.updateBoundingBox(t, e.selected));\n\n        t.restore();\n      }\n    }, {\n      key: \"_drawNodes\",\n      value: function (t) {\n        for (var e, i, o = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = this.body.nodes, r = this.body.nodeIndices, s = [], a = [], h = 20, d = this.canvas.DOMtoCanvas({\n          x: -h,\n          y: -h\n        }), l = this.canvas.DOMtoCanvas({\n          x: this.canvas.frame.canvas.clientWidth + h,\n          y: this.canvas.frame.canvas.clientHeight + h\n        }), c = {\n          top: d.y,\n          left: d.x,\n          bottom: l.y,\n          right: l.x\n        }, u = [], f = 0; f < r.length; f++) if ((e = n[r[f]]).hover) a.push(r[f]);else if (e.isSelected()) s.push(r[f]);else if (!0 === o) {\n          var p = e.draw(t);\n          null != p.drawExternalLabel && u.push(p.drawExternalLabel);\n        } else if (!0 === e.isBoundingBoxOverlappingWith(c)) {\n          var v = e.draw(t);\n          null != v.drawExternalLabel && u.push(v.drawExternalLabel);\n        } else e.updateBoundingBox(t, e.selected);\n\n        var g = s.length,\n            y = a.length;\n\n        for (i = 0; i < g; i++) {\n          var m = (e = n[s[i]]).draw(t);\n          null != m.drawExternalLabel && u.push(m.drawExternalLabel);\n        }\n\n        for (i = 0; i < y; i++) {\n          var b = (e = n[a[i]]).draw(t);\n          null != b.drawExternalLabel && u.push(b.drawExternalLabel);\n        }\n\n        return {\n          drawExternalLabels: function () {\n            var t,\n                e = Dm(u);\n\n            try {\n              for (e.s(); !(t = e.n()).done;) {\n                (0, t.value)();\n              }\n            } catch (t) {\n              e.e(t);\n            } finally {\n              e.f();\n            }\n          }\n        };\n      }\n    }, {\n      key: \"_drawEdges\",\n      value: function (t) {\n        for (var e = this.body.edges, i = this.body.edgeIndices, o = 0; o < i.length; o++) {\n          var n = e[i[o]];\n          !0 === n.connected && n.draw(t);\n        }\n      }\n    }, {\n      key: \"_drawArrows\",\n      value: function (t) {\n        for (var e = this.body.edges, i = this.body.edgeIndices, o = 0; o < i.length; o++) {\n          var n = e[i[o]];\n          !0 === n.connected && n.drawArrows(t);\n        }\n      }\n    }, {\n      key: \"_determineBrowserMethod\",\n      value: function () {\n        if (\"undefined\" != typeof window) {\n          var t = navigator.userAgent.toLowerCase();\n          this.requiresTimeout = !1, (-1 != Cl(t).call(t, \"msie 9.0\") || -1 != Cl(t).call(t, \"safari\") && Cl(t).call(t, \"chrome\") <= -1) && (this.requiresTimeout = !0);\n        } else this.requiresTimeout = !0;\n      }\n    }, {\n      key: \"_drawSelectionBox\",\n      value: function (t) {\n        if (this.body.selectionBox.show) {\n          t.beginPath();\n          var e = this.body.selectionBox.position.end.x - this.body.selectionBox.position.start.x,\n              i = this.body.selectionBox.position.end.y - this.body.selectionBox.position.start.y;\n          t.rect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, e, i), t.fillStyle = \"rgba(151, 194, 252, 0.2)\", t.fillRect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, e, i), t.strokeStyle = \"rgba(151, 194, 252, 1)\", t.stroke();\n        } else t.closePath();\n      }\n    }]), t;\n  }(),\n      zm = O.setInterval;\n\n  function Fm(t, e) {\n    e.inputHandler = function (t) {\n      t.isFirst && e(t);\n    }, t.on(\"hammer.input\", e.inputHandler);\n  }\n\n  function Nm(t, e) {\n    return e.inputHandler = function (t) {\n      t.isFinal && e(t);\n    }, t.on(\"hammer.input\", e.inputHandler);\n  }\n\n  var Am = function () {\n    function t(e) {\n      Ra(this, t), this.body = e, this.pixelRatio = 1, this.cameraState = {}, this.initialized = !1, this.canvasViewCenter = {}, this._cleanupCallbacks = [], this.options = {}, this.defaultOptions = {\n        autoResize: !0,\n        height: \"100%\",\n        width: \"100%\"\n      }, Ke(this.options, this.defaultOptions), this.bindEventListeners();\n    }\n\n    return Ha(t, [{\n      key: \"bindEventListeners\",\n      value: function () {\n        var t,\n            e = this;\n        this.body.emitter.once(\"resize\", function (t) {\n          0 !== t.width && (e.body.view.translation.x = .5 * t.width), 0 !== t.height && (e.body.view.translation.y = .5 * t.height);\n        }), this.body.emitter.on(\"setSize\", si(t = this.setSize).call(t, this)), this.body.emitter.on(\"destroy\", function () {\n          e.hammerFrame.destroy(), e.hammer.destroy(), e._cleanUp();\n        });\n      }\n    }, {\n      key: \"setOptions\",\n      value: function (t) {\n        var e,\n            i,\n            o,\n            n,\n            r,\n            s = this;\n\n        if (void 0 !== t) {\n          nf([\"width\", \"height\", \"autoResize\"], this.options, t);\n        }\n\n        if (this._cleanUp(), !0 === this.options.autoResize) {\n          var a;\n\n          if (window.ResizeObserver) {\n            var h = new ResizeObserver(function () {\n              !0 === s.setSize() && s.body.emitter.emit(\"_requestRedraw\");\n            }),\n                d = this.frame;\n            h.observe(d), this._cleanupCallbacks.push(function () {\n              h.unobserve(d);\n            });\n          } else {\n            var l = zm(function () {\n              !0 === s.setSize() && s.body.emitter.emit(\"_requestRedraw\");\n            }, 1e3);\n\n            this._cleanupCallbacks.push(function () {\n              clearInterval(l);\n            });\n          }\n\n          var c = si(a = this._onResize).call(a, this);\n          e = window, i = \"resize\", o = c, e.addEventListener ? (void 0 === n && (n = !1), \"mousewheel\" === i && Hd(r = navigator.userAgent).call(r, \"Firefox\") && (i = \"DOMMouseScroll\"), e.addEventListener(i, o, n)) : e.attachEvent(\"on\" + i, o), this._cleanupCallbacks.push(function () {\n            !function (t, e, i, o) {\n              var n;\n              t.removeEventListener ? (void 0 === o && (o = !1), \"mousewheel\" === e && Hd(n = navigator.userAgent).call(n, \"Firefox\") && (e = \"DOMMouseScroll\"), t.removeEventListener(e, i, o)) : t.detachEvent(\"on\" + e, i);\n            }(window, \"resize\", c);\n          });\n        }\n      }\n    }, {\n      key: \"_cleanUp\",\n      value: function () {\n        var t, e, i;\n        nd(t = ld(e = Od(i = this._cleanupCallbacks).call(i, 0)).call(e)).call(t, function (t) {\n          try {\n            t();\n          } catch (t) {\n            console.error(t);\n          }\n        });\n      }\n    }, {\n      key: \"_onResize\",\n      value: function () {\n        this.setSize(), this.body.emitter.emit(\"_redraw\");\n      }\n    }, {\n      key: \"_getCameraState\",\n      value: function () {\n        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.pixelRatio;\n        !0 === this.initialized && (this.cameraState.previousWidth = this.frame.canvas.width / t, this.cameraState.previousHeight = this.frame.canvas.height / t, this.cameraState.scale = this.body.view.scale, this.cameraState.position = this.DOMtoCanvas({\n          x: .5 * this.frame.canvas.width / t,\n          y: .5 * this.frame.canvas.height / t\n        }));\n      }\n    }, {\n      key: \"_setCameraState\",\n      value: function () {\n        if (void 0 !== this.cameraState.scale && 0 !== this.frame.canvas.clientWidth && 0 !== this.frame.canvas.clientHeight && 0 !== this.pixelRatio && this.cameraState.previousWidth > 0 && this.cameraState.previousHeight > 0) {\n          var t = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth,\n              e = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight,\n              i = this.cameraState.scale;\n          1 != t && 1 != e ? i = .5 * this.cameraState.scale * (t + e) : 1 != t ? i = this.cameraState.scale * t : 1 != e && (i = this.cameraState.scale * e), this.body.view.scale = i;\n          var o = this.DOMtoCanvas({\n            x: .5 * this.frame.canvas.clientWidth,\n            y: .5 * this.frame.canvas.clientHeight\n          }),\n              n = {\n            x: o.x - this.cameraState.position.x,\n            y: o.y - this.cameraState.position.y\n          };\n          this.body.view.translation.x += n.x * this.body.view.scale, this.body.view.translation.y += n.y * this.body.view.scale;\n        }\n      }\n    }, {\n      key: \"_prepareValue\",\n      value: function (t) {\n        if (\"number\" == typeof t) return t + \"px\";\n\n        if (\"string\" == typeof t) {\n          if (-1 !== Cl(t).call(t, \"%\") || -1 !== Cl(t).call(t, \"px\")) return t;\n          if (-1 === Cl(t).call(t, \"%\")) return t + \"px\";\n        }\n\n        throw new Error(\"Could not use the value supplied for width or height:\" + t);\n      }\n    }, {\n      key: \"_create\",\n      value: function () {\n        for (; this.body.container.hasChildNodes();) this.body.container.removeChild(this.body.container.firstChild);\n\n        if (this.frame = document.createElement(\"div\"), this.frame.className = \"vis-network\", this.frame.style.position = \"relative\", this.frame.style.overflow = \"hidden\", this.frame.tabIndex = 0, this.frame.canvas = document.createElement(\"canvas\"), this.frame.canvas.style.position = \"relative\", this.frame.appendChild(this.frame.canvas), this.frame.canvas.getContext) this._setPixelRatio(), this.setTransform();else {\n          var t = document.createElement(\"DIV\");\n          t.style.color = \"red\", t.style.fontWeight = \"bold\", t.style.padding = \"10px\", t.innerText = \"Error: your browser does not support HTML canvas\", this.frame.canvas.appendChild(t);\n        }\n        this.body.container.appendChild(this.frame), this.body.view.scale = 1, this.body.view.translation = {\n          x: .5 * this.frame.canvas.clientWidth,\n          y: .5 * this.frame.canvas.clientHeight\n        }, this._bindHammer();\n      }\n    }, {\n      key: \"_bindHammer\",\n      value: function () {\n        var t = this;\n        void 0 !== this.hammer && this.hammer.destroy(), this.drag = {}, this.pinch = {}, this.hammer = new If(this.frame.canvas), this.hammer.get(\"pinch\").set({\n          enable: !0\n        }), this.hammer.get(\"pan\").set({\n          threshold: 5,\n          direction: If.DIRECTION_ALL\n        }), Fm(this.hammer, function (e) {\n          t.body.eventListeners.onTouch(e);\n        }), this.hammer.on(\"tap\", function (e) {\n          t.body.eventListeners.onTap(e);\n        }), this.hammer.on(\"doubletap\", function (e) {\n          t.body.eventListeners.onDoubleTap(e);\n        }), this.hammer.on(\"press\", function (e) {\n          t.body.eventListeners.onHold(e);\n        }), this.hammer.on(\"panstart\", function (e) {\n          t.body.eventListeners.onDragStart(e);\n        }), this.hammer.on(\"panmove\", function (e) {\n          t.body.eventListeners.onDrag(e);\n        }), this.hammer.on(\"panend\", function (e) {\n          t.body.eventListeners.onDragEnd(e);\n        }), this.hammer.on(\"pinch\", function (e) {\n          t.body.eventListeners.onPinch(e);\n        }), this.frame.canvas.addEventListener(\"wheel\", function (e) {\n          t.body.eventListeners.onMouseWheel(e);\n        }), this.frame.canvas.addEventListener(\"mousemove\", function (e) {\n          t.body.eventListeners.onMouseMove(e);\n        }), this.frame.canvas.addEventListener(\"contextmenu\", function (e) {\n          t.body.eventListeners.onContext(e);\n        }), this.hammerFrame = new If(this.frame), Nm(this.hammerFrame, function (e) {\n          t.body.eventListeners.onRelease(e);\n        });\n      }\n    }, {\n      key: \"setSize\",\n      value: function () {\n        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.options.width,\n            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.options.height;\n        t = this._prepareValue(t), e = this._prepareValue(e);\n        var i = !1,\n            o = this.frame.canvas.width,\n            n = this.frame.canvas.height,\n            r = this.pixelRatio;\n        if (this._setPixelRatio(), t != this.options.width || e != this.options.height || this.frame.style.width != t || this.frame.style.height != e) this._getCameraState(r), this.frame.style.width = t, this.frame.style.height = e, this.frame.canvas.style.width = \"100%\", this.frame.canvas.style.height = \"100%\", this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio), this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio), this.options.width = t, this.options.height = e, this.canvasViewCenter = {\n          x: .5 * this.frame.clientWidth,\n          y: .5 * this.frame.clientHeight\n        }, i = !0;else {\n          var s = Math.round(this.frame.canvas.clientWidth * this.pixelRatio),\n              a = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);\n          this.frame.canvas.width === s && this.frame.canvas.height === a || this._getCameraState(r), this.frame.canvas.width !== s && (this.frame.canvas.width = s, i = !0), this.frame.canvas.height !== a && (this.frame.canvas.height = a, i = !0);\n        }\n        return !0 === i && (this.body.emitter.emit(\"resize\", {\n          width: Math.round(this.frame.canvas.width / this.pixelRatio),\n          height: Math.round(this.frame.canvas.height / this.pixelRatio),\n          oldWidth: Math.round(o / this.pixelRatio),\n          oldHeight: Math.round(n / this.pixelRatio)\n        }), this._setCameraState()), this.initialized = !0, i;\n      }\n    }, {\n      key: \"getContext\",\n      value: function () {\n        return this.frame.canvas.getContext(\"2d\");\n      }\n    }, {\n      key: \"_determinePixelRatio\",\n      value: function () {\n        var t = this.getContext();\n        if (void 0 === t) throw new Error(\"Could not get canvax context\");\n        var e = 1;\n        return \"undefined\" != typeof window && (e = window.devicePixelRatio || 1), e / (t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1);\n      }\n    }, {\n      key: \"_setPixelRatio\",\n      value: function () {\n        this.pixelRatio = this._determinePixelRatio();\n      }\n    }, {\n      key: \"setTransform\",\n      value: function () {\n        var t = this.getContext();\n        if (void 0 === t) throw new Error(\"Could not get canvax context\");\n        t.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n      }\n    }, {\n      key: \"_XconvertDOMtoCanvas\",\n      value: function (t) {\n        return (t - this.body.view.translation.x) / this.body.view.scale;\n      }\n    }, {\n      key: \"_XconvertCanvasToDOM\",\n      value: function (t) {\n        return t * this.body.view.scale + this.body.view.translation.x;\n      }\n    }, {\n      key: \"_YconvertDOMtoCanvas\",\n      value: function (t) {\n        return (t - this.body.view.translation.y) / this.body.view.scale;\n      }\n    }, {\n      key: \"_YconvertCanvasToDOM\",\n      value: function (t) {\n        return t * this.body.view.scale + this.body.view.translation.y;\n      }\n    }, {\n      key: \"canvasToDOM\",\n      value: function (t) {\n        return {\n          x: this._XconvertCanvasToDOM(t.x),\n          y: this._YconvertCanvasToDOM(t.y)\n        };\n      }\n    }, {\n      key: \"DOMtoCanvas\",\n      value: function (t) {\n        return {\n          x: this._XconvertDOMtoCanvas(t.x),\n          y: this._YconvertDOMtoCanvas(t.y)\n        };\n      }\n    }]), t;\n  }();\n\n  function Rm(t, e) {\n    var i = Ke({\n      nodes: e,\n      minZoomLevel: Number.MIN_VALUE,\n      maxZoomLevel: 1\n    }, null != t ? t : {});\n    if (!Hh(i.nodes)) throw new TypeError(\"Nodes has to be an array of ids.\");\n    if (0 === i.nodes.length && (i.nodes = e), !(\"number\" == typeof i.minZoomLevel && i.minZoomLevel > 0)) throw new TypeError(\"Min zoom level has to be a number higher than zero.\");\n    if (!(\"number\" == typeof i.maxZoomLevel && i.minZoomLevel <= i.maxZoomLevel)) throw new TypeError(\"Max zoom level has to be a number higher than min zoom level.\");\n    return i;\n  }\n\n  var jm = function () {\n    function t(e, i) {\n      var o,\n          n,\n          r = this;\n      Ra(this, t), this.body = e, this.canvas = i, this.animationSpeed = 1 / this.renderRefreshRate, this.animationEasingFunction = \"easeInOutQuint\", this.easingTime = 0, this.sourceScale = 0, this.targetScale = 0, this.sourceTranslation = 0, this.targetTranslation = 0, this.lockedOnNodeId = void 0, this.lockedOnNodeOffset = void 0, this.touchTime = 0, this.viewFunction = void 0, this.body.emitter.on(\"fit\", si(o = this.fit).call(o, this)), this.body.emitter.on(\"animationFinished\", function () {\n        r.body.emitter.emit(\"_stopRendering\");\n      }), this.body.emitter.on(\"unlockNode\", si(n = this.releaseNode).call(n, this));\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function () {\n        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n        this.options = t;\n      }\n    }, {\n      key: \"fit\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n        t = Rm(t, this.body.nodeIndices);\n        var i,\n            o,\n            n = this.canvas.frame.canvas.clientWidth,\n            r = this.canvas.frame.canvas.clientHeight;\n        if (0 === n || 0 === r) o = 1, i = Sm.getRange(this.body.nodes, t.nodes);else if (!0 === e) {\n          var s = 0;\n\n          for (var a in this.body.nodes) if (Object.prototype.hasOwnProperty.call(this.body.nodes, a)) {\n            var h = this.body.nodes[a];\n            !0 === h.predefinedPosition && (s += 1);\n          }\n\n          if (s > .5 * this.body.nodeIndices.length) return void this.fit(t, !1);\n          i = Sm.getRange(this.body.nodes, t.nodes);\n          var d = this.body.nodeIndices.length;\n          o = 12.662 / (d + 7.4147) + .0964822;\n          var l = Math.min(n / 600, r / 600);\n          o *= l;\n        } else {\n          this.body.emitter.emit(\"_resizeNodes\"), i = Sm.getRange(this.body.nodes, t.nodes);\n          var c = 1.1 * Math.abs(i.maxX - i.minX),\n              u = 1.1 * Math.abs(i.maxY - i.minY),\n              f = n / c,\n              p = r / u;\n          o = f <= p ? f : p;\n        }\n        o > t.maxZoomLevel ? o = t.maxZoomLevel : o < t.minZoomLevel && (o = t.minZoomLevel);\n        var v = Sm.findCenter(i),\n            g = {\n          position: v,\n          scale: o,\n          animation: t.animation\n        };\n        this.moveTo(g);\n      }\n    }, {\n      key: \"focus\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n\n        if (void 0 !== this.body.nodes[t]) {\n          var i = {\n            x: this.body.nodes[t].x,\n            y: this.body.nodes[t].y\n          };\n          e.position = i, e.lockedOnNode = t, this.moveTo(e);\n        } else console.error(\"Node: \" + t + \" cannot be found.\");\n      }\n    }, {\n      key: \"moveTo\",\n      value: function (t) {\n        if (void 0 !== t) {\n          if (null != t.offset) {\n            if (null != t.offset.x) {\n              if (t.offset.x = +t.offset.x, !Pv(t.offset.x)) throw new TypeError('The option \"offset.x\" has to be a finite number.');\n            } else t.offset.x = 0;\n\n            if (null != t.offset.y) {\n              if (t.offset.y = +t.offset.y, !Pv(t.offset.y)) throw new TypeError('The option \"offset.y\" has to be a finite number.');\n            } else t.offset.x = 0;\n          } else t.offset = {\n            x: 0,\n            y: 0\n          };\n\n          if (null != t.position) {\n            if (null != t.position.x) {\n              if (t.position.x = +t.position.x, !Pv(t.position.x)) throw new TypeError('The option \"position.x\" has to be a finite number.');\n            } else t.position.x = 0;\n\n            if (null != t.position.y) {\n              if (t.position.y = +t.position.y, !Pv(t.position.y)) throw new TypeError('The option \"position.y\" has to be a finite number.');\n            } else t.position.x = 0;\n          } else t.position = this.getViewPosition();\n\n          if (null != t.scale) {\n            if (t.scale = +t.scale, !(t.scale > 0)) throw new TypeError('The option \"scale\" has to be a number greater than zero.');\n          } else t.scale = this.body.view.scale;\n\n          void 0 === t.animation && (t.animation = {\n            duration: 0\n          }), !1 === t.animation && (t.animation = {\n            duration: 0\n          }), !0 === t.animation && (t.animation = {}), void 0 === t.animation.duration && (t.animation.duration = 1e3), void 0 === t.animation.easingFunction && (t.animation.easingFunction = \"easeInOutQuad\"), this.animateView(t);\n        } else t = {};\n      }\n    }, {\n      key: \"animateView\",\n      value: function (t) {\n        if (void 0 !== t) {\n          this.animationEasingFunction = t.animation.easingFunction, this.releaseNode(), !0 === t.locked && (this.lockedOnNodeId = t.lockedOnNode, this.lockedOnNodeOffset = t.offset), 0 != this.easingTime && this._transitionRedraw(!0), this.sourceScale = this.body.view.scale, this.sourceTranslation = this.body.view.translation, this.targetScale = t.scale, this.body.view.scale = this.targetScale;\n          var e,\n              i,\n              o = this.canvas.DOMtoCanvas({\n            x: .5 * this.canvas.frame.canvas.clientWidth,\n            y: .5 * this.canvas.frame.canvas.clientHeight\n          }),\n              n = o.x - t.position.x,\n              r = o.y - t.position.y;\n          if (this.targetTranslation = {\n            x: this.sourceTranslation.x + n * this.targetScale + t.offset.x,\n            y: this.sourceTranslation.y + r * this.targetScale + t.offset.y\n          }, 0 === t.animation.duration) {\n            if (null != this.lockedOnNodeId) this.viewFunction = si(e = this._lockedRedraw).call(e, this), this.body.emitter.on(\"initRedraw\", this.viewFunction);else this.body.view.scale = this.targetScale, this.body.view.translation = this.targetTranslation, this.body.emitter.emit(\"_requestRedraw\");\n          } else this.animationSpeed = 1 / (60 * t.animation.duration * .001) || 1 / 60, this.animationEasingFunction = t.animation.easingFunction, this.viewFunction = si(i = this._transitionRedraw).call(i, this), this.body.emitter.on(\"initRedraw\", this.viewFunction), this.body.emitter.emit(\"_startRendering\");\n        }\n      }\n    }, {\n      key: \"_lockedRedraw\",\n      value: function () {\n        var t = this.body.nodes[this.lockedOnNodeId].x,\n            e = this.body.nodes[this.lockedOnNodeId].y,\n            i = this.canvas.DOMtoCanvas({\n          x: .5 * this.canvas.frame.canvas.clientWidth,\n          y: .5 * this.canvas.frame.canvas.clientHeight\n        }),\n            o = i.x - t,\n            n = i.y - e,\n            r = this.body.view.translation,\n            s = {\n          x: r.x + o * this.body.view.scale + this.lockedOnNodeOffset.x,\n          y: r.y + n * this.body.view.scale + this.lockedOnNodeOffset.y\n        };\n        this.body.view.translation = s;\n      }\n    }, {\n      key: \"releaseNode\",\n      value: function () {\n        void 0 !== this.lockedOnNodeId && void 0 !== this.viewFunction && (this.body.emitter.off(\"initRedraw\", this.viewFunction), this.lockedOnNodeId = void 0, this.lockedOnNodeOffset = void 0);\n      }\n    }, {\n      key: \"_transitionRedraw\",\n      value: function () {\n        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n        this.easingTime += this.animationSpeed, this.easingTime = !0 === t ? 1 : this.easingTime;\n        var e = xf[this.animationEasingFunction](this.easingTime);\n\n        if (this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * e, this.body.view.translation = {\n          x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * e,\n          y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * e\n        }, this.easingTime >= 1) {\n          var i;\n          if (this.body.emitter.off(\"initRedraw\", this.viewFunction), this.easingTime = 0, null != this.lockedOnNodeId) this.viewFunction = si(i = this._lockedRedraw).call(i, this), this.body.emitter.on(\"initRedraw\", this.viewFunction);\n          this.body.emitter.emit(\"animationFinished\");\n        }\n      }\n    }, {\n      key: \"getScale\",\n      value: function () {\n        return this.body.view.scale;\n      }\n    }, {\n      key: \"getViewPosition\",\n      value: function () {\n        return this.canvas.DOMtoCanvas({\n          x: .5 * this.canvas.frame.canvas.clientWidth,\n          y: .5 * this.canvas.frame.canvas.clientHeight\n        });\n      }\n    }]), t;\n  }();\n\n  function Lm(t) {\n    var e,\n        i = t && t.preventDefault || !1,\n        o = t && t.container || window,\n        n = {},\n        r = {\n      keydown: {},\n      keyup: {}\n    },\n        s = {};\n\n    for (e = 97; e <= 122; e++) s[String.fromCharCode(e)] = {\n      code: e - 97 + 65,\n      shift: !1\n    };\n\n    for (e = 65; e <= 90; e++) s[String.fromCharCode(e)] = {\n      code: e,\n      shift: !0\n    };\n\n    for (e = 0; e <= 9; e++) s[\"\" + e] = {\n      code: 48 + e,\n      shift: !1\n    };\n\n    for (e = 1; e <= 12; e++) s[\"F\" + e] = {\n      code: 111 + e,\n      shift: !1\n    };\n\n    for (e = 0; e <= 9; e++) s[\"num\" + e] = {\n      code: 96 + e,\n      shift: !1\n    };\n\n    s[\"num*\"] = {\n      code: 106,\n      shift: !1\n    }, s[\"num+\"] = {\n      code: 107,\n      shift: !1\n    }, s[\"num-\"] = {\n      code: 109,\n      shift: !1\n    }, s[\"num/\"] = {\n      code: 111,\n      shift: !1\n    }, s[\"num.\"] = {\n      code: 110,\n      shift: !1\n    }, s.left = {\n      code: 37,\n      shift: !1\n    }, s.up = {\n      code: 38,\n      shift: !1\n    }, s.right = {\n      code: 39,\n      shift: !1\n    }, s.down = {\n      code: 40,\n      shift: !1\n    }, s.space = {\n      code: 32,\n      shift: !1\n    }, s.enter = {\n      code: 13,\n      shift: !1\n    }, s.shift = {\n      code: 16,\n      shift: void 0\n    }, s.esc = {\n      code: 27,\n      shift: !1\n    }, s.backspace = {\n      code: 8,\n      shift: !1\n    }, s.tab = {\n      code: 9,\n      shift: !1\n    }, s.ctrl = {\n      code: 17,\n      shift: !1\n    }, s.alt = {\n      code: 18,\n      shift: !1\n    }, s.delete = {\n      code: 46,\n      shift: !1\n    }, s.pageup = {\n      code: 33,\n      shift: !1\n    }, s.pagedown = {\n      code: 34,\n      shift: !1\n    }, s[\"=\"] = {\n      code: 187,\n      shift: !1\n    }, s[\"-\"] = {\n      code: 189,\n      shift: !1\n    }, s[\"]\"] = {\n      code: 221,\n      shift: !1\n    }, s[\"[\"] = {\n      code: 219,\n      shift: !1\n    };\n\n    var a = function (t) {\n      d(t, \"keydown\");\n    },\n        h = function (t) {\n      d(t, \"keyup\");\n    },\n        d = function (t, e) {\n      if (void 0 !== r[e][t.keyCode]) {\n        for (var o = r[e][t.keyCode], n = 0; n < o.length; n++) (void 0 === o[n].shift || 1 == o[n].shift && 1 == t.shiftKey || 0 == o[n].shift && 0 == t.shiftKey) && o[n].fn(t);\n\n        1 == i && t.preventDefault();\n      }\n    };\n\n    return n.bind = function (t, e, i) {\n      if (void 0 === i && (i = \"keydown\"), void 0 === s[t]) throw new Error(\"unsupported key: \" + t);\n      void 0 === r[i][s[t].code] && (r[i][s[t].code] = []), r[i][s[t].code].push({\n        fn: e,\n        shift: s[t].shift\n      });\n    }, n.bindAll = function (t, e) {\n      for (var i in void 0 === e && (e = \"keydown\"), s) s.hasOwnProperty(i) && n.bind(i, t, e);\n    }, n.getKey = function (t) {\n      for (var e in s) if (s.hasOwnProperty(e)) {\n        if (1 == t.shiftKey && 1 == s[e].shift && t.keyCode == s[e].code) return e;\n        if (0 == t.shiftKey && 0 == s[e].shift && t.keyCode == s[e].code) return e;\n        if (t.keyCode == s[e].code && \"shift\" == e) return e;\n      }\n\n      return \"unknown key, currently not supported\";\n    }, n.unbind = function (t, e, i) {\n      if (void 0 === i && (i = \"keydown\"), void 0 === s[t]) throw new Error(\"unsupported key: \" + t);\n\n      if (void 0 !== e) {\n        var o = [],\n            n = r[i][s[t].code];\n        if (void 0 !== n) for (var a = 0; a < n.length; a++) n[a].fn == e && n[a].shift == s[t].shift || o.push(r[i][s[t].code][a]);\n        r[i][s[t].code] = o;\n      } else r[i][s[t].code] = [];\n    }, n.reset = function () {\n      r = {\n        keydown: {},\n        keyup: {}\n      };\n    }, n.destroy = function () {\n      r = {\n        keydown: {},\n        keyup: {}\n      }, o.removeEventListener(\"keydown\", a, !0), o.removeEventListener(\"keyup\", h, !0);\n    }, o.addEventListener(\"keydown\", a, !0), o.addEventListener(\"keyup\", h, !0), n;\n  }\n\n  var Hm = function () {\n    function t(e, i) {\n      var o = this;\n      Ra(this, t), this.body = e, this.canvas = i, this.iconsCreated = !1, this.navigationHammers = [], this.boundFunctions = {}, this.touchTime = 0, this.activated = !1, this.body.emitter.on(\"activate\", function () {\n        o.activated = !0, o.configureKeyboardBindings();\n      }), this.body.emitter.on(\"deactivate\", function () {\n        o.activated = !1, o.configureKeyboardBindings();\n      }), this.body.emitter.on(\"destroy\", function () {\n        void 0 !== o.keycharm && o.keycharm.destroy();\n      }), this.options = {};\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function (t) {\n        void 0 !== t && (this.options = t, this.create());\n      }\n    }, {\n      key: \"create\",\n      value: function () {\n        !0 === this.options.navigationButtons ? !1 === this.iconsCreated && this.loadNavigationElements() : !0 === this.iconsCreated && this.cleanNavigation(), this.configureKeyboardBindings();\n      }\n    }, {\n      key: \"cleanNavigation\",\n      value: function () {\n        if (0 != this.navigationHammers.length) {\n          for (var t = 0; t < this.navigationHammers.length; t++) this.navigationHammers[t].destroy();\n\n          this.navigationHammers = [];\n        }\n\n        this.navigationDOM && this.navigationDOM.wrapper && this.navigationDOM.wrapper.parentNode && this.navigationDOM.wrapper.parentNode.removeChild(this.navigationDOM.wrapper), this.iconsCreated = !1;\n      }\n    }, {\n      key: \"loadNavigationElements\",\n      value: function () {\n        var t = this;\n        this.cleanNavigation(), this.navigationDOM = {};\n        var e = [\"up\", \"down\", \"left\", \"right\", \"zoomIn\", \"zoomOut\", \"zoomExtends\"],\n            i = [\"_moveUp\", \"_moveDown\", \"_moveLeft\", \"_moveRight\", \"_zoomIn\", \"_zoomOut\", \"_fit\"];\n        this.navigationDOM.wrapper = document.createElement(\"div\"), this.navigationDOM.wrapper.className = \"vis-navigation\", this.canvas.frame.appendChild(this.navigationDOM.wrapper);\n\n        for (var o = 0; o < e.length; o++) {\n          this.navigationDOM[e[o]] = document.createElement(\"div\"), this.navigationDOM[e[o]].className = \"vis-button vis-\" + e[o], this.navigationDOM.wrapper.appendChild(this.navigationDOM[e[o]]);\n          var n,\n              r,\n              s = new If(this.navigationDOM[e[o]]);\n          if (\"_fit\" === i[o]) Fm(s, si(n = this._fit).call(n, this));else Fm(s, si(r = this.bindToRedraw).call(r, this, i[o]));\n          this.navigationHammers.push(s);\n        }\n\n        var a = new If(this.canvas.frame);\n        Nm(a, function () {\n          t._stopMovement();\n        }), this.navigationHammers.push(a), this.iconsCreated = !0;\n      }\n    }, {\n      key: \"bindToRedraw\",\n      value: function (t) {\n        var e;\n        void 0 === this.boundFunctions[t] && (this.boundFunctions[t] = si(e = this[t]).call(e, this), this.body.emitter.on(\"initRedraw\", this.boundFunctions[t]), this.body.emitter.emit(\"_startRendering\"));\n      }\n    }, {\n      key: \"unbindFromRedraw\",\n      value: function (t) {\n        void 0 !== this.boundFunctions[t] && (this.body.emitter.off(\"initRedraw\", this.boundFunctions[t]), this.body.emitter.emit(\"_stopRendering\"), delete this.boundFunctions[t]);\n      }\n    }, {\n      key: \"_fit\",\n      value: function () {\n        new Date().valueOf() - this.touchTime > 700 && (this.body.emitter.emit(\"fit\", {\n          duration: 700\n        }), this.touchTime = new Date().valueOf());\n      }\n    }, {\n      key: \"_stopMovement\",\n      value: function () {\n        for (var t in this.boundFunctions) Object.prototype.hasOwnProperty.call(this.boundFunctions, t) && (this.body.emitter.off(\"initRedraw\", this.boundFunctions[t]), this.body.emitter.emit(\"_stopRendering\"));\n\n        this.boundFunctions = {};\n      }\n    }, {\n      key: \"_moveUp\",\n      value: function () {\n        this.body.view.translation.y += this.options.keyboard.speed.y;\n      }\n    }, {\n      key: \"_moveDown\",\n      value: function () {\n        this.body.view.translation.y -= this.options.keyboard.speed.y;\n      }\n    }, {\n      key: \"_moveLeft\",\n      value: function () {\n        this.body.view.translation.x += this.options.keyboard.speed.x;\n      }\n    }, {\n      key: \"_moveRight\",\n      value: function () {\n        this.body.view.translation.x -= this.options.keyboard.speed.x;\n      }\n    }, {\n      key: \"_zoomIn\",\n      value: function () {\n        var t = this.body.view.scale,\n            e = this.body.view.scale * (1 + this.options.keyboard.speed.zoom),\n            i = this.body.view.translation,\n            o = e / t,\n            n = (1 - o) * this.canvas.canvasViewCenter.x + i.x * o,\n            r = (1 - o) * this.canvas.canvasViewCenter.y + i.y * o;\n        this.body.view.scale = e, this.body.view.translation = {\n          x: n,\n          y: r\n        }, this.body.emitter.emit(\"zoom\", {\n          direction: \"+\",\n          scale: this.body.view.scale,\n          pointer: null\n        });\n      }\n    }, {\n      key: \"_zoomOut\",\n      value: function () {\n        var t = this.body.view.scale,\n            e = this.body.view.scale / (1 + this.options.keyboard.speed.zoom),\n            i = this.body.view.translation,\n            o = e / t,\n            n = (1 - o) * this.canvas.canvasViewCenter.x + i.x * o,\n            r = (1 - o) * this.canvas.canvasViewCenter.y + i.y * o;\n        this.body.view.scale = e, this.body.view.translation = {\n          x: n,\n          y: r\n        }, this.body.emitter.emit(\"zoom\", {\n          direction: \"-\",\n          scale: this.body.view.scale,\n          pointer: null\n        });\n      }\n    }, {\n      key: \"configureKeyboardBindings\",\n      value: function () {\n        var t,\n            e,\n            i,\n            o,\n            n,\n            r,\n            s,\n            a,\n            h,\n            d,\n            l,\n            c,\n            u,\n            f,\n            p,\n            v,\n            g,\n            y,\n            m,\n            b,\n            w,\n            k,\n            _,\n            x,\n            E = this;\n\n        (void 0 !== this.keycharm && this.keycharm.destroy(), !0 === this.options.keyboard.enabled) && (!0 === this.options.keyboard.bindToWindow ? this.keycharm = Lm({\n          container: window,\n          preventDefault: !0\n        }) : this.keycharm = Lm({\n          container: this.canvas.frame,\n          preventDefault: !0\n        }), this.keycharm.reset(), !0 === this.activated && (si(t = this.keycharm).call(t, \"up\", function () {\n          E.bindToRedraw(\"_moveUp\");\n        }, \"keydown\"), si(e = this.keycharm).call(e, \"down\", function () {\n          E.bindToRedraw(\"_moveDown\");\n        }, \"keydown\"), si(i = this.keycharm).call(i, \"left\", function () {\n          E.bindToRedraw(\"_moveLeft\");\n        }, \"keydown\"), si(o = this.keycharm).call(o, \"right\", function () {\n          E.bindToRedraw(\"_moveRight\");\n        }, \"keydown\"), si(n = this.keycharm).call(n, \"=\", function () {\n          E.bindToRedraw(\"_zoomIn\");\n        }, \"keydown\"), si(r = this.keycharm).call(r, \"num+\", function () {\n          E.bindToRedraw(\"_zoomIn\");\n        }, \"keydown\"), si(s = this.keycharm).call(s, \"num-\", function () {\n          E.bindToRedraw(\"_zoomOut\");\n        }, \"keydown\"), si(a = this.keycharm).call(a, \"-\", function () {\n          E.bindToRedraw(\"_zoomOut\");\n        }, \"keydown\"), si(h = this.keycharm).call(h, \"[\", function () {\n          E.bindToRedraw(\"_zoomOut\");\n        }, \"keydown\"), si(d = this.keycharm).call(d, \"]\", function () {\n          E.bindToRedraw(\"_zoomIn\");\n        }, \"keydown\"), si(l = this.keycharm).call(l, \"pageup\", function () {\n          E.bindToRedraw(\"_zoomIn\");\n        }, \"keydown\"), si(c = this.keycharm).call(c, \"pagedown\", function () {\n          E.bindToRedraw(\"_zoomOut\");\n        }, \"keydown\"), si(u = this.keycharm).call(u, \"up\", function () {\n          E.unbindFromRedraw(\"_moveUp\");\n        }, \"keyup\"), si(f = this.keycharm).call(f, \"down\", function () {\n          E.unbindFromRedraw(\"_moveDown\");\n        }, \"keyup\"), si(p = this.keycharm).call(p, \"left\", function () {\n          E.unbindFromRedraw(\"_moveLeft\");\n        }, \"keyup\"), si(v = this.keycharm).call(v, \"right\", function () {\n          E.unbindFromRedraw(\"_moveRight\");\n        }, \"keyup\"), si(g = this.keycharm).call(g, \"=\", function () {\n          E.unbindFromRedraw(\"_zoomIn\");\n        }, \"keyup\"), si(y = this.keycharm).call(y, \"num+\", function () {\n          E.unbindFromRedraw(\"_zoomIn\");\n        }, \"keyup\"), si(m = this.keycharm).call(m, \"num-\", function () {\n          E.unbindFromRedraw(\"_zoomOut\");\n        }, \"keyup\"), si(b = this.keycharm).call(b, \"-\", function () {\n          E.unbindFromRedraw(\"_zoomOut\");\n        }, \"keyup\"), si(w = this.keycharm).call(w, \"[\", function () {\n          E.unbindFromRedraw(\"_zoomOut\");\n        }, \"keyup\"), si(k = this.keycharm).call(k, \"]\", function () {\n          E.unbindFromRedraw(\"_zoomIn\");\n        }, \"keyup\"), si(_ = this.keycharm).call(_, \"pageup\", function () {\n          E.unbindFromRedraw(\"_zoomIn\");\n        }, \"keyup\"), si(x = this.keycharm).call(x, \"pagedown\", function () {\n          E.unbindFromRedraw(\"_zoomOut\");\n        }, \"keyup\")));\n      }\n    }]), t;\n  }();\n\n  function Wm(t, e) {\n    var i = void 0 !== Nh && xr(t) || t[\"@@iterator\"];\n\n    if (!i) {\n      if (Hh(t) || (i = function (t, e) {\n        var i;\n        if (!t) return;\n        if (\"string\" == typeof t) return Vm(t, e);\n        var o = Lh(i = Object.prototype.toString.call(t)).call(i, 8, -1);\n        \"Object\" === o && t.constructor && (o = t.constructor.name);\n        if (\"Map\" === o || \"Set\" === o) return rr(t);\n        if (\"Arguments\" === o || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)) return Vm(t, e);\n      }(t)) || e && t && \"number\" == typeof t.length) {\n        i && (t = i);\n\n        var o = 0,\n            n = function () {};\n\n        return {\n          s: n,\n          n: function () {\n            return o >= t.length ? {\n              done: !0\n            } : {\n              done: !1,\n              value: t[o++]\n            };\n          },\n          e: function (t) {\n            throw t;\n          },\n          f: n\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var r,\n        s = !0,\n        a = !1;\n    return {\n      s: function () {\n        i = i.call(t);\n      },\n      n: function () {\n        var t = i.next();\n        return s = t.done, t;\n      },\n      e: function (t) {\n        a = !0, r = t;\n      },\n      f: function () {\n        try {\n          s || null == i.return || i.return();\n        } finally {\n          if (a) throw r;\n        }\n      }\n    };\n  }\n\n  function Vm(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var i = 0, o = new Array(e); i < e; i++) o[i] = t[i];\n\n    return o;\n  }\n\n  var qm = function () {\n    function t(e, i, o) {\n      var n, r, s, a, h, d, l, c, u, f, p, v, g;\n      Ra(this, t), this.body = e, this.canvas = i, this.selectionHandler = o, this.navigationHandler = new Hm(e, i), this.body.eventListeners.onTap = si(n = this.onTap).call(n, this), this.body.eventListeners.onTouch = si(r = this.onTouch).call(r, this), this.body.eventListeners.onDoubleTap = si(s = this.onDoubleTap).call(s, this), this.body.eventListeners.onHold = si(a = this.onHold).call(a, this), this.body.eventListeners.onDragStart = si(h = this.onDragStart).call(h, this), this.body.eventListeners.onDrag = si(d = this.onDrag).call(d, this), this.body.eventListeners.onDragEnd = si(l = this.onDragEnd).call(l, this), this.body.eventListeners.onMouseWheel = si(c = this.onMouseWheel).call(c, this), this.body.eventListeners.onPinch = si(u = this.onPinch).call(u, this), this.body.eventListeners.onMouseMove = si(f = this.onMouseMove).call(f, this), this.body.eventListeners.onRelease = si(p = this.onRelease).call(p, this), this.body.eventListeners.onContext = si(v = this.onContext).call(v, this), this.touchTime = 0, this.drag = {}, this.pinch = {}, this.popup = void 0, this.popupObj = void 0, this.popupTimer = void 0, this.body.functions.getPointer = si(g = this.getPointer).call(g, this), this.options = {}, this.defaultOptions = {\n        dragNodes: !0,\n        dragView: !0,\n        hover: !1,\n        keyboard: {\n          enabled: !1,\n          speed: {\n            x: 10,\n            y: 10,\n            zoom: .02\n          },\n          bindToWindow: !0,\n          autoFocus: !0\n        },\n        navigationButtons: !1,\n        tooltipDelay: 300,\n        zoomView: !0,\n        zoomSpeed: 1\n      }, Ke(this.options, this.defaultOptions), this.bindEventListeners();\n    }\n\n    return Ha(t, [{\n      key: \"bindEventListeners\",\n      value: function () {\n        var t = this;\n        this.body.emitter.on(\"destroy\", function () {\n          clearTimeout(t.popupTimer), delete t.body.functions.getPointer;\n        });\n      }\n    }, {\n      key: \"setOptions\",\n      value: function (t) {\n        if (void 0 !== t) {\n          rf([\"hideEdgesOnDrag\", \"hideEdgesOnZoom\", \"hideNodesOnDrag\", \"keyboard\", \"multiselect\", \"selectable\", \"selectConnectedEdges\"], this.options, t), _f(this.options, t, \"keyboard\"), t.tooltip && (Ke(this.options.tooltip, t.tooltip), t.tooltip.color && (this.options.tooltip.color = pf(t.tooltip.color)));\n        }\n\n        this.navigationHandler.setOptions(this.options);\n      }\n    }, {\n      key: \"getPointer\",\n      value: function (t) {\n        return {\n          x: t.x - (e = this.canvas.frame.canvas, e.getBoundingClientRect().left),\n          y: t.y - df(this.canvas.frame.canvas)\n        };\n        var e;\n      }\n    }, {\n      key: \"onTouch\",\n      value: function (t) {\n        new Date().valueOf() - this.touchTime > 50 && (this.drag.pointer = this.getPointer(t.center), this.drag.pinched = !1, this.pinch.scale = this.body.view.scale, this.touchTime = new Date().valueOf());\n      }\n    }, {\n      key: \"onTap\",\n      value: function (t) {\n        var e = this.getPointer(t.center),\n            i = this.selectionHandler.options.multiselect && (t.changedPointers[0].ctrlKey || t.changedPointers[0].metaKey);\n        this.checkSelectionChanges(e, i), this.selectionHandler.commitAndEmit(e, t), this.selectionHandler.generateClickEvent(\"click\", t, e);\n      }\n    }, {\n      key: \"onDoubleTap\",\n      value: function (t) {\n        var e = this.getPointer(t.center);\n        this.selectionHandler.generateClickEvent(\"doubleClick\", t, e);\n      }\n    }, {\n      key: \"onHold\",\n      value: function (t) {\n        var e = this.getPointer(t.center),\n            i = this.selectionHandler.options.multiselect;\n        this.checkSelectionChanges(e, i), this.selectionHandler.commitAndEmit(e, t), this.selectionHandler.generateClickEvent(\"click\", t, e), this.selectionHandler.generateClickEvent(\"hold\", t, e);\n      }\n    }, {\n      key: \"onRelease\",\n      value: function (t) {\n        if (new Date().valueOf() - this.touchTime > 10) {\n          var e = this.getPointer(t.center);\n          this.selectionHandler.generateClickEvent(\"release\", t, e), this.touchTime = new Date().valueOf();\n        }\n      }\n    }, {\n      key: \"onContext\",\n      value: function (t) {\n        var e = this.getPointer({\n          x: t.clientX,\n          y: t.clientY\n        });\n        this.selectionHandler.generateClickEvent(\"oncontext\", t, e);\n      }\n    }, {\n      key: \"checkSelectionChanges\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n        !0 === e ? this.selectionHandler.selectAdditionalOnPoint(t) : this.selectionHandler.selectOnPoint(t);\n      }\n    }, {\n      key: \"_determineDifference\",\n      value: function (t, e) {\n        var i = function (t, e) {\n          for (var i = [], o = 0; o < t.length; o++) {\n            var n = t[o];\n            -1 === Cl(e).call(e, n) && i.push(n);\n          }\n\n          return i;\n        };\n\n        return {\n          nodes: i(t.nodes, e.nodes),\n          edges: i(t.edges, e.edges)\n        };\n      }\n    }, {\n      key: \"onDragStart\",\n      value: function (t) {\n        if (!this.drag.dragging) {\n          void 0 === this.drag.pointer && this.onTouch(t);\n          var e = this.selectionHandler.getNodeAt(this.drag.pointer);\n\n          if (this.drag.dragging = !0, this.drag.selection = [], this.drag.translation = Ke({}, this.body.view.translation), this.drag.nodeId = void 0, t.srcEvent.shiftKey) {\n            this.body.selectionBox.show = !0;\n            var i = this.getPointer(t.center);\n            this.body.selectionBox.position.start = {\n              x: this.canvas._XconvertDOMtoCanvas(i.x),\n              y: this.canvas._YconvertDOMtoCanvas(i.y)\n            }, this.body.selectionBox.position.end = {\n              x: this.canvas._XconvertDOMtoCanvas(i.x),\n              y: this.canvas._YconvertDOMtoCanvas(i.y)\n            };\n          }\n\n          if (void 0 !== e && !0 === this.options.dragNodes) {\n            this.drag.nodeId = e.id, !1 === e.isSelected() && (this.selectionHandler.unselectAll(), this.selectionHandler.selectObject(e)), this.selectionHandler.generateClickEvent(\"dragStart\", t, this.drag.pointer);\n            var o,\n                n = Wm(this.selectionHandler.getSelectedNodes());\n\n            try {\n              for (n.s(); !(o = n.n()).done;) {\n                var r = o.value,\n                    s = {\n                  id: r.id,\n                  node: r,\n                  x: r.x,\n                  y: r.y,\n                  xFixed: r.options.fixed.x,\n                  yFixed: r.options.fixed.y\n                };\n                r.options.fixed.x = !0, r.options.fixed.y = !0, this.drag.selection.push(s);\n              }\n            } catch (t) {\n              n.e(t);\n            } finally {\n              n.f();\n            }\n          } else this.selectionHandler.generateClickEvent(\"dragStart\", t, this.drag.pointer, void 0, !0);\n        }\n      }\n    }, {\n      key: \"onDrag\",\n      value: function (t) {\n        var e = this;\n\n        if (!0 !== this.drag.pinched) {\n          this.body.emitter.emit(\"unlockNode\");\n          var i = this.getPointer(t.center),\n              o = this.drag.selection;\n\n          if (o && o.length && !0 === this.options.dragNodes) {\n            this.selectionHandler.generateClickEvent(\"dragging\", t, i);\n            var n = i.x - this.drag.pointer.x,\n                r = i.y - this.drag.pointer.y;\n            nd(o).call(o, function (t) {\n              var i = t.node;\n              !1 === t.xFixed && (i.x = e.canvas._XconvertDOMtoCanvas(e.canvas._XconvertCanvasToDOM(t.x) + n)), !1 === t.yFixed && (i.y = e.canvas._YconvertDOMtoCanvas(e.canvas._YconvertCanvasToDOM(t.y) + r));\n            }), this.body.emitter.emit(\"startSimulation\");\n          } else {\n            if (t.srcEvent.shiftKey) {\n              if (this.selectionHandler.generateClickEvent(\"dragging\", t, i, void 0, !0), void 0 === this.drag.pointer) return void this.onDragStart(t);\n              this.body.selectionBox.position.end = {\n                x: this.canvas._XconvertDOMtoCanvas(i.x),\n                y: this.canvas._YconvertDOMtoCanvas(i.y)\n              }, this.body.emitter.emit(\"_requestRedraw\");\n            }\n\n            if (!0 === this.options.dragView && !t.srcEvent.shiftKey) {\n              if (this.selectionHandler.generateClickEvent(\"dragging\", t, i, void 0, !0), void 0 === this.drag.pointer) return void this.onDragStart(t);\n              var s = i.x - this.drag.pointer.x,\n                  a = i.y - this.drag.pointer.y;\n              this.body.view.translation = {\n                x: this.drag.translation.x + s,\n                y: this.drag.translation.y + a\n              }, this.body.emitter.emit(\"_requestRedraw\");\n            }\n          }\n        }\n      }\n    }, {\n      key: \"onDragEnd\",\n      value: function (t) {\n        var e = this;\n\n        if (this.drag.dragging = !1, this.body.selectionBox.show) {\n          var i;\n          this.body.selectionBox.show = !1;\n          var o = this.body.selectionBox.position,\n              n = {\n            minX: Math.min(o.start.x, o.end.x),\n            minY: Math.min(o.start.y, o.end.y),\n            maxX: Math.max(o.start.x, o.end.x),\n            maxY: Math.max(o.start.y, o.end.y)\n          },\n              r = $d(i = this.body.nodeIndices).call(i, function (t) {\n            var i = e.body.nodes[t];\n            return i.x >= n.minX && i.x <= n.maxX && i.y >= n.minY && i.y <= n.maxY;\n          });\n          nd(r).call(r, function (t) {\n            return e.selectionHandler.selectObject(e.body.nodes[t]);\n          });\n          var s = this.getPointer(t.center);\n          this.selectionHandler.commitAndEmit(s, t), this.selectionHandler.generateClickEvent(\"dragEnd\", t, this.getPointer(t.center), void 0, !0), this.body.emitter.emit(\"_requestRedraw\");\n        } else {\n          var a = this.drag.selection;\n          a && a.length ? (nd(a).call(a, function (t) {\n            t.node.options.fixed.x = t.xFixed, t.node.options.fixed.y = t.yFixed;\n          }), this.selectionHandler.generateClickEvent(\"dragEnd\", t, this.getPointer(t.center)), this.body.emitter.emit(\"startSimulation\")) : (this.selectionHandler.generateClickEvent(\"dragEnd\", t, this.getPointer(t.center), void 0, !0), this.body.emitter.emit(\"_requestRedraw\"));\n        }\n      }\n    }, {\n      key: \"onPinch\",\n      value: function (t) {\n        var e = this.getPointer(t.center);\n        this.drag.pinched = !0, void 0 === this.pinch.scale && (this.pinch.scale = 1);\n        var i = this.pinch.scale * t.scale;\n        this.zoom(i, e);\n      }\n    }, {\n      key: \"zoom\",\n      value: function (t, e) {\n        if (!0 === this.options.zoomView) {\n          var i = this.body.view.scale;\n          t < 1e-5 && (t = 1e-5), t > 10 && (t = 10);\n          var o = void 0;\n          void 0 !== this.drag && !0 === this.drag.dragging && (o = this.canvas.DOMtoCanvas(this.drag.pointer));\n          var n = this.body.view.translation,\n              r = t / i,\n              s = (1 - r) * e.x + n.x * r,\n              a = (1 - r) * e.y + n.y * r;\n\n          if (this.body.view.scale = t, this.body.view.translation = {\n            x: s,\n            y: a\n          }, null != o) {\n            var h = this.canvas.canvasToDOM(o);\n            this.drag.pointer.x = h.x, this.drag.pointer.y = h.y;\n          }\n\n          this.body.emitter.emit(\"_requestRedraw\"), i < t ? this.body.emitter.emit(\"zoom\", {\n            direction: \"+\",\n            scale: this.body.view.scale,\n            pointer: e\n          }) : this.body.emitter.emit(\"zoom\", {\n            direction: \"-\",\n            scale: this.body.view.scale,\n            pointer: e\n          });\n        }\n      }\n    }, {\n      key: \"onMouseWheel\",\n      value: function (t) {\n        if (!0 === this.options.zoomView) {\n          if (0 !== t.deltaY) {\n            var e = this.body.view.scale;\n            e *= 1 + (t.deltaY < 0 ? 1 : -1) * (.1 * this.options.zoomSpeed);\n            var i = this.getPointer({\n              x: t.clientX,\n              y: t.clientY\n            });\n            this.zoom(e, i);\n          }\n\n          t.preventDefault();\n        }\n      }\n    }, {\n      key: \"onMouseMove\",\n      value: function (t) {\n        var e = this,\n            i = this.getPointer({\n          x: t.clientX,\n          y: t.clientY\n        }),\n            o = !1;\n        void 0 !== this.popup && (!1 === this.popup.hidden && this._checkHidePopup(i), !1 === this.popup.hidden && (o = !0, this.popup.setPosition(i.x + 3, i.y - 5), this.popup.show())), this.options.keyboard.autoFocus && !1 === this.options.keyboard.bindToWindow && !0 === this.options.keyboard.enabled && this.canvas.frame.focus(), !1 === o && (void 0 !== this.popupTimer && (clearInterval(this.popupTimer), this.popupTimer = void 0), this.drag.dragging || (this.popupTimer = Yl(function () {\n          return e._checkShowPopup(i);\n        }, this.options.tooltipDelay))), !0 === this.options.hover && this.selectionHandler.hoverObject(t, i);\n      }\n    }, {\n      key: \"_checkShowPopup\",\n      value: function (t) {\n        var e = this.canvas._XconvertDOMtoCanvas(t.x),\n            i = this.canvas._YconvertDOMtoCanvas(t.y),\n            o = {\n          left: e,\n          top: i,\n          right: e,\n          bottom: i\n        },\n            n = void 0 === this.popupObj ? void 0 : this.popupObj.id,\n            r = !1,\n            s = \"node\";\n\n        if (void 0 === this.popupObj) {\n          for (var a, h = this.body.nodeIndices, d = this.body.nodes, l = [], c = 0; c < h.length; c++) !0 === (a = d[h[c]]).isOverlappingWith(o) && (r = !0, void 0 !== a.getTitle() && l.push(h[c]));\n\n          l.length > 0 && (this.popupObj = d[l[l.length - 1]], r = !0);\n        }\n\n        if (void 0 === this.popupObj && !1 === r) {\n          for (var u, f = this.body.edgeIndices, p = this.body.edges, v = [], g = 0; g < f.length; g++) !0 === (u = p[f[g]]).isOverlappingWith(o) && !0 === u.connected && void 0 !== u.getTitle() && v.push(f[g]);\n\n          v.length > 0 && (this.popupObj = p[v[v.length - 1]], s = \"edge\");\n        }\n\n        void 0 !== this.popupObj ? this.popupObj.id !== n && (void 0 === this.popup && (this.popup = new zf(this.canvas.frame)), this.popup.popupTargetType = s, this.popup.popupTargetId = this.popupObj.id, this.popup.setPosition(t.x + 3, t.y - 5), this.popup.setText(this.popupObj.getTitle()), this.popup.show(), this.body.emitter.emit(\"showPopup\", this.popupObj.id)) : void 0 !== this.popup && (this.popup.hide(), this.body.emitter.emit(\"hidePopup\"));\n      }\n    }, {\n      key: \"_checkHidePopup\",\n      value: function (t) {\n        var e = this.selectionHandler._pointerToPositionObject(t),\n            i = !1;\n\n        if (\"node\" === this.popup.popupTargetType) {\n          if (void 0 !== this.body.nodes[this.popup.popupTargetId] && !0 === (i = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(e))) {\n            var o = this.selectionHandler.getNodeAt(t);\n            i = void 0 !== o && o.id === this.popup.popupTargetId;\n          }\n        } else void 0 === this.selectionHandler.getNodeAt(t) && void 0 !== this.body.edges[this.popup.popupTargetId] && (i = this.body.edges[this.popup.popupTargetId].isOverlappingWith(e));\n\n        !1 === i && (this.popupObj = void 0, this.popup.hide(), this.body.emitter.emit(\"hidePopup\"));\n      }\n    }]), t;\n  }();\n\n  sv(\"Set\", function (t) {\n    return function () {\n      return t(this, arguments.length ? arguments[0] : void 0);\n    };\n  }, Ov);\n\n  var Um = O.Set,\n      Ym = hv,\n      Xm = kp.exports.getWeakData,\n      Gm = Kt,\n      Km = E,\n      $m = Up,\n      Zm = qp,\n      Qm = et,\n      Jm = Zi.set,\n      tb = Zi.getterFor,\n      eb = Jr.find,\n      ib = Jr.findIndex,\n      ob = 0,\n      nb = function (t) {\n    return t.frozen || (t.frozen = new rb());\n  },\n      rb = function () {\n    this.entries = [];\n  },\n      sb = function (t, e) {\n    return eb(t.entries, function (t) {\n      return t[0] === e;\n    });\n  };\n\n  rb.prototype = {\n    get: function (t) {\n      var e = sb(this, t);\n      if (e) return e[1];\n    },\n    has: function (t) {\n      return !!sb(this, t);\n    },\n    set: function (t, e) {\n      var i = sb(this, t);\n      i ? i[1] = e : this.entries.push([t, e]);\n    },\n    delete: function (t) {\n      var e = ib(this.entries, function (e) {\n        return e[0] === t;\n      });\n      return ~e && this.entries.splice(e, 1), !!~e;\n    }\n  };\n\n  var ab,\n      hb = {\n    getConstructor: function (t, e, i, o) {\n      var n = t(function (t, r) {\n        $m(t, n, e), Jm(t, {\n          type: e,\n          id: ob++,\n          frozen: void 0\n        }), null != r && Zm(r, t[o], {\n          that: t,\n          AS_ENTRIES: i\n        });\n      }),\n          r = tb(e),\n          s = function (t, e, i) {\n        var o = r(t),\n            n = Xm(Gm(e), !0);\n        return !0 === n ? nb(o).set(e, i) : n[o.id] = i, t;\n      };\n\n      return Ym(n.prototype, {\n        delete: function (t) {\n          var e = r(this);\n          if (!Km(t)) return !1;\n          var i = Xm(t);\n          return !0 === i ? nb(e).delete(t) : i && Qm(i, e.id) && delete i[e.id];\n        },\n        has: function (t) {\n          var e = r(this);\n          if (!Km(t)) return !1;\n          var i = Xm(t);\n          return !0 === i ? nb(e).has(t) : i && Qm(i, e.id);\n        }\n      }), Ym(n.prototype, i ? {\n        get: function (t) {\n          var e = r(this);\n\n          if (Km(t)) {\n            var i = Xm(t);\n            return !0 === i ? nb(e).get(t) : i ? i[e.id] : void 0;\n          }\n        },\n        set: function (t, e) {\n          return s(this, t, e);\n        }\n      } : {\n        add: function (t) {\n          return s(this, t, !0);\n        }\n      }), n;\n    }\n  },\n      db = n,\n      lb = hv,\n      cb = kp.exports,\n      ub = sv,\n      fb = hb,\n      pb = E,\n      vb = Zi.enforce,\n      gb = Mi,\n      yb = !db.ActiveXObject && \"ActiveXObject\" in db,\n      mb = Object.isExtensible,\n      bb = function (t) {\n    return function () {\n      return t(this, arguments.length ? arguments[0] : void 0);\n    };\n  },\n      wb = ub(\"WeakMap\", bb, fb);\n\n  if (gb && yb) {\n    ab = fb.getConstructor(bb, \"WeakMap\", !0), cb.enable();\n    var kb = wb.prototype,\n        _b = kb.delete,\n        xb = kb.has,\n        Eb = kb.get,\n        Ob = kb.set;\n    lb(kb, {\n      delete: function (t) {\n        if (pb(t) && !mb(t)) {\n          var e = vb(this);\n          return e.frozen || (e.frozen = new ab()), _b.call(this, t) || e.frozen.delete(t);\n        }\n\n        return _b.call(this, t);\n      },\n      has: function (t) {\n        if (pb(t) && !mb(t)) {\n          var e = vb(this);\n          return e.frozen || (e.frozen = new ab()), xb.call(this, t) || e.frozen.has(t);\n        }\n\n        return xb.call(this, t);\n      },\n      get: function (t) {\n        if (pb(t) && !mb(t)) {\n          var e = vb(this);\n          return e.frozen || (e.frozen = new ab()), xb.call(this, t) ? Eb.call(this, t) : e.frozen.get(t);\n        }\n\n        return Eb.call(this, t);\n      },\n      set: function (t, e) {\n        if (pb(t) && !mb(t)) {\n          var i = vb(this);\n          i.frozen || (i.frozen = new ab()), xb.call(this, t) ? Ob.call(this, t, e) : i.frozen.set(t, e);\n        } else Ob.call(this, t, e);\n\n        return this;\n      }\n    });\n  }\n\n  var Cb,\n      Sb,\n      Tb,\n      Mb,\n      Pb,\n      Db = O.WeakMap;\n  /*! *****************************************************************************\n  \tCopyright (c) Microsoft Corporation.\n  \n  \tPermission to use, copy, modify, and/or distribute this software for any\n  \tpurpose with or without fee is hereby granted.\n  \n  \tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  \tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n  \tAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  \tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n  \tLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n  \tOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n  \tPERFORMANCE OF THIS SOFTWARE.\n  \t***************************************************************************** */\n\n  function Bb(t, e, i, o) {\n    if (\"a\" === i && !o) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (\"function\" == typeof e ? t !== e || !o : !e.has(t)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return \"m\" === i ? o : \"a\" === i ? o.call(t) : o ? o.value : e.get(t);\n  }\n\n  function Ib(t, e, i, o, n) {\n    if (\"m\" === o) throw new TypeError(\"Private method is not writable\");\n    if (\"a\" === o && !n) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (\"function\" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return \"a\" === o ? n.call(t, i) : n ? n.value = i : e.set(t, i), i;\n  }\n\n  function zb(t, e) {\n    var i = void 0 !== Nh && xr(t) || t[\"@@iterator\"];\n\n    if (!i) {\n      if (Hh(t) || (i = function (t, e) {\n        var i;\n        if (!t) return;\n        if (\"string\" == typeof t) return Fb(t, e);\n        var o = Lh(i = Object.prototype.toString.call(t)).call(i, 8, -1);\n        \"Object\" === o && t.constructor && (o = t.constructor.name);\n        if (\"Map\" === o || \"Set\" === o) return rr(t);\n        if (\"Arguments\" === o || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)) return Fb(t, e);\n      }(t)) || e && t && \"number\" == typeof t.length) {\n        i && (t = i);\n\n        var o = 0,\n            n = function () {};\n\n        return {\n          s: n,\n          n: function () {\n            return o >= t.length ? {\n              done: !0\n            } : {\n              done: !1,\n              value: t[o++]\n            };\n          },\n          e: function (t) {\n            throw t;\n          },\n          f: n\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var r,\n        s = !0,\n        a = !1;\n    return {\n      s: function () {\n        i = i.call(t);\n      },\n      n: function () {\n        var t = i.next();\n        return s = t.done, t;\n      },\n      e: function (t) {\n        a = !0, r = t;\n      },\n      f: function () {\n        try {\n          s || null == i.return || i.return();\n        } finally {\n          if (a) throw r;\n        }\n      }\n    };\n  }\n\n  function Fb(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var i = 0, o = new Array(e); i < e; i++) o[i] = t[i];\n\n    return o;\n  }\n\n  function Nb(t, e) {\n    var i,\n        o = new Um(),\n        n = zb(e);\n\n    try {\n      for (n.s(); !(i = n.n()).done;) {\n        var r = i.value;\n        t.has(r) || o.add(r);\n      }\n    } catch (t) {\n      n.e(t);\n    } finally {\n      n.f();\n    }\n\n    return o;\n  }\n\n  var Ab = function () {\n    function t() {\n      Ra(this, t), Cb.set(this, new Um()), Sb.set(this, new Um());\n    }\n\n    return Ha(t, [{\n      key: \"size\",\n      get: function () {\n        return Bb(this, Sb, \"f\").size;\n      }\n    }, {\n      key: \"add\",\n      value: function () {\n        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];\n\n        for (var o = 0, n = e; o < n.length; o++) {\n          var r = n[o];\n          Bb(this, Sb, \"f\").add(r);\n        }\n      }\n    }, {\n      key: \"delete\",\n      value: function () {\n        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];\n\n        for (var o = 0, n = e; o < n.length; o++) {\n          var r = n[o];\n          Bb(this, Sb, \"f\").delete(r);\n        }\n      }\n    }, {\n      key: \"clear\",\n      value: function () {\n        Bb(this, Sb, \"f\").clear();\n      }\n    }, {\n      key: \"getSelection\",\n      value: function () {\n        return Fh(Bb(this, Sb, \"f\"));\n      }\n    }, {\n      key: \"getChanges\",\n      value: function () {\n        return {\n          added: Fh(Nb(Bb(this, Cb, \"f\"), Bb(this, Sb, \"f\"))),\n          deleted: Fh(Nb(Bb(this, Sb, \"f\"), Bb(this, Cb, \"f\"))),\n          previous: Fh(new Um(Bb(this, Cb, \"f\"))),\n          current: Fh(new Um(Bb(this, Sb, \"f\")))\n        };\n      }\n    }, {\n      key: \"commit\",\n      value: function () {\n        var t = this.getChanges();\n        Ib(this, Cb, Bb(this, Sb, \"f\"), \"f\"), Ib(this, Sb, new Um(Bb(this, Cb, \"f\")), \"f\");\n        var e,\n            i = zb(t.added);\n\n        try {\n          for (i.s(); !(e = i.n()).done;) {\n            e.value.select();\n          }\n        } catch (t) {\n          i.e(t);\n        } finally {\n          i.f();\n        }\n\n        var o,\n            n = zb(t.deleted);\n\n        try {\n          for (n.s(); !(o = n.n()).done;) {\n            o.value.unselect();\n          }\n        } catch (t) {\n          n.e(t);\n        } finally {\n          n.f();\n        }\n\n        return t;\n      }\n    }]), t;\n  }();\n\n  Cb = new Db(), Sb = new Db();\n\n  var Rb = function () {\n    function t() {\n      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {};\n      Ra(this, t), Tb.set(this, new Ab()), Mb.set(this, new Ab()), Pb.set(this, void 0), Ib(this, Pb, e, \"f\");\n    }\n\n    return Ha(t, [{\n      key: \"sizeNodes\",\n      get: function () {\n        return Bb(this, Tb, \"f\").size;\n      }\n    }, {\n      key: \"sizeEdges\",\n      get: function () {\n        return Bb(this, Mb, \"f\").size;\n      }\n    }, {\n      key: \"getNodes\",\n      value: function () {\n        return Bb(this, Tb, \"f\").getSelection();\n      }\n    }, {\n      key: \"getEdges\",\n      value: function () {\n        return Bb(this, Mb, \"f\").getSelection();\n      }\n    }, {\n      key: \"addNodes\",\n      value: function () {\n        var t;\n        (t = Bb(this, Tb, \"f\")).add.apply(t, arguments);\n      }\n    }, {\n      key: \"addEdges\",\n      value: function () {\n        var t;\n        (t = Bb(this, Mb, \"f\")).add.apply(t, arguments);\n      }\n    }, {\n      key: \"deleteNodes\",\n      value: function (t) {\n        Bb(this, Tb, \"f\").delete(t);\n      }\n    }, {\n      key: \"deleteEdges\",\n      value: function (t) {\n        Bb(this, Mb, \"f\").delete(t);\n      }\n    }, {\n      key: \"clear\",\n      value: function () {\n        Bb(this, Tb, \"f\").clear(), Bb(this, Mb, \"f\").clear();\n      }\n    }, {\n      key: \"commit\",\n      value: function () {\n        for (var t, e, i = {\n          nodes: Bb(this, Tb, \"f\").commit(),\n          edges: Bb(this, Mb, \"f\").commit()\n        }, o = arguments.length, n = new Array(o), r = 0; r < o; r++) n[r] = arguments[r];\n\n        return (t = Bb(this, Pb, \"f\")).call.apply(t, jh(e = [this, i]).call(e, n)), i;\n      }\n    }]), t;\n  }();\n\n  function jb(t, e) {\n    var i = void 0 !== Nh && xr(t) || t[\"@@iterator\"];\n\n    if (!i) {\n      if (Hh(t) || (i = function (t, e) {\n        var i;\n        if (!t) return;\n        if (\"string\" == typeof t) return Lb(t, e);\n        var o = Lh(i = Object.prototype.toString.call(t)).call(i, 8, -1);\n        \"Object\" === o && t.constructor && (o = t.constructor.name);\n        if (\"Map\" === o || \"Set\" === o) return rr(t);\n        if (\"Arguments\" === o || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)) return Lb(t, e);\n      }(t)) || e && t && \"number\" == typeof t.length) {\n        i && (t = i);\n\n        var o = 0,\n            n = function () {};\n\n        return {\n          s: n,\n          n: function () {\n            return o >= t.length ? {\n              done: !0\n            } : {\n              done: !1,\n              value: t[o++]\n            };\n          },\n          e: function (t) {\n            throw t;\n          },\n          f: n\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var r,\n        s = !0,\n        a = !1;\n    return {\n      s: function () {\n        i = i.call(t);\n      },\n      n: function () {\n        var t = i.next();\n        return s = t.done, t;\n      },\n      e: function (t) {\n        a = !0, r = t;\n      },\n      f: function () {\n        try {\n          s || null == i.return || i.return();\n        } finally {\n          if (a) throw r;\n        }\n      }\n    };\n  }\n\n  function Lb(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var i = 0, o = new Array(e); i < e; i++) o[i] = t[i];\n\n    return o;\n  }\n\n  Tb = new Db(), Mb = new Db(), Pb = new Db();\n\n  var Hb = function () {\n    function t(e, i) {\n      var o = this;\n      Ra(this, t), this.body = e, this.canvas = i, this._selectionAccumulator = new Rb(), this.hoverObj = {\n        nodes: {},\n        edges: {}\n      }, this.options = {}, this.defaultOptions = {\n        multiselect: !1,\n        selectable: !0,\n        selectConnectedEdges: !0,\n        hoverConnectedEdges: !0\n      }, Ke(this.options, this.defaultOptions), this.body.emitter.on(\"_dataChanged\", function () {\n        o.updateSelection();\n      });\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function (t) {\n        if (void 0 !== t) {\n          nf([\"multiselect\", \"hoverConnectedEdges\", \"selectable\", \"selectConnectedEdges\"], this.options, t);\n        }\n      }\n    }, {\n      key: \"selectOnPoint\",\n      value: function (t) {\n        var e = !1;\n\n        if (!0 === this.options.selectable) {\n          var i = this.getNodeAt(t) || this.getEdgeAt(t);\n          this.unselectAll(), void 0 !== i && (e = this.selectObject(i)), this.body.emitter.emit(\"_requestRedraw\");\n        }\n\n        return e;\n      }\n    }, {\n      key: \"selectAdditionalOnPoint\",\n      value: function (t) {\n        var e = !1;\n\n        if (!0 === this.options.selectable) {\n          var i = this.getNodeAt(t) || this.getEdgeAt(t);\n          void 0 !== i && (e = !0, !0 === i.isSelected() ? this.deselectObject(i) : this.selectObject(i), this.body.emitter.emit(\"_requestRedraw\"));\n        }\n\n        return e;\n      }\n    }, {\n      key: \"_initBaseEvent\",\n      value: function (t, e) {\n        var i = {};\n        return i.pointer = {\n          DOM: {\n            x: e.x,\n            y: e.y\n          },\n          canvas: this.canvas.DOMtoCanvas(e)\n        }, i.event = t, i;\n      }\n    }, {\n      key: \"generateClickEvent\",\n      value: function (t, e, i, o) {\n        var n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],\n            r = this._initBaseEvent(e, i);\n\n        if (!0 === n) r.nodes = [], r.edges = [];else {\n          var s = this.getSelection();\n          r.nodes = s.nodes, r.edges = s.edges;\n        }\n        void 0 !== o && (r.previousSelection = o), \"click\" == t && (r.items = this.getClickedItems(i)), void 0 !== e.controlEdge && (r.controlEdge = e.controlEdge), this.body.emitter.emit(t, r);\n      }\n    }, {\n      key: \"selectObject\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.options.selectConnectedEdges;\n\n        if (void 0 !== t) {\n          if (t instanceof uy) {\n            var i;\n            if (!0 === e) (i = this._selectionAccumulator).addEdges.apply(i, Fh(t.edges));\n\n            this._selectionAccumulator.addNodes(t);\n          } else this._selectionAccumulator.addEdges(t);\n\n          return !0;\n        }\n\n        return !1;\n      }\n    }, {\n      key: \"deselectObject\",\n      value: function (t) {\n        !0 === t.isSelected() && (t.selected = !1, this._removeFromSelection(t));\n      }\n    }, {\n      key: \"_getAllNodesOverlappingWith\",\n      value: function (t) {\n        for (var e = [], i = this.body.nodes, o = 0; o < this.body.nodeIndices.length; o++) {\n          var n = this.body.nodeIndices[o];\n          i[n].isOverlappingWith(t) && e.push(n);\n        }\n\n        return e;\n      }\n    }, {\n      key: \"_pointerToPositionObject\",\n      value: function (t) {\n        var e = this.canvas.DOMtoCanvas(t);\n        return {\n          left: e.x - 1,\n          top: e.y + 1,\n          right: e.x + 1,\n          bottom: e.y - 1\n        };\n      }\n    }, {\n      key: \"getNodeAt\",\n      value: function (t) {\n        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],\n            i = this._pointerToPositionObject(t),\n            o = this._getAllNodesOverlappingWith(i);\n\n        return o.length > 0 ? !0 === e ? this.body.nodes[o[o.length - 1]] : o[o.length - 1] : void 0;\n      }\n    }, {\n      key: \"_getEdgesOverlappingWith\",\n      value: function (t, e) {\n        for (var i = this.body.edges, o = 0; o < this.body.edgeIndices.length; o++) {\n          var n = this.body.edgeIndices[o];\n          i[n].isOverlappingWith(t) && e.push(n);\n        }\n      }\n    }, {\n      key: \"_getAllEdgesOverlappingWith\",\n      value: function (t) {\n        var e = [];\n        return this._getEdgesOverlappingWith(t, e), e;\n      }\n    }, {\n      key: \"getEdgeAt\",\n      value: function (t) {\n        for (var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = this.canvas.DOMtoCanvas(t), o = 10, n = null, r = this.body.edges, s = 0; s < this.body.edgeIndices.length; s++) {\n          var a = this.body.edgeIndices[s],\n              h = r[a];\n\n          if (h.connected) {\n            var d = h.from.x,\n                l = h.from.y,\n                c = h.to.x,\n                u = h.to.y,\n                f = h.edgeType.getDistanceToEdge(d, l, c, u, i.x, i.y);\n            f < o && (n = a, o = f);\n          }\n        }\n\n        return null !== n ? !0 === e ? this.body.edges[n] : n : void 0;\n      }\n    }, {\n      key: \"_addToHover\",\n      value: function (t) {\n        t instanceof uy ? this.hoverObj.nodes[t.id] = t : this.hoverObj.edges[t.id] = t;\n      }\n    }, {\n      key: \"_removeFromSelection\",\n      value: function (t) {\n        var e;\n        t instanceof uy ? (this._selectionAccumulator.deleteNodes(t), (e = this._selectionAccumulator).deleteEdges.apply(e, Fh(t.edges))) : this._selectionAccumulator.deleteEdges(t);\n      }\n    }, {\n      key: \"unselectAll\",\n      value: function () {\n        this._selectionAccumulator.clear();\n      }\n    }, {\n      key: \"getSelectedNodeCount\",\n      value: function () {\n        return this._selectionAccumulator.sizeNodes;\n      }\n    }, {\n      key: \"getSelectedEdgeCount\",\n      value: function () {\n        return this._selectionAccumulator.sizeEdges;\n      }\n    }, {\n      key: \"_hoverConnectedEdges\",\n      value: function (t) {\n        for (var e = 0; e < t.edges.length; e++) {\n          var i = t.edges[e];\n          i.hover = !0, this._addToHover(i);\n        }\n      }\n    }, {\n      key: \"emitBlurEvent\",\n      value: function (t, e, i) {\n        var o = this._initBaseEvent(t, e);\n\n        !0 === i.hover && (i.hover = !1, i instanceof uy ? (o.node = i.id, this.body.emitter.emit(\"blurNode\", o)) : (o.edge = i.id, this.body.emitter.emit(\"blurEdge\", o)));\n      }\n    }, {\n      key: \"emitHoverEvent\",\n      value: function (t, e, i) {\n        var o = this._initBaseEvent(t, e),\n            n = !1;\n\n        return !1 === i.hover && (i.hover = !0, this._addToHover(i), n = !0, i instanceof uy ? (o.node = i.id, this.body.emitter.emit(\"hoverNode\", o)) : (o.edge = i.id, this.body.emitter.emit(\"hoverEdge\", o))), n;\n      }\n    }, {\n      key: \"hoverObject\",\n      value: function (t, e) {\n        var i = this.getNodeAt(e);\n        void 0 === i && (i = this.getEdgeAt(e));\n        var o = !1;\n\n        for (var n in this.hoverObj.nodes) Object.prototype.hasOwnProperty.call(this.hoverObj.nodes, n) && (void 0 === i || i instanceof uy && i.id != n || i instanceof sm) && (this.emitBlurEvent(t, e, this.hoverObj.nodes[n]), delete this.hoverObj.nodes[n], o = !0);\n\n        for (var r in this.hoverObj.edges) Object.prototype.hasOwnProperty.call(this.hoverObj.edges, r) && (!0 === o ? (this.hoverObj.edges[r].hover = !1, delete this.hoverObj.edges[r]) : (void 0 === i || i instanceof sm && i.id != r || i instanceof uy && !i.hover) && (this.emitBlurEvent(t, e, this.hoverObj.edges[r]), delete this.hoverObj.edges[r], o = !0));\n\n        if (void 0 !== i) {\n          var s = Gh(this.hoverObj.edges).length,\n              a = Gh(this.hoverObj.nodes).length;\n          (o || i instanceof sm && 0 === s && 0 === a || i instanceof uy && 0 === s && 0 === a) && (o = this.emitHoverEvent(t, e, i)), i instanceof uy && !0 === this.options.hoverConnectedEdges && this._hoverConnectedEdges(i);\n        }\n\n        !0 === o && this.body.emitter.emit(\"_requestRedraw\");\n      }\n    }, {\n      key: \"commitWithoutEmitting\",\n      value: function () {\n        this._selectionAccumulator.commit();\n      }\n    }, {\n      key: \"commitAndEmit\",\n      value: function (t, e) {\n        var i = !1,\n            o = this._selectionAccumulator.commit(),\n            n = {\n          nodes: o.nodes.previous,\n          edges: o.edges.previous\n        };\n\n        o.edges.deleted.length > 0 && (this.generateClickEvent(\"deselectEdge\", e, t, n), i = !0), o.nodes.deleted.length > 0 && (this.generateClickEvent(\"deselectNode\", e, t, n), i = !0), o.nodes.added.length > 0 && (this.generateClickEvent(\"selectNode\", e, t), i = !0), o.edges.added.length > 0 && (this.generateClickEvent(\"selectEdge\", e, t), i = !0), !0 === i && this.generateClickEvent(\"select\", e, t);\n      }\n    }, {\n      key: \"getSelection\",\n      value: function () {\n        return {\n          nodes: this.getSelectedNodeIds(),\n          edges: this.getSelectedEdgeIds()\n        };\n      }\n    }, {\n      key: \"getSelectedNodes\",\n      value: function () {\n        return this._selectionAccumulator.getNodes();\n      }\n    }, {\n      key: \"getSelectedEdges\",\n      value: function () {\n        return this._selectionAccumulator.getEdges();\n      }\n    }, {\n      key: \"getSelectedNodeIds\",\n      value: function () {\n        var t;\n        return Uh(t = this._selectionAccumulator.getNodes()).call(t, function (t) {\n          return t.id;\n        });\n      }\n    }, {\n      key: \"getSelectedEdgeIds\",\n      value: function () {\n        var t;\n        return Uh(t = this._selectionAccumulator.getEdges()).call(t, function (t) {\n          return t.id;\n        });\n      }\n    }, {\n      key: \"setSelection\",\n      value: function (t) {\n        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        if (!t || !t.nodes && !t.edges) throw new TypeError(\"Selection must be an object with nodes and/or edges properties\");\n\n        if ((e.unselectAll || void 0 === e.unselectAll) && this.unselectAll(), t.nodes) {\n          var i,\n              o = jb(t.nodes);\n\n          try {\n            for (o.s(); !(i = o.n()).done;) {\n              var n = i.value,\n                  r = this.body.nodes[n];\n              if (!r) throw new RangeError('Node with id \"' + n + '\" not found');\n              this.selectObject(r, e.highlightEdges);\n            }\n          } catch (t) {\n            o.e(t);\n          } finally {\n            o.f();\n          }\n        }\n\n        if (t.edges) {\n          var s,\n              a = jb(t.edges);\n\n          try {\n            for (a.s(); !(s = a.n()).done;) {\n              var h = s.value,\n                  d = this.body.edges[h];\n              if (!d) throw new RangeError('Edge with id \"' + h + '\" not found');\n              this.selectObject(d);\n            }\n          } catch (t) {\n            a.e(t);\n          } finally {\n            a.f();\n          }\n        }\n\n        this.body.emitter.emit(\"_requestRedraw\"), this._selectionAccumulator.commit();\n      }\n    }, {\n      key: \"selectNodes\",\n      value: function (t) {\n        var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n        if (!t || void 0 === t.length) throw \"Selection must be an array with ids\";\n        this.setSelection({\n          nodes: t\n        }, {\n          highlightEdges: e\n        });\n      }\n    }, {\n      key: \"selectEdges\",\n      value: function (t) {\n        if (!t || void 0 === t.length) throw \"Selection must be an array with ids\";\n        this.setSelection({\n          edges: t\n        });\n      }\n    }, {\n      key: \"updateSelection\",\n      value: function () {\n        for (var t in this._selectionAccumulator.getNodes()) Object.prototype.hasOwnProperty.call(this.body.nodes, t.id) || this._selectionAccumulator.deleteNodes(t);\n\n        for (var e in this._selectionAccumulator.getEdges()) Object.prototype.hasOwnProperty.call(this.body.edges, e.id) || this._selectionAccumulator.deleteEdges(e);\n      }\n    }, {\n      key: \"getClickedItems\",\n      value: function (t) {\n        for (var e = this.canvas.DOMtoCanvas(t), i = [], o = this.body.nodeIndices, n = this.body.nodes, r = o.length - 1; r >= 0; r--) {\n          var s = n[o[r]].getItemsOnPoint(e);\n          i.push.apply(i, s);\n        }\n\n        for (var a = this.body.edgeIndices, h = this.body.edges, d = a.length - 1; d >= 0; d--) {\n          var l = h[a[d]].getItemsOnPoint(e);\n          i.push.apply(i, l);\n        }\n\n        return i;\n      }\n    }]), t;\n  }(),\n      Wb = Math.floor,\n      Vb = function (t, e) {\n    var i = t.length,\n        o = Wb(i / 2);\n    return i < 8 ? qb(t, e) : Ub(Vb(t.slice(0, o), e), Vb(t.slice(o), e), e);\n  },\n      qb = function (t, e) {\n    for (var i, o, n = t.length, r = 1; r < n;) {\n      for (o = r, i = t[r]; o && e(t[o - 1], i) > 0;) t[o] = t[--o];\n\n      o !== r++ && (t[o] = i);\n    }\n\n    return t;\n  },\n      Ub = function (t, e, i) {\n    for (var o = t.length, n = e.length, r = 0, s = 0, a = []; r < o || s < n;) r < o && s < n ? a.push(i(t[r], e[s]) <= 0 ? t[r++] : e[s++]) : a.push(r < o ? t[r++] : e[s++]);\n\n    return a;\n  },\n      Yb = Vb,\n      Xb = P.match(/firefox\\/(\\d+)/i),\n      Gb = !!Xb && +Xb[1],\n      Kb = /MSIE|Trident/.test(P),\n      $b = P.match(/AppleWebKit\\/(\\d+)\\./),\n      Zb = !!$b && +$b[1],\n      Qb = ue,\n      Jb = qt,\n      tw = Q,\n      ew = me,\n      iw = gi,\n      ow = s,\n      nw = Yb,\n      rw = Zh,\n      sw = Gb,\n      aw = Kb,\n      hw = A,\n      dw = Zb,\n      lw = [],\n      cw = lw.sort,\n      uw = ow(function () {\n    lw.sort(void 0);\n  }),\n      fw = ow(function () {\n    lw.sort(null);\n  }),\n      pw = rw(\"sort\"),\n      vw = !ow(function () {\n    if (hw) return hw < 70;\n\n    if (!(sw && sw > 3)) {\n      if (aw) return !0;\n      if (dw) return dw < 603;\n      var t,\n          e,\n          i,\n          o,\n          n = \"\";\n\n      for (t = 65; t < 76; t++) {\n        switch (e = String.fromCharCode(t), t) {\n          case 66:\n          case 69:\n          case 70:\n          case 72:\n            i = 3;\n            break;\n\n          case 68:\n          case 71:\n            i = 4;\n            break;\n\n          default:\n            i = 2;\n        }\n\n        for (o = 0; o < 47; o++) lw.push({\n          k: e + o,\n          v: i\n        });\n      }\n\n      for (lw.sort(function (t, e) {\n        return e.v - t.v;\n      }), o = 0; o < lw.length; o++) e = lw[o].k.charAt(0), n.charAt(n.length - 1) !== e && (n += e);\n\n      return \"DGBEFHACIJK\" !== n;\n    }\n  });\n\n  Qb({\n    target: \"Array\",\n    proto: !0,\n    forced: uw || !fw || !pw || !vw\n  }, {\n    sort: function (t) {\n      void 0 !== t && Jb(t);\n      var e = tw(this);\n      if (vw) return void 0 === t ? cw.call(e) : cw.call(e, t);\n      var i,\n          o,\n          n = [],\n          r = ew(e.length);\n\n      for (o = 0; o < r; o++) o in e && n.push(e[o]);\n\n      for (i = (n = nw(n, function (t) {\n        return function (e, i) {\n          return void 0 === i ? -1 : void 0 === e ? 1 : void 0 !== t ? +t(e, i) || 0 : iw(e) > iw(i) ? 1 : -1;\n        };\n      }(t))).length, o = 0; o < i;) e[o] = n[o++];\n\n      for (; o < r;) delete e[o++];\n\n      return e;\n    }\n  });\n\n  var gw = oi(\"Array\").sort,\n      yw = Array.prototype,\n      mw = function (t) {\n    var e = t.sort;\n    return t === yw || t instanceof Array && e === yw.sort ? gw : e;\n  },\n      bw = qt,\n      ww = Q,\n      kw = b,\n      _w = me,\n      xw = function (t) {\n    return function (e, i, o, n) {\n      bw(i);\n\n      var r = ww(e),\n          s = kw(r),\n          a = _w(r.length),\n          h = t ? a - 1 : 0,\n          d = t ? -1 : 1;\n\n      if (o < 2) for (;;) {\n        if (h in s) {\n          n = s[h], h += d;\n          break;\n        }\n\n        if (h += d, t ? h < 0 : a <= h) throw TypeError(\"Reduce of empty array with no initial value\");\n      }\n\n      for (; t ? h >= 0 : a > h; h += d) h in s && (n = i(n, s[h], h, r));\n\n      return n;\n    };\n  },\n      Ew = {\n    left: xw(!1),\n    right: xw(!0)\n  },\n      Ow = \"process\" == g(n.process),\n      Cw = Ew.left,\n      Sw = A,\n      Tw = Ow;\n\n  ue({\n    target: \"Array\",\n    proto: !0,\n    forced: !Zh(\"reduce\") || !Tw && Sw > 79 && Sw < 83\n  }, {\n    reduce: function (t) {\n      return Cw(this, t, arguments.length, arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n\n  var Mw = oi(\"Array\").reduce,\n      Pw = Array.prototype,\n      Dw = function (t) {\n    var e = t.reduce;\n    return t === Pw || t instanceof Array && e === Pw.reduce ? Mw : e;\n  },\n      Bw = {};\n\n  !function (t) {\n    !function (t) {\n      function e(t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      t.__esModule = !0, t.sort = v;\n      var i = 32,\n          o = 7,\n          n = 256,\n          r = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];\n\n      function s(t) {\n        return t < 1e5 ? t < 100 ? t < 10 ? 0 : 1 : t < 1e4 ? t < 1e3 ? 2 : 3 : 4 : t < 1e7 ? t < 1e6 ? 5 : 6 : t < 1e9 ? t < 1e8 ? 7 : 8 : 9;\n      }\n\n      function a(t, e) {\n        if (t === e) return 0;\n\n        if (~~t === t && ~~e === e) {\n          if (0 === t || 0 === e) return t < e ? -1 : 1;\n\n          if (t < 0 || e < 0) {\n            if (e >= 0) return -1;\n            if (t >= 0) return 1;\n            t = -t, e = -e;\n          }\n\n          var i = s(t),\n              o = s(e),\n              n = 0;\n          return i < o ? (t *= r[o - i - 1], e /= 10, n = -1) : i > o && (e *= r[i - o - 1], t /= 10, n = 1), t === e ? n : t < e ? -1 : 1;\n        }\n\n        var a = String(t),\n            h = String(e);\n        return a === h ? 0 : a < h ? -1 : 1;\n      }\n\n      function h(t) {\n        for (var e = 0; t >= i;) e |= 1 & t, t >>= 1;\n\n        return t + e;\n      }\n\n      function d(t, e, i, o) {\n        var n = e + 1;\n        if (n === i) return 1;\n\n        if (o(t[n++], t[e]) < 0) {\n          for (; n < i && o(t[n], t[n - 1]) < 0;) n++;\n\n          l(t, e, n);\n        } else for (; n < i && o(t[n], t[n - 1]) >= 0;) n++;\n\n        return n - e;\n      }\n\n      function l(t, e, i) {\n        for (i--; e < i;) {\n          var o = t[e];\n          t[e++] = t[i], t[i--] = o;\n        }\n      }\n\n      function c(t, e, i, o, n) {\n        for (o === e && o++; o < i; o++) {\n          for (var r = t[o], s = e, a = o; s < a;) {\n            var h = s + a >>> 1;\n            n(r, t[h]) < 0 ? a = h : s = h + 1;\n          }\n\n          var d = o - s;\n\n          switch (d) {\n            case 3:\n              t[s + 3] = t[s + 2];\n\n            case 2:\n              t[s + 2] = t[s + 1];\n\n            case 1:\n              t[s + 1] = t[s];\n              break;\n\n            default:\n              for (; d > 0;) t[s + d] = t[s + d - 1], d--;\n\n          }\n\n          t[s] = r;\n        }\n      }\n\n      function u(t, e, i, o, n, r) {\n        var s = 0,\n            a = 0,\n            h = 1;\n\n        if (r(t, e[i + n]) > 0) {\n          for (a = o - n; h < a && r(t, e[i + n + h]) > 0;) s = h, (h = 1 + (h << 1)) <= 0 && (h = a);\n\n          h > a && (h = a), s += n, h += n;\n        } else {\n          for (a = n + 1; h < a && r(t, e[i + n - h]) <= 0;) s = h, (h = 1 + (h << 1)) <= 0 && (h = a);\n\n          h > a && (h = a);\n          var d = s;\n          s = n - h, h = n - d;\n        }\n\n        for (s++; s < h;) {\n          var l = s + (h - s >>> 1);\n          r(t, e[i + l]) > 0 ? s = l + 1 : h = l;\n        }\n\n        return h;\n      }\n\n      function f(t, e, i, o, n, r) {\n        var s = 0,\n            a = 0,\n            h = 1;\n\n        if (r(t, e[i + n]) < 0) {\n          for (a = n + 1; h < a && r(t, e[i + n - h]) < 0;) s = h, (h = 1 + (h << 1)) <= 0 && (h = a);\n\n          h > a && (h = a);\n          var d = s;\n          s = n - h, h = n - d;\n        } else {\n          for (a = o - n; h < a && r(t, e[i + n + h]) >= 0;) s = h, (h = 1 + (h << 1)) <= 0 && (h = a);\n\n          h > a && (h = a), s += n, h += n;\n        }\n\n        for (s++; s < h;) {\n          var l = s + (h - s >>> 1);\n          r(t, e[i + l]) < 0 ? h = l : s = l + 1;\n        }\n\n        return h;\n      }\n\n      var p = function () {\n        function t(i, r) {\n          e(this, t), this.array = null, this.compare = null, this.minGallop = o, this.length = 0, this.tmpStorageLength = n, this.stackLength = 0, this.runStart = null, this.runLength = null, this.stackSize = 0, this.array = i, this.compare = r, this.length = i.length, this.length < 2 * n && (this.tmpStorageLength = this.length >>> 1), this.tmp = new Array(this.tmpStorageLength), this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40, this.runStart = new Array(this.stackLength), this.runLength = new Array(this.stackLength);\n        }\n\n        return t.prototype.pushRun = function (t, e) {\n          this.runStart[this.stackSize] = t, this.runLength[this.stackSize] = e, this.stackSize += 1;\n        }, t.prototype.mergeRuns = function () {\n          for (; this.stackSize > 1;) {\n            var t = this.stackSize - 2;\n            if (t >= 1 && this.runLength[t - 1] <= this.runLength[t] + this.runLength[t + 1] || t >= 2 && this.runLength[t - 2] <= this.runLength[t] + this.runLength[t - 1]) this.runLength[t - 1] < this.runLength[t + 1] && t--;else if (this.runLength[t] > this.runLength[t + 1]) break;\n            this.mergeAt(t);\n          }\n        }, t.prototype.forceMergeRuns = function () {\n          for (; this.stackSize > 1;) {\n            var t = this.stackSize - 2;\n            t > 0 && this.runLength[t - 1] < this.runLength[t + 1] && t--, this.mergeAt(t);\n          }\n        }, t.prototype.mergeAt = function (t) {\n          var e = this.compare,\n              i = this.array,\n              o = this.runStart[t],\n              n = this.runLength[t],\n              r = this.runStart[t + 1],\n              s = this.runLength[t + 1];\n          this.runLength[t] = n + s, t === this.stackSize - 3 && (this.runStart[t + 1] = this.runStart[t + 2], this.runLength[t + 1] = this.runLength[t + 2]), this.stackSize--;\n          var a = f(i[r], i, o, n, 0, e);\n          o += a, 0 != (n -= a) && 0 !== (s = u(i[o + n - 1], i, r, s, s - 1, e)) && (n <= s ? this.mergeLow(o, n, r, s) : this.mergeHigh(o, n, r, s));\n        }, t.prototype.mergeLow = function (t, e, i, n) {\n          var r = this.compare,\n              s = this.array,\n              a = this.tmp,\n              h = 0;\n\n          for (h = 0; h < e; h++) a[h] = s[t + h];\n\n          var d = 0,\n              l = i,\n              c = t;\n          if (s[c++] = s[l++], 0 != --n) {\n            if (1 !== e) {\n              for (var p = this.minGallop;;) {\n                var v = 0,\n                    g = 0,\n                    y = !1;\n\n                do {\n                  if (r(s[l], a[d]) < 0) {\n                    if (s[c++] = s[l++], g++, v = 0, 0 == --n) {\n                      y = !0;\n                      break;\n                    }\n                  } else if (s[c++] = a[d++], v++, g = 0, 1 == --e) {\n                    y = !0;\n                    break;\n                  }\n                } while ((v | g) < p);\n\n                if (y) break;\n\n                do {\n                  if (0 !== (v = f(s[l], a, d, e, 0, r))) {\n                    for (h = 0; h < v; h++) s[c + h] = a[d + h];\n\n                    if (c += v, d += v, (e -= v) <= 1) {\n                      y = !0;\n                      break;\n                    }\n                  }\n\n                  if (s[c++] = s[l++], 0 == --n) {\n                    y = !0;\n                    break;\n                  }\n\n                  if (0 !== (g = u(a[d], s, l, n, 0, r))) {\n                    for (h = 0; h < g; h++) s[c + h] = s[l + h];\n\n                    if (c += g, l += g, 0 == (n -= g)) {\n                      y = !0;\n                      break;\n                    }\n                  }\n\n                  if (s[c++] = a[d++], 1 == --e) {\n                    y = !0;\n                    break;\n                  }\n\n                  p--;\n                } while (v >= o || g >= o);\n\n                if (y) break;\n                p < 0 && (p = 0), p += 2;\n              }\n\n              if (this.minGallop = p, p < 1 && (this.minGallop = 1), 1 === e) {\n                for (h = 0; h < n; h++) s[c + h] = s[l + h];\n\n                s[c + n] = a[d];\n              } else {\n                if (0 === e) throw new Error(\"mergeLow preconditions were not respected\");\n\n                for (h = 0; h < e; h++) s[c + h] = a[d + h];\n              }\n            } else {\n              for (h = 0; h < n; h++) s[c + h] = s[l + h];\n\n              s[c + n] = a[d];\n            }\n          } else for (h = 0; h < e; h++) s[c + h] = a[d + h];\n        }, t.prototype.mergeHigh = function (t, e, i, n) {\n          var r = this.compare,\n              s = this.array,\n              a = this.tmp,\n              h = 0;\n\n          for (h = 0; h < n; h++) a[h] = s[i + h];\n\n          var d = t + e - 1,\n              l = n - 1,\n              c = i + n - 1,\n              p = 0,\n              v = 0;\n          if (s[c--] = s[d--], 0 != --e) {\n            if (1 !== n) {\n              for (var g = this.minGallop;;) {\n                var y = 0,\n                    m = 0,\n                    b = !1;\n\n                do {\n                  if (r(a[l], s[d]) < 0) {\n                    if (s[c--] = s[d--], y++, m = 0, 0 == --e) {\n                      b = !0;\n                      break;\n                    }\n                  } else if (s[c--] = a[l--], m++, y = 0, 1 == --n) {\n                    b = !0;\n                    break;\n                  }\n                } while ((y | m) < g);\n\n                if (b) break;\n\n                do {\n                  if (0 != (y = e - f(a[l], s, t, e, e - 1, r))) {\n                    for (e -= y, v = 1 + (c -= y), p = 1 + (d -= y), h = y - 1; h >= 0; h--) s[v + h] = s[p + h];\n\n                    if (0 === e) {\n                      b = !0;\n                      break;\n                    }\n                  }\n\n                  if (s[c--] = a[l--], 1 == --n) {\n                    b = !0;\n                    break;\n                  }\n\n                  if (0 != (m = n - u(s[d], a, 0, n, n - 1, r))) {\n                    for (n -= m, v = 1 + (c -= m), p = 1 + (l -= m), h = 0; h < m; h++) s[v + h] = a[p + h];\n\n                    if (n <= 1) {\n                      b = !0;\n                      break;\n                    }\n                  }\n\n                  if (s[c--] = s[d--], 0 == --e) {\n                    b = !0;\n                    break;\n                  }\n\n                  g--;\n                } while (y >= o || m >= o);\n\n                if (b) break;\n                g < 0 && (g = 0), g += 2;\n              }\n\n              if (this.minGallop = g, g < 1 && (this.minGallop = 1), 1 === n) {\n                for (v = 1 + (c -= e), p = 1 + (d -= e), h = e - 1; h >= 0; h--) s[v + h] = s[p + h];\n\n                s[c] = a[l];\n              } else {\n                if (0 === n) throw new Error(\"mergeHigh preconditions were not respected\");\n\n                for (p = c - (n - 1), h = 0; h < n; h++) s[p + h] = a[h];\n              }\n            } else {\n              for (v = 1 + (c -= e), p = 1 + (d -= e), h = e - 1; h >= 0; h--) s[v + h] = s[p + h];\n\n              s[c] = a[l];\n            }\n          } else for (p = c - (n - 1), h = 0; h < n; h++) s[p + h] = a[h];\n        }, t;\n      }();\n\n      function v(t, e, o, n) {\n        if (!Array.isArray(t)) throw new TypeError(\"Can only sort arrays\");\n        e ? \"function\" != typeof e && (n = o, o = e, e = a) : e = a, o || (o = 0), n || (n = t.length);\n        var r = n - o;\n\n        if (!(r < 2)) {\n          var s = 0;\n          if (r < i) c(t, o, n, o + (s = d(t, o, n, e)), e);else {\n            var l = new p(t, e),\n                u = h(r);\n\n            do {\n              if ((s = d(t, o, n, e)) < u) {\n                var f = r;\n                f > u && (f = u), c(t, o, o + f, o + s, e), s = f;\n              }\n\n              l.pushRun(o, s), l.mergeRuns(), r -= s, o += s;\n            } while (0 !== r);\n\n            l.forceMergeRuns();\n          }\n        }\n      }\n    }(t);\n  }(Bw);\n  var Iw = Bw;\n\n  function zw(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !yg) return !1;\n      if (yg.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Boolean.prototype.valueOf.call(yg(Boolean, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var i,\n          o = Eg(t);\n\n      if (e) {\n        var n = Eg(this).constructor;\n        i = yg(o, arguments, n);\n      } else i = o.apply(this, arguments);\n\n      return _g(this, i);\n    };\n  }\n\n  var Fw = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, [{\n      key: \"abstract\",\n      value: function () {\n        throw new Error(\"Can't instantiate abstract class!\");\n      }\n    }, {\n      key: \"fake_use\",\n      value: function () {}\n    }, {\n      key: \"curveType\",\n      value: function () {\n        return this.abstract();\n      }\n    }, {\n      key: \"getPosition\",\n      value: function (t) {\n        return this.fake_use(t), this.abstract();\n      }\n    }, {\n      key: \"setPosition\",\n      value: function (t, e) {\n        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;\n        this.fake_use(t, e, i), this.abstract();\n      }\n    }, {\n      key: \"getTreeSize\",\n      value: function (t) {\n        return this.fake_use(t), this.abstract();\n      }\n    }, {\n      key: \"sort\",\n      value: function (t) {\n        this.fake_use(t), this.abstract();\n      }\n    }, {\n      key: \"fix\",\n      value: function (t, e) {\n        this.fake_use(t, e), this.abstract();\n      }\n    }, {\n      key: \"shift\",\n      value: function (t, e) {\n        this.fake_use(t, e), this.abstract();\n      }\n    }]), t;\n  }(),\n      Nw = function (t) {\n    kg(i, t);\n    var e = zw(i);\n\n    function i(t) {\n      var o;\n      return Ra(this, i), (o = e.call(this)).layout = t, o;\n    }\n\n    return Ha(i, [{\n      key: \"curveType\",\n      value: function () {\n        return \"horizontal\";\n      }\n    }, {\n      key: \"getPosition\",\n      value: function (t) {\n        return t.x;\n      }\n    }, {\n      key: \"setPosition\",\n      value: function (t, e) {\n        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;\n        void 0 !== i && this.layout.hierarchical.addToOrdering(t, i), t.x = e;\n      }\n    }, {\n      key: \"getTreeSize\",\n      value: function (t) {\n        var e = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, t);\n        return {\n          min: e.min_x,\n          max: e.max_x\n        };\n      }\n    }, {\n      key: \"sort\",\n      value: function (t) {\n        Iw.sort(t, function (t, e) {\n          return t.x - e.x;\n        });\n      }\n    }, {\n      key: \"fix\",\n      value: function (t, e) {\n        t.y = this.layout.options.hierarchical.levelSeparation * e, t.options.fixed.y = !0;\n      }\n    }, {\n      key: \"shift\",\n      value: function (t, e) {\n        this.layout.body.nodes[t].x += e;\n      }\n    }]), i;\n  }(Fw),\n      Aw = function (t) {\n    kg(i, t);\n    var e = zw(i);\n\n    function i(t) {\n      var o;\n      return Ra(this, i), (o = e.call(this)).layout = t, o;\n    }\n\n    return Ha(i, [{\n      key: \"curveType\",\n      value: function () {\n        return \"vertical\";\n      }\n    }, {\n      key: \"getPosition\",\n      value: function (t) {\n        return t.y;\n      }\n    }, {\n      key: \"setPosition\",\n      value: function (t, e) {\n        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;\n        void 0 !== i && this.layout.hierarchical.addToOrdering(t, i), t.y = e;\n      }\n    }, {\n      key: \"getTreeSize\",\n      value: function (t) {\n        var e = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, t);\n        return {\n          min: e.min_y,\n          max: e.max_y\n        };\n      }\n    }, {\n      key: \"sort\",\n      value: function (t) {\n        Iw.sort(t, function (t, e) {\n          return t.y - e.y;\n        });\n      }\n    }, {\n      key: \"fix\",\n      value: function (t, e) {\n        t.x = this.layout.options.hierarchical.levelSeparation * e, t.options.fixed.x = !0;\n      }\n    }, {\n      key: \"shift\",\n      value: function (t, e) {\n        this.layout.body.nodes[t].y += e;\n      }\n    }]), i;\n  }(Fw),\n      Rw = Jr.every;\n\n  ue({\n    target: \"Array\",\n    proto: !0,\n    forced: !Zh(\"every\")\n  }, {\n    every: function (t) {\n      return Rw(this, t, arguments.length > 1 ? arguments[1] : void 0);\n    }\n  });\n\n  var jw = oi(\"Array\").every,\n      Lw = Array.prototype,\n      Hw = function (t) {\n    var e = t.every;\n    return t === Lw || t instanceof Array && e === Lw.every ? jw : e;\n  };\n\n  function Ww(t, e) {\n    var i = void 0 !== Nh && xr(t) || t[\"@@iterator\"];\n\n    if (!i) {\n      if (Hh(t) || (i = function (t, e) {\n        var i;\n        if (!t) return;\n        if (\"string\" == typeof t) return Vw(t, e);\n        var o = Lh(i = Object.prototype.toString.call(t)).call(i, 8, -1);\n        \"Object\" === o && t.constructor && (o = t.constructor.name);\n        if (\"Map\" === o || \"Set\" === o) return rr(t);\n        if (\"Arguments\" === o || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)) return Vw(t, e);\n      }(t)) || e && t && \"number\" == typeof t.length) {\n        i && (t = i);\n\n        var o = 0,\n            n = function () {};\n\n        return {\n          s: n,\n          n: function () {\n            return o >= t.length ? {\n              done: !0\n            } : {\n              done: !1,\n              value: t[o++]\n            };\n          },\n          e: function (t) {\n            throw t;\n          },\n          f: n\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var r,\n        s = !0,\n        a = !1;\n    return {\n      s: function () {\n        i = i.call(t);\n      },\n      n: function () {\n        var t = i.next();\n        return s = t.done, t;\n      },\n      e: function (t) {\n        a = !0, r = t;\n      },\n      f: function () {\n        try {\n          s || null == i.return || i.return();\n        } finally {\n          if (a) throw r;\n        }\n      }\n    };\n  }\n\n  function Vw(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var i = 0, o = new Array(e); i < e; i++) o[i] = t[i];\n\n    return o;\n  }\n\n  function qw(t, e) {\n    var i = new Um();\n    return nd(t).call(t, function (t) {\n      var e;\n      nd(e = t.edges).call(e, function (t) {\n        t.connected && i.add(t);\n      });\n    }), nd(i).call(i, function (t) {\n      var i = t.from.id,\n          o = t.to.id;\n      null == e[i] && (e[i] = 0), (null == e[o] || e[i] >= e[o]) && (e[o] = e[i] + 1);\n    }), e;\n  }\n\n  function Uw(t, e, i, o) {\n    var n,\n        r,\n        s = Bl(null),\n        a = Dw(n = Fh(Jv(o).call(o))).call(n, function (t, e) {\n      return t + 1 + e.edges.length;\n    }, 0),\n        h = i + \"Id\",\n        d = \"to\" === i ? 1 : -1,\n        l = Ww(o);\n\n    try {\n      var c = function () {\n        var n = Bh(r.value, 2),\n            l = n[0],\n            c = n[1];\n        if (!o.has(l) || !t(c)) return \"continue\";\n        s[l] = 0;\n\n        for (var u = [c], f = 0, p = void 0, v = function () {\n          var t, n;\n          if (!o.has(l)) return \"continue\";\n          var r = s[p.id] + d;\n          if (nd(t = $d(n = p.edges).call(n, function (t) {\n            return t.connected && t.to !== t.from && t[i] !== p && o.has(t.toId) && o.has(t.fromId);\n          })).call(t, function (t) {\n            var o = t[h],\n                n = s[o];\n            (null == n || e(r, n)) && (s[o] = r, u.push(t[i]));\n          }), f > a) return {\n            v: {\n              v: qw(o, s)\n            }\n          };\n          ++f;\n        }; p = u.pop();) {\n          var g = v();\n          if (\"continue\" !== g && \"object\" === zh(g)) return g.v;\n        }\n      };\n\n      for (l.s(); !(r = l.n()).done;) {\n        var u = c();\n        if (\"continue\" !== u && \"object\" === zh(u)) return u.v;\n      }\n    } catch (t) {\n      l.e(t);\n    } finally {\n      l.f();\n    }\n\n    return s;\n  }\n\n  var Yw = function () {\n    function t() {\n      Ra(this, t), this.childrenReference = {}, this.parentReference = {}, this.trees = {}, this.distributionOrdering = {}, this.levels = {}, this.distributionIndex = {}, this.isTree = !1, this.treeIndex = -1;\n    }\n\n    return Ha(t, [{\n      key: \"addRelation\",\n      value: function (t, e) {\n        void 0 === this.childrenReference[t] && (this.childrenReference[t] = []), this.childrenReference[t].push(e), void 0 === this.parentReference[e] && (this.parentReference[e] = []), this.parentReference[e].push(t);\n      }\n    }, {\n      key: \"checkIfTree\",\n      value: function () {\n        for (var t in this.parentReference) if (this.parentReference[t].length > 1) return void (this.isTree = !1);\n\n        this.isTree = !0;\n      }\n    }, {\n      key: \"numTrees\",\n      value: function () {\n        return this.treeIndex + 1;\n      }\n    }, {\n      key: \"setTreeIndex\",\n      value: function (t, e) {\n        void 0 !== e && void 0 === this.trees[t.id] && (this.trees[t.id] = e, this.treeIndex = Math.max(e, this.treeIndex));\n      }\n    }, {\n      key: \"ensureLevel\",\n      value: function (t) {\n        void 0 === this.levels[t] && (this.levels[t] = 0);\n      }\n    }, {\n      key: \"getMaxLevel\",\n      value: function (t) {\n        var e = this,\n            i = {};\n        return function t(o) {\n          if (void 0 !== i[o]) return i[o];\n          var n = e.levels[o];\n\n          if (e.childrenReference[o]) {\n            var r = e.childrenReference[o];\n            if (r.length > 0) for (var s = 0; s < r.length; s++) n = Math.max(n, t(r[s]));\n          }\n\n          return i[o] = n, n;\n        }(t);\n      }\n    }, {\n      key: \"levelDownstream\",\n      value: function (t, e) {\n        void 0 === this.levels[e.id] && (void 0 === this.levels[t.id] && (this.levels[t.id] = 0), this.levels[e.id] = this.levels[t.id] + 1);\n      }\n    }, {\n      key: \"setMinLevelToZero\",\n      value: function (t) {\n        var e = 1e9;\n\n        for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && void 0 !== this.levels[i] && (e = Math.min(this.levels[i], e));\n\n        for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && void 0 !== this.levels[o] && (this.levels[o] -= e);\n      }\n    }, {\n      key: \"getTreeSize\",\n      value: function (t, e) {\n        var i = 1e9,\n            o = -1e9,\n            n = 1e9,\n            r = -1e9;\n\n        for (var s in this.trees) if (Object.prototype.hasOwnProperty.call(this.trees, s) && this.trees[s] === e) {\n          var a = t[s];\n          i = Math.min(a.x, i), o = Math.max(a.x, o), n = Math.min(a.y, n), r = Math.max(a.y, r);\n        }\n\n        return {\n          min_x: i,\n          max_x: o,\n          min_y: n,\n          max_y: r\n        };\n      }\n    }, {\n      key: \"hasSameParent\",\n      value: function (t, e) {\n        var i = this.parentReference[t.id],\n            o = this.parentReference[e.id];\n        if (void 0 === i || void 0 === o) return !1;\n\n        for (var n = 0; n < i.length; n++) for (var r = 0; r < o.length; r++) if (i[n] == o[r]) return !0;\n\n        return !1;\n      }\n    }, {\n      key: \"inSameSubNetwork\",\n      value: function (t, e) {\n        return this.trees[t.id] === this.trees[e.id];\n      }\n    }, {\n      key: \"getLevels\",\n      value: function () {\n        return Gh(this.distributionOrdering);\n      }\n    }, {\n      key: \"addToOrdering\",\n      value: function (t, e) {\n        void 0 === this.distributionOrdering[e] && (this.distributionOrdering[e] = []);\n        var i = !1,\n            o = this.distributionOrdering[e];\n\n        for (var n in o) if (o[n] === t) {\n          i = !0;\n          break;\n        }\n\n        i || (this.distributionOrdering[e].push(t), this.distributionIndex[t.id] = this.distributionOrdering[e].length - 1);\n      }\n    }]), t;\n  }(),\n      Xw = function () {\n    function t(e) {\n      Ra(this, t), this.body = e, this._resetRNG(Math.random() + \":\" + Kh()), this.setPhysics = !1, this.options = {}, this.optionsBackup = {\n        physics: {}\n      }, this.defaultOptions = {\n        randomSeed: void 0,\n        improvedLayout: !0,\n        clusterThreshold: 150,\n        hierarchical: {\n          enabled: !1,\n          levelSeparation: 150,\n          nodeSpacing: 100,\n          treeSpacing: 200,\n          blockShifting: !0,\n          edgeMinimization: !0,\n          parentCentralization: !0,\n          direction: \"UD\",\n          sortMethod: \"hubsize\"\n        }\n      }, Ke(this.options, this.defaultOptions), this.bindEventListeners();\n    }\n\n    return Ha(t, [{\n      key: \"bindEventListeners\",\n      value: function () {\n        var t = this;\n        this.body.emitter.on(\"_dataChanged\", function () {\n          t.setupHierarchicalLayout();\n        }), this.body.emitter.on(\"_dataLoaded\", function () {\n          t.layoutNetwork();\n        }), this.body.emitter.on(\"_resetHierarchicalLayout\", function () {\n          t.setupHierarchicalLayout();\n        }), this.body.emitter.on(\"_adjustEdgesForHierarchicalLayout\", function () {\n          if (!0 === t.options.hierarchical.enabled) {\n            var e = t.direction.curveType();\n            t.body.emitter.emit(\"_forceDisableDynamicCurves\", e, !1);\n          }\n        });\n      }\n    }, {\n      key: \"setOptions\",\n      value: function (t, e) {\n        if (void 0 !== t) {\n          var i = this.options.hierarchical,\n              o = i.enabled;\n          if (nf([\"randomSeed\", \"improvedLayout\", \"clusterThreshold\"], this.options, t), _f(this.options, t, \"hierarchical\"), void 0 !== t.randomSeed && this._resetRNG(t.randomSeed), !0 === i.enabled) return !0 === o && this.body.emitter.emit(\"refresh\", !0), \"RL\" === i.direction || \"DU\" === i.direction ? i.levelSeparation > 0 && (i.levelSeparation *= -1) : i.levelSeparation < 0 && (i.levelSeparation *= -1), this.setDirectionStrategy(), this.body.emitter.emit(\"_resetHierarchicalLayout\"), this.adaptAllOptionsForHierarchicalLayout(e);\n          if (!0 === o) return this.body.emitter.emit(\"refresh\"), sf(e, this.optionsBackup);\n        }\n\n        return e;\n      }\n    }, {\n      key: \"_resetRNG\",\n      value: function (t) {\n        this.initialRandomSeed = t, this._rng = Vu(this.initialRandomSeed);\n      }\n    }, {\n      key: \"adaptAllOptionsForHierarchicalLayout\",\n      value: function (t) {\n        if (!0 === this.options.hierarchical.enabled) {\n          var e = this.optionsBackup.physics;\n          void 0 === t.physics || !0 === t.physics ? (t.physics = {\n            enabled: void 0 === e.enabled || e.enabled,\n            solver: \"hierarchicalRepulsion\"\n          }, e.enabled = void 0 === e.enabled || e.enabled, e.solver = e.solver || \"barnesHut\") : \"object\" === zh(t.physics) ? (e.enabled = void 0 === t.physics.enabled || t.physics.enabled, e.solver = t.physics.solver || \"barnesHut\", t.physics.solver = \"hierarchicalRepulsion\") : !1 !== t.physics && (e.solver = \"barnesHut\", t.physics = {\n            solver: \"hierarchicalRepulsion\"\n          });\n          var i = this.direction.curveType();\n          if (void 0 === t.edges) this.optionsBackup.edges = {\n            smooth: {\n              enabled: !0,\n              type: \"dynamic\"\n            }\n          }, t.edges = {\n            smooth: !1\n          };else if (void 0 === t.edges.smooth) this.optionsBackup.edges = {\n            smooth: {\n              enabled: !0,\n              type: \"dynamic\"\n            }\n          }, t.edges.smooth = !1;else if (\"boolean\" == typeof t.edges.smooth) this.optionsBackup.edges = {\n            smooth: t.edges.smooth\n          }, t.edges.smooth = {\n            enabled: t.edges.smooth,\n            type: i\n          };else {\n            var o = t.edges.smooth;\n            void 0 !== o.type && \"dynamic\" !== o.type && (i = o.type), this.optionsBackup.edges = {\n              smooth: {\n                enabled: void 0 === o.enabled || o.enabled,\n                type: void 0 === o.type ? \"dynamic\" : o.type,\n                roundness: void 0 === o.roundness ? .5 : o.roundness,\n                forceDirection: void 0 !== o.forceDirection && o.forceDirection\n              }\n            }, t.edges.smooth = {\n              enabled: void 0 === o.enabled || o.enabled,\n              type: i,\n              roundness: void 0 === o.roundness ? .5 : o.roundness,\n              forceDirection: void 0 !== o.forceDirection && o.forceDirection\n            };\n          }\n          this.body.emitter.emit(\"_forceDisableDynamicCurves\", i);\n        }\n\n        return t;\n      }\n    }, {\n      key: \"positionInitially\",\n      value: function (t) {\n        if (!0 !== this.options.hierarchical.enabled) {\n          this._resetRNG(this.initialRandomSeed);\n\n          for (var e = t.length + 50, i = 0; i < t.length; i++) {\n            var o = t[i],\n                n = 2 * Math.PI * this._rng();\n\n            void 0 === o.x && (o.x = e * Math.cos(n)), void 0 === o.y && (o.y = e * Math.sin(n));\n          }\n        }\n      }\n    }, {\n      key: \"layoutNetwork\",\n      value: function () {\n        if (!0 !== this.options.hierarchical.enabled && !0 === this.options.improvedLayout) {\n          for (var t = this.body.nodeIndices, e = 0, i = 0; i < t.length; i++) {\n            !0 === this.body.nodes[t[i]].predefinedPosition && (e += 1);\n          }\n\n          if (e < .5 * t.length) {\n            var o = 0,\n                n = this.options.clusterThreshold,\n                r = {\n              clusterNodeProperties: {\n                shape: \"ellipse\",\n                label: \"\",\n                group: \"\",\n                font: {\n                  multi: !1\n                }\n              },\n              clusterEdgeProperties: {\n                label: \"\",\n                font: {\n                  multi: !1\n                },\n                smooth: {\n                  enabled: !1\n                }\n              }\n            };\n\n            if (t.length > n) {\n              for (var s = t.length; t.length > n && o <= 10;) {\n                o += 1;\n                var a = t.length;\n                if (o % 3 == 0 ? this.body.modules.clustering.clusterBridges(r) : this.body.modules.clustering.clusterOutliers(r), a == t.length && o % 3 != 0) return this._declusterAll(), this.body.emitter.emit(\"_layoutFailed\"), void console.info(\"This network could not be positioned by this version of the improved layout algorithm. Please disable improvedLayout for better performance.\");\n              }\n\n              this.body.modules.kamadaKawai.setOptions({\n                springLength: Math.max(150, 2 * s)\n              });\n            }\n\n            o > 10 && console.info(\"The clustering didn't succeed within the amount of interations allowed, progressing with partial result.\"), this.body.modules.kamadaKawai.solve(t, this.body.edgeIndices, !0), this._shiftToCenter();\n\n            for (var h = 0; h < t.length; h++) {\n              var d = this.body.nodes[t[h]];\n              !1 === d.predefinedPosition && (d.x += 70 * (.5 - this._rng()), d.y += 70 * (.5 - this._rng()));\n            }\n\n            this._declusterAll(), this.body.emitter.emit(\"_repositionBezierNodes\");\n          }\n        }\n      }\n    }, {\n      key: \"_shiftToCenter\",\n      value: function () {\n        for (var t = Sm.getRangeCore(this.body.nodes, this.body.nodeIndices), e = Sm.findCenter(t), i = 0; i < this.body.nodeIndices.length; i++) {\n          var o = this.body.nodes[this.body.nodeIndices[i]];\n          o.x -= e.x, o.y -= e.y;\n        }\n      }\n    }, {\n      key: \"_declusterAll\",\n      value: function () {\n        for (var t = !0; !0 === t;) {\n          t = !1;\n\n          for (var e = 0; e < this.body.nodeIndices.length; e++) !0 === this.body.nodes[this.body.nodeIndices[e]].isCluster && (t = !0, this.body.modules.clustering.openCluster(this.body.nodeIndices[e], {}, !1));\n\n          !0 === t && this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }, {\n      key: \"getSeed\",\n      value: function () {\n        return this.initialRandomSeed;\n      }\n    }, {\n      key: \"setupHierarchicalLayout\",\n      value: function () {\n        if (!0 === this.options.hierarchical.enabled && this.body.nodeIndices.length > 0) {\n          var t,\n              e,\n              i = !1,\n              o = !1;\n\n          for (e in this.lastNodeOnLevel = {}, this.hierarchical = new Yw(), this.body.nodes) Object.prototype.hasOwnProperty.call(this.body.nodes, e) && (void 0 !== (t = this.body.nodes[e]).options.level ? (i = !0, this.hierarchical.levels[e] = t.options.level) : o = !0);\n\n          if (!0 === o && !0 === i) throw new Error(\"To use the hierarchical layout, nodes require either no predefined levels or levels have to be defined for all nodes.\");\n\n          if (!0 === o) {\n            var n = this.options.hierarchical.sortMethod;\n            \"hubsize\" === n ? this._determineLevelsByHubsize() : \"directed\" === n ? this._determineLevelsDirected() : \"custom\" === n && this._determineLevelsCustomCallback();\n          }\n\n          for (var r in this.body.nodes) Object.prototype.hasOwnProperty.call(this.body.nodes, r) && this.hierarchical.ensureLevel(r);\n\n          var s = this._getDistribution();\n\n          this._generateMap(), this._placeNodesByHierarchy(s), this._condenseHierarchy(), this._shiftToCenter();\n        }\n      }\n    }, {\n      key: \"_condenseHierarchy\",\n      value: function () {\n        var t = this,\n            e = !1,\n            i = {},\n            o = function (e, i) {\n          var o = t.hierarchical.trees;\n\n          for (var n in o) Object.prototype.hasOwnProperty.call(o, n) && o[n] === e && t.direction.shift(n, i);\n        },\n            n = function () {\n          for (var e = [], i = 0; i < t.hierarchical.numTrees(); i++) e.push(t.direction.getTreeSize(i));\n\n          return e;\n        },\n            r = function e(i, o) {\n          if (!o[i.id] && (o[i.id] = !0, t.hierarchical.childrenReference[i.id])) {\n            var n = t.hierarchical.childrenReference[i.id];\n            if (n.length > 0) for (var r = 0; r < n.length; r++) e(t.body.nodes[n[r]], o);\n          }\n        },\n            s = function (e) {\n          var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e9,\n              o = 1e9,\n              n = 1e9,\n              r = 1e9,\n              s = -1e9;\n\n          for (var a in e) if (Object.prototype.hasOwnProperty.call(e, a)) {\n            var h = t.body.nodes[a],\n                d = t.hierarchical.levels[h.id],\n                l = t.direction.getPosition(h),\n                c = t._getSpaceAroundNode(h, e),\n                u = Bh(c, 2),\n                f = u[0],\n                p = u[1];\n\n            o = Math.min(f, o), n = Math.min(p, n), d <= i && (r = Math.min(l, r), s = Math.max(l, s));\n          }\n\n          return [r, s, o, n];\n        },\n            a = function (e, i) {\n          var o = t.hierarchical.getMaxLevel(e.id),\n              n = t.hierarchical.getMaxLevel(i.id);\n          return Math.min(o, n);\n        },\n            h = function (e, i, o) {\n          for (var n = t.hierarchical, r = 0; r < i.length; r++) {\n            var s = i[r],\n                a = n.distributionOrdering[s];\n            if (a.length > 1) for (var h = 0; h < a.length - 1; h++) {\n              var d = a[h],\n                  l = a[h + 1];\n              n.hasSameParent(d, l) && n.inSameSubNetwork(d, l) && e(d, l, o);\n            }\n          }\n        },\n            d = function (i, o) {\n          var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n              h = t.direction.getPosition(i),\n              d = t.direction.getPosition(o),\n              l = Math.abs(d - h),\n              c = t.options.hierarchical.nodeSpacing;\n\n          if (l > c) {\n            var u = {},\n                f = {};\n            r(i, u), r(o, f);\n            var p = a(i, o),\n                v = s(u, p),\n                g = s(f, p),\n                y = v[1],\n                m = g[0],\n                b = g[2],\n                w = Math.abs(y - m);\n\n            if (w > c) {\n              var k = y - m + c;\n              k < -b + c && (k = -b + c), k < 0 && (t._shiftBlock(o.id, k), e = !0, !0 === n && t._centerParent(o));\n            }\n          }\n        },\n            l = function (o, n) {\n          for (var a = n.id, h = n.edges, d = t.hierarchical.levels[n.id], l = t.options.hierarchical.levelSeparation * t.options.hierarchical.levelSeparation, c = {}, u = [], f = 0; f < h.length; f++) {\n            var p = h[f];\n\n            if (p.toId != p.fromId) {\n              var v = p.toId == a ? p.from : p.to;\n              c[h[f].id] = v, t.hierarchical.levels[v.id] < d && u.push(p);\n            }\n          }\n\n          var g = function (e, i) {\n            for (var o = 0, n = 0; n < i.length; n++) if (void 0 !== c[i[n].id]) {\n              var r = t.direction.getPosition(c[i[n].id]) - e;\n              o += r / Math.sqrt(r * r + l);\n            }\n\n            return o;\n          },\n              y = function (e, i) {\n            for (var o = 0, n = 0; n < i.length; n++) if (void 0 !== c[i[n].id]) {\n              var r = t.direction.getPosition(c[i[n].id]) - e;\n              o -= l * Math.pow(r * r + l, -1.5);\n            }\n\n            return o;\n          },\n              m = function (e, i) {\n            for (var o = t.direction.getPosition(n), r = {}, s = 0; s < e; s++) {\n              var a = g(o, i),\n                  h = y(o, i);\n              if (void 0 !== r[o -= Math.max(-40, Math.min(40, Math.round(a / h)))]) break;\n              r[o] = s;\n            }\n\n            return o;\n          },\n              b = m(o, u);\n\n          !function (o) {\n            var a = t.direction.getPosition(n);\n\n            if (void 0 === i[n.id]) {\n              var h = {};\n              r(n, h), i[n.id] = h;\n            }\n\n            var d = s(i[n.id]),\n                l = d[2],\n                c = d[3],\n                u = o - a,\n                f = 0;\n            u > 0 ? f = Math.min(u, c - t.options.hierarchical.nodeSpacing) : u < 0 && (f = -Math.min(-u, l - t.options.hierarchical.nodeSpacing)), 0 != f && (t._shiftBlock(n.id, f), e = !0);\n          }(b), function (i) {\n            var o = t.direction.getPosition(n),\n                r = Bh(t._getSpaceAroundNode(n), 2),\n                s = r[0],\n                a = r[1],\n                h = i - o,\n                d = o;\n            h > 0 ? d = Math.min(o + (a - t.options.hierarchical.nodeSpacing), i) : h < 0 && (d = Math.max(o - (s - t.options.hierarchical.nodeSpacing), i)), d !== o && (t.direction.setPosition(n, d), e = !0);\n          }(b = m(o, h));\n        };\n\n        !0 === this.options.hierarchical.blockShifting && (function (i) {\n          var o = t.hierarchical.getLevels();\n          o = ld(o).call(o);\n\n          for (var n = 0; n < i && (e = !1, h(d, o, !0), !0 === e); n++);\n        }(5), function () {\n          for (var e in t.body.nodes) Object.prototype.hasOwnProperty.call(t.body.nodes, e) && t._centerParent(t.body.nodes[e]);\n        }()), !0 === this.options.hierarchical.edgeMinimization && function (i) {\n          var o = t.hierarchical.getLevels();\n          o = ld(o).call(o);\n\n          for (var n = 0; n < i; n++) {\n            e = !1;\n\n            for (var r = 0; r < o.length; r++) for (var s = o[r], a = t.hierarchical.distributionOrdering[s], h = 0; h < a.length; h++) l(1e3, a[h]);\n\n            if (!0 !== e) break;\n          }\n        }(20), !0 === this.options.hierarchical.parentCentralization && function () {\n          var e = t.hierarchical.getLevels();\n          e = ld(e).call(e);\n\n          for (var i = 0; i < e.length; i++) for (var o = e[i], n = t.hierarchical.distributionOrdering[o], r = 0; r < n.length; r++) t._centerParent(n[r]);\n        }(), function () {\n          for (var e = n(), i = 0, r = 0; r < e.length - 1; r++) {\n            i += e[r].max - e[r + 1].min + t.options.hierarchical.treeSpacing, o(r + 1, i);\n          }\n        }();\n      }\n    }, {\n      key: \"_getSpaceAroundNode\",\n      value: function (t, e) {\n        var i = !0;\n        void 0 === e && (i = !1);\n        var o = this.hierarchical.levels[t.id];\n\n        if (void 0 !== o) {\n          var n = this.hierarchical.distributionIndex[t.id],\n              r = this.direction.getPosition(t),\n              s = this.hierarchical.distributionOrdering[o],\n              a = 1e9,\n              h = 1e9;\n\n          if (0 !== n) {\n            var d = s[n - 1];\n            if (!0 === i && void 0 === e[d.id] || !1 === i) a = r - this.direction.getPosition(d);\n          }\n\n          if (n != s.length - 1) {\n            var l = s[n + 1];\n\n            if (!0 === i && void 0 === e[l.id] || !1 === i) {\n              var c = this.direction.getPosition(l);\n              h = Math.min(h, c - r);\n            }\n          }\n\n          return [a, h];\n        }\n\n        return [0, 0];\n      }\n    }, {\n      key: \"_centerParent\",\n      value: function (t) {\n        if (this.hierarchical.parentReference[t.id]) for (var e = this.hierarchical.parentReference[t.id], i = 0; i < e.length; i++) {\n          var o = e[i],\n              n = this.body.nodes[o],\n              r = this.hierarchical.childrenReference[o];\n\n          if (void 0 !== r) {\n            var s = this._getCenterPosition(r),\n                a = this.direction.getPosition(n),\n                h = Bh(this._getSpaceAroundNode(n), 2),\n                d = h[0],\n                l = h[1],\n                c = a - s;\n\n            (c < 0 && Math.abs(c) < l - this.options.hierarchical.nodeSpacing || c > 0 && Math.abs(c) < d - this.options.hierarchical.nodeSpacing) && this.direction.setPosition(n, s);\n          }\n        }\n      }\n    }, {\n      key: \"_placeNodesByHierarchy\",\n      value: function (t) {\n        for (var e in this.positionedNodes = {}, t) if (Object.prototype.hasOwnProperty.call(t, e)) {\n          var i,\n              o = Gh(t[e]);\n          o = this._indexArrayToNodes(o), mw(i = this.direction).call(i, o);\n\n          for (var n = 0, r = 0; r < o.length; r++) {\n            var s = o[r];\n\n            if (void 0 === this.positionedNodes[s.id]) {\n              var a = this.options.hierarchical.nodeSpacing,\n                  h = a * n;\n              n > 0 && (h = this.direction.getPosition(o[r - 1]) + a), this.direction.setPosition(s, h, e), this._validatePositionAndContinue(s, e, h), n++;\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_placeBranchNodes\",\n      value: function (t, e) {\n        var i,\n            o = this.hierarchical.childrenReference[t];\n\n        if (void 0 !== o) {\n          for (var n = [], r = 0; r < o.length; r++) n.push(this.body.nodes[o[r]]);\n\n          mw(i = this.direction).call(i, n);\n\n          for (var s = 0; s < n.length; s++) {\n            var a = n[s],\n                h = this.hierarchical.levels[a.id];\n            if (!(h > e && void 0 === this.positionedNodes[a.id])) return;\n            var d = this.options.hierarchical.nodeSpacing,\n                l = void 0;\n            l = 0 === s ? this.direction.getPosition(this.body.nodes[t]) : this.direction.getPosition(n[s - 1]) + d, this.direction.setPosition(a, l, h), this._validatePositionAndContinue(a, h, l);\n          }\n\n          var c = this._getCenterPosition(n);\n\n          this.direction.setPosition(this.body.nodes[t], c, e);\n        }\n      }\n    }, {\n      key: \"_validatePositionAndContinue\",\n      value: function (t, e, i) {\n        if (this.hierarchical.isTree) {\n          if (void 0 !== this.lastNodeOnLevel[e]) {\n            var o = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[e]]);\n\n            if (i - o < this.options.hierarchical.nodeSpacing) {\n              var n = o + this.options.hierarchical.nodeSpacing - i,\n                  r = this._findCommonParent(this.lastNodeOnLevel[e], t.id);\n\n              this._shiftBlock(r.withChild, n);\n            }\n          }\n\n          this.lastNodeOnLevel[e] = t.id, this.positionedNodes[t.id] = !0, this._placeBranchNodes(t.id, e);\n        }\n      }\n    }, {\n      key: \"_indexArrayToNodes\",\n      value: function (t) {\n        for (var e = [], i = 0; i < t.length; i++) e.push(this.body.nodes[t[i]]);\n\n        return e;\n      }\n    }, {\n      key: \"_getDistribution\",\n      value: function () {\n        var t,\n            e,\n            i = {};\n\n        for (t in this.body.nodes) if (Object.prototype.hasOwnProperty.call(this.body.nodes, t)) {\n          e = this.body.nodes[t];\n          var o = void 0 === this.hierarchical.levels[t] ? 0 : this.hierarchical.levels[t];\n          this.direction.fix(e, o), void 0 === i[o] && (i[o] = {}), i[o][t] = e;\n        }\n\n        return i;\n      }\n    }, {\n      key: \"_getActiveEdges\",\n      value: function (t) {\n        var e = this,\n            i = [];\n        return lf(t.edges, function (t) {\n          var o;\n          -1 !== Cl(o = e.body.edgeIndices).call(o, t.id) && i.push(t);\n        }), i;\n      }\n    }, {\n      key: \"_getHubSizes\",\n      value: function () {\n        var t = this,\n            e = {};\n        lf(this.body.nodeIndices, function (i) {\n          var o = t.body.nodes[i],\n              n = t._getActiveEdges(o).length;\n\n          e[n] = !0;\n        });\n        var i = [];\n        return lf(e, function (t) {\n          i.push(Number(t));\n        }), mw(Iw).call(Iw, i, function (t, e) {\n          return e - t;\n        }), i;\n      }\n    }, {\n      key: \"_determineLevelsByHubsize\",\n      value: function () {\n        for (var t = this, e = function (e, i) {\n          t.hierarchical.levelDownstream(e, i);\n        }, i = this._getHubSizes(), o = function (o) {\n          var n = i[o];\n          if (0 === n) return \"break\";\n          lf(t.body.nodeIndices, function (i) {\n            var o = t.body.nodes[i];\n            n === t._getActiveEdges(o).length && t._crawlNetwork(e, i);\n          });\n        }, n = 0; n < i.length; ++n) {\n          if (\"break\" === o(n)) break;\n        }\n      }\n    }, {\n      key: \"_determineLevelsCustomCallback\",\n      value: function () {\n        var t = this;\n        this._crawlNetwork(function (e, i, o) {\n          var n = t.hierarchical.levels[e.id];\n          void 0 === n && (n = t.hierarchical.levels[e.id] = 1e5);\n          var r = (Sm.cloneOptions(e, \"node\"), Sm.cloneOptions(i, \"node\"), void Sm.cloneOptions(o, \"edge\"));\n          t.hierarchical.levels[i.id] = n + r;\n        }), this.hierarchical.setMinLevelToZero(this.body.nodes);\n      }\n    }, {\n      key: \"_determineLevelsDirected\",\n      value: function () {\n        var t,\n            e = this,\n            i = Dw(t = this.body.nodeIndices).call(t, function (t, i) {\n          return t.set(i, e.body.nodes[i]), t;\n        }, new Cv());\n        \"roots\" === this.options.hierarchical.shakeTowards ? this.hierarchical.levels = function (t) {\n          return Uw(function (e) {\n            var i, o;\n            return Hw(i = $d(o = e.edges).call(o, function (e) {\n              return t.has(e.toId);\n            })).call(i, function (t) {\n              return t.from === e;\n            });\n          }, function (t, e) {\n            return e < t;\n          }, \"to\", t);\n        }(i) : this.hierarchical.levels = function (t) {\n          return Uw(function (e) {\n            var i, o;\n            return Hw(i = $d(o = e.edges).call(o, function (e) {\n              return t.has(e.toId);\n            })).call(i, function (t) {\n              return t.to === e;\n            });\n          }, function (t, e) {\n            return e > t;\n          }, \"from\", t);\n        }(i), this.hierarchical.setMinLevelToZero(this.body.nodes);\n      }\n    }, {\n      key: \"_generateMap\",\n      value: function () {\n        var t = this;\n        this._crawlNetwork(function (e, i) {\n          t.hierarchical.levels[i.id] > t.hierarchical.levels[e.id] && t.hierarchical.addRelation(e.id, i.id);\n        }), this.hierarchical.checkIfTree();\n      }\n    }, {\n      key: \"_crawlNetwork\",\n      value: function () {\n        var t = this,\n            e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {},\n            i = arguments.length > 1 ? arguments[1] : void 0,\n            o = {},\n            n = function i(n, r) {\n          if (void 0 === o[n.id]) {\n            var s;\n            t.hierarchical.setTreeIndex(n, r), o[n.id] = !0;\n\n            for (var a = t._getActiveEdges(n), h = 0; h < a.length; h++) {\n              var d = a[h];\n              !0 === d.connected && (s = d.toId == n.id ? d.from : d.to, n.id != s.id && (e(n, s, d), i(s, r)));\n            }\n          }\n        };\n\n        if (void 0 === i) for (var r = 0, s = 0; s < this.body.nodeIndices.length; s++) {\n          var a = this.body.nodeIndices[s];\n\n          if (void 0 === o[a]) {\n            var h = this.body.nodes[a];\n            n(h, r), r += 1;\n          }\n        } else {\n          var d = this.body.nodes[i];\n          if (void 0 === d) return void console.error(\"Node not found:\", i);\n          n(d);\n        }\n      }\n    }, {\n      key: \"_shiftBlock\",\n      value: function (t, e) {\n        var i = this,\n            o = {};\n        !function t(n) {\n          if (!o[n]) {\n            o[n] = !0, i.direction.shift(n, e);\n            var r = i.hierarchical.childrenReference[n];\n            if (void 0 !== r) for (var s = 0; s < r.length; s++) t(r[s]);\n          }\n        }(t);\n      }\n    }, {\n      key: \"_findCommonParent\",\n      value: function (t, e) {\n        var i = this,\n            o = {};\n        return function t(e, o) {\n          var n = i.hierarchical.parentReference[o];\n          if (void 0 !== n) for (var r = 0; r < n.length; r++) {\n            var s = n[r];\n            e[s] = !0, t(e, s);\n          }\n        }(o, t), function t(e, o) {\n          var n = i.hierarchical.parentReference[o];\n          if (void 0 !== n) for (var r = 0; r < n.length; r++) {\n            var s = n[r];\n            if (void 0 !== e[s]) return {\n              foundParent: s,\n              withChild: o\n            };\n            var a = t(e, s);\n            if (null !== a.foundParent) return a;\n          }\n          return {\n            foundParent: null,\n            withChild: o\n          };\n        }(o, e);\n      }\n    }, {\n      key: \"setDirectionStrategy\",\n      value: function () {\n        var t = \"UD\" === this.options.hierarchical.direction || \"DU\" === this.options.hierarchical.direction;\n        this.direction = t ? new Nw(this) : new Aw(this);\n      }\n    }, {\n      key: \"_getCenterPosition\",\n      value: function (t) {\n        for (var e = 1e9, i = -1e9, o = 0; o < t.length; o++) {\n          var n = void 0;\n          if (void 0 !== t[o].id) n = t[o];else {\n            var r = t[o];\n            n = this.body.nodes[r];\n          }\n          var s = this.direction.getPosition(n);\n          e = Math.min(e, s), i = Math.max(i, s);\n        }\n\n        return .5 * (e + i);\n      }\n    }]), t;\n  }();\n\n  function Gw(t, e) {\n    var i = void 0 !== Nh && xr(t) || t[\"@@iterator\"];\n\n    if (!i) {\n      if (Hh(t) || (i = function (t, e) {\n        var i;\n        if (!t) return;\n        if (\"string\" == typeof t) return Kw(t, e);\n        var o = Lh(i = Object.prototype.toString.call(t)).call(i, 8, -1);\n        \"Object\" === o && t.constructor && (o = t.constructor.name);\n        if (\"Map\" === o || \"Set\" === o) return rr(t);\n        if (\"Arguments\" === o || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o)) return Kw(t, e);\n      }(t)) || e && t && \"number\" == typeof t.length) {\n        i && (t = i);\n\n        var o = 0,\n            n = function () {};\n\n        return {\n          s: n,\n          n: function () {\n            return o >= t.length ? {\n              done: !0\n            } : {\n              done: !1,\n              value: t[o++]\n            };\n          },\n          e: function (t) {\n            throw t;\n          },\n          f: n\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var r,\n        s = !0,\n        a = !1;\n    return {\n      s: function () {\n        i = i.call(t);\n      },\n      n: function () {\n        var t = i.next();\n        return s = t.done, t;\n      },\n      e: function (t) {\n        a = !0, r = t;\n      },\n      f: function () {\n        try {\n          s || null == i.return || i.return();\n        } finally {\n          if (a) throw r;\n        }\n      }\n    };\n  }\n\n  function Kw(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var i = 0, o = new Array(e); i < e; i++) o[i] = t[i];\n\n    return o;\n  }\n\n  var $w = function () {\n    function t(e, i, o, n) {\n      var r,\n          s,\n          a = this;\n      Ra(this, t), this.body = e, this.canvas = i, this.selectionHandler = o, this.interactionHandler = n, this.editMode = !1, this.manipulationDiv = void 0, this.editModeDiv = void 0, this.closeDiv = void 0, this._domEventListenerCleanupQueue = [], this.temporaryUIFunctions = {}, this.temporaryEventFunctions = [], this.touchTime = 0, this.temporaryIds = {\n        nodes: [],\n        edges: []\n      }, this.guiEnabled = !1, this.inMode = !1, this.selectedControlNode = void 0, this.options = {}, this.defaultOptions = {\n        enabled: !1,\n        initiallyActive: !1,\n        addNode: !0,\n        addEdge: !0,\n        editNode: void 0,\n        editEdge: !0,\n        deleteNode: !0,\n        deleteEdge: !0,\n        controlNodeStyle: {\n          shape: \"dot\",\n          size: 6,\n          color: {\n            background: \"#ff0000\",\n            border: \"#3c3c3c\",\n            highlight: {\n              background: \"#07f968\",\n              border: \"#3c3c3c\"\n            }\n          },\n          borderWidth: 2,\n          borderWidthSelected: 2\n        }\n      }, Ke(this.options, this.defaultOptions), this.body.emitter.on(\"destroy\", function () {\n        a._clean();\n      }), this.body.emitter.on(\"_dataChanged\", si(r = this._restore).call(r, this)), this.body.emitter.on(\"_resetData\", si(s = this._restore).call(s, this));\n    }\n\n    return Ha(t, [{\n      key: \"_restore\",\n      value: function () {\n        !1 !== this.inMode && (!0 === this.options.initiallyActive ? this.enableEditMode() : this.disableEditMode());\n      }\n    }, {\n      key: \"setOptions\",\n      value: function (t, e, i) {\n        void 0 !== e && (void 0 !== e.locale ? this.options.locale = e.locale : this.options.locale = i.locale, void 0 !== e.locales ? this.options.locales = e.locales : this.options.locales = i.locales), void 0 !== t && (\"boolean\" == typeof t ? this.options.enabled = t : (this.options.enabled = !0, sf(this.options, t)), !0 === this.options.initiallyActive && (this.editMode = !0), this._setup());\n      }\n    }, {\n      key: \"toggleEditMode\",\n      value: function () {\n        !0 === this.editMode ? this.disableEditMode() : this.enableEditMode();\n      }\n    }, {\n      key: \"enableEditMode\",\n      value: function () {\n        this.editMode = !0, this._clean(), !0 === this.guiEnabled && (this.manipulationDiv.style.display = \"block\", this.closeDiv.style.display = \"block\", this.editModeDiv.style.display = \"none\", this.showManipulatorToolbar());\n      }\n    }, {\n      key: \"disableEditMode\",\n      value: function () {\n        this.editMode = !1, this._clean(), !0 === this.guiEnabled && (this.manipulationDiv.style.display = \"none\", this.closeDiv.style.display = \"none\", this.editModeDiv.style.display = \"block\", this._createEditButton());\n      }\n    }, {\n      key: \"showManipulatorToolbar\",\n      value: function () {\n        if (this._clean(), this.manipulationDOM = {}, !0 === this.guiEnabled) {\n          var t, e;\n          this.editMode = !0, this.manipulationDiv.style.display = \"block\", this.closeDiv.style.display = \"block\";\n          var i = this.selectionHandler.getSelectedNodeCount(),\n              o = this.selectionHandler.getSelectedEdgeCount(),\n              n = i + o,\n              r = this.options.locales[this.options.locale],\n              s = !1;\n          !1 !== this.options.addNode && (this._createAddNodeButton(r), s = !0), !1 !== this.options.addEdge && (!0 === s ? this._createSeperator(1) : s = !0, this._createAddEdgeButton(r)), 1 === i && \"function\" == typeof this.options.editNode ? (!0 === s ? this._createSeperator(2) : s = !0, this._createEditNodeButton(r)) : 1 === o && 0 === i && !1 !== this.options.editEdge && (!0 === s ? this._createSeperator(3) : s = !0, this._createEditEdgeButton(r)), 0 !== n && (i > 0 && !1 !== this.options.deleteNode || 0 === i && !1 !== this.options.deleteEdge) && (!0 === s && this._createSeperator(4), this._createDeleteButton(r)), this._bindElementEvents(this.closeDiv, si(t = this.toggleEditMode).call(t, this)), this._temporaryBindEvent(\"select\", si(e = this.showManipulatorToolbar).call(e, this));\n        }\n\n        this.body.emitter.emit(\"_redraw\");\n      }\n    }, {\n      key: \"addNodeMode\",\n      value: function () {\n        var t;\n\n        if (!0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = \"addNode\", !0 === this.guiEnabled) {\n          var e,\n              i = this.options.locales[this.options.locale];\n          this.manipulationDOM = {}, this._createBackButton(i), this._createSeperator(), this._createDescription(i.addDescription || this.options.locales.en.addDescription), this._bindElementEvents(this.closeDiv, si(e = this.toggleEditMode).call(e, this));\n        }\n\n        this._temporaryBindEvent(\"click\", si(t = this._performAddNode).call(t, this));\n      }\n    }, {\n      key: \"editNode\",\n      value: function () {\n        var t = this;\n        !0 !== this.editMode && this.enableEditMode(), this._clean();\n        var e = this.selectionHandler.getSelectedNodes()[0];\n\n        if (void 0 !== e) {\n          if (this.inMode = \"editNode\", \"function\" != typeof this.options.editNode) throw new Error(\"No function has been configured to handle the editing of nodes.\");\n\n          if (!0 !== e.isCluster) {\n            var i = sf({}, e.options, !1);\n            if (i.x = e.x, i.y = e.y, 2 !== this.options.editNode.length) throw new Error(\"The function for edit does not support two arguments (data, callback)\");\n            this.options.editNode(i, function (e) {\n              null != e && \"editNode\" === t.inMode && t.body.data.nodes.getDataSet().update(e), t.showManipulatorToolbar();\n            });\n          } else alert(this.options.locales[this.options.locale].editClusterError || this.options.locales.en.editClusterError);\n        } else this.showManipulatorToolbar();\n      }\n    }, {\n      key: \"addEdgeMode\",\n      value: function () {\n        var t, e, i, o, n;\n\n        if (!0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = \"addEdge\", !0 === this.guiEnabled) {\n          var r,\n              s = this.options.locales[this.options.locale];\n          this.manipulationDOM = {}, this._createBackButton(s), this._createSeperator(), this._createDescription(s.edgeDescription || this.options.locales.en.edgeDescription), this._bindElementEvents(this.closeDiv, si(r = this.toggleEditMode).call(r, this));\n        }\n\n        this._temporaryBindUI(\"onTouch\", si(t = this._handleConnect).call(t, this)), this._temporaryBindUI(\"onDragEnd\", si(e = this._finishConnect).call(e, this)), this._temporaryBindUI(\"onDrag\", si(i = this._dragControlNode).call(i, this)), this._temporaryBindUI(\"onRelease\", si(o = this._finishConnect).call(o, this)), this._temporaryBindUI(\"onDragStart\", si(n = this._dragStartEdge).call(n, this)), this._temporaryBindUI(\"onHold\", function () {});\n      }\n    }, {\n      key: \"editEdgeMode\",\n      value: function () {\n        if (!0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = \"editEdge\", \"object\" !== zh(this.options.editEdge) || \"function\" != typeof this.options.editEdge.editWithoutDrag || (this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0], void 0 === this.edgeBeingEditedId)) {\n          if (!0 === this.guiEnabled) {\n            var t,\n                e = this.options.locales[this.options.locale];\n            this.manipulationDOM = {}, this._createBackButton(e), this._createSeperator(), this._createDescription(e.editEdgeDescription || this.options.locales.en.editEdgeDescription), this._bindElementEvents(this.closeDiv, si(t = this.toggleEditMode).call(t, this));\n          }\n\n          if (this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0], void 0 !== this.edgeBeingEditedId) {\n            var i,\n                o,\n                n,\n                r,\n                s = this.body.edges[this.edgeBeingEditedId],\n                a = this._getNewTargetNode(s.from.x, s.from.y),\n                h = this._getNewTargetNode(s.to.x, s.to.y);\n\n            this.temporaryIds.nodes.push(a.id), this.temporaryIds.nodes.push(h.id), this.body.nodes[a.id] = a, this.body.nodeIndices.push(a.id), this.body.nodes[h.id] = h, this.body.nodeIndices.push(h.id), this._temporaryBindUI(\"onTouch\", si(i = this._controlNodeTouch).call(i, this)), this._temporaryBindUI(\"onTap\", function () {}), this._temporaryBindUI(\"onHold\", function () {}), this._temporaryBindUI(\"onDragStart\", si(o = this._controlNodeDragStart).call(o, this)), this._temporaryBindUI(\"onDrag\", si(n = this._controlNodeDrag).call(n, this)), this._temporaryBindUI(\"onDragEnd\", si(r = this._controlNodeDragEnd).call(r, this)), this._temporaryBindUI(\"onMouseMove\", function () {}), this._temporaryBindEvent(\"beforeDrawing\", function (t) {\n              var e = s.edgeType.findBorderPositions(t);\n              !1 === a.selected && (a.x = e.from.x, a.y = e.from.y), !1 === h.selected && (h.x = e.to.x, h.y = e.to.y);\n            }), this.body.emitter.emit(\"_redraw\");\n          } else this.showManipulatorToolbar();\n        } else {\n          var d = this.body.edges[this.edgeBeingEditedId];\n\n          this._performEditEdge(d.from.id, d.to.id);\n        }\n      }\n    }, {\n      key: \"deleteSelected\",\n      value: function () {\n        var t = this;\n        !0 !== this.editMode && this.enableEditMode(), this._clean(), this.inMode = \"delete\";\n        var e = this.selectionHandler.getSelectedNodeIds(),\n            i = this.selectionHandler.getSelectedEdgeIds(),\n            o = void 0;\n\n        if (e.length > 0) {\n          for (var n = 0; n < e.length; n++) if (!0 === this.body.nodes[e[n]].isCluster) return void alert(this.options.locales[this.options.locale].deleteClusterError || this.options.locales.en.deleteClusterError);\n\n          \"function\" == typeof this.options.deleteNode && (o = this.options.deleteNode);\n        } else i.length > 0 && \"function\" == typeof this.options.deleteEdge && (o = this.options.deleteEdge);\n\n        if (\"function\" == typeof o) {\n          var r = {\n            nodes: e,\n            edges: i\n          };\n          if (2 !== o.length) throw new Error(\"The function for delete does not support two arguments (data, callback)\");\n          o(r, function (e) {\n            null != e && \"delete\" === t.inMode ? (t.body.data.edges.getDataSet().remove(e.edges), t.body.data.nodes.getDataSet().remove(e.nodes), t.body.emitter.emit(\"startSimulation\"), t.showManipulatorToolbar()) : (t.body.emitter.emit(\"startSimulation\"), t.showManipulatorToolbar());\n          });\n        } else this.body.data.edges.getDataSet().remove(i), this.body.data.nodes.getDataSet().remove(e), this.body.emitter.emit(\"startSimulation\"), this.showManipulatorToolbar();\n      }\n    }, {\n      key: \"_setup\",\n      value: function () {\n        !0 === this.options.enabled ? (this.guiEnabled = !0, this._createWrappers(), !1 === this.editMode ? this._createEditButton() : this.showManipulatorToolbar()) : (this._removeManipulationDOM(), this.guiEnabled = !1);\n      }\n    }, {\n      key: \"_createWrappers\",\n      value: function () {\n        var t, e;\n        (void 0 === this.manipulationDiv && (this.manipulationDiv = document.createElement(\"div\"), this.manipulationDiv.className = \"vis-manipulation\", !0 === this.editMode ? this.manipulationDiv.style.display = \"block\" : this.manipulationDiv.style.display = \"none\", this.canvas.frame.appendChild(this.manipulationDiv)), void 0 === this.editModeDiv && (this.editModeDiv = document.createElement(\"div\"), this.editModeDiv.className = \"vis-edit-mode\", !0 === this.editMode ? this.editModeDiv.style.display = \"none\" : this.editModeDiv.style.display = \"block\", this.canvas.frame.appendChild(this.editModeDiv)), void 0 === this.closeDiv) && (this.closeDiv = document.createElement(\"button\"), this.closeDiv.className = \"vis-close\", this.closeDiv.setAttribute(\"aria-label\", null !== (t = null === (e = this.options.locales[this.options.locale]) || void 0 === e ? void 0 : e.close) && void 0 !== t ? t : this.options.locales.en.close), this.closeDiv.style.display = this.manipulationDiv.style.display, this.canvas.frame.appendChild(this.closeDiv));\n      }\n    }, {\n      key: \"_getNewTargetNode\",\n      value: function (t, e) {\n        var i = sf({}, this.options.controlNodeStyle);\n        i.id = \"targetNode\" + Cm(), i.hidden = !1, i.physics = !1, i.x = t, i.y = e;\n        var o = this.body.functions.createNode(i);\n        return o.shape.boundingBox = {\n          left: t,\n          right: t,\n          top: e,\n          bottom: e\n        }, o;\n      }\n    }, {\n      key: \"_createEditButton\",\n      value: function () {\n        var t;\n        this._clean(), this.manipulationDOM = {}, Qu(this.editModeDiv);\n\n        var e = this.options.locales[this.options.locale],\n            i = this._createButton(\"editMode\", \"vis-edit vis-edit-mode\", e.edit || this.options.locales.en.edit);\n\n        this.editModeDiv.appendChild(i), this._bindElementEvents(i, si(t = this.toggleEditMode).call(t, this));\n      }\n    }, {\n      key: \"_clean\",\n      value: function () {\n        this.inMode = !1, !0 === this.guiEnabled && (Qu(this.editModeDiv), Qu(this.manipulationDiv), this._cleanupDOMEventListeners()), this._cleanupTemporaryNodesAndEdges(), this._unbindTemporaryUIs(), this._unbindTemporaryEvents(), this.body.emitter.emit(\"restorePhysics\");\n      }\n    }, {\n      key: \"_cleanupDOMEventListeners\",\n      value: function () {\n        var t,\n            e,\n            i = Gw(Od(t = this._domEventListenerCleanupQueue).call(t, 0));\n\n        try {\n          for (i.s(); !(e = i.n()).done;) {\n            (0, e.value)();\n          }\n        } catch (t) {\n          i.e(t);\n        } finally {\n          i.f();\n        }\n      }\n    }, {\n      key: \"_removeManipulationDOM\",\n      value: function () {\n        this._clean(), Qu(this.manipulationDiv), Qu(this.editModeDiv), Qu(this.closeDiv), this.manipulationDiv && this.canvas.frame.removeChild(this.manipulationDiv), this.editModeDiv && this.canvas.frame.removeChild(this.editModeDiv), this.closeDiv && this.canvas.frame.removeChild(this.closeDiv), this.manipulationDiv = void 0, this.editModeDiv = void 0, this.closeDiv = void 0;\n      }\n    }, {\n      key: \"_createSeperator\",\n      value: function () {\n        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;\n        this.manipulationDOM[\"seperatorLineDiv\" + t] = document.createElement(\"div\"), this.manipulationDOM[\"seperatorLineDiv\" + t].className = \"vis-separator-line\", this.manipulationDiv.appendChild(this.manipulationDOM[\"seperatorLineDiv\" + t]);\n      }\n    }, {\n      key: \"_createAddNodeButton\",\n      value: function (t) {\n        var e,\n            i = this._createButton(\"addNode\", \"vis-add\", t.addNode || this.options.locales.en.addNode);\n\n        this.manipulationDiv.appendChild(i), this._bindElementEvents(i, si(e = this.addNodeMode).call(e, this));\n      }\n    }, {\n      key: \"_createAddEdgeButton\",\n      value: function (t) {\n        var e,\n            i = this._createButton(\"addEdge\", \"vis-connect\", t.addEdge || this.options.locales.en.addEdge);\n\n        this.manipulationDiv.appendChild(i), this._bindElementEvents(i, si(e = this.addEdgeMode).call(e, this));\n      }\n    }, {\n      key: \"_createEditNodeButton\",\n      value: function (t) {\n        var e,\n            i = this._createButton(\"editNode\", \"vis-edit\", t.editNode || this.options.locales.en.editNode);\n\n        this.manipulationDiv.appendChild(i), this._bindElementEvents(i, si(e = this.editNode).call(e, this));\n      }\n    }, {\n      key: \"_createEditEdgeButton\",\n      value: function (t) {\n        var e,\n            i = this._createButton(\"editEdge\", \"vis-edit\", t.editEdge || this.options.locales.en.editEdge);\n\n        this.manipulationDiv.appendChild(i), this._bindElementEvents(i, si(e = this.editEdgeMode).call(e, this));\n      }\n    }, {\n      key: \"_createDeleteButton\",\n      value: function (t) {\n        var e, i;\n        i = this.options.rtl ? \"vis-delete-rtl\" : \"vis-delete\";\n\n        var o = this._createButton(\"delete\", i, t.del || this.options.locales.en.del);\n\n        this.manipulationDiv.appendChild(o), this._bindElementEvents(o, si(e = this.deleteSelected).call(e, this));\n      }\n    }, {\n      key: \"_createBackButton\",\n      value: function (t) {\n        var e,\n            i = this._createButton(\"back\", \"vis-back\", t.back || this.options.locales.en.back);\n\n        this.manipulationDiv.appendChild(i), this._bindElementEvents(i, si(e = this.showManipulatorToolbar).call(e, this));\n      }\n    }, {\n      key: \"_createButton\",\n      value: function (t, e, i) {\n        var o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : \"vis-label\";\n        return this.manipulationDOM[t + \"Div\"] = document.createElement(\"button\"), this.manipulationDOM[t + \"Div\"].className = \"vis-button \" + e, this.manipulationDOM[t + \"Label\"] = document.createElement(\"div\"), this.manipulationDOM[t + \"Label\"].className = o, this.manipulationDOM[t + \"Label\"].innerText = i, this.manipulationDOM[t + \"Div\"].appendChild(this.manipulationDOM[t + \"Label\"]), this.manipulationDOM[t + \"Div\"];\n      }\n    }, {\n      key: \"_createDescription\",\n      value: function (t) {\n        this.manipulationDOM.descriptionLabel = document.createElement(\"div\"), this.manipulationDOM.descriptionLabel.className = \"vis-none\", this.manipulationDOM.descriptionLabel.innerText = t, this.manipulationDiv.appendChild(this.manipulationDOM.descriptionLabel);\n      }\n    }, {\n      key: \"_temporaryBindEvent\",\n      value: function (t, e) {\n        this.temporaryEventFunctions.push({\n          event: t,\n          boundFunction: e\n        }), this.body.emitter.on(t, e);\n      }\n    }, {\n      key: \"_temporaryBindUI\",\n      value: function (t, e) {\n        if (void 0 === this.body.eventListeners[t]) throw new Error(\"This UI function does not exist. Typo? You tried: \" + t + \" possible are: \" + Wl(Gh(this.body.eventListeners)));\n        this.temporaryUIFunctions[t] = this.body.eventListeners[t], this.body.eventListeners[t] = e;\n      }\n    }, {\n      key: \"_unbindTemporaryUIs\",\n      value: function () {\n        for (var t in this.temporaryUIFunctions) Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions, t) && (this.body.eventListeners[t] = this.temporaryUIFunctions[t], delete this.temporaryUIFunctions[t]);\n\n        this.temporaryUIFunctions = {};\n      }\n    }, {\n      key: \"_unbindTemporaryEvents\",\n      value: function () {\n        for (var t = 0; t < this.temporaryEventFunctions.length; t++) {\n          var e = this.temporaryEventFunctions[t].event,\n              i = this.temporaryEventFunctions[t].boundFunction;\n          this.body.emitter.off(e, i);\n        }\n\n        this.temporaryEventFunctions = [];\n      }\n    }, {\n      key: \"_bindElementEvents\",\n      value: function (t, e) {\n        var i = new If(t, {});\n        Fm(i, e), this._domEventListenerCleanupQueue.push(function () {\n          i.destroy();\n        });\n\n        var o = function (t) {\n          var i = t.keyCode,\n              o = t.key;\n          \"Enter\" !== o && \" \" !== o && 13 !== i && 32 !== i || e();\n        };\n\n        t.addEventListener(\"keyup\", o, !1), this._domEventListenerCleanupQueue.push(function () {\n          t.removeEventListener(\"keyup\", o, !1);\n        });\n      }\n    }, {\n      key: \"_cleanupTemporaryNodesAndEdges\",\n      value: function () {\n        for (var t = 0; t < this.temporaryIds.edges.length; t++) {\n          var e;\n          this.body.edges[this.temporaryIds.edges[t]].disconnect(), delete this.body.edges[this.temporaryIds.edges[t]];\n          var i,\n              o = Cl(e = this.body.edgeIndices).call(e, this.temporaryIds.edges[t]);\n          if (-1 !== o) Od(i = this.body.edgeIndices).call(i, o, 1);\n        }\n\n        for (var n = 0; n < this.temporaryIds.nodes.length; n++) {\n          var r;\n          delete this.body.nodes[this.temporaryIds.nodes[n]];\n          var s,\n              a = Cl(r = this.body.nodeIndices).call(r, this.temporaryIds.nodes[n]);\n          if (-1 !== a) Od(s = this.body.nodeIndices).call(s, a, 1);\n        }\n\n        this.temporaryIds = {\n          nodes: [],\n          edges: []\n        };\n      }\n    }, {\n      key: \"_controlNodeTouch\",\n      value: function (t) {\n        this.selectionHandler.unselectAll(), this.lastTouch = this.body.functions.getPointer(t.center), this.lastTouch.translation = Ke({}, this.body.view.translation);\n      }\n    }, {\n      key: \"_controlNodeDragStart\",\n      value: function () {\n        var t = this.lastTouch,\n            e = this.selectionHandler._pointerToPositionObject(t),\n            i = this.body.nodes[this.temporaryIds.nodes[0]],\n            o = this.body.nodes[this.temporaryIds.nodes[1]],\n            n = this.body.edges[this.edgeBeingEditedId];\n\n        this.selectedControlNode = void 0;\n        var r = i.isOverlappingWith(e),\n            s = o.isOverlappingWith(e);\n        !0 === r ? (this.selectedControlNode = i, n.edgeType.from = i) : !0 === s && (this.selectedControlNode = o, n.edgeType.to = o), void 0 !== this.selectedControlNode && this.selectionHandler.selectObject(this.selectedControlNode), this.body.emitter.emit(\"_redraw\");\n      }\n    }, {\n      key: \"_controlNodeDrag\",\n      value: function (t) {\n        this.body.emitter.emit(\"disablePhysics\");\n        var e = this.body.functions.getPointer(t.center),\n            i = this.canvas.DOMtoCanvas(e);\n        void 0 !== this.selectedControlNode ? (this.selectedControlNode.x = i.x, this.selectedControlNode.y = i.y) : this.interactionHandler.onDrag(t), this.body.emitter.emit(\"_redraw\");\n      }\n    }, {\n      key: \"_controlNodeDragEnd\",\n      value: function (t) {\n        var e = this.body.functions.getPointer(t.center),\n            i = this.selectionHandler._pointerToPositionObject(e),\n            o = this.body.edges[this.edgeBeingEditedId];\n\n        if (void 0 !== this.selectedControlNode) {\n          this.selectionHandler.unselectAll();\n\n          for (var n = this.selectionHandler._getAllNodesOverlappingWith(i), r = void 0, s = n.length - 1; s >= 0; s--) if (n[s] !== this.selectedControlNode.id) {\n            r = this.body.nodes[n[s]];\n            break;\n          }\n\n          if (void 0 !== r && void 0 !== this.selectedControlNode) {\n            if (!0 === r.isCluster) alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError);else {\n              var a = this.body.nodes[this.temporaryIds.nodes[0]];\n              this.selectedControlNode.id === a.id ? this._performEditEdge(r.id, o.to.id) : this._performEditEdge(o.from.id, r.id);\n            }\n          } else o.updateEdgeType(), this.body.emitter.emit(\"restorePhysics\");\n          this.body.emitter.emit(\"_redraw\");\n        }\n      }\n    }, {\n      key: \"_handleConnect\",\n      value: function (t) {\n        if (new Date().valueOf() - this.touchTime > 100) {\n          this.lastTouch = this.body.functions.getPointer(t.center), this.lastTouch.translation = Ke({}, this.body.view.translation), this.interactionHandler.drag.pointer = this.lastTouch, this.interactionHandler.drag.translation = this.lastTouch.translation;\n          var e = this.lastTouch,\n              i = this.selectionHandler.getNodeAt(e);\n          if (void 0 !== i) if (!0 === i.isCluster) alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError);else {\n            var o = this._getNewTargetNode(i.x, i.y);\n\n            this.body.nodes[o.id] = o, this.body.nodeIndices.push(o.id);\n            var n = this.body.functions.createEdge({\n              id: \"connectionEdge\" + Cm(),\n              from: i.id,\n              to: o.id,\n              physics: !1,\n              smooth: {\n                enabled: !0,\n                type: \"continuous\",\n                roundness: .5\n              }\n            });\n            this.body.edges[n.id] = n, this.body.edgeIndices.push(n.id), this.temporaryIds.nodes.push(o.id), this.temporaryIds.edges.push(n.id);\n          }\n          this.touchTime = new Date().valueOf();\n        }\n      }\n    }, {\n      key: \"_dragControlNode\",\n      value: function (t) {\n        var e = this.body.functions.getPointer(t.center),\n            i = this.selectionHandler._pointerToPositionObject(e),\n            o = void 0;\n\n        void 0 !== this.temporaryIds.edges[0] && (o = this.body.edges[this.temporaryIds.edges[0]].fromId);\n\n        for (var n = this.selectionHandler._getAllNodesOverlappingWith(i), r = void 0, s = n.length - 1; s >= 0; s--) {\n          var a;\n\n          if (-1 === Cl(a = this.temporaryIds.nodes).call(a, n[s])) {\n            r = this.body.nodes[n[s]];\n            break;\n          }\n        }\n\n        if (t.controlEdge = {\n          from: o,\n          to: r ? r.id : void 0\n        }, this.selectionHandler.generateClickEvent(\"controlNodeDragging\", t, e), void 0 !== this.temporaryIds.nodes[0]) {\n          var h = this.body.nodes[this.temporaryIds.nodes[0]];\n          h.x = this.canvas._XconvertDOMtoCanvas(e.x), h.y = this.canvas._YconvertDOMtoCanvas(e.y), this.body.emitter.emit(\"_redraw\");\n        } else this.interactionHandler.onDrag(t);\n      }\n    }, {\n      key: \"_finishConnect\",\n      value: function (t) {\n        var e = this.body.functions.getPointer(t.center),\n            i = this.selectionHandler._pointerToPositionObject(e),\n            o = void 0;\n\n        void 0 !== this.temporaryIds.edges[0] && (o = this.body.edges[this.temporaryIds.edges[0]].fromId);\n\n        for (var n = this.selectionHandler._getAllNodesOverlappingWith(i), r = void 0, s = n.length - 1; s >= 0; s--) {\n          var a;\n\n          if (-1 === Cl(a = this.temporaryIds.nodes).call(a, n[s])) {\n            r = this.body.nodes[n[s]];\n            break;\n          }\n        }\n\n        this._cleanupTemporaryNodesAndEdges(), void 0 !== r && (!0 === r.isCluster ? alert(this.options.locales[this.options.locale].createEdgeError || this.options.locales.en.createEdgeError) : void 0 !== this.body.nodes[o] && void 0 !== this.body.nodes[r.id] && this._performAddEdge(o, r.id)), t.controlEdge = {\n          from: o,\n          to: r ? r.id : void 0\n        }, this.selectionHandler.generateClickEvent(\"controlNodeDragEnd\", t, e), this.body.emitter.emit(\"_redraw\");\n      }\n    }, {\n      key: \"_dragStartEdge\",\n      value: function (t) {\n        var e = this.lastTouch;\n        this.selectionHandler.generateClickEvent(\"dragStart\", t, e, void 0, !0);\n      }\n    }, {\n      key: \"_performAddNode\",\n      value: function (t) {\n        var e = this,\n            i = {\n          id: Cm(),\n          x: t.pointer.canvas.x,\n          y: t.pointer.canvas.y,\n          label: \"new\"\n        };\n\n        if (\"function\" == typeof this.options.addNode) {\n          if (2 !== this.options.addNode.length) throw this.showManipulatorToolbar(), new Error(\"The function for add does not support two arguments (data,callback)\");\n          this.options.addNode(i, function (t) {\n            null != t && \"addNode\" === e.inMode && e.body.data.nodes.getDataSet().add(t), e.showManipulatorToolbar();\n          });\n        } else this.body.data.nodes.getDataSet().add(i), this.showManipulatorToolbar();\n      }\n    }, {\n      key: \"_performAddEdge\",\n      value: function (t, e) {\n        var i = this,\n            o = {\n          from: t,\n          to: e\n        };\n\n        if (\"function\" == typeof this.options.addEdge) {\n          if (2 !== this.options.addEdge.length) throw new Error(\"The function for connect does not support two arguments (data,callback)\");\n          this.options.addEdge(o, function (t) {\n            null != t && \"addEdge\" === i.inMode && (i.body.data.edges.getDataSet().add(t), i.selectionHandler.unselectAll(), i.showManipulatorToolbar());\n          });\n        } else this.body.data.edges.getDataSet().add(o), this.selectionHandler.unselectAll(), this.showManipulatorToolbar();\n      }\n    }, {\n      key: \"_performEditEdge\",\n      value: function (t, e) {\n        var i = this,\n            o = {\n          id: this.edgeBeingEditedId,\n          from: t,\n          to: e,\n          label: this.body.data.edges.get(this.edgeBeingEditedId).label\n        },\n            n = this.options.editEdge;\n\n        if (\"object\" === zh(n) && (n = n.editWithoutDrag), \"function\" == typeof n) {\n          if (2 !== n.length) throw new Error(\"The function for edit does not support two arguments (data, callback)\");\n          n(o, function (t) {\n            null == t || \"editEdge\" !== i.inMode ? (i.body.edges[o.id].updateEdgeType(), i.body.emitter.emit(\"_redraw\"), i.showManipulatorToolbar()) : (i.body.data.edges.getDataSet().update(t), i.selectionHandler.unselectAll(), i.showManipulatorToolbar());\n          });\n        } else this.body.data.edges.getDataSet().update(o), this.selectionHandler.unselectAll(), this.showManipulatorToolbar();\n      }\n    }]), t;\n  }(),\n      Zw = \"string\",\n      Qw = \"boolean\",\n      Jw = \"number\",\n      tk = \"array\",\n      ek = \"object\",\n      ik = [\"arrow\", \"bar\", \"box\", \"circle\", \"crow\", \"curve\", \"diamond\", \"image\", \"inv_curve\", \"inv_triangle\", \"triangle\", \"vee\"],\n      ok = {\n    borderWidth: {\n      number: Jw\n    },\n    borderWidthSelected: {\n      number: Jw,\n      undefined: \"undefined\"\n    },\n    brokenImage: {\n      string: Zw,\n      undefined: \"undefined\"\n    },\n    chosen: {\n      label: {\n        boolean: Qw,\n        function: \"function\"\n      },\n      node: {\n        boolean: Qw,\n        function: \"function\"\n      },\n      __type__: {\n        object: ek,\n        boolean: Qw\n      }\n    },\n    color: {\n      border: {\n        string: Zw\n      },\n      background: {\n        string: Zw\n      },\n      highlight: {\n        border: {\n          string: Zw\n        },\n        background: {\n          string: Zw\n        },\n        __type__: {\n          object: ek,\n          string: Zw\n        }\n      },\n      hover: {\n        border: {\n          string: Zw\n        },\n        background: {\n          string: Zw\n        },\n        __type__: {\n          object: ek,\n          string: Zw\n        }\n      },\n      __type__: {\n        object: ek,\n        string: Zw\n      }\n    },\n    opacity: {\n      number: Jw,\n      undefined: \"undefined\"\n    },\n    fixed: {\n      x: {\n        boolean: Qw\n      },\n      y: {\n        boolean: Qw\n      },\n      __type__: {\n        object: ek,\n        boolean: Qw\n      }\n    },\n    font: {\n      align: {\n        string: Zw\n      },\n      color: {\n        string: Zw\n      },\n      size: {\n        number: Jw\n      },\n      face: {\n        string: Zw\n      },\n      background: {\n        string: Zw\n      },\n      strokeWidth: {\n        number: Jw\n      },\n      strokeColor: {\n        string: Zw\n      },\n      vadjust: {\n        number: Jw\n      },\n      multi: {\n        boolean: Qw,\n        string: Zw\n      },\n      bold: {\n        color: {\n          string: Zw\n        },\n        size: {\n          number: Jw\n        },\n        face: {\n          string: Zw\n        },\n        mod: {\n          string: Zw\n        },\n        vadjust: {\n          number: Jw\n        },\n        __type__: {\n          object: ek,\n          string: Zw\n        }\n      },\n      boldital: {\n        color: {\n          string: Zw\n        },\n        size: {\n          number: Jw\n        },\n        face: {\n          string: Zw\n        },\n        mod: {\n          string: Zw\n        },\n        vadjust: {\n          number: Jw\n        },\n        __type__: {\n          object: ek,\n          string: Zw\n        }\n      },\n      ital: {\n        color: {\n          string: Zw\n        },\n        size: {\n          number: Jw\n        },\n        face: {\n          string: Zw\n        },\n        mod: {\n          string: Zw\n        },\n        vadjust: {\n          number: Jw\n        },\n        __type__: {\n          object: ek,\n          string: Zw\n        }\n      },\n      mono: {\n        color: {\n          string: Zw\n        },\n        size: {\n          number: Jw\n        },\n        face: {\n          string: Zw\n        },\n        mod: {\n          string: Zw\n        },\n        vadjust: {\n          number: Jw\n        },\n        __type__: {\n          object: ek,\n          string: Zw\n        }\n      },\n      __type__: {\n        object: ek,\n        string: Zw\n      }\n    },\n    group: {\n      string: Zw,\n      number: Jw,\n      undefined: \"undefined\"\n    },\n    heightConstraint: {\n      minimum: {\n        number: Jw\n      },\n      valign: {\n        string: Zw\n      },\n      __type__: {\n        object: ek,\n        boolean: Qw,\n        number: Jw\n      }\n    },\n    hidden: {\n      boolean: Qw\n    },\n    icon: {\n      face: {\n        string: Zw\n      },\n      code: {\n        string: Zw\n      },\n      size: {\n        number: Jw\n      },\n      color: {\n        string: Zw\n      },\n      weight: {\n        string: Zw,\n        number: Jw\n      },\n      __type__: {\n        object: ek\n      }\n    },\n    id: {\n      string: Zw,\n      number: Jw\n    },\n    image: {\n      selected: {\n        string: Zw,\n        undefined: \"undefined\"\n      },\n      unselected: {\n        string: Zw,\n        undefined: \"undefined\"\n      },\n      __type__: {\n        object: ek,\n        string: Zw\n      }\n    },\n    imagePadding: {\n      top: {\n        number: Jw\n      },\n      right: {\n        number: Jw\n      },\n      bottom: {\n        number: Jw\n      },\n      left: {\n        number: Jw\n      },\n      __type__: {\n        object: ek,\n        number: Jw\n      }\n    },\n    label: {\n      string: Zw,\n      undefined: \"undefined\"\n    },\n    labelHighlightBold: {\n      boolean: Qw\n    },\n    level: {\n      number: Jw,\n      undefined: \"undefined\"\n    },\n    margin: {\n      top: {\n        number: Jw\n      },\n      right: {\n        number: Jw\n      },\n      bottom: {\n        number: Jw\n      },\n      left: {\n        number: Jw\n      },\n      __type__: {\n        object: ek,\n        number: Jw\n      }\n    },\n    mass: {\n      number: Jw\n    },\n    physics: {\n      boolean: Qw\n    },\n    scaling: {\n      min: {\n        number: Jw\n      },\n      max: {\n        number: Jw\n      },\n      label: {\n        enabled: {\n          boolean: Qw\n        },\n        min: {\n          number: Jw\n        },\n        max: {\n          number: Jw\n        },\n        maxVisible: {\n          number: Jw\n        },\n        drawThreshold: {\n          number: Jw\n        },\n        __type__: {\n          object: ek,\n          boolean: Qw\n        }\n      },\n      customScalingFunction: {\n        function: \"function\"\n      },\n      __type__: {\n        object: ek\n      }\n    },\n    shadow: {\n      enabled: {\n        boolean: Qw\n      },\n      color: {\n        string: Zw\n      },\n      size: {\n        number: Jw\n      },\n      x: {\n        number: Jw\n      },\n      y: {\n        number: Jw\n      },\n      __type__: {\n        object: ek,\n        boolean: Qw\n      }\n    },\n    shape: {\n      string: [\"custom\", \"ellipse\", \"circle\", \"database\", \"box\", \"text\", \"image\", \"circularImage\", \"diamond\", \"dot\", \"star\", \"triangle\", \"triangleDown\", \"square\", \"icon\", \"hexagon\"]\n    },\n    ctxRenderer: {\n      function: \"function\"\n    },\n    shapeProperties: {\n      borderDashes: {\n        boolean: Qw,\n        array: tk\n      },\n      borderRadius: {\n        number: Jw\n      },\n      interpolation: {\n        boolean: Qw\n      },\n      useImageSize: {\n        boolean: Qw\n      },\n      useBorderWithImage: {\n        boolean: Qw\n      },\n      coordinateOrigin: {\n        string: [\"center\", \"top-left\"]\n      },\n      __type__: {\n        object: ek\n      }\n    },\n    size: {\n      number: Jw\n    },\n    title: {\n      string: Zw,\n      dom: \"dom\",\n      undefined: \"undefined\"\n    },\n    value: {\n      number: Jw,\n      undefined: \"undefined\"\n    },\n    widthConstraint: {\n      minimum: {\n        number: Jw\n      },\n      maximum: {\n        number: Jw\n      },\n      __type__: {\n        object: ek,\n        boolean: Qw,\n        number: Jw\n      }\n    },\n    x: {\n      number: Jw\n    },\n    y: {\n      number: Jw\n    },\n    __type__: {\n      object: ek\n    }\n  },\n      nk = {\n    configure: {\n      enabled: {\n        boolean: Qw\n      },\n      filter: {\n        boolean: Qw,\n        string: Zw,\n        array: tk,\n        function: \"function\"\n      },\n      container: {\n        dom: \"dom\"\n      },\n      showButton: {\n        boolean: Qw\n      },\n      __type__: {\n        object: ek,\n        boolean: Qw,\n        string: Zw,\n        array: tk,\n        function: \"function\"\n      }\n    },\n    edges: {\n      arrows: {\n        to: {\n          enabled: {\n            boolean: Qw\n          },\n          scaleFactor: {\n            number: Jw\n          },\n          type: {\n            string: ik\n          },\n          imageHeight: {\n            number: Jw\n          },\n          imageWidth: {\n            number: Jw\n          },\n          src: {\n            string: Zw\n          },\n          __type__: {\n            object: ek,\n            boolean: Qw\n          }\n        },\n        middle: {\n          enabled: {\n            boolean: Qw\n          },\n          scaleFactor: {\n            number: Jw\n          },\n          type: {\n            string: ik\n          },\n          imageWidth: {\n            number: Jw\n          },\n          imageHeight: {\n            number: Jw\n          },\n          src: {\n            string: Zw\n          },\n          __type__: {\n            object: ek,\n            boolean: Qw\n          }\n        },\n        from: {\n          enabled: {\n            boolean: Qw\n          },\n          scaleFactor: {\n            number: Jw\n          },\n          type: {\n            string: ik\n          },\n          imageWidth: {\n            number: Jw\n          },\n          imageHeight: {\n            number: Jw\n          },\n          src: {\n            string: Zw\n          },\n          __type__: {\n            object: ek,\n            boolean: Qw\n          }\n        },\n        __type__: {\n          string: [\"from\", \"to\", \"middle\"],\n          object: ek\n        }\n      },\n      endPointOffset: {\n        from: {\n          number: Jw\n        },\n        to: {\n          number: Jw\n        },\n        __type__: {\n          object: ek,\n          number: Jw\n        }\n      },\n      arrowStrikethrough: {\n        boolean: Qw\n      },\n      background: {\n        enabled: {\n          boolean: Qw\n        },\n        color: {\n          string: Zw\n        },\n        size: {\n          number: Jw\n        },\n        dashes: {\n          boolean: Qw,\n          array: tk\n        },\n        __type__: {\n          object: ek,\n          boolean: Qw\n        }\n      },\n      chosen: {\n        label: {\n          boolean: Qw,\n          function: \"function\"\n        },\n        edge: {\n          boolean: Qw,\n          function: \"function\"\n        },\n        __type__: {\n          object: ek,\n          boolean: Qw\n        }\n      },\n      color: {\n        color: {\n          string: Zw\n        },\n        highlight: {\n          string: Zw\n        },\n        hover: {\n          string: Zw\n        },\n        inherit: {\n          string: [\"from\", \"to\", \"both\"],\n          boolean: Qw\n        },\n        opacity: {\n          number: Jw\n        },\n        __type__: {\n          object: ek,\n          string: Zw\n        }\n      },\n      dashes: {\n        boolean: Qw,\n        array: tk\n      },\n      font: {\n        color: {\n          string: Zw\n        },\n        size: {\n          number: Jw\n        },\n        face: {\n          string: Zw\n        },\n        background: {\n          string: Zw\n        },\n        strokeWidth: {\n          number: Jw\n        },\n        strokeColor: {\n          string: Zw\n        },\n        align: {\n          string: [\"horizontal\", \"top\", \"middle\", \"bottom\"]\n        },\n        vadjust: {\n          number: Jw\n        },\n        multi: {\n          boolean: Qw,\n          string: Zw\n        },\n        bold: {\n          color: {\n            string: Zw\n          },\n          size: {\n            number: Jw\n          },\n          face: {\n            string: Zw\n          },\n          mod: {\n            string: Zw\n          },\n          vadjust: {\n            number: Jw\n          },\n          __type__: {\n            object: ek,\n            string: Zw\n          }\n        },\n        boldital: {\n          color: {\n            string: Zw\n          },\n          size: {\n            number: Jw\n          },\n          face: {\n            string: Zw\n          },\n          mod: {\n            string: Zw\n          },\n          vadjust: {\n            number: Jw\n          },\n          __type__: {\n            object: ek,\n            string: Zw\n          }\n        },\n        ital: {\n          color: {\n            string: Zw\n          },\n          size: {\n            number: Jw\n          },\n          face: {\n            string: Zw\n          },\n          mod: {\n            string: Zw\n          },\n          vadjust: {\n            number: Jw\n          },\n          __type__: {\n            object: ek,\n            string: Zw\n          }\n        },\n        mono: {\n          color: {\n            string: Zw\n          },\n          size: {\n            number: Jw\n          },\n          face: {\n            string: Zw\n          },\n          mod: {\n            string: Zw\n          },\n          vadjust: {\n            number: Jw\n          },\n          __type__: {\n            object: ek,\n            string: Zw\n          }\n        },\n        __type__: {\n          object: ek,\n          string: Zw\n        }\n      },\n      hidden: {\n        boolean: Qw\n      },\n      hoverWidth: {\n        function: \"function\",\n        number: Jw\n      },\n      label: {\n        string: Zw,\n        undefined: \"undefined\"\n      },\n      labelHighlightBold: {\n        boolean: Qw\n      },\n      length: {\n        number: Jw,\n        undefined: \"undefined\"\n      },\n      physics: {\n        boolean: Qw\n      },\n      scaling: {\n        min: {\n          number: Jw\n        },\n        max: {\n          number: Jw\n        },\n        label: {\n          enabled: {\n            boolean: Qw\n          },\n          min: {\n            number: Jw\n          },\n          max: {\n            number: Jw\n          },\n          maxVisible: {\n            number: Jw\n          },\n          drawThreshold: {\n            number: Jw\n          },\n          __type__: {\n            object: ek,\n            boolean: Qw\n          }\n        },\n        customScalingFunction: {\n          function: \"function\"\n        },\n        __type__: {\n          object: ek\n        }\n      },\n      selectionWidth: {\n        function: \"function\",\n        number: Jw\n      },\n      selfReferenceSize: {\n        number: Jw\n      },\n      selfReference: {\n        size: {\n          number: Jw\n        },\n        angle: {\n          number: Jw\n        },\n        renderBehindTheNode: {\n          boolean: Qw\n        },\n        __type__: {\n          object: ek\n        }\n      },\n      shadow: {\n        enabled: {\n          boolean: Qw\n        },\n        color: {\n          string: Zw\n        },\n        size: {\n          number: Jw\n        },\n        x: {\n          number: Jw\n        },\n        y: {\n          number: Jw\n        },\n        __type__: {\n          object: ek,\n          boolean: Qw\n        }\n      },\n      smooth: {\n        enabled: {\n          boolean: Qw\n        },\n        type: {\n          string: [\"dynamic\", \"continuous\", \"discrete\", \"diagonalCross\", \"straightCross\", \"horizontal\", \"vertical\", \"curvedCW\", \"curvedCCW\", \"cubicBezier\"]\n        },\n        roundness: {\n          number: Jw\n        },\n        forceDirection: {\n          string: [\"horizontal\", \"vertical\", \"none\"],\n          boolean: Qw\n        },\n        __type__: {\n          object: ek,\n          boolean: Qw\n        }\n      },\n      title: {\n        string: Zw,\n        undefined: \"undefined\"\n      },\n      width: {\n        number: Jw\n      },\n      widthConstraint: {\n        maximum: {\n          number: Jw\n        },\n        __type__: {\n          object: ek,\n          boolean: Qw,\n          number: Jw\n        }\n      },\n      value: {\n        number: Jw,\n        undefined: \"undefined\"\n      },\n      __type__: {\n        object: ek\n      }\n    },\n    groups: {\n      useDefaultGroups: {\n        boolean: Qw\n      },\n      __any__: ok,\n      __type__: {\n        object: ek\n      }\n    },\n    interaction: {\n      dragNodes: {\n        boolean: Qw\n      },\n      dragView: {\n        boolean: Qw\n      },\n      hideEdgesOnDrag: {\n        boolean: Qw\n      },\n      hideEdgesOnZoom: {\n        boolean: Qw\n      },\n      hideNodesOnDrag: {\n        boolean: Qw\n      },\n      hover: {\n        boolean: Qw\n      },\n      keyboard: {\n        enabled: {\n          boolean: Qw\n        },\n        speed: {\n          x: {\n            number: Jw\n          },\n          y: {\n            number: Jw\n          },\n          zoom: {\n            number: Jw\n          },\n          __type__: {\n            object: ek\n          }\n        },\n        bindToWindow: {\n          boolean: Qw\n        },\n        autoFocus: {\n          boolean: Qw\n        },\n        __type__: {\n          object: ek,\n          boolean: Qw\n        }\n      },\n      multiselect: {\n        boolean: Qw\n      },\n      navigationButtons: {\n        boolean: Qw\n      },\n      selectable: {\n        boolean: Qw\n      },\n      selectConnectedEdges: {\n        boolean: Qw\n      },\n      hoverConnectedEdges: {\n        boolean: Qw\n      },\n      tooltipDelay: {\n        number: Jw\n      },\n      zoomView: {\n        boolean: Qw\n      },\n      zoomSpeed: {\n        number: Jw\n      },\n      __type__: {\n        object: ek\n      }\n    },\n    layout: {\n      randomSeed: {\n        undefined: \"undefined\",\n        number: Jw,\n        string: Zw\n      },\n      improvedLayout: {\n        boolean: Qw\n      },\n      clusterThreshold: {\n        number: Jw\n      },\n      hierarchical: {\n        enabled: {\n          boolean: Qw\n        },\n        levelSeparation: {\n          number: Jw\n        },\n        nodeSpacing: {\n          number: Jw\n        },\n        treeSpacing: {\n          number: Jw\n        },\n        blockShifting: {\n          boolean: Qw\n        },\n        edgeMinimization: {\n          boolean: Qw\n        },\n        parentCentralization: {\n          boolean: Qw\n        },\n        direction: {\n          string: [\"UD\", \"DU\", \"LR\", \"RL\"]\n        },\n        sortMethod: {\n          string: [\"hubsize\", \"directed\"]\n        },\n        shakeTowards: {\n          string: [\"leaves\", \"roots\"]\n        },\n        __type__: {\n          object: ek,\n          boolean: Qw\n        }\n      },\n      __type__: {\n        object: ek\n      }\n    },\n    manipulation: {\n      enabled: {\n        boolean: Qw\n      },\n      initiallyActive: {\n        boolean: Qw\n      },\n      addNode: {\n        boolean: Qw,\n        function: \"function\"\n      },\n      addEdge: {\n        boolean: Qw,\n        function: \"function\"\n      },\n      editNode: {\n        function: \"function\"\n      },\n      editEdge: {\n        editWithoutDrag: {\n          function: \"function\"\n        },\n        __type__: {\n          object: ek,\n          boolean: Qw,\n          function: \"function\"\n        }\n      },\n      deleteNode: {\n        boolean: Qw,\n        function: \"function\"\n      },\n      deleteEdge: {\n        boolean: Qw,\n        function: \"function\"\n      },\n      controlNodeStyle: ok,\n      __type__: {\n        object: ek,\n        boolean: Qw\n      }\n    },\n    nodes: ok,\n    physics: {\n      enabled: {\n        boolean: Qw\n      },\n      barnesHut: {\n        theta: {\n          number: Jw\n        },\n        gravitationalConstant: {\n          number: Jw\n        },\n        centralGravity: {\n          number: Jw\n        },\n        springLength: {\n          number: Jw\n        },\n        springConstant: {\n          number: Jw\n        },\n        damping: {\n          number: Jw\n        },\n        avoidOverlap: {\n          number: Jw\n        },\n        __type__: {\n          object: ek\n        }\n      },\n      forceAtlas2Based: {\n        theta: {\n          number: Jw\n        },\n        gravitationalConstant: {\n          number: Jw\n        },\n        centralGravity: {\n          number: Jw\n        },\n        springLength: {\n          number: Jw\n        },\n        springConstant: {\n          number: Jw\n        },\n        damping: {\n          number: Jw\n        },\n        avoidOverlap: {\n          number: Jw\n        },\n        __type__: {\n          object: ek\n        }\n      },\n      repulsion: {\n        centralGravity: {\n          number: Jw\n        },\n        springLength: {\n          number: Jw\n        },\n        springConstant: {\n          number: Jw\n        },\n        nodeDistance: {\n          number: Jw\n        },\n        damping: {\n          number: Jw\n        },\n        __type__: {\n          object: ek\n        }\n      },\n      hierarchicalRepulsion: {\n        centralGravity: {\n          number: Jw\n        },\n        springLength: {\n          number: Jw\n        },\n        springConstant: {\n          number: Jw\n        },\n        nodeDistance: {\n          number: Jw\n        },\n        damping: {\n          number: Jw\n        },\n        avoidOverlap: {\n          number: Jw\n        },\n        __type__: {\n          object: ek\n        }\n      },\n      maxVelocity: {\n        number: Jw\n      },\n      minVelocity: {\n        number: Jw\n      },\n      solver: {\n        string: [\"barnesHut\", \"repulsion\", \"hierarchicalRepulsion\", \"forceAtlas2Based\"]\n      },\n      stabilization: {\n        enabled: {\n          boolean: Qw\n        },\n        iterations: {\n          number: Jw\n        },\n        updateInterval: {\n          number: Jw\n        },\n        onlyDynamicEdges: {\n          boolean: Qw\n        },\n        fit: {\n          boolean: Qw\n        },\n        __type__: {\n          object: ek,\n          boolean: Qw\n        }\n      },\n      timestep: {\n        number: Jw\n      },\n      adaptiveTimestep: {\n        boolean: Qw\n      },\n      wind: {\n        x: {\n          number: Jw\n        },\n        y: {\n          number: Jw\n        },\n        __type__: {\n          object: ek\n        }\n      },\n      __type__: {\n        object: ek,\n        boolean: Qw\n      }\n    },\n    autoResize: {\n      boolean: Qw\n    },\n    clickToUse: {\n      boolean: Qw\n    },\n    locale: {\n      string: Zw\n    },\n    locales: {\n      __any__: {\n        any: \"any\"\n      },\n      __type__: {\n        object: ek\n      }\n    },\n    height: {\n      string: Zw\n    },\n    width: {\n      string: Zw\n    },\n    __type__: {\n      object: ek\n    }\n  },\n      rk = {\n    nodes: {\n      borderWidth: [1, 0, 10, 1],\n      borderWidthSelected: [2, 0, 10, 1],\n      color: {\n        border: [\"color\", \"#2B7CE9\"],\n        background: [\"color\", \"#97C2FC\"],\n        highlight: {\n          border: [\"color\", \"#2B7CE9\"],\n          background: [\"color\", \"#D2E5FF\"]\n        },\n        hover: {\n          border: [\"color\", \"#2B7CE9\"],\n          background: [\"color\", \"#D2E5FF\"]\n        }\n      },\n      opacity: [0, 0, 1, .1],\n      fixed: {\n        x: !1,\n        y: !1\n      },\n      font: {\n        color: [\"color\", \"#343434\"],\n        size: [14, 0, 100, 1],\n        face: [\"arial\", \"verdana\", \"tahoma\"],\n        background: [\"color\", \"none\"],\n        strokeWidth: [0, 0, 50, 1],\n        strokeColor: [\"color\", \"#ffffff\"]\n      },\n      hidden: !1,\n      labelHighlightBold: !0,\n      physics: !0,\n      scaling: {\n        min: [10, 0, 200, 1],\n        max: [30, 0, 200, 1],\n        label: {\n          enabled: !1,\n          min: [14, 0, 200, 1],\n          max: [30, 0, 200, 1],\n          maxVisible: [30, 0, 200, 1],\n          drawThreshold: [5, 0, 20, 1]\n        }\n      },\n      shadow: {\n        enabled: !1,\n        color: \"rgba(0,0,0,0.5)\",\n        size: [10, 0, 20, 1],\n        x: [5, -30, 30, 1],\n        y: [5, -30, 30, 1]\n      },\n      shape: [\"ellipse\", \"box\", \"circle\", \"database\", \"diamond\", \"dot\", \"square\", \"star\", \"text\", \"triangle\", \"triangleDown\", \"hexagon\"],\n      shapeProperties: {\n        borderDashes: !1,\n        borderRadius: [6, 0, 20, 1],\n        interpolation: !0,\n        useImageSize: !1\n      },\n      size: [25, 0, 200, 1]\n    },\n    edges: {\n      arrows: {\n        to: {\n          enabled: !1,\n          scaleFactor: [1, 0, 3, .05],\n          type: \"arrow\"\n        },\n        middle: {\n          enabled: !1,\n          scaleFactor: [1, 0, 3, .05],\n          type: \"arrow\"\n        },\n        from: {\n          enabled: !1,\n          scaleFactor: [1, 0, 3, .05],\n          type: \"arrow\"\n        }\n      },\n      endPointOffset: {\n        from: [0, -10, 10, 1],\n        to: [0, -10, 10, 1]\n      },\n      arrowStrikethrough: !0,\n      color: {\n        color: [\"color\", \"#848484\"],\n        highlight: [\"color\", \"#848484\"],\n        hover: [\"color\", \"#848484\"],\n        inherit: [\"from\", \"to\", \"both\", !0, !1],\n        opacity: [1, 0, 1, .05]\n      },\n      dashes: !1,\n      font: {\n        color: [\"color\", \"#343434\"],\n        size: [14, 0, 100, 1],\n        face: [\"arial\", \"verdana\", \"tahoma\"],\n        background: [\"color\", \"none\"],\n        strokeWidth: [2, 0, 50, 1],\n        strokeColor: [\"color\", \"#ffffff\"],\n        align: [\"horizontal\", \"top\", \"middle\", \"bottom\"]\n      },\n      hidden: !1,\n      hoverWidth: [1.5, 0, 5, .1],\n      labelHighlightBold: !0,\n      physics: !0,\n      scaling: {\n        min: [1, 0, 100, 1],\n        max: [15, 0, 100, 1],\n        label: {\n          enabled: !0,\n          min: [14, 0, 200, 1],\n          max: [30, 0, 200, 1],\n          maxVisible: [30, 0, 200, 1],\n          drawThreshold: [5, 0, 20, 1]\n        }\n      },\n      selectionWidth: [1.5, 0, 5, .1],\n      selfReferenceSize: [20, 0, 200, 1],\n      selfReference: {\n        size: [20, 0, 200, 1],\n        angle: [Math.PI / 2, -6 * Math.PI, 6 * Math.PI, Math.PI / 8],\n        renderBehindTheNode: !0\n      },\n      shadow: {\n        enabled: !1,\n        color: \"rgba(0,0,0,0.5)\",\n        size: [10, 0, 20, 1],\n        x: [5, -30, 30, 1],\n        y: [5, -30, 30, 1]\n      },\n      smooth: {\n        enabled: !0,\n        type: [\"dynamic\", \"continuous\", \"discrete\", \"diagonalCross\", \"straightCross\", \"horizontal\", \"vertical\", \"curvedCW\", \"curvedCCW\", \"cubicBezier\"],\n        forceDirection: [\"horizontal\", \"vertical\", \"none\"],\n        roundness: [.5, 0, 1, .05]\n      },\n      width: [1, 0, 30, 1]\n    },\n    layout: {\n      hierarchical: {\n        enabled: !1,\n        levelSeparation: [150, 20, 500, 5],\n        nodeSpacing: [100, 20, 500, 5],\n        treeSpacing: [200, 20, 500, 5],\n        blockShifting: !0,\n        edgeMinimization: !0,\n        parentCentralization: !0,\n        direction: [\"UD\", \"DU\", \"LR\", \"RL\"],\n        sortMethod: [\"hubsize\", \"directed\"],\n        shakeTowards: [\"leaves\", \"roots\"]\n      }\n    },\n    interaction: {\n      dragNodes: !0,\n      dragView: !0,\n      hideEdgesOnDrag: !1,\n      hideEdgesOnZoom: !1,\n      hideNodesOnDrag: !1,\n      hover: !1,\n      keyboard: {\n        enabled: !1,\n        speed: {\n          x: [10, 0, 40, 1],\n          y: [10, 0, 40, 1],\n          zoom: [.02, 0, .1, .005]\n        },\n        bindToWindow: !0,\n        autoFocus: !0\n      },\n      multiselect: !1,\n      navigationButtons: !1,\n      selectable: !0,\n      selectConnectedEdges: !0,\n      hoverConnectedEdges: !0,\n      tooltipDelay: [300, 0, 1e3, 25],\n      zoomView: !0,\n      zoomSpeed: [1, .1, 2, .1]\n    },\n    manipulation: {\n      enabled: !1,\n      initiallyActive: !1\n    },\n    physics: {\n      enabled: !0,\n      barnesHut: {\n        theta: [.5, .1, 1, .05],\n        gravitationalConstant: [-2e3, -3e4, 0, 50],\n        centralGravity: [.3, 0, 10, .05],\n        springLength: [95, 0, 500, 5],\n        springConstant: [.04, 0, 1.2, .005],\n        damping: [.09, 0, 1, .01],\n        avoidOverlap: [0, 0, 1, .01]\n      },\n      forceAtlas2Based: {\n        theta: [.5, .1, 1, .05],\n        gravitationalConstant: [-50, -500, 0, 1],\n        centralGravity: [.01, 0, 1, .005],\n        springLength: [95, 0, 500, 5],\n        springConstant: [.08, 0, 1.2, .005],\n        damping: [.4, 0, 1, .01],\n        avoidOverlap: [0, 0, 1, .01]\n      },\n      repulsion: {\n        centralGravity: [.2, 0, 10, .05],\n        springLength: [200, 0, 500, 5],\n        springConstant: [.05, 0, 1.2, .005],\n        nodeDistance: [100, 0, 500, 5],\n        damping: [.09, 0, 1, .01]\n      },\n      hierarchicalRepulsion: {\n        centralGravity: [.2, 0, 10, .05],\n        springLength: [100, 0, 500, 5],\n        springConstant: [.01, 0, 1.2, .005],\n        nodeDistance: [120, 0, 500, 5],\n        damping: [.09, 0, 1, .01],\n        avoidOverlap: [0, 0, 1, .01]\n      },\n      maxVelocity: [50, 0, 150, 1],\n      minVelocity: [.1, .01, .5, .01],\n      solver: [\"barnesHut\", \"forceAtlas2Based\", \"repulsion\", \"hierarchicalRepulsion\"],\n      timestep: [.5, .01, 1, .01],\n      wind: {\n        x: [0, -10, 10, .1],\n        y: [0, -10, 10, .1]\n      }\n    }\n  },\n      sk = function (t, e, i) {\n    var o;\n    return !(!Hd(t).call(t, \"physics\") || !Hd(o = rk.physics.solver).call(o, e) || i.physics.solver === e || \"wind\" === e);\n  },\n      ak = Object.freeze({\n    __proto__: null,\n    configuratorHideOption: sk,\n    allOptions: nk,\n    configureOptions: rk\n  }),\n      hk = function () {\n    function t() {\n      Ra(this, t);\n    }\n\n    return Ha(t, [{\n      key: \"getDistances\",\n      value: function (t, e, i) {\n        for (var o = {}, n = t.edges, r = 0; r < e.length; r++) {\n          var s = {};\n          o[e[r]] = s;\n\n          for (var a = 0; a < e.length; a++) s[e[a]] = r == a ? 0 : 1e9;\n        }\n\n        for (var h = 0; h < i.length; h++) {\n          var d = n[i[h]];\n          !0 === d.connected && void 0 !== o[d.fromId] && void 0 !== o[d.toId] && (o[d.fromId][d.toId] = 1, o[d.toId][d.fromId] = 1);\n        }\n\n        for (var l = e.length, c = 0; c < l; c++) for (var u = e[c], f = o[u], p = 0; p < l - 1; p++) for (var v = e[p], g = o[v], y = p + 1; y < l; y++) {\n          var m = e[y],\n              b = o[m],\n              w = Math.min(g[m], g[u] + f[m]);\n          g[m] = w, b[v] = w;\n        }\n\n        return o;\n      }\n    }]), t;\n  }(),\n      dk = function () {\n    function t(e, i, o) {\n      Ra(this, t), this.body = e, this.springLength = i, this.springConstant = o, this.distanceSolver = new hk();\n    }\n\n    return Ha(t, [{\n      key: \"setOptions\",\n      value: function (t) {\n        t && (t.springLength && (this.springLength = t.springLength), t.springConstant && (this.springConstant = t.springConstant));\n      }\n    }, {\n      key: \"solve\",\n      value: function (t, e) {\n        var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n            o = this.distanceSolver.getDistances(this.body, t, e);\n        this._createL_matrix(o), this._createK_matrix(o), this._createE_matrix();\n\n        for (var n = .01, r = 1, s = 0, a = Math.max(1e3, Math.min(10 * this.body.nodeIndices.length, 6e3)), h = 5, d = 1e9, l = 0, c = 0, u = 0, f = 0, p = 0; d > n && s < a;) {\n          s += 1;\n\n          var v = this._getHighestEnergyNode(i),\n              g = Bh(v, 4);\n\n          for (l = g[0], d = g[1], c = g[2], u = g[3], f = d, p = 0; f > r && p < h;) {\n            p += 1, this._moveNode(l, c, u);\n\n            var y = this._getEnergy(l),\n                m = Bh(y, 3);\n\n            f = m[0], c = m[1], u = m[2];\n          }\n        }\n      }\n    }, {\n      key: \"_getHighestEnergyNode\",\n      value: function (t) {\n        for (var e = this.body.nodeIndices, i = this.body.nodes, o = 0, n = e[0], r = 0, s = 0, a = 0; a < e.length; a++) {\n          var h = e[a];\n\n          if (!0 !== i[h].predefinedPosition || !0 === i[h].isCluster && !0 === t || !0 !== i[h].options.fixed.x || !0 !== i[h].options.fixed.y) {\n            var d = Bh(this._getEnergy(h), 3),\n                l = d[0],\n                c = d[1],\n                u = d[2];\n            o < l && (o = l, n = h, r = c, s = u);\n          }\n        }\n\n        return [n, o, r, s];\n      }\n    }, {\n      key: \"_getEnergy\",\n      value: function (t) {\n        var e = Bh(this.E_sums[t], 2),\n            i = e[0],\n            o = e[1];\n        return [Math.sqrt(Math.pow(i, 2) + Math.pow(o, 2)), i, o];\n      }\n    }, {\n      key: \"_moveNode\",\n      value: function (t, e, i) {\n        for (var o = this.body.nodeIndices, n = this.body.nodes, r = 0, s = 0, a = 0, h = n[t].x, d = n[t].y, l = this.K_matrix[t], c = this.L_matrix[t], u = 0; u < o.length; u++) {\n          var f = o[u];\n\n          if (f !== t) {\n            var p = n[f].x,\n                v = n[f].y,\n                g = l[f],\n                y = c[f],\n                m = 1 / Math.pow(Math.pow(h - p, 2) + Math.pow(d - v, 2), 1.5);\n            r += g * (1 - y * Math.pow(d - v, 2) * m), s += g * (y * (h - p) * (d - v) * m), a += g * (1 - y * Math.pow(h - p, 2) * m);\n          }\n        }\n\n        var b = (e / r + i / s) / (s / r - a / s),\n            w = -(s * b + e) / r;\n        n[t].x += w, n[t].y += b, this._updateE_matrix(t);\n      }\n    }, {\n      key: \"_createL_matrix\",\n      value: function (t) {\n        var e = this.body.nodeIndices,\n            i = this.springLength;\n        this.L_matrix = [];\n\n        for (var o = 0; o < e.length; o++) {\n          this.L_matrix[e[o]] = {};\n\n          for (var n = 0; n < e.length; n++) this.L_matrix[e[o]][e[n]] = i * t[e[o]][e[n]];\n        }\n      }\n    }, {\n      key: \"_createK_matrix\",\n      value: function (t) {\n        var e = this.body.nodeIndices,\n            i = this.springConstant;\n        this.K_matrix = [];\n\n        for (var o = 0; o < e.length; o++) {\n          this.K_matrix[e[o]] = {};\n\n          for (var n = 0; n < e.length; n++) this.K_matrix[e[o]][e[n]] = i * Math.pow(t[e[o]][e[n]], -2);\n        }\n      }\n    }, {\n      key: \"_createE_matrix\",\n      value: function () {\n        var t = this.body.nodeIndices,\n            e = this.body.nodes;\n        this.E_matrix = {}, this.E_sums = {};\n\n        for (var i = 0; i < t.length; i++) this.E_matrix[t[i]] = [];\n\n        for (var o = 0; o < t.length; o++) {\n          for (var n = t[o], r = e[n].x, s = e[n].y, a = 0, h = 0, d = o; d < t.length; d++) {\n            var l = t[d];\n\n            if (l !== n) {\n              var c = e[l].x,\n                  u = e[l].y,\n                  f = 1 / Math.sqrt(Math.pow(r - c, 2) + Math.pow(s - u, 2));\n              this.E_matrix[n][d] = [this.K_matrix[n][l] * (r - c - this.L_matrix[n][l] * (r - c) * f), this.K_matrix[n][l] * (s - u - this.L_matrix[n][l] * (s - u) * f)], this.E_matrix[l][o] = this.E_matrix[n][d], a += this.E_matrix[n][d][0], h += this.E_matrix[n][d][1];\n            }\n          }\n\n          this.E_sums[n] = [a, h];\n        }\n      }\n    }, {\n      key: \"_updateE_matrix\",\n      value: function (t) {\n        for (var e = this.body.nodeIndices, i = this.body.nodes, o = this.E_matrix[t], n = this.K_matrix[t], r = this.L_matrix[t], s = i[t].x, a = i[t].y, h = 0, d = 0, l = 0; l < e.length; l++) {\n          var c = e[l];\n\n          if (c !== t) {\n            var u = o[l],\n                f = u[0],\n                p = u[1],\n                v = i[c].x,\n                g = i[c].y,\n                y = 1 / Math.sqrt(Math.pow(s - v, 2) + Math.pow(a - g, 2)),\n                m = n[c] * (s - v - r[c] * (s - v) * y),\n                b = n[c] * (a - g - r[c] * (a - g) * y);\n            o[l] = [m, b], h += m, d += b;\n            var w = this.E_sums[c];\n            w[0] += m - f, w[1] += b - p;\n          }\n        }\n\n        this.E_sums[t] = [h, d];\n      }\n    }]), t;\n  }();\n\n  function lk(t, e, i) {\n    var o,\n        n,\n        r,\n        s,\n        a = this;\n    if (!(this instanceof lk)) throw new SyntaxError(\"Constructor must be called with the new operator\");\n    this.options = {}, this.defaultOptions = {\n      locale: \"en\",\n      locales: mp,\n      clickToUse: !1\n    }, Ke(this.options, this.defaultOptions), this.body = {\n      container: t,\n      nodes: {},\n      nodeIndices: [],\n      edges: {},\n      edgeIndices: [],\n      emitter: {\n        on: si(o = this.on).call(o, this),\n        off: si(n = this.off).call(n, this),\n        emit: si(r = this.emit).call(r, this),\n        once: si(s = this.once).call(s, this)\n      },\n      eventListeners: {\n        onTap: function () {},\n        onTouch: function () {},\n        onDoubleTap: function () {},\n        onHold: function () {},\n        onDragStart: function () {},\n        onDrag: function () {},\n        onDragEnd: function () {},\n        onMouseWheel: function () {},\n        onPinch: function () {},\n        onMouseMove: function () {},\n        onRelease: function () {},\n        onContext: function () {}\n      },\n      data: {\n        nodes: null,\n        edges: null\n      },\n      functions: {\n        createNode: function () {},\n        createEdge: function () {},\n        getPointer: function () {}\n      },\n      modules: {},\n      view: {\n        scale: 1,\n        translation: {\n          x: 0,\n          y: 0\n        }\n      },\n      selectionBox: {\n        show: !1,\n        position: {\n          start: {\n            x: 0,\n            y: 0\n          },\n          end: {\n            x: 0,\n            y: 0\n          }\n        }\n      }\n    }, this.bindEventListeners(), this.images = new wp(function () {\n      return a.body.emitter.emit(\"_requestRedraw\");\n    }), this.groups = new Sv(), this.canvas = new Am(this.body), this.selectionHandler = new Hb(this.body, this.canvas), this.interactionHandler = new qm(this.body, this.canvas, this.selectionHandler), this.view = new jm(this.body, this.canvas), this.renderer = new Im(this.body, this.canvas), this.physics = new bm(this.body), this.layoutEngine = new Xw(this.body), this.clustering = new Pm(this.body), this.manipulation = new $w(this.body, this.canvas, this.selectionHandler, this.interactionHandler), this.nodesHandler = new vy(this.body, this.images, this.groups, this.layoutEngine), this.edgesHandler = new am(this.body, this.images, this.groups), this.body.modules.kamadaKawai = new dk(this.body, 150, .05), this.body.modules.clustering = this.clustering, this.canvas._create(), this.setOptions(i), this.setData(e);\n  }\n\n  pi(lk.prototype), lk.prototype.setOptions = function (t) {\n    var e = this;\n\n    if (null === t && (t = void 0), void 0 !== t) {\n      !0 === Nf.validate(t, nk) && console.error(\"%cErrors have been found in the supplied options object.\", Ff);\n\n      if (nf([\"locale\", \"locales\", \"clickToUse\"], this.options, t), void 0 !== t.locale && (t.locale = function (t, e) {\n        try {\n          var i = Bh(e.split(/[-_ /]/, 2), 2),\n              o = i[0],\n              n = i[1],\n              r = null != o ? o.toLowerCase() : null,\n              s = null != n ? n.toUpperCase() : null;\n\n          if (r && s) {\n            var a,\n                h = r + \"-\" + s;\n            if (Object.prototype.hasOwnProperty.call(t, h)) return h;\n            console.warn(jh(a = \"Unknown variant \".concat(s, \" of language \")).call(a, r, \".\"));\n          }\n\n          if (r) {\n            var d = r;\n            if (Object.prototype.hasOwnProperty.call(t, d)) return d;\n            console.warn(\"Unknown language \".concat(r));\n          }\n\n          return console.warn(\"Unknown locale \".concat(e, \", falling back to English.\")), \"en\";\n        } catch (t) {\n          return console.error(t), console.warn(\"Unexpected error while normalizing locale \".concat(e, \", falling back to English.\")), \"en\";\n        }\n      }(t.locales || this.options.locales, t.locale)), t = this.layoutEngine.setOptions(t.layout, t), this.canvas.setOptions(t), this.groups.setOptions(t.groups), this.nodesHandler.setOptions(t.nodes), this.edgesHandler.setOptions(t.edges), this.physics.setOptions(t.physics), this.manipulation.setOptions(t.manipulation, t, this.options), this.interactionHandler.setOptions(t.interaction), this.renderer.setOptions(t.interaction), this.selectionHandler.setOptions(t.interaction), void 0 !== t.groups && this.body.emitter.emit(\"refreshNodes\"), \"configure\" in t && (this.configurator || (this.configurator = new Bf(this, this.body.container, rk, this.canvas.pixelRatio, sk)), this.configurator.setOptions(t.configure)), this.configurator && !0 === this.configurator.options.enabled) {\n        var i = {\n          nodes: {},\n          edges: {},\n          layout: {},\n          interaction: {},\n          manipulation: {},\n          physics: {},\n          global: {}\n        };\n        sf(i.nodes, this.nodesHandler.options), sf(i.edges, this.edgesHandler.options), sf(i.layout, this.layoutEngine.options), sf(i.interaction, this.selectionHandler.options), sf(i.interaction, this.renderer.options), sf(i.interaction, this.interactionHandler.options), sf(i.manipulation, this.manipulation.options), sf(i.physics, this.physics.options), sf(i.global, this.canvas.options), sf(i.global, this.options), this.configurator.setModuleOptions(i);\n      }\n\n      void 0 !== t.clickToUse ? !0 === t.clickToUse ? void 0 === this.activator && (this.activator = new Df(this.canvas.frame), this.activator.on(\"change\", function () {\n        e.body.emitter.emit(\"activate\");\n      })) : (void 0 !== this.activator && (this.activator.destroy(), delete this.activator), this.body.emitter.emit(\"activate\")) : this.body.emitter.emit(\"activate\"), this.canvas.setSize(), this.body.emitter.emit(\"startSimulation\");\n    }\n  }, lk.prototype._updateVisibleIndices = function () {\n    var t = this.body.nodes,\n        e = this.body.edges;\n\n    for (var i in this.body.nodeIndices = [], this.body.edgeIndices = [], t) Object.prototype.hasOwnProperty.call(t, i) && (this.clustering._isClusteredNode(i) || !1 !== t[i].options.hidden || this.body.nodeIndices.push(t[i].id));\n\n    for (var o in e) if (Object.prototype.hasOwnProperty.call(e, o)) {\n      var n = e[o],\n          r = t[n.fromId],\n          s = t[n.toId],\n          a = void 0 !== r && void 0 !== s;\n      !this.clustering._isClusteredEdge(o) && !1 === n.options.hidden && a && !1 === r.options.hidden && !1 === s.options.hidden && this.body.edgeIndices.push(n.id);\n    }\n  }, lk.prototype.bindEventListeners = function () {\n    var t = this;\n    this.body.emitter.on(\"_dataChanged\", function () {\n      t.edgesHandler._updateState(), t.body.emitter.emit(\"_dataUpdated\");\n    }), this.body.emitter.on(\"_dataUpdated\", function () {\n      t.clustering._updateState(), t._updateVisibleIndices(), t._updateValueRange(t.body.nodes), t._updateValueRange(t.body.edges), t.body.emitter.emit(\"startSimulation\"), t.body.emitter.emit(\"_requestRedraw\");\n    });\n  }, lk.prototype.setData = function (t) {\n    if (this.body.emitter.emit(\"resetPhysics\"), this.body.emitter.emit(\"_resetData\"), this.selectionHandler.unselectAll(), t && t.dot && (t.nodes || t.edges)) throw new SyntaxError('Data must contain either parameter \"dot\" or  parameter pair \"nodes\" and \"edges\", but not both.');\n\n    if (this.setOptions(t && t.options), t && t.dot) {\n      console.warn(\"The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);\");\n      var e = pp(t.dot);\n      this.setData(e);\n    } else if (t && t.gephi) {\n      console.warn(\"The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);\");\n      var i = gp(t.gephi);\n      this.setData(i);\n    } else this.nodesHandler.setData(t && t.nodes, !0), this.edgesHandler.setData(t && t.edges, !0), this.body.emitter.emit(\"_dataChanged\"), this.body.emitter.emit(\"_dataLoaded\"), this.body.emitter.emit(\"initPhysics\");\n  }, lk.prototype.destroy = function () {\n    for (var t in this.body.emitter.emit(\"destroy\"), this.body.emitter.off(), this.off(), delete this.groups, delete this.canvas, delete this.selectionHandler, delete this.interactionHandler, delete this.view, delete this.renderer, delete this.physics, delete this.layoutEngine, delete this.clustering, delete this.manipulation, delete this.nodesHandler, delete this.edgesHandler, delete this.configurator, delete this.images, this.body.nodes) Object.prototype.hasOwnProperty.call(this.body.nodes, t) && delete this.body.nodes[t];\n\n    for (var e in this.body.edges) Object.prototype.hasOwnProperty.call(this.body.edges, e) && delete this.body.edges[e];\n\n    Qu(this.body.container);\n  }, lk.prototype._updateValueRange = function (t) {\n    var e,\n        i = void 0,\n        o = void 0,\n        n = 0;\n\n    for (e in t) if (Object.prototype.hasOwnProperty.call(t, e)) {\n      var r = t[e].getValue();\n      void 0 !== r && (i = void 0 === i ? r : Math.min(r, i), o = void 0 === o ? r : Math.max(r, o), n += r);\n    }\n\n    if (void 0 !== i && void 0 !== o) for (e in t) Object.prototype.hasOwnProperty.call(t, e) && t[e].setValueRange(i, o, n);\n  }, lk.prototype.isActive = function () {\n    return !this.activator || this.activator.active;\n  }, lk.prototype.setSize = function () {\n    return this.canvas.setSize.apply(this.canvas, arguments);\n  }, lk.prototype.canvasToDOM = function () {\n    return this.canvas.canvasToDOM.apply(this.canvas, arguments);\n  }, lk.prototype.DOMtoCanvas = function () {\n    return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);\n  }, lk.prototype.findNode = function () {\n    return this.clustering.findNode.apply(this.clustering, arguments);\n  }, lk.prototype.isCluster = function () {\n    return this.clustering.isCluster.apply(this.clustering, arguments);\n  }, lk.prototype.openCluster = function () {\n    return this.clustering.openCluster.apply(this.clustering, arguments);\n  }, lk.prototype.cluster = function () {\n    return this.clustering.cluster.apply(this.clustering, arguments);\n  }, lk.prototype.getNodesInCluster = function () {\n    return this.clustering.getNodesInCluster.apply(this.clustering, arguments);\n  }, lk.prototype.clusterByConnection = function () {\n    return this.clustering.clusterByConnection.apply(this.clustering, arguments);\n  }, lk.prototype.clusterByHubsize = function () {\n    return this.clustering.clusterByHubsize.apply(this.clustering, arguments);\n  }, lk.prototype.updateClusteredNode = function () {\n    return this.clustering.updateClusteredNode.apply(this.clustering, arguments);\n  }, lk.prototype.getClusteredEdges = function () {\n    return this.clustering.getClusteredEdges.apply(this.clustering, arguments);\n  }, lk.prototype.getBaseEdge = function () {\n    return this.clustering.getBaseEdge.apply(this.clustering, arguments);\n  }, lk.prototype.getBaseEdges = function () {\n    return this.clustering.getBaseEdges.apply(this.clustering, arguments);\n  }, lk.prototype.updateEdge = function () {\n    return this.clustering.updateEdge.apply(this.clustering, arguments);\n  }, lk.prototype.clusterOutliers = function () {\n    return this.clustering.clusterOutliers.apply(this.clustering, arguments);\n  }, lk.prototype.getSeed = function () {\n    return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);\n  }, lk.prototype.enableEditMode = function () {\n    return this.manipulation.enableEditMode.apply(this.manipulation, arguments);\n  }, lk.prototype.disableEditMode = function () {\n    return this.manipulation.disableEditMode.apply(this.manipulation, arguments);\n  }, lk.prototype.addNodeMode = function () {\n    return this.manipulation.addNodeMode.apply(this.manipulation, arguments);\n  }, lk.prototype.editNode = function () {\n    return this.manipulation.editNode.apply(this.manipulation, arguments);\n  }, lk.prototype.editNodeMode = function () {\n    return console.warn(\"Deprecated: Please use editNode instead of editNodeMode.\"), this.manipulation.editNode.apply(this.manipulation, arguments);\n  }, lk.prototype.addEdgeMode = function () {\n    return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);\n  }, lk.prototype.editEdgeMode = function () {\n    return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);\n  }, lk.prototype.deleteSelected = function () {\n    return this.manipulation.deleteSelected.apply(this.manipulation, arguments);\n  }, lk.prototype.getPositions = function () {\n    return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);\n  }, lk.prototype.getPosition = function () {\n    return this.nodesHandler.getPosition.apply(this.nodesHandler, arguments);\n  }, lk.prototype.storePositions = function () {\n    return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);\n  }, lk.prototype.moveNode = function () {\n    return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);\n  }, lk.prototype.getBoundingBox = function () {\n    return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);\n  }, lk.prototype.getConnectedNodes = function (t) {\n    return void 0 !== this.body.nodes[t] ? this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments) : this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);\n  }, lk.prototype.getConnectedEdges = function () {\n    return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);\n  }, lk.prototype.startSimulation = function () {\n    return this.physics.startSimulation.apply(this.physics, arguments);\n  }, lk.prototype.stopSimulation = function () {\n    return this.physics.stopSimulation.apply(this.physics, arguments);\n  }, lk.prototype.stabilize = function () {\n    return this.physics.stabilize.apply(this.physics, arguments);\n  }, lk.prototype.getSelection = function () {\n    return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);\n  }, lk.prototype.setSelection = function () {\n    return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);\n  }, lk.prototype.getSelectedNodes = function () {\n    return this.selectionHandler.getSelectedNodeIds.apply(this.selectionHandler, arguments);\n  }, lk.prototype.getSelectedEdges = function () {\n    return this.selectionHandler.getSelectedEdgeIds.apply(this.selectionHandler, arguments);\n  }, lk.prototype.getNodeAt = function () {\n    var t = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);\n    return void 0 !== t && void 0 !== t.id ? t.id : t;\n  }, lk.prototype.getEdgeAt = function () {\n    var t = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);\n    return void 0 !== t && void 0 !== t.id ? t.id : t;\n  }, lk.prototype.selectNodes = function () {\n    return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);\n  }, lk.prototype.selectEdges = function () {\n    return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);\n  }, lk.prototype.unselectAll = function () {\n    this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments), this.selectionHandler.commitWithoutEmitting.apply(this.selectionHandler), this.redraw();\n  }, lk.prototype.redraw = function () {\n    return this.renderer.redraw.apply(this.renderer, arguments);\n  }, lk.prototype.getScale = function () {\n    return this.view.getScale.apply(this.view, arguments);\n  }, lk.prototype.getViewPosition = function () {\n    return this.view.getViewPosition.apply(this.view, arguments);\n  }, lk.prototype.fit = function () {\n    return this.view.fit.apply(this.view, arguments);\n  }, lk.prototype.moveTo = function () {\n    return this.view.moveTo.apply(this.view, arguments);\n  }, lk.prototype.focus = function () {\n    return this.view.focus.apply(this.view, arguments);\n  }, lk.prototype.releaseNode = function () {\n    return this.view.releaseNode.apply(this.view, arguments);\n  }, lk.prototype.getOptionsFromConfigurator = function () {\n    var t = {};\n    return this.configurator && (t = this.configurator.getOptions.apply(this.configurator)), t;\n  };\n  var ck = pp;\n  t.Network = lk, t.NetworkImages = wp, t.networkDOTParser = vp, t.networkGephiParser = yp, t.networkOptions = ak, t.parseDOTNetwork = ck, t.parseGephiNetwork = gp, Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n}); //# sourceMappingURL=vis-network.min.js.map","map":null,"metadata":{},"sourceType":"script"}