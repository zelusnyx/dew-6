{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Output, Injectable, HostListener, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, ContentChild, ViewChildren, NgModule } from '@angular/core';\nimport * as i3 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport { __decorate } from 'tslib';\nimport { trigger, transition, style, animate } from '@angular/animations';\nimport { select } from 'd3-selection';\nimport * as shape from 'd3-shape';\nimport * as ease from 'd3-ease';\nimport 'd3-transition';\nimport { Subject, Subscription, Observable, of, fromEvent } from 'rxjs';\nimport { takeUntil, first, debounceTime } from 'rxjs/operators';\nimport { identity, transform, translate, scale, toSVG, smoothMatrix } from 'transformation-matrix';\nimport { scaleOrdinal } from 'd3-scale';\nimport * as dagre from 'dagre';\nimport * as d3Force from 'd3-force';\nimport { forceSimulation, forceManyBody, forceCollide, forceLink } from 'd3-force';\nimport { d3adaptor } from 'webcola';\nimport * as d3Dispatch from 'd3-dispatch';\nimport * as d3Timer from 'd3-timer';\nconst _c0 = [\"linkTemplate\"];\nconst _c1 = [\"nodeTemplate\"];\nconst _c2 = [\"clusterTemplate\"];\nconst _c3 = [\"defsTemplate\"];\nconst _c4 = [\"miniMapNodeTemplate\"];\nconst _c5 = [\"nodeElement\"];\nconst _c6 = [\"linkElement\"];\n\nfunction GraphComponent__svg_g_2__svg_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementContainer(0, 15);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.defsTemplate);\n  }\n}\n\nfunction GraphComponent__svg_g_2__svg_path_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"path\", 16);\n  }\n\n  if (rf & 2) {\n    const link_r8 = ctx.$implicit;\n    i0.ɵɵattribute(\"d\", link_r8.textPath)(\"id\", link_r8.id);\n  }\n}\n\nconst _c7 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\n\nfunction GraphComponent__svg_g_2__svg_g_7__svg_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementContainer(0, 21);\n  }\n\n  if (rf & 2) {\n    const node_r9 = i0.ɵɵnextContext().$implicit;\n    const ctx_r11 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r11.clusterTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c7, node_r9));\n  }\n}\n\nfunction GraphComponent__svg_g_2__svg_g_7__svg_g_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"g\", 22);\n    i0.ɵɵelement(1, \"rect\");\n    i0.ɵɵelementStart(2, \"text\", 23);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const node_r9 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"width\", node_r9.dimension.width)(\"height\", node_r9.dimension.height)(\"fill\", node_r9.data == null ? null : node_r9.data.color);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"x\", 10)(\"y\", node_r9.dimension.height / 2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", node_r9.label, \" \");\n  }\n}\n\nfunction GraphComponent__svg_g_2__svg_g_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"g\", 17, 18);\n    i0.ɵɵlistener(\"click\", function GraphComponent__svg_g_2__svg_g_7_Template__svg_g_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r16);\n      const node_r9 = restoredCtx.$implicit;\n      const ctx_r15 = i0.ɵɵnextContext(2);\n      return ctx_r15.onClick(node_r9);\n    });\n    i0.ɵɵtemplate(2, GraphComponent__svg_g_2__svg_g_7__svg_ng_container_2_Template, 1, 4, \"ng-container\", 19);\n    i0.ɵɵtemplate(3, GraphComponent__svg_g_2__svg_g_7__svg_g_3_Template, 4, 6, \"g\", 20);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const node_r9 = ctx.$implicit;\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"old-node\", ctx_r4.animate && ctx_r4.oldClusters.has(node_r9.id));\n    i0.ɵɵproperty(\"id\", node_r9.id);\n    i0.ɵɵattribute(\"transform\", node_r9.transform);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r4.clusterTemplate && !node_r9.hidden);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r4.clusterTemplate);\n  }\n}\n\nfunction GraphComponent__svg_g_2__svg_g_9__svg_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementContainer(0, 21);\n  }\n\n  if (rf & 2) {\n    const node_r17 = i0.ɵɵnextContext().$implicit;\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r19.nodeTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c7, node_r17));\n  }\n}\n\nfunction GraphComponent__svg_g_2__svg_g_9__svg_g_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"g\", 27);\n    i0.ɵɵelement(1, \"rect\");\n    i0.ɵɵelementStart(2, \"text\", 23);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const node_r17 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"width\", node_r17.dimension.width)(\"height\", node_r17.dimension.height)(\"fill\", node_r17.data == null ? null : node_r17.data.color);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"x\", 10)(\"y\", node_r17.dimension.height / 2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", node_r17.label, \" \");\n  }\n}\n\nfunction GraphComponent__svg_g_2__svg_g_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r24 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"g\", 24, 25);\n    i0.ɵɵlistener(\"click\", function GraphComponent__svg_g_2__svg_g_9_Template__svg_g_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r24);\n      const node_r17 = restoredCtx.$implicit;\n      const ctx_r23 = i0.ɵɵnextContext(2);\n      return ctx_r23.onClick(node_r17);\n    })(\"mousedown\", function GraphComponent__svg_g_2__svg_g_9_Template__svg_g_mousedown_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r24);\n      const node_r17 = restoredCtx.$implicit;\n      const ctx_r25 = i0.ɵɵnextContext(2);\n      return ctx_r25.onNodeMouseDown($event, node_r17);\n    });\n    i0.ɵɵtemplate(2, GraphComponent__svg_g_2__svg_g_9__svg_ng_container_2_Template, 1, 4, \"ng-container\", 19);\n    i0.ɵɵtemplate(3, GraphComponent__svg_g_2__svg_g_9__svg_g_3_Template, 4, 6, \"g\", 26);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const node_r17 = ctx.$implicit;\n    const ctx_r5 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"old-node\", ctx_r5.animate && ctx_r5.oldCompoundNodes.has(node_r17.id));\n    i0.ɵɵproperty(\"id\", node_r17.id);\n    i0.ɵɵattribute(\"transform\", node_r17.transform);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r5.nodeTemplate && !node_r17.hidden);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r5.nodeTemplate);\n  }\n}\n\nfunction GraphComponent__svg_g_2__svg_g_11__svg_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementContainer(0, 21);\n  }\n\n  if (rf & 2) {\n    const link_r26 = i0.ɵɵnextContext().$implicit;\n    const ctx_r28 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r28.linkTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c7, link_r26));\n  }\n}\n\nfunction GraphComponent__svg_g_2__svg_g_11__svg_path_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"path\", 31);\n  }\n\n  if (rf & 2) {\n    const link_r26 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵattribute(\"d\", link_r26.line);\n  }\n}\n\nfunction GraphComponent__svg_g_2__svg_g_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"g\", 28, 29);\n    i0.ɵɵtemplate(2, GraphComponent__svg_g_2__svg_g_11__svg_ng_container_2_Template, 1, 4, \"ng-container\", 19);\n    i0.ɵɵtemplate(3, GraphComponent__svg_g_2__svg_g_11__svg_path_3_Template, 1, 1, \"path\", 30);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const link_r26 = ctx.$implicit;\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"id\", link_r26.id);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r6.linkTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r6.linkTemplate);\n  }\n}\n\nfunction GraphComponent__svg_g_2__svg_g_13__svg_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementContainer(0, 21);\n  }\n\n  if (rf & 2) {\n    const node_r32 = i0.ɵɵnextContext().$implicit;\n    const ctx_r34 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r34.nodeTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c7, node_r32));\n  }\n}\n\nfunction GraphComponent__svg_g_2__svg_g_13__svg_circle_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"circle\", 33);\n  }\n\n  if (rf & 2) {\n    const node_r32 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵattribute(\"cx\", node_r32.dimension.width / 2)(\"cy\", node_r32.dimension.height / 2)(\"fill\", node_r32.data == null ? null : node_r32.data.color);\n  }\n}\n\nfunction GraphComponent__svg_g_2__svg_g_13_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r39 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"g\", 24, 25);\n    i0.ɵɵlistener(\"click\", function GraphComponent__svg_g_2__svg_g_13_Template__svg_g_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r39);\n      const node_r32 = restoredCtx.$implicit;\n      const ctx_r38 = i0.ɵɵnextContext(2);\n      return ctx_r38.onClick(node_r32);\n    })(\"mousedown\", function GraphComponent__svg_g_2__svg_g_13_Template__svg_g_mousedown_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r39);\n      const node_r32 = restoredCtx.$implicit;\n      const ctx_r40 = i0.ɵɵnextContext(2);\n      return ctx_r40.onNodeMouseDown($event, node_r32);\n    });\n    i0.ɵɵtemplate(2, GraphComponent__svg_g_2__svg_g_13__svg_ng_container_2_Template, 1, 4, \"ng-container\", 19);\n    i0.ɵɵtemplate(3, GraphComponent__svg_g_2__svg_g_13__svg_circle_3_Template, 1, 3, \"circle\", 32);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const node_r32 = ctx.$implicit;\n    const ctx_r7 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"old-node\", ctx_r7.animate && ctx_r7.oldNodes.has(node_r32.id));\n    i0.ɵɵproperty(\"id\", node_r32.id);\n    i0.ɵɵattribute(\"transform\", node_r32.transform);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7.nodeTemplate && !node_r32.hidden);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r7.nodeTemplate);\n  }\n}\n\nfunction GraphComponent__svg_g_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r42 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"g\", 4);\n    i0.ɵɵlistener(\"touchstart\", function GraphComponent__svg_g_2_Template__svg_g_touchstart_0_listener($event) {\n      i0.ɵɵrestoreView(_r42);\n      const ctx_r41 = i0.ɵɵnextContext();\n      return ctx_r41.onTouchStart($event);\n    })(\"touchend\", function GraphComponent__svg_g_2_Template__svg_g_touchend_0_listener($event) {\n      i0.ɵɵrestoreView(_r42);\n      const ctx_r43 = i0.ɵɵnextContext();\n      return ctx_r43.onTouchEnd($event);\n    });\n    i0.ɵɵelementStart(1, \"defs\");\n    i0.ɵɵtemplate(2, GraphComponent__svg_g_2__svg_ng_container_2_Template, 1, 1, \"ng-container\", 5);\n    i0.ɵɵtemplate(3, GraphComponent__svg_g_2__svg_path_3_Template, 1, 2, \"path\", 6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"rect\", 7);\n    i0.ɵɵlistener(\"mousedown\", function GraphComponent__svg_g_2_Template__svg_rect_mousedown_4_listener() {\n      i0.ɵɵrestoreView(_r42);\n      const ctx_r44 = i0.ɵɵnextContext();\n      return ctx_r44.isPanning = true;\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵprojection(5);\n    i0.ɵɵelementStart(6, \"g\", 8);\n    i0.ɵɵtemplate(7, GraphComponent__svg_g_2__svg_g_7_Template, 4, 6, \"g\", 9);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(8, \"g\", 10);\n    i0.ɵɵtemplate(9, GraphComponent__svg_g_2__svg_g_9_Template, 4, 6, \"g\", 11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(10, \"g\", 12);\n    i0.ɵɵtemplate(11, GraphComponent__svg_g_2__svg_g_11_Template, 4, 3, \"g\", 13);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(12, \"g\", 14);\n    i0.ɵɵtemplate(13, GraphComponent__svg_g_2__svg_g_13_Template, 4, 6, \"g\", 11);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"transform\", ctx_r0.transform);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.defsTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.graph.edges);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"width\", ctx_r0.dims.width * 100)(\"height\", ctx_r0.dims.height * 100)(\"transform\", \"translate(\" + (-ctx_r0.dims.width || 0) * 50 + \",\" + (-ctx_r0.dims.height || 0) * 50 + \")\");\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.graph.clusters)(\"ngForTrackBy\", ctx_r0.trackNodeBy);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.graph.compoundNodes)(\"ngForTrackBy\", ctx_r0.trackNodeBy);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.graph.edges)(\"ngForTrackBy\", ctx_r0.trackLinkBy);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.graph.nodes)(\"ngForTrackBy\", ctx_r0.trackNodeBy);\n  }\n}\n\nfunction GraphComponent__svg_g_5__svg_g_4__svg_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementContainer(0, 21);\n  }\n\n  if (rf & 2) {\n    const node_r46 = i0.ɵɵnextContext().$implicit;\n    const ctx_r48 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r48.miniMapNodeTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c7, node_r46));\n  }\n}\n\nfunction GraphComponent__svg_g_5__svg_g_4__svg_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementContainer(0, 21);\n  }\n\n  if (rf & 2) {\n    const node_r46 = i0.ɵɵnextContext().$implicit;\n    const ctx_r49 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r49.nodeTemplate)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c7, node_r46));\n  }\n}\n\nfunction GraphComponent__svg_g_5__svg_g_4__svg_circle_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelement(0, \"circle\", 33);\n  }\n\n  if (rf & 2) {\n    const node_r46 = i0.ɵɵnextContext().$implicit;\n    const ctx_r50 = i0.ɵɵnextContext(2);\n    i0.ɵɵattribute(\"cx\", node_r46.dimension.width / 2 / ctx_r50.minimapScaleCoefficient)(\"cy\", node_r46.dimension.height / 2 / ctx_r50.minimapScaleCoefficient)(\"fill\", node_r46.data == null ? null : node_r46.data.color);\n  }\n}\n\nfunction GraphComponent__svg_g_5__svg_g_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"g\", 39, 25);\n    i0.ɵɵtemplate(2, GraphComponent__svg_g_5__svg_g_4__svg_ng_container_2_Template, 1, 4, \"ng-container\", 19);\n    i0.ɵɵtemplate(3, GraphComponent__svg_g_5__svg_g_4__svg_ng_container_3_Template, 1, 4, \"ng-container\", 19);\n    i0.ɵɵtemplate(4, GraphComponent__svg_g_5__svg_g_4__svg_circle_4_Template, 1, 3, \"circle\", 32);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const node_r46 = ctx.$implicit;\n    const ctx_r45 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"old-node\", ctx_r45.animate && ctx_r45.oldNodes.has(node_r46.id));\n    i0.ɵɵproperty(\"id\", node_r46.id);\n    i0.ɵɵattribute(\"transform\", node_r46.transform);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r45.miniMapNodeTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r45.miniMapNodeTemplate && ctx_r45.nodeTemplate);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r45.nodeTemplate && !ctx_r45.miniMapNodeTemplate);\n  }\n}\n\nfunction GraphComponent__svg_g_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r55 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"g\", 34);\n    i0.ɵɵelementStart(1, \"rect\", 35);\n    i0.ɵɵlistener(\"mousedown\", function GraphComponent__svg_g_5_Template__svg_rect_mousedown_1_listener($event) {\n      i0.ɵɵrestoreView(_r55);\n      const ctx_r54 = i0.ɵɵnextContext();\n      return ctx_r54.onMinimapPanTo($event);\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"g\");\n    i0.ɵɵelementStart(3, \"g\", 36);\n    i0.ɵɵtemplate(4, GraphComponent__svg_g_5__svg_g_4_Template, 5, 7, \"g\", 37);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"rect\", 38);\n    i0.ɵɵlistener(\"mousedown\", function GraphComponent__svg_g_5_Template__svg_rect_mousedown_5_listener() {\n      i0.ɵɵrestoreView(_r55);\n      const ctx_r56 = i0.ɵɵnextContext();\n      return ctx_r56.onMinimapDragMouseDown();\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"transform\", ctx_r1.minimapTransform)(\"clip-path\", \"url(#\" + ctx_r1.minimapClipPathId + \")\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"width\", ctx_r1.graphDims.width / ctx_r1.minimapScaleCoefficient)(\"height\", ctx_r1.graphDims.height / ctx_r1.minimapScaleCoefficient);\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"transform\", \"translate(\" + -ctx_r1.minimapOffsetX / ctx_r1.minimapScaleCoefficient + \"px,\" + -ctx_r1.minimapOffsetY / ctx_r1.minimapScaleCoefficient + \"px)\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵstyleProp(\"transform\", \"scale(\" + 1 / ctx_r1.minimapScaleCoefficient + \")\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.graph.nodes)(\"ngForTrackBy\", ctx_r1.trackNodeBy);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"panning\", ctx_r1.isMinimapPanning);\n    i0.ɵɵattribute(\"transform\", \"translate(\" + ctx_r1.panOffsetX / ctx_r1.zoomLevel / -ctx_r1.minimapScaleCoefficient + \",\" + ctx_r1.panOffsetY / ctx_r1.zoomLevel / -ctx_r1.minimapScaleCoefficient + \")\")(\"width\", ctx_r1.width / ctx_r1.minimapScaleCoefficient / ctx_r1.zoomLevel)(\"height\", ctx_r1.height / ctx_r1.minimapScaleCoefficient / ctx_r1.zoomLevel);\n  }\n}\n\nconst _c8 = [\"*\"];\nconst cache = {};\n/**\n * Generates a short id.\n *\n */\n\nfunction id() {\n  let newId = ('0000' + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);\n  newId = `a${newId}`; // ensure not already used\n\n  if (!cache[newId]) {\n    cache[newId] = true;\n    return newId;\n  }\n\n  return id();\n}\n\nvar PanningAxis = /*#__PURE__*/(() => {\n  (function (PanningAxis) {\n    PanningAxis[\"Both\"] = \"both\";\n    PanningAxis[\"Horizontal\"] = \"horizontal\";\n    PanningAxis[\"Vertical\"] = \"vertical\";\n  })(PanningAxis || (PanningAxis = {}));\n\n  return PanningAxis;\n})();\nvar MiniMapPosition = /*#__PURE__*/(() => {\n  (function (MiniMapPosition) {\n    MiniMapPosition[\"UpperLeft\"] = \"UpperLeft\";\n    MiniMapPosition[\"UpperRight\"] = \"UpperRight\";\n  })(MiniMapPosition || (MiniMapPosition = {}));\n\n  return MiniMapPosition;\n})();\n\n/**\n * Throttle a function\n *\n * @export\n * @param {*}      func\n * @param {number} wait\n * @param {*}      [options]\n * @returns\n */\nfunction throttle(func, wait, options) {\n  options = options || {};\n  let context;\n  let args;\n  let result;\n  let timeout = null;\n  let previous = 0;\n\n  function later() {\n    previous = options.leading === false ? 0 : +new Date();\n    timeout = null;\n    result = func.apply(context, args);\n  }\n\n  return function (..._arguments) {\n    const now = +new Date();\n\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n\n    const remaining = wait - (now - previous);\n    context = this;\n    args = _arguments;\n\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n/**\n * Throttle decorator\n *\n *  class MyClass {\n *    throttleable(10)\n *    myFn() { ... }\n *  }\n *\n * @export\n * @param {number} duration\n * @param {*} [options]\n * @returns\n */\n\n\nfunction throttleable(duration, options) {\n  return function innerDecorator(target, key, descriptor) {\n    return {\n      configurable: true,\n      enumerable: descriptor.enumerable,\n      get: function getter() {\n        Object.defineProperty(this, key, {\n          configurable: true,\n          enumerable: descriptor.enumerable,\n          value: throttle(descriptor.value, duration, options)\n        });\n        return this[key];\n      }\n    };\n  };\n}\n\nconst colorSets = [{\n  name: 'vivid',\n  selectable: true,\n  group: 'Ordinal',\n  domain: ['#647c8a', '#3f51b5', '#2196f3', '#00b862', '#afdf0a', '#a7b61a', '#f3e562', '#ff9800', '#ff5722', '#ff4514']\n}, {\n  name: 'natural',\n  selectable: true,\n  group: 'Ordinal',\n  domain: ['#bf9d76', '#e99450', '#d89f59', '#f2dfa7', '#a5d7c6', '#7794b1', '#afafaf', '#707160', '#ba9383', '#d9d5c3']\n}, {\n  name: 'cool',\n  selectable: true,\n  group: 'Ordinal',\n  domain: ['#a8385d', '#7aa3e5', '#a27ea8', '#aae3f5', '#adcded', '#a95963', '#8796c0', '#7ed3ed', '#50abcc', '#ad6886']\n}, {\n  name: 'fire',\n  selectable: true,\n  group: 'Ordinal',\n  domain: ['#ff3d00', '#bf360c', '#ff8f00', '#ff6f00', '#ff5722', '#e65100', '#ffca28', '#ffab00']\n}, {\n  name: 'solar',\n  selectable: true,\n  group: 'Continuous',\n  domain: ['#fff8e1', '#ffecb3', '#ffe082', '#ffd54f', '#ffca28', '#ffc107', '#ffb300', '#ffa000', '#ff8f00', '#ff6f00']\n}, {\n  name: 'air',\n  selectable: true,\n  group: 'Continuous',\n  domain: ['#e1f5fe', '#b3e5fc', '#81d4fa', '#4fc3f7', '#29b6f6', '#03a9f4', '#039be5', '#0288d1', '#0277bd', '#01579b']\n}, {\n  name: 'aqua',\n  selectable: true,\n  group: 'Continuous',\n  domain: ['#e0f7fa', '#b2ebf2', '#80deea', '#4dd0e1', '#26c6da', '#00bcd4', '#00acc1', '#0097a7', '#00838f', '#006064']\n}, {\n  name: 'flame',\n  selectable: false,\n  group: 'Ordinal',\n  domain: ['#A10A28', '#D3342D', '#EF6D49', '#FAAD67', '#FDDE90', '#DBED91', '#A9D770', '#6CBA67', '#2C9653', '#146738']\n}, {\n  name: 'ocean',\n  selectable: false,\n  group: 'Ordinal',\n  domain: ['#1D68FB', '#33C0FC', '#4AFFFE', '#AFFFFF', '#FFFC63', '#FDBD2D', '#FC8A25', '#FA4F1E', '#FA141B', '#BA38D1']\n}, {\n  name: 'forest',\n  selectable: false,\n  group: 'Ordinal',\n  domain: ['#55C22D', '#C1F33D', '#3CC099', '#AFFFFF', '#8CFC9D', '#76CFFA', '#BA60FB', '#EE6490', '#C42A1C', '#FC9F32']\n}, {\n  name: 'horizon',\n  selectable: false,\n  group: 'Ordinal',\n  domain: ['#2597FB', '#65EBFD', '#99FDD0', '#FCEE4B', '#FEFCFA', '#FDD6E3', '#FCB1A8', '#EF6F7B', '#CB96E8', '#EFDEE0']\n}, {\n  name: 'neons',\n  selectable: false,\n  group: 'Ordinal',\n  domain: ['#FF3333', '#FF33FF', '#CC33FF', '#0000FF', '#33CCFF', '#33FFFF', '#33FF66', '#CCFF33', '#FFCC00', '#FF6600']\n}, {\n  name: 'picnic',\n  selectable: false,\n  group: 'Ordinal',\n  domain: ['#FAC51D', '#66BD6D', '#FAA026', '#29BB9C', '#E96B56', '#55ACD2', '#B7332F', '#2C83C9', '#9166B8', '#92E7E8']\n}, {\n  name: 'night',\n  selectable: false,\n  group: 'Ordinal',\n  domain: ['#2B1B5A', '#501356', '#183356', '#28203F', '#391B3C', '#1E2B3C', '#120634', '#2D0432', '#051932', '#453080', '#75267D', '#2C507D', '#4B3880', '#752F7D', '#35547D']\n}, {\n  name: 'nightLights',\n  selectable: false,\n  group: 'Ordinal',\n  domain: ['#4e31a5', '#9c25a7', '#3065ab', '#57468b', '#904497', '#46648b', '#32118d', '#a00fb3', '#1052a2', '#6e51bd', '#b63cc3', '#6c97cb', '#8671c1', '#b455be', '#7496c3']\n}];\n\nclass ColorHelper {\n  constructor(scheme, domain, customColors) {\n    if (typeof scheme === 'string') {\n      scheme = colorSets.find(cs => {\n        return cs.name === scheme;\n      });\n    }\n\n    this.colorDomain = scheme.domain;\n    this.domain = domain;\n    this.customColors = customColors;\n    this.scale = this.generateColorScheme(scheme, this.domain);\n  }\n\n  generateColorScheme(scheme, domain) {\n    if (typeof scheme === 'string') {\n      scheme = colorSets.find(cs => {\n        return cs.name === scheme;\n      });\n    }\n\n    return scaleOrdinal().range(scheme.domain).domain(domain);\n  }\n\n  getColor(value) {\n    if (value === undefined || value === null) {\n      throw new Error('Value can not be null');\n    }\n\n    if (typeof this.customColors === 'function') {\n      return this.customColors(value);\n    }\n\n    const formattedValue = value.toString();\n    let found; // todo type customColors\n\n    if (this.customColors && this.customColors.length > 0) {\n      found = this.customColors.find(mapping => {\n        return mapping.name.toLowerCase() === formattedValue.toLowerCase();\n      });\n    }\n\n    if (found) {\n      return found.value;\n    } else {\n      return this.scale(value);\n    }\n  }\n\n}\n\nfunction calculateViewDimensions({\n  width,\n  height\n}) {\n  let chartWidth = width;\n  let chartHeight = height;\n  chartWidth = Math.max(0, chartWidth);\n  chartHeight = Math.max(0, chartHeight);\n  return {\n    width: Math.floor(chartWidth),\n    height: Math.floor(chartHeight)\n  };\n}\n/**\n * Visibility Observer\n */\n\n\nlet VisibilityObserver = /*#__PURE__*/(() => {\n  class VisibilityObserver {\n    constructor(element, zone) {\n      this.element = element;\n      this.zone = zone;\n      this.visible = new EventEmitter();\n      this.isVisible = false;\n      this.runCheck();\n    }\n\n    destroy() {\n      clearTimeout(this.timeout);\n    }\n\n    onVisibilityChange() {\n      // trigger zone recalc for columns\n      this.zone.run(() => {\n        this.isVisible = true;\n        this.visible.emit(true);\n      });\n    }\n\n    runCheck() {\n      const check = () => {\n        if (!this.element) {\n          return;\n        } // https://davidwalsh.name/offsetheight-visibility\n\n\n        const {\n          offsetHeight,\n          offsetWidth\n        } = this.element.nativeElement;\n\n        if (offsetHeight && offsetWidth) {\n          clearTimeout(this.timeout);\n          this.onVisibilityChange();\n        } else {\n          clearTimeout(this.timeout);\n          this.zone.runOutsideAngular(() => {\n            this.timeout = setTimeout(() => check(), 100);\n          });\n        }\n      };\n\n      this.zone.runOutsideAngular(() => {\n        this.timeout = setTimeout(() => check());\n      });\n    }\n\n  }\n\n  VisibilityObserver.ɵfac = function VisibilityObserver_Factory(t) {\n    return new (t || VisibilityObserver)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  VisibilityObserver.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: VisibilityObserver,\n    selectors: [[\"visibility-observer\"]],\n    outputs: {\n      visible: \"visible\"\n    }\n  });\n  return VisibilityObserver;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar Orientation = /*#__PURE__*/(() => {\n  (function (Orientation) {\n    Orientation[\"LEFT_TO_RIGHT\"] = \"LR\";\n    Orientation[\"RIGHT_TO_LEFT\"] = \"RL\";\n    Orientation[\"TOP_TO_BOTTOM\"] = \"TB\";\n    Orientation[\"BOTTOM_TO_TOM\"] = \"BT\";\n  })(Orientation || (Orientation = {}));\n\n  return Orientation;\n})();\nvar Alignment = /*#__PURE__*/(() => {\n  (function (Alignment) {\n    Alignment[\"CENTER\"] = \"C\";\n    Alignment[\"UP_LEFT\"] = \"UL\";\n    Alignment[\"UP_RIGHT\"] = \"UR\";\n    Alignment[\"DOWN_LEFT\"] = \"DL\";\n    Alignment[\"DOWN_RIGHT\"] = \"DR\";\n  })(Alignment || (Alignment = {}));\n\n  return Alignment;\n})();\n\nclass DagreLayout {\n  constructor() {\n    this.defaultSettings = {\n      orientation: Orientation.LEFT_TO_RIGHT,\n      marginX: 20,\n      marginY: 20,\n      edgePadding: 100,\n      rankPadding: 100,\n      nodePadding: 50,\n      multigraph: true,\n      compound: true\n    };\n    this.settings = {};\n  }\n\n  run(graph) {\n    this.createDagreGraph(graph);\n    dagre.layout(this.dagreGraph);\n    graph.edgeLabels = this.dagreGraph._edgeLabels;\n\n    for (const dagreNodeId in this.dagreGraph._nodes) {\n      const dagreNode = this.dagreGraph._nodes[dagreNodeId];\n      const node = graph.nodes.find(n => n.id === dagreNode.id);\n      node.position = {\n        x: dagreNode.x,\n        y: dagreNode.y\n      };\n      node.dimension = {\n        width: dagreNode.width,\n        height: dagreNode.height\n      };\n    }\n\n    return graph;\n  }\n\n  updateEdge(graph, edge) {\n    const sourceNode = graph.nodes.find(n => n.id === edge.source);\n    const targetNode = graph.nodes.find(n => n.id === edge.target); // determine new arrow position\n\n    const dir = sourceNode.position.y <= targetNode.position.y ? -1 : 1;\n    const startingPoint = {\n      x: sourceNode.position.x,\n      y: sourceNode.position.y - dir * (sourceNode.dimension.height / 2)\n    };\n    const endingPoint = {\n      x: targetNode.position.x,\n      y: targetNode.position.y + dir * (targetNode.dimension.height / 2)\n    }; // generate new points\n\n    edge.points = [startingPoint, endingPoint];\n    return graph;\n  }\n\n  createDagreGraph(graph) {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n    this.dagreGraph = new dagre.graphlib.Graph({\n      compound: settings.compound,\n      multigraph: settings.multigraph\n    });\n    this.dagreGraph.setGraph({\n      rankdir: settings.orientation,\n      marginx: settings.marginX,\n      marginy: settings.marginY,\n      edgesep: settings.edgePadding,\n      ranksep: settings.rankPadding,\n      nodesep: settings.nodePadding,\n      align: settings.align,\n      acyclicer: settings.acyclicer,\n      ranker: settings.ranker,\n      multigraph: settings.multigraph,\n      compound: settings.compound\n    }); // Default to assigning a new object as a label for each new edge.\n\n    this.dagreGraph.setDefaultEdgeLabel(() => {\n      return {\n        /* empty */\n      };\n    });\n    this.dagreNodes = graph.nodes.map(n => {\n      const node = Object.assign({}, n);\n      node.width = n.dimension.width;\n      node.height = n.dimension.height;\n      node.x = n.position.x;\n      node.y = n.position.y;\n      return node;\n    });\n    this.dagreEdges = graph.edges.map(l => {\n      const newLink = Object.assign({}, l);\n\n      if (!newLink.id) {\n        newLink.id = id();\n      }\n\n      return newLink;\n    });\n\n    for (const node of this.dagreNodes) {\n      if (!node.width) {\n        node.width = 20;\n      }\n\n      if (!node.height) {\n        node.height = 30;\n      } // update dagre\n\n\n      this.dagreGraph.setNode(node.id, node);\n    } // update dagre\n\n\n    for (const edge of this.dagreEdges) {\n      if (settings.multigraph) {\n        this.dagreGraph.setEdge(edge.source, edge.target, edge, edge.id);\n      } else {\n        this.dagreGraph.setEdge(edge.source, edge.target);\n      }\n    }\n\n    return this.dagreGraph;\n  }\n\n}\n\nclass DagreClusterLayout {\n  constructor() {\n    this.defaultSettings = {\n      orientation: Orientation.LEFT_TO_RIGHT,\n      marginX: 20,\n      marginY: 20,\n      edgePadding: 100,\n      rankPadding: 100,\n      nodePadding: 50,\n      multigraph: true,\n      compound: true\n    };\n    this.settings = {};\n  }\n\n  run(graph) {\n    this.createDagreGraph(graph);\n    dagre.layout(this.dagreGraph);\n    graph.edgeLabels = this.dagreGraph._edgeLabels;\n\n    const dagreToOutput = node => {\n      const dagreNode = this.dagreGraph._nodes[node.id];\n      return Object.assign(Object.assign({}, node), {\n        position: {\n          x: dagreNode.x,\n          y: dagreNode.y\n        },\n        dimension: {\n          width: dagreNode.width,\n          height: dagreNode.height\n        }\n      });\n    };\n\n    graph.clusters = (graph.clusters || []).map(dagreToOutput);\n    graph.nodes = graph.nodes.map(dagreToOutput);\n    return graph;\n  }\n\n  updateEdge(graph, edge) {\n    const sourceNode = graph.nodes.find(n => n.id === edge.source);\n    const targetNode = graph.nodes.find(n => n.id === edge.target); // determine new arrow position\n\n    const dir = sourceNode.position.y <= targetNode.position.y ? -1 : 1;\n    const startingPoint = {\n      x: sourceNode.position.x,\n      y: sourceNode.position.y - dir * (sourceNode.dimension.height / 2)\n    };\n    const endingPoint = {\n      x: targetNode.position.x,\n      y: targetNode.position.y + dir * (targetNode.dimension.height / 2)\n    }; // generate new points\n\n    edge.points = [startingPoint, endingPoint];\n    return graph;\n  }\n\n  createDagreGraph(graph) {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n    this.dagreGraph = new dagre.graphlib.Graph({\n      compound: settings.compound,\n      multigraph: settings.multigraph\n    });\n    this.dagreGraph.setGraph({\n      rankdir: settings.orientation,\n      marginx: settings.marginX,\n      marginy: settings.marginY,\n      edgesep: settings.edgePadding,\n      ranksep: settings.rankPadding,\n      nodesep: settings.nodePadding,\n      align: settings.align,\n      acyclicer: settings.acyclicer,\n      ranker: settings.ranker,\n      multigraph: settings.multigraph,\n      compound: settings.compound\n    }); // Default to assigning a new object as a label for each new edge.\n\n    this.dagreGraph.setDefaultEdgeLabel(() => {\n      return {\n        /* empty */\n      };\n    });\n    this.dagreNodes = graph.nodes.map(n => {\n      const node = Object.assign({}, n);\n      node.width = n.dimension.width;\n      node.height = n.dimension.height;\n      node.x = n.position.x;\n      node.y = n.position.y;\n      return node;\n    });\n    this.dagreClusters = graph.clusters || [];\n    this.dagreEdges = graph.edges.map(l => {\n      const newLink = Object.assign({}, l);\n\n      if (!newLink.id) {\n        newLink.id = id();\n      }\n\n      return newLink;\n    });\n\n    for (const node of this.dagreNodes) {\n      this.dagreGraph.setNode(node.id, node);\n    }\n\n    for (const cluster of this.dagreClusters) {\n      this.dagreGraph.setNode(cluster.id, cluster);\n      cluster.childNodeIds.forEach(childNodeId => {\n        this.dagreGraph.setParent(childNodeId, cluster.id);\n      });\n    } // update dagre\n\n\n    for (const edge of this.dagreEdges) {\n      if (settings.multigraph) {\n        this.dagreGraph.setEdge(edge.source, edge.target, edge, edge.id);\n      } else {\n        this.dagreGraph.setEdge(edge.source, edge.target);\n      }\n    }\n\n    return this.dagreGraph;\n  }\n\n}\n\nconst DEFAULT_EDGE_NAME = '\\x00';\nconst GRAPH_NODE = '\\x00';\nconst EDGE_KEY_DELIM = '\\x01';\n\nclass DagreNodesOnlyLayout {\n  constructor() {\n    this.defaultSettings = {\n      orientation: Orientation.LEFT_TO_RIGHT,\n      marginX: 20,\n      marginY: 20,\n      edgePadding: 100,\n      rankPadding: 100,\n      nodePadding: 50,\n      curveDistance: 20,\n      multigraph: true,\n      compound: true\n    };\n    this.settings = {};\n  }\n\n  run(graph) {\n    this.createDagreGraph(graph);\n    dagre.layout(this.dagreGraph);\n    graph.edgeLabels = this.dagreGraph._edgeLabels;\n\n    for (const dagreNodeId in this.dagreGraph._nodes) {\n      const dagreNode = this.dagreGraph._nodes[dagreNodeId];\n      const node = graph.nodes.find(n => n.id === dagreNode.id);\n      node.position = {\n        x: dagreNode.x,\n        y: dagreNode.y\n      };\n      node.dimension = {\n        width: dagreNode.width,\n        height: dagreNode.height\n      };\n    }\n\n    for (const edge of graph.edges) {\n      this.updateEdge(graph, edge);\n    }\n\n    return graph;\n  }\n\n  updateEdge(graph, edge) {\n    const sourceNode = graph.nodes.find(n => n.id === edge.source);\n    const targetNode = graph.nodes.find(n => n.id === edge.target);\n    const rankAxis = this.settings.orientation === 'BT' || this.settings.orientation === 'TB' ? 'y' : 'x';\n    const orderAxis = rankAxis === 'y' ? 'x' : 'y';\n    const rankDimension = rankAxis === 'y' ? 'height' : 'width'; // determine new arrow position\n\n    const dir = sourceNode.position[rankAxis] <= targetNode.position[rankAxis] ? -1 : 1;\n    const startingPoint = {\n      [orderAxis]: sourceNode.position[orderAxis],\n      [rankAxis]: sourceNode.position[rankAxis] - dir * (sourceNode.dimension[rankDimension] / 2)\n    };\n    const endingPoint = {\n      [orderAxis]: targetNode.position[orderAxis],\n      [rankAxis]: targetNode.position[rankAxis] + dir * (targetNode.dimension[rankDimension] / 2)\n    };\n    const curveDistance = this.settings.curveDistance || this.defaultSettings.curveDistance; // generate new points\n\n    edge.points = [startingPoint, {\n      [orderAxis]: startingPoint[orderAxis],\n      [rankAxis]: startingPoint[rankAxis] - dir * curveDistance\n    }, {\n      [orderAxis]: endingPoint[orderAxis],\n      [rankAxis]: endingPoint[rankAxis] + dir * curveDistance\n    }, endingPoint];\n    const edgeLabelId = `${edge.source}${EDGE_KEY_DELIM}${edge.target}${EDGE_KEY_DELIM}${DEFAULT_EDGE_NAME}`;\n    const matchingEdgeLabel = graph.edgeLabels[edgeLabelId];\n\n    if (matchingEdgeLabel) {\n      matchingEdgeLabel.points = edge.points;\n    }\n\n    return graph;\n  }\n\n  createDagreGraph(graph) {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n    this.dagreGraph = new dagre.graphlib.Graph({\n      compound: settings.compound,\n      multigraph: settings.multigraph\n    });\n    this.dagreGraph.setGraph({\n      rankdir: settings.orientation,\n      marginx: settings.marginX,\n      marginy: settings.marginY,\n      edgesep: settings.edgePadding,\n      ranksep: settings.rankPadding,\n      nodesep: settings.nodePadding,\n      align: settings.align,\n      acyclicer: settings.acyclicer,\n      ranker: settings.ranker,\n      multigraph: settings.multigraph,\n      compound: settings.compound\n    }); // Default to assigning a new object as a label for each new edge.\n\n    this.dagreGraph.setDefaultEdgeLabel(() => {\n      return {\n        /* empty */\n      };\n    });\n    this.dagreNodes = graph.nodes.map(n => {\n      const node = Object.assign({}, n);\n      node.width = n.dimension.width;\n      node.height = n.dimension.height;\n      node.x = n.position.x;\n      node.y = n.position.y;\n      return node;\n    });\n    this.dagreEdges = graph.edges.map(l => {\n      const newLink = Object.assign({}, l);\n\n      if (!newLink.id) {\n        newLink.id = id();\n      }\n\n      return newLink;\n    });\n\n    for (const node of this.dagreNodes) {\n      if (!node.width) {\n        node.width = 20;\n      }\n\n      if (!node.height) {\n        node.height = 30;\n      } // update dagre\n\n\n      this.dagreGraph.setNode(node.id, node);\n    } // update dagre\n\n\n    for (const edge of this.dagreEdges) {\n      if (settings.multigraph) {\n        this.dagreGraph.setEdge(edge.source, edge.target, edge, edge.id);\n      } else {\n        this.dagreGraph.setEdge(edge.source, edge.target);\n      }\n    }\n\n    return this.dagreGraph;\n  }\n\n}\n\nfunction toD3Node(maybeNode) {\n  if (typeof maybeNode === 'string') {\n    return {\n      id: maybeNode,\n      x: 0,\n      y: 0\n    };\n  }\n\n  return maybeNode;\n}\n\nclass D3ForceDirectedLayout {\n  constructor() {\n    this.defaultSettings = {\n      force: forceSimulation().force('charge', forceManyBody().strength(-150)).force('collide', forceCollide(5)),\n      forceLink: forceLink().id(node => node.id).distance(() => 100)\n    };\n    this.settings = {};\n    this.outputGraph$ = new Subject();\n  }\n\n  run(graph) {\n    this.inputGraph = graph;\n    this.d3Graph = {\n      nodes: [...this.inputGraph.nodes.map(n => Object.assign({}, n))],\n      edges: [...this.inputGraph.edges.map(e => Object.assign({}, e))]\n    };\n    this.outputGraph = {\n      nodes: [],\n      edges: [],\n      edgeLabels: []\n    };\n    this.outputGraph$.next(this.outputGraph);\n    this.settings = Object.assign({}, this.defaultSettings, this.settings);\n\n    if (this.settings.force) {\n      this.settings.force.nodes(this.d3Graph.nodes).force('link', this.settings.forceLink.links(this.d3Graph.edges)).alpha(0.5).restart().on('tick', () => {\n        this.outputGraph$.next(this.d3GraphToOutputGraph(this.d3Graph));\n      });\n    }\n\n    return this.outputGraph$.asObservable();\n  }\n\n  updateEdge(graph, edge) {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n\n    if (settings.force) {\n      settings.force.nodes(this.d3Graph.nodes).force('link', settings.forceLink.links(this.d3Graph.edges)).alpha(0.5).restart().on('tick', () => {\n        this.outputGraph$.next(this.d3GraphToOutputGraph(this.d3Graph));\n      });\n    }\n\n    return this.outputGraph$.asObservable();\n  }\n\n  d3GraphToOutputGraph(d3Graph) {\n    this.outputGraph.nodes = this.d3Graph.nodes.map(node => Object.assign(Object.assign({}, node), {\n      id: node.id || id(),\n      position: {\n        x: node.x,\n        y: node.y\n      },\n      dimension: {\n        width: node.dimension && node.dimension.width || 20,\n        height: node.dimension && node.dimension.height || 20\n      },\n      transform: `translate(${node.x - (node.dimension && node.dimension.width || 20) / 2 || 0}, ${node.y - (node.dimension && node.dimension.height || 20) / 2 || 0})`\n    }));\n    this.outputGraph.edges = this.d3Graph.edges.map(edge => Object.assign(Object.assign({}, edge), {\n      source: toD3Node(edge.source).id,\n      target: toD3Node(edge.target).id,\n      points: [{\n        x: toD3Node(edge.source).x,\n        y: toD3Node(edge.source).y\n      }, {\n        x: toD3Node(edge.target).x,\n        y: toD3Node(edge.target).y\n      }]\n    }));\n    this.outputGraph.edgeLabels = this.outputGraph.edges;\n    return this.outputGraph;\n  }\n\n  onDragStart(draggingNode, $event) {\n    this.settings.force.alphaTarget(0.3).restart();\n    const node = this.d3Graph.nodes.find(d3Node => d3Node.id === draggingNode.id);\n\n    if (!node) {\n      return;\n    }\n\n    this.draggingStart = {\n      x: $event.x - node.x,\n      y: $event.y - node.y\n    };\n    node.fx = $event.x - this.draggingStart.x;\n    node.fy = $event.y - this.draggingStart.y;\n  }\n\n  onDrag(draggingNode, $event) {\n    if (!draggingNode) {\n      return;\n    }\n\n    const node = this.d3Graph.nodes.find(d3Node => d3Node.id === draggingNode.id);\n\n    if (!node) {\n      return;\n    }\n\n    node.fx = $event.x - this.draggingStart.x;\n    node.fy = $event.y - this.draggingStart.y;\n  }\n\n  onDragEnd(draggingNode, $event) {\n    if (!draggingNode) {\n      return;\n    }\n\n    const node = this.d3Graph.nodes.find(d3Node => d3Node.id === draggingNode.id);\n\n    if (!node) {\n      return;\n    }\n\n    this.settings.force.alphaTarget(0);\n    node.fx = undefined;\n    node.fy = undefined;\n  }\n\n}\n\nfunction toNode(nodes, nodeRef) {\n  if (typeof nodeRef === 'number') {\n    return nodes[nodeRef];\n  }\n\n  return nodeRef;\n}\n\nclass ColaForceDirectedLayout {\n  constructor() {\n    this.defaultSettings = {\n      force: d3adaptor(Object.assign(Object.assign(Object.assign({}, d3Dispatch), d3Force), d3Timer)).linkDistance(150).avoidOverlaps(true),\n      viewDimensions: {\n        width: 600,\n        height: 600\n      }\n    };\n    this.settings = {};\n    this.outputGraph$ = new Subject();\n  }\n\n  run(graph) {\n    this.inputGraph = graph;\n\n    if (!this.inputGraph.clusters) {\n      this.inputGraph.clusters = [];\n    }\n\n    this.internalGraph = {\n      nodes: [...this.inputGraph.nodes.map(n => Object.assign(Object.assign({}, n), {\n        width: n.dimension ? n.dimension.width : 20,\n        height: n.dimension ? n.dimension.height : 20\n      }))],\n      groups: [...this.inputGraph.clusters.map(cluster => ({\n        padding: 5,\n        groups: cluster.childNodeIds.map(nodeId => this.inputGraph.clusters.findIndex(node => node.id === nodeId)).filter(x => x >= 0),\n        leaves: cluster.childNodeIds.map(nodeId => this.inputGraph.nodes.findIndex(node => node.id === nodeId)).filter(x => x >= 0)\n      }))],\n      links: [...this.inputGraph.edges.map(e => {\n        const sourceNodeIndex = this.inputGraph.nodes.findIndex(node => e.source === node.id);\n        const targetNodeIndex = this.inputGraph.nodes.findIndex(node => e.target === node.id);\n\n        if (sourceNodeIndex === -1 || targetNodeIndex === -1) {\n          return undefined;\n        }\n\n        return Object.assign(Object.assign({}, e), {\n          source: sourceNodeIndex,\n          target: targetNodeIndex\n        });\n      }).filter(x => !!x)],\n      groupLinks: [...this.inputGraph.edges.map(e => {\n        const sourceNodeIndex = this.inputGraph.nodes.findIndex(node => e.source === node.id);\n        const targetNodeIndex = this.inputGraph.nodes.findIndex(node => e.target === node.id);\n\n        if (sourceNodeIndex >= 0 && targetNodeIndex >= 0) {\n          return undefined;\n        }\n\n        return e;\n      }).filter(x => !!x)]\n    };\n    this.outputGraph = {\n      nodes: [],\n      clusters: [],\n      edges: [],\n      edgeLabels: []\n    };\n    this.outputGraph$.next(this.outputGraph);\n    this.settings = Object.assign({}, this.defaultSettings, this.settings);\n\n    if (this.settings.force) {\n      this.settings.force = this.settings.force.nodes(this.internalGraph.nodes).groups(this.internalGraph.groups).links(this.internalGraph.links).alpha(0.5).on('tick', () => {\n        if (this.settings.onTickListener) {\n          this.settings.onTickListener(this.internalGraph);\n        }\n\n        this.outputGraph$.next(this.internalGraphToOutputGraph(this.internalGraph));\n      });\n\n      if (this.settings.viewDimensions) {\n        this.settings.force = this.settings.force.size([this.settings.viewDimensions.width, this.settings.viewDimensions.height]);\n      }\n\n      if (this.settings.forceModifierFn) {\n        this.settings.force = this.settings.forceModifierFn(this.settings.force);\n      }\n\n      this.settings.force.start();\n    }\n\n    return this.outputGraph$.asObservable();\n  }\n\n  updateEdge(graph, edge) {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n\n    if (settings.force) {\n      settings.force.start();\n    }\n\n    return this.outputGraph$.asObservable();\n  }\n\n  internalGraphToOutputGraph(internalGraph) {\n    this.outputGraph.nodes = internalGraph.nodes.map(node => Object.assign(Object.assign({}, node), {\n      id: node.id || id(),\n      position: {\n        x: node.x,\n        y: node.y\n      },\n      dimension: {\n        width: node.dimension && node.dimension.width || 20,\n        height: node.dimension && node.dimension.height || 20\n      },\n      transform: `translate(${node.x - (node.dimension && node.dimension.width || 20) / 2 || 0}, ${node.y - (node.dimension && node.dimension.height || 20) / 2 || 0})`\n    }));\n    this.outputGraph.edges = internalGraph.links.map(edge => {\n      const source = toNode(internalGraph.nodes, edge.source);\n      const target = toNode(internalGraph.nodes, edge.target);\n      return Object.assign(Object.assign({}, edge), {\n        source: source.id,\n        target: target.id,\n        points: [source.bounds.rayIntersection(target.bounds.cx(), target.bounds.cy()), target.bounds.rayIntersection(source.bounds.cx(), source.bounds.cy())]\n      });\n    }).concat(internalGraph.groupLinks.map(groupLink => {\n      const sourceNode = internalGraph.nodes.find(foundNode => foundNode.id === groupLink.source);\n      const targetNode = internalGraph.nodes.find(foundNode => foundNode.id === groupLink.target);\n      const source = sourceNode || internalGraph.groups.find(foundGroup => foundGroup.id === groupLink.source);\n      const target = targetNode || internalGraph.groups.find(foundGroup => foundGroup.id === groupLink.target);\n      return Object.assign(Object.assign({}, groupLink), {\n        source: source.id,\n        target: target.id,\n        points: [source.bounds.rayIntersection(target.bounds.cx(), target.bounds.cy()), target.bounds.rayIntersection(source.bounds.cx(), source.bounds.cy())]\n      });\n    }));\n    this.outputGraph.clusters = internalGraph.groups.map((group, index) => {\n      const inputGroup = this.inputGraph.clusters[index];\n      return Object.assign(Object.assign({}, inputGroup), {\n        dimension: {\n          width: group.bounds ? group.bounds.width() : 20,\n          height: group.bounds ? group.bounds.height() : 20\n        },\n        position: {\n          x: group.bounds ? group.bounds.x + group.bounds.width() / 2 : 0,\n          y: group.bounds ? group.bounds.y + group.bounds.height() / 2 : 0\n        }\n      });\n    });\n    this.outputGraph.edgeLabels = this.outputGraph.edges;\n    return this.outputGraph;\n  }\n\n  onDragStart(draggingNode, $event) {\n    const nodeIndex = this.outputGraph.nodes.findIndex(foundNode => foundNode.id === draggingNode.id);\n    const node = this.internalGraph.nodes[nodeIndex];\n\n    if (!node) {\n      return;\n    }\n\n    this.draggingStart = {\n      x: node.x - $event.x,\n      y: node.y - $event.y\n    };\n    node.fixed = 1;\n    this.settings.force.start();\n  }\n\n  onDrag(draggingNode, $event) {\n    if (!draggingNode) {\n      return;\n    }\n\n    const nodeIndex = this.outputGraph.nodes.findIndex(foundNode => foundNode.id === draggingNode.id);\n    const node = this.internalGraph.nodes[nodeIndex];\n\n    if (!node) {\n      return;\n    }\n\n    node.x = this.draggingStart.x + $event.x;\n    node.y = this.draggingStart.y + $event.y;\n  }\n\n  onDragEnd(draggingNode, $event) {\n    if (!draggingNode) {\n      return;\n    }\n\n    const nodeIndex = this.outputGraph.nodes.findIndex(foundNode => foundNode.id === draggingNode.id);\n    const node = this.internalGraph.nodes[nodeIndex];\n\n    if (!node) {\n      return;\n    }\n\n    node.fixed = 0;\n  }\n\n}\n\nconst layouts = {\n  dagre: DagreLayout,\n  dagreCluster: DagreClusterLayout,\n  dagreNodesOnly: DagreNodesOnlyLayout,\n  d3ForceDirected: D3ForceDirectedLayout,\n  colaForceDirected: ColaForceDirectedLayout\n};\nlet LayoutService = /*#__PURE__*/(() => {\n  class LayoutService {\n    getLayout(name) {\n      if (layouts[name]) {\n        return new layouts[name]();\n      } else {\n        throw new Error(`Unknown layout type '${name}'`);\n      }\n    }\n\n  }\n\n  LayoutService.ɵfac = function LayoutService_Factory(t) {\n    return new (t || LayoutService)();\n  };\n\n  LayoutService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LayoutService,\n    factory: LayoutService.ɵfac\n  });\n  return LayoutService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Mousewheel directive\n * https://github.com/SodhanaLibrary/angular2-examples/blob/master/app/mouseWheelDirective/mousewheel.directive.ts\n *\n * @export\n */\n// tslint:disable-next-line: directive-selector\n\n\nlet MouseWheelDirective = /*#__PURE__*/(() => {\n  class MouseWheelDirective {\n    constructor() {\n      this.mouseWheelUp = new EventEmitter();\n      this.mouseWheelDown = new EventEmitter();\n    }\n\n    onMouseWheelChrome(event) {\n      this.mouseWheelFunc(event);\n    }\n\n    onMouseWheelFirefox(event) {\n      this.mouseWheelFunc(event);\n    }\n\n    onWheel(event) {\n      this.mouseWheelFunc(event);\n    }\n\n    onMouseWheelIE(event) {\n      this.mouseWheelFunc(event);\n    }\n\n    mouseWheelFunc(event) {\n      if (window.event) {\n        event = window.event;\n      }\n\n      const delta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail || event.deltaY || event.deltaX)); // Firefox don't have native support for wheel event, as a result delta values are reverse\n\n      const isWheelMouseUp = event.wheelDelta ? delta > 0 : delta < 0;\n      const isWheelMouseDown = event.wheelDelta ? delta < 0 : delta > 0;\n\n      if (isWheelMouseUp) {\n        this.mouseWheelUp.emit(event);\n      } else if (isWheelMouseDown) {\n        this.mouseWheelDown.emit(event);\n      } // for IE\n\n\n      event.returnValue = false; // for Chrome and Firefox\n\n      if (event.preventDefault) {\n        event.preventDefault();\n      }\n    }\n\n  }\n\n  MouseWheelDirective.ɵfac = function MouseWheelDirective_Factory(t) {\n    return new (t || MouseWheelDirective)();\n  };\n\n  MouseWheelDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MouseWheelDirective,\n    selectors: [[\"\", \"mouseWheel\", \"\"]],\n    hostBindings: function MouseWheelDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousewheel\", function MouseWheelDirective_mousewheel_HostBindingHandler($event) {\n          return ctx.onMouseWheelChrome($event);\n        })(\"DOMMouseScroll\", function MouseWheelDirective_DOMMouseScroll_HostBindingHandler($event) {\n          return ctx.onMouseWheelFirefox($event);\n        })(\"wheel\", function MouseWheelDirective_wheel_HostBindingHandler($event) {\n          return ctx.onWheel($event);\n        })(\"onmousewheel\", function MouseWheelDirective_onmousewheel_HostBindingHandler($event) {\n          return ctx.onMouseWheelIE($event);\n        });\n      }\n    },\n    outputs: {\n      mouseWheelUp: \"mouseWheelUp\",\n      mouseWheelDown: \"mouseWheelDown\"\n    }\n  });\n  return MouseWheelDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar NgxGraphStates = /*#__PURE__*/(() => {\n  (function (NgxGraphStates) {\n    NgxGraphStates[\"Init\"] = \"init\";\n    NgxGraphStates[\"Subscribe\"] = \"subscribe\";\n    NgxGraphStates[\"Transform\"] = \"transform\";\n  })(NgxGraphStates || (NgxGraphStates = {}));\n\n  return NgxGraphStates;\n})();\nlet GraphComponent = /*#__PURE__*/(() => {\n  class GraphComponent {\n    constructor(el, zone, cd, layoutService) {\n      this.el = el;\n      this.zone = zone;\n      this.cd = cd;\n      this.layoutService = layoutService;\n      this.nodes = [];\n      this.clusters = [];\n      this.compoundNodes = [];\n      this.links = [];\n      this.activeEntries = [];\n      this.draggingEnabled = true;\n      this.panningEnabled = true;\n      this.panningAxis = PanningAxis.Both;\n      this.enableZoom = true;\n      this.zoomSpeed = 0.1;\n      this.minZoomLevel = 0.1;\n      this.maxZoomLevel = 4.0;\n      this.autoZoom = false;\n      this.panOnZoom = true;\n      this.animate = false;\n      this.autoCenter = false;\n      this.enableTrackpadSupport = false;\n      this.showMiniMap = false;\n      this.miniMapMaxWidth = 100;\n      this.miniMapPosition = MiniMapPosition.UpperRight;\n      this.scheme = 'cool';\n      this.animations = true;\n      this.deferDisplayUntilPosition = false;\n      this.centerNodesOnPositionChange = true;\n      this.enablePreUpdateTransform = true;\n      this.select = new EventEmitter();\n      this.activate = new EventEmitter();\n      this.deactivate = new EventEmitter();\n      this.zoomChange = new EventEmitter();\n      this.clickHandler = new EventEmitter();\n      this.stateChange = new EventEmitter();\n      this.isMouseMoveCalled = false;\n      this.graphSubscription = new Subscription();\n      this.isPanning = false;\n      this.isDragging = false;\n      this.initialized = false;\n      this.graphDims = {\n        width: 0,\n        height: 0\n      };\n      this._oldLinks = [];\n      this.oldNodes = new Set();\n      this.oldClusters = new Set();\n      this.oldCompoundNodes = new Set();\n      this.transformationMatrix = identity();\n      this._touchLastX = null;\n      this._touchLastY = null;\n      this.minimapScaleCoefficient = 3;\n      this.minimapOffsetX = 0;\n      this.minimapOffsetY = 0;\n      this.isMinimapPanning = false;\n      this.destroy$ = new Subject();\n\n      this.groupResultsBy = node => node.label;\n    }\n    /**\n     * Get the current zoom level\n     */\n\n\n    get zoomLevel() {\n      return this.transformationMatrix.a;\n    }\n    /**\n     * Set the current zoom level\n     */\n\n\n    set zoomLevel(level) {\n      this.zoomTo(Number(level));\n    }\n    /**\n     * Get the current `x` position of the graph\n     */\n\n\n    get panOffsetX() {\n      return this.transformationMatrix.e;\n    }\n    /**\n     * Set the current `x` position of the graph\n     */\n\n\n    set panOffsetX(x) {\n      this.panTo(Number(x), null);\n    }\n    /**\n     * Get the current `y` position of the graph\n     */\n\n\n    get panOffsetY() {\n      return this.transformationMatrix.f;\n    }\n    /**\n     * Set the current `y` position of the graph\n     */\n\n\n    set panOffsetY(y) {\n      this.panTo(null, Number(y));\n    }\n    /**\n     * Angular lifecycle event\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    ngOnInit() {\n      if (this.update$) {\n        this.update$.pipe(takeUntil(this.destroy$)).subscribe(() => {\n          this.update();\n        });\n      }\n\n      if (this.center$) {\n        this.center$.pipe(takeUntil(this.destroy$)).subscribe(() => {\n          this.center();\n        });\n      }\n\n      if (this.zoomToFit$) {\n        this.zoomToFit$.pipe(takeUntil(this.destroy$)).subscribe(options => {\n          this.zoomToFit(options ? options : {});\n        });\n      }\n\n      if (this.panToNode$) {\n        this.panToNode$.pipe(takeUntil(this.destroy$)).subscribe(nodeId => {\n          this.panToNodeId(nodeId);\n        });\n      }\n\n      this.minimapClipPathId = `minimapClip${id()}`;\n      this.stateChange.emit({\n        state: NgxGraphStates.Subscribe\n      });\n    }\n\n    ngOnChanges(changes) {\n      this.basicUpdate();\n      const {\n        layout,\n        layoutSettings,\n        nodes,\n        clusters,\n        links,\n        compoundNodes\n      } = changes;\n      this.setLayout(this.layout);\n\n      if (layoutSettings) {\n        this.setLayoutSettings(this.layoutSettings);\n      }\n\n      this.update();\n    }\n\n    setLayout(layout) {\n      this.initialized = false;\n\n      if (!layout) {\n        layout = 'dagre';\n      }\n\n      if (typeof layout === 'string') {\n        this.layout = this.layoutService.getLayout(layout);\n        this.setLayoutSettings(this.layoutSettings);\n      }\n    }\n\n    setLayoutSettings(settings) {\n      if (this.layout && typeof this.layout !== 'string') {\n        this.layout.settings = settings;\n      }\n    }\n    /**\n     * Angular lifecycle event\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    ngOnDestroy() {\n      this.unbindEvents();\n\n      if (this.visibilityObserver) {\n        this.visibilityObserver.visible.unsubscribe();\n        this.visibilityObserver.destroy();\n      }\n\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n    /**\n     * Angular lifecycle event\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    ngAfterViewInit() {\n      this.bindWindowResizeEvent(); // listen for visibility of the element for hidden by default scenario\n\n      this.visibilityObserver = new VisibilityObserver(this.el, this.zone);\n      this.visibilityObserver.visible.subscribe(this.update.bind(this));\n      setTimeout(() => this.update());\n    }\n    /**\n     * Base class update implementation for the dag graph\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    update() {\n      this.basicUpdate();\n\n      if (!this.curve) {\n        this.curve = shape.curveBundle.beta(1);\n      }\n\n      this.zone.run(() => {\n        this.dims = calculateViewDimensions({\n          width: this.width,\n          height: this.height\n        });\n        this.seriesDomain = this.getSeriesDomain();\n        this.setColors();\n        this.createGraph();\n        this.updateTransform();\n\n        if (!this.initialized) {\n          this.stateChange.emit({\n            state: NgxGraphStates.Init\n          });\n        }\n\n        this.initialized = true;\n      });\n    }\n    /**\n     * Creates the dagre graph engine\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    createGraph() {\n      this.graphSubscription.unsubscribe();\n      this.graphSubscription = new Subscription();\n\n      const initializeNode = n => {\n        if (!n.meta) {\n          n.meta = {};\n        }\n\n        if (!n.id) {\n          n.id = id();\n        }\n\n        if (!n.dimension) {\n          n.dimension = {\n            width: this.nodeWidth ? this.nodeWidth : 30,\n            height: this.nodeHeight ? this.nodeHeight : 30\n          };\n          n.meta.forceDimensions = false;\n        } else {\n          n.meta.forceDimensions = n.meta.forceDimensions === undefined ? true : n.meta.forceDimensions;\n        }\n\n        if (!n.position) {\n          n.position = {\n            x: 0,\n            y: 0\n          };\n\n          if (this.deferDisplayUntilPosition) {\n            n.hidden = true;\n          }\n        }\n\n        n.data = n.data ? n.data : {};\n        return n;\n      };\n\n      this.graph = {\n        nodes: this.nodes.length > 0 ? [...this.nodes].map(initializeNode) : [],\n        clusters: this.clusters && this.clusters.length > 0 ? [...this.clusters].map(initializeNode) : [],\n        compoundNodes: this.compoundNodes && this.compoundNodes.length > 0 ? [...this.compoundNodes].map(initializeNode) : [],\n        edges: this.links.length > 0 ? [...this.links].map(e => {\n          if (!e.id) {\n            e.id = id();\n          }\n\n          return e;\n        }) : []\n      };\n      requestAnimationFrame(() => this.draw());\n    }\n    /**\n     * Draws the graph using dagre layouts\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    draw() {\n      var _a;\n\n      if (!this.layout || typeof this.layout === 'string') {\n        return;\n      } // Calc view dims for the nodes\n\n\n      this.applyNodeDimensions(); // Recalc the layout\n\n      const result = this.layout.run(this.graph);\n      const result$ = result instanceof Observable ? result : of(result);\n      this.graphSubscription.add(result$.subscribe(graph => {\n        this.graph = graph;\n        this.tick();\n      }));\n\n      if (this.graph.nodes.length === 0 && ((_a = this.graph.compoundNodes) === null || _a === void 0 ? void 0 : _a.length) === 0) {\n        return;\n      }\n\n      result$.pipe(first()).subscribe(() => this.applyNodeDimensions());\n    }\n\n    tick() {\n      // Transposes view options to the node\n      const oldNodes = new Set();\n      this.graph.nodes.map(n => {\n        n.transform = `translate(${n.position.x - (this.centerNodesOnPositionChange ? n.dimension.width / 2 : 0) || 0}, ${n.position.y - (this.centerNodesOnPositionChange ? n.dimension.height / 2 : 0) || 0})`;\n\n        if (!n.data) {\n          n.data = {};\n        }\n\n        n.data.color = this.colors.getColor(this.groupResultsBy(n));\n\n        if (this.deferDisplayUntilPosition) {\n          n.hidden = false;\n        }\n\n        oldNodes.add(n.id);\n      });\n      const oldClusters = new Set();\n      const oldCompoundNodes = new Set();\n      (this.graph.clusters || []).map(n => {\n        n.transform = `translate(${n.position.x - (this.centerNodesOnPositionChange ? n.dimension.width / 2 : 0) || 0}, ${n.position.y - (this.centerNodesOnPositionChange ? n.dimension.height / 2 : 0) || 0})`;\n\n        if (!n.data) {\n          n.data = {};\n        }\n\n        n.data.color = this.colors.getColor(this.groupResultsBy(n));\n\n        if (this.deferDisplayUntilPosition) {\n          n.hidden = false;\n        }\n\n        oldClusters.add(n.id);\n      });\n      (this.graph.compoundNodes || []).map(n => {\n        n.transform = `translate(${n.position.x - (this.centerNodesOnPositionChange ? n.dimension.width / 2 : 0) || 0}, ${n.position.y - (this.centerNodesOnPositionChange ? n.dimension.height / 2 : 0) || 0})`;\n\n        if (!n.data) {\n          n.data = {};\n        }\n\n        n.data.color = this.colors.getColor(this.groupResultsBy(n));\n\n        if (this.deferDisplayUntilPosition) {\n          n.hidden = false;\n        }\n\n        oldCompoundNodes.add(n.id);\n      }); // Prevent animations on new nodes\n\n      setTimeout(() => {\n        this.oldNodes = oldNodes;\n        this.oldClusters = oldClusters;\n        this.oldCompoundNodes = oldCompoundNodes;\n      }, 500); // Update the labels to the new positions\n\n      const newLinks = [];\n\n      for (const edgeLabelId in this.graph.edgeLabels) {\n        const edgeLabel = this.graph.edgeLabels[edgeLabelId];\n        const normKey = edgeLabelId.replace(/[^\\w-]*/g, '');\n        const isMultigraph = this.layout && typeof this.layout !== 'string' && this.layout.settings && this.layout.settings.multigraph;\n        let oldLink = isMultigraph ? this._oldLinks.find(ol => `${ol.source}${ol.target}${ol.id}` === normKey) : this._oldLinks.find(ol => `${ol.source}${ol.target}` === normKey);\n        const linkFromGraph = isMultigraph ? this.graph.edges.find(nl => `${nl.source}${nl.target}${nl.id}` === normKey) : this.graph.edges.find(nl => `${nl.source}${nl.target}` === normKey);\n\n        if (!oldLink) {\n          oldLink = linkFromGraph || edgeLabel;\n        } else if (oldLink.data && linkFromGraph && linkFromGraph.data && JSON.stringify(oldLink.data) !== JSON.stringify(linkFromGraph.data)) {\n          // Compare old link to new link and replace if not equal\n          oldLink.data = linkFromGraph.data;\n        }\n\n        oldLink.oldLine = oldLink.line;\n        const points = edgeLabel.points;\n        const line = this.generateLine(points);\n        const newLink = Object.assign({}, oldLink);\n        newLink.line = line;\n        newLink.points = points;\n        this.updateMidpointOnEdge(newLink, points);\n        const textPos = points[Math.floor(points.length / 2)];\n\n        if (textPos) {\n          newLink.textTransform = `translate(${textPos.x || 0},${textPos.y || 0})`;\n        }\n\n        newLink.textAngle = 0;\n\n        if (!newLink.oldLine) {\n          newLink.oldLine = newLink.line;\n        }\n\n        this.calcDominantBaseline(newLink);\n        newLinks.push(newLink);\n      }\n\n      this.graph.edges = newLinks; // Map the old links for animations\n\n      if (this.graph.edges) {\n        this._oldLinks = this.graph.edges.map(l => {\n          const newL = Object.assign({}, l);\n          newL.oldLine = l.line;\n          return newL;\n        });\n      }\n\n      this.updateMinimap();\n\n      if (this.autoZoom) {\n        this.zoomToFit();\n      }\n\n      if (this.autoCenter) {\n        // Auto-center when rendering\n        this.center();\n      }\n\n      requestAnimationFrame(() => this.redrawLines());\n      this.cd.markForCheck();\n    }\n\n    getMinimapTransform() {\n      switch (this.miniMapPosition) {\n        case MiniMapPosition.UpperLeft:\n          {\n            return '';\n          }\n\n        case MiniMapPosition.UpperRight:\n          {\n            return 'translate(' + (this.dims.width - this.graphDims.width / this.minimapScaleCoefficient) + ',' + 0 + ')';\n          }\n\n        default:\n          {\n            return '';\n          }\n      }\n    }\n\n    updateGraphDims() {\n      let minX = +Infinity;\n      let maxX = -Infinity;\n      let minY = +Infinity;\n      let maxY = -Infinity;\n\n      for (let i = 0; i < this.graph.nodes.length; i++) {\n        const node = this.graph.nodes[i];\n        minX = node.position.x < minX ? node.position.x : minX;\n        minY = node.position.y < minY ? node.position.y : minY;\n        maxX = node.position.x + node.dimension.width > maxX ? node.position.x + node.dimension.width : maxX;\n        maxY = node.position.y + node.dimension.height > maxY ? node.position.y + node.dimension.height : maxY;\n      }\n\n      minX -= 100;\n      minY -= 100;\n      maxX += 100;\n      maxY += 100;\n      this.graphDims.width = maxX - minX;\n      this.graphDims.height = maxY - minY;\n      this.minimapOffsetX = minX;\n      this.minimapOffsetY = minY;\n    }\n\n    updateMinimap() {\n      // Calculate the height/width total, but only if we have any nodes\n      if (this.graph.nodes && this.graph.nodes.length) {\n        this.updateGraphDims();\n\n        if (this.miniMapMaxWidth) {\n          this.minimapScaleCoefficient = this.graphDims.width / this.miniMapMaxWidth;\n        }\n\n        if (this.miniMapMaxHeight) {\n          this.minimapScaleCoefficient = Math.max(this.minimapScaleCoefficient, this.graphDims.height / this.miniMapMaxHeight);\n        }\n\n        this.minimapTransform = this.getMinimapTransform();\n      }\n    }\n    /**\n     * Measures the node element and applies the dimensions\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    applyNodeDimensions() {\n      if (this.nodeElements && this.nodeElements.length) {\n        this.nodeElements.map(elem => {\n          const nativeElement = elem.nativeElement;\n          const node = this.graph.nodes.find(n => n.id === nativeElement.id);\n\n          if (!node) {\n            return;\n          } // calculate the height\n\n\n          let dims;\n\n          try {\n            dims = nativeElement.getBBox();\n\n            if (!dims.width || !dims.height) {\n              return;\n            }\n          } catch (ex) {\n            // Skip drawing if element is not displayed - Firefox would throw an error here\n            return;\n          }\n\n          if (this.nodeHeight) {\n            node.dimension.height = node.dimension.height && node.meta.forceDimensions ? node.dimension.height : this.nodeHeight;\n          } else {\n            node.dimension.height = node.dimension.height && node.meta.forceDimensions ? node.dimension.height : dims.height;\n          }\n\n          if (this.nodeMaxHeight) {\n            node.dimension.height = Math.max(node.dimension.height, this.nodeMaxHeight);\n          }\n\n          if (this.nodeMinHeight) {\n            node.dimension.height = Math.min(node.dimension.height, this.nodeMinHeight);\n          }\n\n          if (this.nodeWidth) {\n            node.dimension.width = node.dimension.width && node.meta.forceDimensions ? node.dimension.width : this.nodeWidth;\n          } else {\n            // calculate the width\n            if (nativeElement.getElementsByTagName('text').length) {\n              let maxTextDims;\n\n              try {\n                for (const textElem of nativeElement.getElementsByTagName('text')) {\n                  const currentBBox = textElem.getBBox();\n\n                  if (!maxTextDims) {\n                    maxTextDims = currentBBox;\n                  } else {\n                    if (currentBBox.width > maxTextDims.width) {\n                      maxTextDims.width = currentBBox.width;\n                    }\n\n                    if (currentBBox.height > maxTextDims.height) {\n                      maxTextDims.height = currentBBox.height;\n                    }\n                  }\n                }\n              } catch (ex) {\n                // Skip drawing if element is not displayed - Firefox would throw an error here\n                return;\n              }\n\n              node.dimension.width = node.dimension.width && node.meta.forceDimensions ? node.dimension.width : maxTextDims.width + 20;\n            } else {\n              node.dimension.width = node.dimension.width && node.meta.forceDimensions ? node.dimension.width : dims.width;\n            }\n          }\n\n          if (this.nodeMaxWidth) {\n            node.dimension.width = Math.max(node.dimension.width, this.nodeMaxWidth);\n          }\n\n          if (this.nodeMinWidth) {\n            node.dimension.width = Math.min(node.dimension.width, this.nodeMinWidth);\n          }\n        });\n      }\n    }\n    /**\n     * Redraws the lines when dragged or viewport updated\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    redrawLines(_animate = this.animate) {\n      this.linkElements.map(linkEl => {\n        const edge = this.graph.edges.find(lin => lin.id === linkEl.nativeElement.id);\n\n        if (edge) {\n          const linkSelection = select(linkEl.nativeElement).select('.line');\n          linkSelection.attr('d', edge.oldLine).transition().ease(ease.easeSinInOut).duration(_animate ? 500 : 0).attr('d', edge.line);\n          const textPathSelection = select(this.el.nativeElement).select(`#${edge.id}`);\n          textPathSelection.attr('d', edge.oldTextPath).transition().ease(ease.easeSinInOut).duration(_animate ? 500 : 0).attr('d', edge.textPath);\n          this.updateMidpointOnEdge(edge, edge.points);\n        }\n      });\n    }\n    /**\n     * Calculate the text directions / flipping\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    calcDominantBaseline(link) {\n      const firstPoint = link.points[0];\n      const lastPoint = link.points[link.points.length - 1];\n      link.oldTextPath = link.textPath;\n\n      if (lastPoint.x < firstPoint.x) {\n        link.dominantBaseline = 'text-before-edge'; // reverse text path for when its flipped upside down\n\n        link.textPath = this.generateLine([...link.points].reverse());\n      } else {\n        link.dominantBaseline = 'text-after-edge';\n        link.textPath = link.line;\n      }\n    }\n    /**\n     * Generate the new line path\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    generateLine(points) {\n      const lineFunction = shape.line().x(d => d.x).y(d => d.y).curve(this.curve);\n      return lineFunction(points);\n    }\n    /**\n     * Zoom was invoked from event\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onZoom($event, direction) {\n      if (this.enableTrackpadSupport && !$event.ctrlKey) {\n        this.pan($event.deltaX * -1, $event.deltaY * -1);\n        return;\n      }\n\n      const zoomFactor = 1 + (direction === 'in' ? this.zoomSpeed : -this.zoomSpeed); // Check that zooming wouldn't put us out of bounds\n\n      const newZoomLevel = this.zoomLevel * zoomFactor;\n\n      if (newZoomLevel <= this.minZoomLevel || newZoomLevel >= this.maxZoomLevel) {\n        return;\n      } // Check if zooming is enabled or not\n\n\n      if (!this.enableZoom) {\n        return;\n      }\n\n      if (this.panOnZoom === true && $event) {\n        // Absolute mouse X/Y on the screen\n        const mouseX = $event.clientX;\n        const mouseY = $event.clientY; // Transform the mouse X/Y into a SVG X/Y\n\n        const svg = this.el.nativeElement.querySelector('svg');\n        const svgGroup = svg.querySelector('g.chart');\n        const point = svg.createSVGPoint();\n        point.x = mouseX;\n        point.y = mouseY;\n        const svgPoint = point.matrixTransform(svgGroup.getScreenCTM().inverse()); // Panzoom\n\n        this.pan(svgPoint.x, svgPoint.y, true);\n        this.zoom(zoomFactor);\n        this.pan(-svgPoint.x, -svgPoint.y, true);\n      } else {\n        this.zoom(zoomFactor);\n      }\n    }\n    /**\n     * Pan by x/y\n     *\n     * @param x\n     * @param y\n     */\n\n\n    pan(x, y, ignoreZoomLevel = false) {\n      const zoomLevel = ignoreZoomLevel ? 1 : this.zoomLevel;\n      this.transformationMatrix = transform(this.transformationMatrix, translate(x / zoomLevel, y / zoomLevel));\n      this.updateTransform();\n    }\n    /**\n     * Pan to a fixed x/y\n     *\n     */\n\n\n    panTo(x, y) {\n      if (x === null || x === undefined || isNaN(x) || y === null || y === undefined || isNaN(y)) {\n        return;\n      }\n\n      const panX = -this.panOffsetX - x * this.zoomLevel + this.dims.width / 2;\n      const panY = -this.panOffsetY - y * this.zoomLevel + this.dims.height / 2;\n      this.transformationMatrix = transform(this.transformationMatrix, translate(panX / this.zoomLevel, panY / this.zoomLevel));\n      this.updateTransform();\n    }\n    /**\n     * Zoom by a factor\n     *\n     */\n\n\n    zoom(factor) {\n      this.transformationMatrix = transform(this.transformationMatrix, scale(factor, factor));\n      this.zoomChange.emit(this.zoomLevel);\n      this.updateTransform();\n    }\n    /**\n     * Zoom to a fixed level\n     *\n     */\n\n\n    zoomTo(level) {\n      this.transformationMatrix.a = isNaN(level) ? this.transformationMatrix.a : Number(level);\n      this.transformationMatrix.d = isNaN(level) ? this.transformationMatrix.d : Number(level);\n      this.zoomChange.emit(this.zoomLevel);\n\n      if (this.enablePreUpdateTransform) {\n        this.updateTransform();\n      }\n\n      this.update();\n    }\n    /**\n     * Drag was invoked from an event\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onDrag(event) {\n      if (!this.draggingEnabled) {\n        return;\n      }\n\n      const node = this.draggingNode;\n\n      if (this.layout && typeof this.layout !== 'string' && this.layout.onDrag) {\n        this.layout.onDrag(node, event);\n      }\n\n      node.position.x += event.movementX / this.zoomLevel;\n      node.position.y += event.movementY / this.zoomLevel; // move the node\n\n      const x = node.position.x - (this.centerNodesOnPositionChange ? node.dimension.width / 2 : 0);\n      const y = node.position.y - (this.centerNodesOnPositionChange ? node.dimension.height / 2 : 0);\n      node.transform = `translate(${x}, ${y})`;\n\n      for (const link of this.graph.edges) {\n        if (link.target === node.id || link.source === node.id || link.target.id === node.id || link.source.id === node.id) {\n          if (this.layout && typeof this.layout !== 'string') {\n            const result = this.layout.updateEdge(this.graph, link);\n            const result$ = result instanceof Observable ? result : of(result);\n            this.graphSubscription.add(result$.subscribe(graph => {\n              this.graph = graph;\n              this.redrawEdge(link);\n            }));\n          }\n        }\n      }\n\n      this.redrawLines(false);\n      this.updateMinimap();\n    }\n\n    redrawEdge(edge) {\n      const line = this.generateLine(edge.points);\n      this.calcDominantBaseline(edge);\n      edge.oldLine = edge.line;\n      edge.line = line;\n    }\n    /**\n     * Update the entire view for the new pan position\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    updateTransform() {\n      this.transform = toSVG(smoothMatrix(this.transformationMatrix, 100));\n      this.stateChange.emit({\n        state: NgxGraphStates.Transform\n      });\n    }\n    /**\n     * Node was clicked\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onClick(event) {\n      this.select.emit(event);\n    }\n    /**\n     * Node was focused\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onActivate(event) {\n      if (this.activeEntries.indexOf(event) > -1) {\n        return;\n      }\n\n      this.activeEntries = [event, ...this.activeEntries];\n      this.activate.emit({\n        value: event,\n        entries: this.activeEntries\n      });\n    }\n    /**\n     * Node was defocused\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onDeactivate(event) {\n      const idx = this.activeEntries.indexOf(event);\n      this.activeEntries.splice(idx, 1);\n      this.activeEntries = [...this.activeEntries];\n      this.deactivate.emit({\n        value: event,\n        entries: this.activeEntries\n      });\n    }\n    /**\n     * Get the domain series for the nodes\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    getSeriesDomain() {\n      return this.nodes.map(d => this.groupResultsBy(d)).reduce((nodes, node) => nodes.indexOf(node) !== -1 ? nodes : nodes.concat([node]), []).sort();\n    }\n    /**\n     * Tracking for the link\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    trackLinkBy(index, link) {\n      return link.id;\n    }\n    /**\n     * Tracking for the node\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    trackNodeBy(index, node) {\n      return node.id;\n    }\n    /**\n     * Sets the colors the nodes\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    setColors() {\n      this.colors = new ColorHelper(this.scheme, this.seriesDomain, this.customColors);\n    }\n    /**\n     * On mouse move event, used for panning and dragging.\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onMouseMove($event) {\n      this.isMouseMoveCalled = true;\n\n      if ((this.isPanning || this.isMinimapPanning) && this.panningEnabled) {\n        this.panWithConstraints(this.panningAxis, $event);\n      } else if (this.isDragging && this.draggingEnabled) {\n        this.onDrag($event);\n      }\n    }\n\n    onMouseDown(event) {\n      this.isMouseMoveCalled = false;\n    }\n\n    graphClick(event) {\n      if (!this.isMouseMoveCalled) this.clickHandler.emit(event);\n    }\n    /**\n     * On touch start event to enable panning.\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onTouchStart(event) {\n      this._touchLastX = event.changedTouches[0].clientX;\n      this._touchLastY = event.changedTouches[0].clientY;\n      this.isPanning = true;\n    }\n    /**\n     * On touch move event, used for panning.\n     *\n     */\n\n\n    onTouchMove($event) {\n      if (this.isPanning && this.panningEnabled) {\n        const clientX = $event.changedTouches[0].clientX;\n        const clientY = $event.changedTouches[0].clientY;\n        const movementX = clientX - this._touchLastX;\n        const movementY = clientY - this._touchLastY;\n        this._touchLastX = clientX;\n        this._touchLastY = clientY;\n        this.pan(movementX, movementY);\n      }\n    }\n    /**\n     * On touch end event to disable panning.\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onTouchEnd(event) {\n      this.isPanning = false;\n    }\n    /**\n     * On mouse up event to disable panning/dragging.\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onMouseUp(event) {\n      this.isDragging = false;\n      this.isPanning = false;\n      this.isMinimapPanning = false;\n\n      if (this.layout && typeof this.layout !== 'string' && this.layout.onDragEnd) {\n        this.layout.onDragEnd(this.draggingNode, event);\n      }\n    }\n    /**\n     * On node mouse down to kick off dragging\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onNodeMouseDown(event, node) {\n      if (!this.draggingEnabled) {\n        return;\n      }\n\n      this.isDragging = true;\n      this.draggingNode = node;\n\n      if (this.layout && typeof this.layout !== 'string' && this.layout.onDragStart) {\n        this.layout.onDragStart(node, event);\n      }\n    }\n    /**\n     * On minimap drag mouse down to kick off minimap panning\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onMinimapDragMouseDown() {\n      this.isMinimapPanning = true;\n    }\n    /**\n     * On minimap pan event. Pans the graph to the clicked position\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onMinimapPanTo(event) {\n      const x = event.offsetX - (this.dims.width - (this.graphDims.width + this.minimapOffsetX) / this.minimapScaleCoefficient);\n      const y = event.offsetY + this.minimapOffsetY / this.minimapScaleCoefficient;\n      this.panTo(x * this.minimapScaleCoefficient, y * this.minimapScaleCoefficient);\n      this.isMinimapPanning = true;\n    }\n    /**\n     * Center the graph in the viewport\n     */\n\n\n    center() {\n      this.panTo(this.graphDims.width / 2, this.graphDims.height / 2);\n    }\n    /**\n     * Zooms to fit the entire graph\n     */\n\n\n    zoomToFit(zoomOptions) {\n      this.updateGraphDims();\n      const heightZoom = this.dims.height / this.graphDims.height;\n      const widthZoom = this.dims.width / this.graphDims.width;\n      let zoomLevel = Math.min(heightZoom, widthZoom, 1);\n\n      if (zoomLevel < this.minZoomLevel) {\n        zoomLevel = this.minZoomLevel;\n      }\n\n      if (zoomLevel > this.maxZoomLevel) {\n        zoomLevel = this.maxZoomLevel;\n      }\n\n      if ((zoomOptions === null || zoomOptions === void 0 ? void 0 : zoomOptions.force) === true || zoomLevel !== this.zoomLevel) {\n        this.zoomLevel = zoomLevel;\n\n        if ((zoomOptions === null || zoomOptions === void 0 ? void 0 : zoomOptions.autoCenter) !== true) {\n          this.updateTransform();\n        }\n\n        if ((zoomOptions === null || zoomOptions === void 0 ? void 0 : zoomOptions.autoCenter) === true) {\n          this.center();\n        }\n\n        this.zoomChange.emit(this.zoomLevel);\n      }\n    }\n    /**\n     * Pans to the node\n     * @param nodeId\n     */\n\n\n    panToNodeId(nodeId) {\n      const node = this.graph.nodes.find(n => n.id === nodeId);\n\n      if (!node) {\n        return;\n      }\n\n      this.panTo(node.position.x, node.position.y);\n    }\n\n    getCompoundNodeChildren(ids) {\n      return this.nodes.filter(node => ids.includes(node.id));\n    }\n\n    panWithConstraints(key, event) {\n      let x = event.movementX;\n      let y = event.movementY;\n\n      if (this.isMinimapPanning) {\n        x = -this.minimapScaleCoefficient * x * this.zoomLevel;\n        y = -this.minimapScaleCoefficient * y * this.zoomLevel;\n      }\n\n      switch (key) {\n        case PanningAxis.Horizontal:\n          this.pan(x, 0);\n          break;\n\n        case PanningAxis.Vertical:\n          this.pan(0, y);\n          break;\n\n        default:\n          this.pan(x, y);\n          break;\n      }\n    }\n\n    updateMidpointOnEdge(edge, points) {\n      var _a, _b, _c;\n\n      if (!edge || !points) {\n        return;\n      }\n\n      if (points.length % 2 === 1) {\n        edge.midPoint = points[Math.floor(points.length / 2)];\n      } else {\n        // Checking if the current layout is Elk\n        if ((_c = (_b = (_a = this.layout) === null || _a === void 0 ? void 0 : _a.settings) === null || _b === void 0 ? void 0 : _b.properties) === null || _c === void 0 ? void 0 : _c['elk.direction']) {\n          this._calcMidPointElk(edge, points);\n        } else {\n          const _first = points[points.length / 2];\n          const _second = points[points.length / 2 - 1];\n          edge.midPoint = {\n            x: (_first.x + _second.x) / 2,\n            y: (_first.y + _second.y) / 2\n          };\n        }\n      }\n    }\n\n    _calcMidPointElk(edge, points) {\n      var _a;\n\n      let _firstX = null;\n      let _secondX = null;\n      let _firstY = null;\n      let _secondY = null;\n      const orientation = (_a = this.layout.settings) === null || _a === void 0 ? void 0 : _a.properties['elk.direction'];\n      const hasBend = orientation === 'RIGHT' ? points.some(p => p.y !== points[0].y) : points.some(p => p.x !== points[0].x);\n\n      if (hasBend) {\n        // getting the last two points\n        _firstX = points[points.length - 1];\n        _secondX = points[points.length - 2];\n        _firstY = points[points.length - 1];\n        _secondY = points[points.length - 2];\n      } else {\n        if (orientation === 'RIGHT') {\n          _firstX = points[0];\n          _secondX = points[points.length - 1];\n          _firstY = points[points.length / 2];\n          _secondY = points[points.length / 2 - 1];\n        } else {\n          _firstX = points[points.length / 2];\n          _secondX = points[points.length / 2 - 1];\n          _firstY = points[0];\n          _secondY = points[points.length - 1];\n        }\n      }\n\n      edge.midPoint = {\n        x: (_firstX.x + _secondX.x) / 2,\n        y: (_firstY.y + _secondY.y) / 2\n      };\n    }\n\n    basicUpdate() {\n      if (this.view) {\n        this.width = this.view[0];\n        this.height = this.view[1];\n      } else {\n        const dims = this.getContainerDims();\n\n        if (dims) {\n          this.width = dims.width;\n          this.height = dims.height;\n        }\n      } // default values if width or height are 0 or undefined\n\n\n      if (!this.width) {\n        this.width = 600;\n      }\n\n      if (!this.height) {\n        this.height = 400;\n      }\n\n      this.width = Math.floor(this.width);\n      this.height = Math.floor(this.height);\n\n      if (this.cd) {\n        this.cd.markForCheck();\n      }\n    }\n\n    getContainerDims() {\n      let width;\n      let height;\n      const hostElem = this.el.nativeElement;\n\n      if (hostElem.parentNode !== null) {\n        // Get the container dimensions\n        const dims = hostElem.parentNode.getBoundingClientRect();\n        width = dims.width;\n        height = dims.height;\n      }\n\n      if (width && height) {\n        return {\n          width,\n          height\n        };\n      }\n\n      return null;\n    }\n    /**\n     * Checks if the graph has dimensions\n     */\n\n\n    hasGraphDims() {\n      return this.graphDims.width > 0 && this.graphDims.height > 0;\n    }\n    /**\n     * Checks if all nodes have dimension\n     */\n\n\n    hasNodeDims() {\n      var _a;\n\n      return (_a = this.graph.nodes) === null || _a === void 0 ? void 0 : _a.every(node => node.dimension.width > 0 && node.dimension.height > 0);\n    }\n    /**\n     * Checks if all compound nodes have dimension\n     */\n\n\n    hasCompoundNodeDims() {\n      var _a;\n\n      return (_a = this.graph.compoundNodes) === null || _a === void 0 ? void 0 : _a.every(node => node.dimension.width > 0 && node.dimension.height > 0);\n    }\n    /**\n     * Checks if the graph and all nodes have dimension.\n     */\n\n\n    hasDims() {\n      return this.hasGraphDims() && this.hasNodeDims() && this.hasCompoundNodeDims();\n    }\n\n    unbindEvents() {\n      if (this.resizeSubscription) {\n        this.resizeSubscription.unsubscribe();\n      }\n    }\n\n    bindWindowResizeEvent() {\n      const source = fromEvent(window, 'resize');\n      const subscription = source.pipe(debounceTime(200)).subscribe(e => {\n        this.update();\n\n        if (this.cd) {\n          this.cd.markForCheck();\n        }\n      });\n      this.resizeSubscription = subscription;\n    }\n\n  }\n\n  GraphComponent.ɵfac = function GraphComponent_Factory(t) {\n    return new (t || GraphComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(LayoutService));\n  };\n\n  GraphComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: GraphComponent,\n    selectors: [[\"ngx-graph\"]],\n    contentQueries: function GraphComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, _c0, 5);\n        i0.ɵɵcontentQuery(dirIndex, _c1, 5);\n        i0.ɵɵcontentQuery(dirIndex, _c2, 5);\n        i0.ɵɵcontentQuery(dirIndex, _c3, 5);\n        i0.ɵɵcontentQuery(dirIndex, _c4, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.linkTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.clusterTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.defsTemplate = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.miniMapNodeTemplate = _t.first);\n      }\n    },\n    viewQuery: function GraphComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c5, 5);\n        i0.ɵɵviewQuery(_c6, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeElements = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.linkElements = _t);\n      }\n    },\n    hostBindings: function GraphComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousemove\", function GraphComponent_mousemove_HostBindingHandler($event) {\n          return ctx.onMouseMove($event);\n        }, false, i0.ɵɵresolveDocument)(\"mousedown\", function GraphComponent_mousedown_HostBindingHandler($event) {\n          return ctx.onMouseDown($event);\n        }, false, i0.ɵɵresolveDocument)(\"click\", function GraphComponent_click_HostBindingHandler($event) {\n          return ctx.graphClick($event);\n        }, false, i0.ɵɵresolveDocument)(\"touchmove\", function GraphComponent_touchmove_HostBindingHandler($event) {\n          return ctx.onTouchMove($event);\n        }, false, i0.ɵɵresolveDocument)(\"mouseup\", function GraphComponent_mouseup_HostBindingHandler($event) {\n          return ctx.onMouseUp($event);\n        }, false, i0.ɵɵresolveDocument);\n      }\n    },\n    inputs: {\n      nodes: \"nodes\",\n      clusters: \"clusters\",\n      compoundNodes: \"compoundNodes\",\n      links: \"links\",\n      activeEntries: \"activeEntries\",\n      curve: \"curve\",\n      draggingEnabled: \"draggingEnabled\",\n      nodeHeight: \"nodeHeight\",\n      nodeMaxHeight: \"nodeMaxHeight\",\n      nodeMinHeight: \"nodeMinHeight\",\n      nodeWidth: \"nodeWidth\",\n      nodeMinWidth: \"nodeMinWidth\",\n      nodeMaxWidth: \"nodeMaxWidth\",\n      panningEnabled: \"panningEnabled\",\n      panningAxis: \"panningAxis\",\n      enableZoom: \"enableZoom\",\n      zoomSpeed: \"zoomSpeed\",\n      minZoomLevel: \"minZoomLevel\",\n      maxZoomLevel: \"maxZoomLevel\",\n      autoZoom: \"autoZoom\",\n      panOnZoom: \"panOnZoom\",\n      animate: \"animate\",\n      autoCenter: \"autoCenter\",\n      update$: \"update$\",\n      center$: \"center$\",\n      zoomToFit$: \"zoomToFit$\",\n      panToNode$: \"panToNode$\",\n      layout: \"layout\",\n      layoutSettings: \"layoutSettings\",\n      enableTrackpadSupport: \"enableTrackpadSupport\",\n      showMiniMap: \"showMiniMap\",\n      miniMapMaxWidth: \"miniMapMaxWidth\",\n      miniMapMaxHeight: \"miniMapMaxHeight\",\n      miniMapPosition: \"miniMapPosition\",\n      view: \"view\",\n      scheme: \"scheme\",\n      customColors: \"customColors\",\n      animations: \"animations\",\n      deferDisplayUntilPosition: \"deferDisplayUntilPosition\",\n      centerNodesOnPositionChange: \"centerNodesOnPositionChange\",\n      enablePreUpdateTransform: \"enablePreUpdateTransform\",\n      groupResultsBy: \"groupResultsBy\",\n      zoomLevel: \"zoomLevel\",\n      panOffsetX: \"panOffsetX\",\n      panOffsetY: \"panOffsetY\"\n    },\n    outputs: {\n      select: \"select\",\n      activate: \"activate\",\n      deactivate: \"deactivate\",\n      zoomChange: \"zoomChange\",\n      clickHandler: \"clickHandler\",\n      stateChange: \"stateChange\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c8,\n    decls: 6,\n    vars: 11,\n    consts: [[\"mouseWheel\", \"\", 1, \"ngx-graph-outer\", 3, \"mouseWheelUp\", \"mouseWheelDown\"], [1, \"ngx-graph\"], [\"class\", \"graph chart\", 3, \"touchstart\", \"touchend\", 4, \"ngIf\"], [\"class\", \"minimap\", 4, \"ngIf\"], [1, \"graph\", \"chart\", 3, \"touchstart\", \"touchend\"], [3, \"ngTemplateOutlet\", 4, \"ngIf\"], [\"class\", \"text-path\", 4, \"ngFor\", \"ngForOf\"], [1, \"panning-rect\", 3, \"mousedown\"], [1, \"clusters\"], [\"class\", \"node-group\", 3, \"old-node\", \"id\", \"click\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"compound-nodes\"], [\"class\", \"node-group\", 3, \"old-node\", \"id\", \"click\", \"mousedown\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"links\"], [\"class\", \"link-group\", 3, \"id\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"nodes\"], [3, \"ngTemplateOutlet\"], [1, \"text-path\"], [1, \"node-group\", 3, \"id\", \"click\"], [\"clusterElement\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\", 4, \"ngIf\"], [\"class\", \"node cluster\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"node\", \"cluster\"], [\"alignment-baseline\", \"central\"], [1, \"node-group\", 3, \"id\", \"click\", \"mousedown\"], [\"nodeElement\", \"\"], [\"class\", \"node compound-node\", 4, \"ngIf\"], [1, \"node\", \"compound-node\"], [1, \"link-group\", 3, \"id\"], [\"linkElement\", \"\"], [\"class\", \"edge\", 4, \"ngIf\"], [1, \"edge\"], [\"r\", \"10\", 4, \"ngIf\"], [\"r\", \"10\"], [1, \"minimap\"], [1, \"minimap-background\", 3, \"mousedown\"], [1, \"minimap-nodes\"], [\"class\", \"node-group\", 3, \"old-node\", \"id\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"minimap-drag\", 3, \"mousedown\"], [1, \"node-group\", 3, \"id\"]],\n    template: function GraphComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"mouseWheelUp\", function GraphComponent_Template_div_mouseWheelUp_0_listener($event) {\n          return ctx.onZoom($event, \"in\");\n        })(\"mouseWheelDown\", function GraphComponent_Template_div_mouseWheelDown_0_listener($event) {\n          return ctx.onZoom($event, \"out\");\n        });\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(1, \"svg\", 1);\n        i0.ɵɵtemplate(2, GraphComponent__svg_g_2_Template, 14, 14, \"g\", 2);\n        i0.ɵɵelementStart(3, \"clipPath\");\n        i0.ɵɵelement(4, \"rect\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, GraphComponent__svg_g_5_Template, 6, 15, \"g\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"width\", ctx.width, \"px\");\n        i0.ɵɵproperty(\"@animationState\", \"active\")(\"@.disabled\", !ctx.animations);\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"width\", ctx.width)(\"height\", ctx.height);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.initialized && ctx.graph);\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"id\", ctx.minimapClipPathId);\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"width\", ctx.graphDims.width / ctx.minimapScaleCoefficient)(\"height\", ctx.graphDims.height / ctx.minimapScaleCoefficient);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showMiniMap);\n      }\n    },\n    directives: [MouseWheelDirective, i3.NgIf, i3.NgForOf, i3.NgTemplateOutlet],\n    styles: [\".minimap .minimap-background{fill:#0000001a}.minimap .minimap-drag{fill:#0003;stroke:#fff;stroke-width:1px;stroke-dasharray:2px;stroke-dashoffset:2px;cursor:pointer}.minimap .minimap-drag.panning{fill:#0000004d}.minimap .minimap-nodes{opacity:.5;pointer-events:none}.graph{-webkit-user-select:none;-moz-user-select:none;user-select:none}.graph .edge{stroke:#666;fill:none}.graph .edge .edge-label{stroke:none;font-size:12px;fill:#251e1e}.graph .panning-rect{fill:#0000;cursor:move}.graph .node-group.old-node{transition:transform .5s ease-in-out}.graph .node-group .node:focus{outline:none}.graph .compound-node rect{opacity:.5}.graph .cluster rect{opacity:.2}\\n\"],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('animationState', [transition(':enter', [style({\n        opacity: 0\n      }), animate('500ms 100ms', style({\n        opacity: 1\n      }))])])]\n    },\n    changeDetection: 0\n  });\n\n  __decorate([throttleable(500)], GraphComponent.prototype, \"updateMinimap\", null);\n\n  return GraphComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet GraphModule = /*#__PURE__*/(() => {\n  class GraphModule {}\n\n  GraphModule.ɵfac = function GraphModule_Factory(t) {\n    return new (t || GraphModule)();\n  };\n\n  GraphModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: GraphModule\n  });\n  GraphModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [LayoutService],\n    imports: [[CommonModule]]\n  });\n  return GraphModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgxGraphModule = /*#__PURE__*/(() => {\n  class NgxGraphModule {}\n\n  NgxGraphModule.ɵfac = function NgxGraphModule_Factory(t) {\n    return new (t || NgxGraphModule)();\n  };\n\n  NgxGraphModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxGraphModule\n  });\n  NgxGraphModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule], GraphModule]\n  });\n  return NgxGraphModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ngx-graph\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Alignment, ColaForceDirectedLayout, D3ForceDirectedLayout, DagreClusterLayout, DagreLayout, DagreNodesOnlyLayout, GraphComponent, GraphModule, MiniMapPosition, MouseWheelDirective, NgxGraphModule, NgxGraphStates, Orientation, PanningAxis, toD3Node, toNode }; //# sourceMappingURL=swimlane-ngx-graph.mjs.map","map":null,"metadata":{},"sourceType":"module"}