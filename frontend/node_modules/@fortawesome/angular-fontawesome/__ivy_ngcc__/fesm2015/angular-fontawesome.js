import { Injectable, ɵɵdefineInjectable, Directive, Input, Component, Optional, HostBinding, Renderer2, ElementRef, Inject, forwardRef, NgModule, ɵɵinject } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { findIconDefinition, parse, icon, counter, text } from '@fortawesome/fontawesome-svg-core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/platform-browser';

const _c0 = [[["fa-icon"], ["fa-duotone-icon"], ["fa-layers-text"], ["fa-layers-counter"]]];
const _c1 = ["fa-icon, fa-duotone-icon, fa-layers-text, fa-layers-counter"];
const _c2 = [[["fa-icon", "stackItemSize", ""], ["fa-duotone-icon", "stackItemSize", ""]]];
const _c3 = ["fa-icon[stackItemSize],fa-duotone-icon[stackItemSize]"];
class FaConfig {
    constructor() {
        /**
         * Default prefix to use, when one is not provided with the icon name.
         *
         * \@default 'fas'
         */
        this.defaultPrefix = 'fas';
        /**
         * Whether components should lookup icon definitions in the global icon
         * library (the one available from
         * `import { library } from '\@fortawesome/fontawesome-svg-core')`.
         *
         * See https://github.com/FortAwesome/angular-fontawesome/blob/master/docs/usage/icon-library.md
         * for detailed description of library modes.
         *
         * - 'unset' - Components should lookup icon definitions in the global library
         * and emit warning if they find a definition there. This option is a default
         * to assist existing applications with a migration. Applications are expected
         * to switch to using {\@link FaIconLibrary}.
         * - true - Components should lookup icon definitions in the global library.
         * Note that global icon library is deprecated and support for it will be
         * removed. This option can be used to temporarily suppress warnings.
         * - false - Components should not lookup icon definitions in the global
         * library. Library will throw an error if missing icon is found in the global
         * library.
         *
         * @deprecated This option is deprecated since 0.5.0. In 0.6.0 default will
         * be changed to false. In 0.7.0 the option will be removed together with the
         * support for the global icon library.
         *
         * \@default 'unset'
         */
        this.globalLibrary = 'unset';
    }
}
FaConfig.ɵfac = function FaConfig_Factory(t) { return new (t || FaConfig)(); };
FaConfig.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: FaConfig, factory: FaConfig.ɵfac, providedIn: 'root' });
/** @nocollapse */ FaConfig.ngInjectableDef = ɵɵdefineInjectable({ factory: function FaConfig_Factory() { return new FaConfig(); }, token: FaConfig, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FaConfig, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FaIconLibrary {
    constructor() {
        this.definitions = {};
    }
    /**
     * @param {...?} icons
     * @return {?}
     */
    addIcons(...icons) {
        for (let i = 0; i < icons.length; i++) {
            /** @type {?} */
            const icon = icons[i];
            if (!(icon.prefix in this.definitions)) {
                this.definitions[icon.prefix] = {};
            }
            this.definitions[icon.prefix][icon.iconName] = icon;
        }
    }
    /**
     * @param {...?} packs
     * @return {?}
     */
    addIconPacks(...packs) {
        for (let i = 0; i < packs.length; i++) {
            /** @type {?} */
            const pack = packs[i];
            /** @type {?} */
            const icons = Object.keys(pack).map((/**
             * @param {?} key
             * @return {?}
             */
            (key) => pack[key]));
            this.addIcons(...icons);
        }
    }
    /**
     * @param {?} prefix
     * @param {?} name
     * @return {?}
     */
    getIconDefinition(prefix, name) {
        if (prefix in this.definitions && name in this.definitions[prefix]) {
            return this.definitions[prefix][name];
        }
        return null;
    }
}
FaIconLibrary.ɵfac = function FaIconLibrary_Factory(t) { return new (t || FaIconLibrary)(); };
FaIconLibrary.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: FaIconLibrary, factory: FaIconLibrary.ɵfac, providedIn: 'root' });
/** @nocollapse */ FaIconLibrary.ngInjectableDef = ɵɵdefineInjectable({ factory: function FaIconLibrary_Factory() { return new FaIconLibrary(); }, token: FaIconLibrary, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FaIconLibrary, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const faWarnIfIconDefinitionMissing = (/**
 * @param {?} iconSpec
 * @return {?}
 */
(iconSpec) => {
    console.error(`FontAwesome: Could not find icon with iconName=${iconSpec.iconName} and prefix=${iconSpec.prefix}. ` +
        `This warning will become a hard error in 0.6.0.`);
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const faWarnIfIconSpecMissing = (/**
 * @return {?}
 */
() => {
    console.error('FontAwesome: Property `icon` is required for `fa-icon`/`fa-duotone-icon` components. ' +
        `This warning will become a hard error in 0.6.0.`);
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Fontawesome class list.
 * Returns classes array by props.
 * @type {?}
 */
const faClassList = (/**
 * @param {?} props
 * @return {?}
 */
(props) => {
    /** @type {?} */
    const classes = {
        'fa-spin': props.spin,
        'fa-pulse': props.pulse,
        'fa-fw': props.fixedWidth,
        'fa-border': props.border,
        'fa-li': props.listItem,
        'fa-inverse': props.inverse,
        'fa-layers-counter': props.counter,
        'fa-flip-horizontal': props.flip === 'horizontal' || props.flip === 'both',
        'fa-flip-vertical': props.flip === 'vertical' || props.flip === 'both',
        [`fa-${props.size}`]: props.size !== null,
        [`fa-rotate-${props.rotate}`]: props.rotate !== null,
        [`fa-pull-${props.pull}`]: props.pull !== null,
        [`fa-stack-${props.stackItemSize}`]: props.stackItemSize != null,
    };
    return Object.keys(classes)
        .map((/**
     * @param {?} key
     * @return {?}
     */
    key => (classes[key] ? key : null)))
        .filter((/**
     * @param {?} key
     * @return {?}
     */
    key => key));
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns if is IconLookup or not.
 * @type {?}
 */
const isIconLookup = (/**
 * @param {?} i
 * @return {?}
 */
(i) => {
    return ((/** @type {?} */ (i))).prefix !== undefined && ((/** @type {?} */ (i))).iconName !== undefined;
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Normalizing icon spec.
 * @type {?}
 */
const faNormalizeIconSpec = (/**
 * @param {?} iconSpec
 * @param {?} defaultPrefix
 * @return {?}
 */
(iconSpec, defaultPrefix) => {
    if (isIconLookup(iconSpec)) {
        return iconSpec;
    }
    if (Array.isArray(iconSpec) && ((/** @type {?} */ (iconSpec))).length === 2) {
        return { prefix: iconSpec[0], iconName: iconSpec[1] };
    }
    if (typeof iconSpec === 'string') {
        return { prefix: defaultPrefix, iconName: iconSpec };
    }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FaStackItemSizeDirective {
    constructor() {
        /**
         * Specify whether icon inside {\@link FaStackComponent} should be rendered in
         * regular size (1x) or as a larger icon (2x).
         */
        this.stackItemSize = '1x';
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('size' in changes) {
            throw new Error('fa-icon is not allowed to customize size when used inside fa-stack. ' +
                'Set size on the enclosing fa-stack instead: <fa-stack size="4x">...</fa-stack>.');
        }
    }
}
FaStackItemSizeDirective.ɵfac = function FaStackItemSizeDirective_Factory(t) { return new (t || FaStackItemSizeDirective)(); };
FaStackItemSizeDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FaStackItemSizeDirective, selectors: [["fa-icon", "stackItemSize", ""], ["fa-duotone-icon", "stackItemSize", ""]], inputs: { stackItemSize: "stackItemSize", size: "size" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
FaStackItemSizeDirective.propDecorators = {
    stackItemSize: [{ type: Input }],
    size: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FaStackItemSizeDirective, [{
        type: Directive,
        args: [{
                selector: 'fa-icon[stackItemSize],fa-duotone-icon[stackItemSize]'
            }]
    }], function () { return []; }, { stackItemSize: [{
            type: Input
        }], size: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FaIconComponent {
    /**
     * @param {?} sanitizer
     * @param {?} config
     * @param {?} iconLibrary
     * @param {?} stackItem
     */
    constructor(sanitizer, config, iconLibrary, stackItem) {
        this.sanitizer = sanitizer;
        this.config = config;
        this.iconLibrary = iconLibrary;
        this.stackItem = stackItem;
        this.classes = [];
    }
    /**
     * @deprecated Since 0.5.0. Will be removed in 0.6.0. Use `icon` property directly.
     * @return {?}
     */
    get iconProp() {
        return this.icon;
    }
    /**
     * @deprecated Since 0.5.0. Will be removed in 0.6.0. Use `icon` property directly.
     * @param {?} value
     * @return {?}
     */
    set iconProp(value) {
        this.icon = value;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.icon == null) {
            return faWarnIfIconSpecMissing();
        }
        if (changes) {
            /** @type {?} */
            const iconDefinition = this.findIconDefinition(this.icon);
            if (iconDefinition != null) {
                /** @type {?} */
                const params = this.buildParams();
                this.renderIcon(iconDefinition, params);
            }
        }
    }
    /**
     * Programmatically trigger rendering of the icon.
     *
     * This method is useful, when creating {\@link FaIconComponent} dynamically or
     * changing its inputs programmatically as in these cases icon won't be
     * re-rendered automatically.
     * @return {?}
     */
    render() {
        this.ngOnChanges({});
    }
    /**
     * @protected
     * @param {?} i
     * @return {?}
     */
    findIconDefinition(i) {
        /** @type {?} */
        const lookup = faNormalizeIconSpec(i, this.config.defaultPrefix);
        if ('icon' in lookup) {
            return lookup;
        }
        /** @type {?} */
        const definition = this.iconLibrary.getIconDefinition(lookup.prefix, lookup.iconName);
        if (definition != null) {
            return definition;
        }
        /** @type {?} */
        const globalDefinition = findIconDefinition(lookup);
        if (globalDefinition != null) {
            /** @type {?} */
            const message = 'Global icon library is deprecated. ' +
                'Consult https://github.com/FortAwesome/angular-fontawesome/blob/master/UPGRADING.md ' +
                'for the migration instructions.';
            if (this.config.globalLibrary === 'unset') {
                console.error('FontAwesome: ' + message);
            }
            else if (!this.config.globalLibrary) {
                throw new Error(message);
            }
            return globalDefinition;
        }
        faWarnIfIconDefinitionMissing(lookup);
        return null;
    }
    /**
     * @protected
     * @return {?}
     */
    buildParams() {
        /** @type {?} */
        const classOpts = {
            flip: this.flip,
            spin: this.spin,
            pulse: this.pulse,
            border: this.border,
            inverse: this.inverse,
            listItem: this.listItem,
            size: this.size || null,
            pull: this.pull || null,
            rotate: this.rotate || null,
            fixedWidth: this.fixedWidth,
            stackItemSize: this.stackItem != null ? this.stackItem.stackItemSize : null,
        };
        /** @type {?} */
        const parsedTransform = typeof this.transform === 'string' ? parse.transform(this.transform) : this.transform;
        return {
            title: this.title,
            transform: parsedTransform,
            classes: [...faClassList(classOpts), ...this.classes],
            mask: this.mask != null ? this.findIconDefinition(this.mask) : null,
            styles: this.styles != null ? this.styles : {},
            symbol: this.symbol,
            attributes: {
                role: this.a11yRole
            }
        };
    }
    /**
     * @private
     * @param {?} definition
     * @param {?} params
     * @return {?}
     */
    renderIcon(definition, params) {
        /** @type {?} */
        const renderedIcon = icon(definition, params);
        this.renderedIconHTML = this.sanitizer.bypassSecurityTrustHtml(renderedIcon.html.join('\n'));
    }
}
FaIconComponent.ɵfac = function FaIconComponent_Factory(t) { return new (t || FaIconComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.DomSanitizer), ɵngcc0.ɵɵdirectiveInject(FaConfig), ɵngcc0.ɵɵdirectiveInject(FaIconLibrary), ɵngcc0.ɵɵdirectiveInject(FaStackItemSizeDirective, 8)); };
FaIconComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FaIconComponent, selectors: [["fa-icon"]], hostAttrs: [1, "ng-fa-icon"], hostVars: 2, hostBindings: function FaIconComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("innerHTML", ctx.renderedIconHTML, ɵngcc0.ɵɵsanitizeHtml);
        ɵngcc0.ɵɵattribute("title", ctx.title);
    } }, inputs: { classes: "classes", icon: "icon", title: "title", spin: "spin", pulse: "pulse", mask: "mask", styles: "styles", flip: "flip", size: "size", pull: "pull", border: "border", inverse: "inverse", symbol: "symbol", listItem: "listItem", rotate: "rotate", fixedWidth: "fixedWidth", transform: "transform", a11yRole: "a11yRole" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function FaIconComponent_Template(rf, ctx) { }, encapsulation: 2 });
/** @nocollapse */
FaIconComponent.ctorParameters = () => [
    { type: DomSanitizer },
    { type: FaConfig },
    { type: FaIconLibrary },
    { type: FaStackItemSizeDirective, decorators: [{ type: Optional }] }
];
FaIconComponent.propDecorators = {
    icon: [{ type: Input }],
    title: [{ type: Input }],
    spin: [{ type: Input }],
    pulse: [{ type: Input }],
    mask: [{ type: Input }],
    styles: [{ type: Input }],
    flip: [{ type: Input }],
    size: [{ type: Input }],
    pull: [{ type: Input }],
    border: [{ type: Input }],
    inverse: [{ type: Input }],
    symbol: [{ type: Input }],
    listItem: [{ type: Input }],
    rotate: [{ type: Input }],
    fixedWidth: [{ type: Input }],
    classes: [{ type: Input }],
    transform: [{ type: Input }],
    a11yRole: [{ type: Input }],
    renderedIconHTML: [{ type: HostBinding, args: ['innerHTML',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FaIconComponent, [{
        type: Component,
        args: [{
                selector: 'fa-icon',
                template: ``,
                host: {
                    class: 'ng-fa-icon',
                    '[attr.title]': 'title'
                }
            }]
    }], function () { return [{ type: ɵngcc1.DomSanitizer }, { type: FaConfig }, { type: FaIconLibrary }, { type: FaStackItemSizeDirective, decorators: [{
                type: Optional
            }] }]; }, { classes: [{
            type: Input
        }], icon: [{
            type: Input
        }], renderedIconHTML: [{
            type: HostBinding,
            args: ['innerHTML']
        }], title: [{
            type: Input
        }], spin: [{
            type: Input
        }], pulse: [{
            type: Input
        }], mask: [{
            type: Input
        }], styles: [{
            type: Input
        }], flip: [{
            type: Input
        }], size: [{
            type: Input
        }], pull: [{
            type: Input
        }], border: [{
            type: Input
        }], inverse: [{
            type: Input
        }], symbol: [{
            type: Input
        }], listItem: [{
            type: Input
        }], rotate: [{
            type: Input
        }], fixedWidth: [{
            type: Input
        }], transform: [{
            type: Input
        }], a11yRole: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FaDuotoneIconComponent extends FaIconComponent {
    /**
     * @protected
     * @param {?} i
     * @return {?}
     */
    findIconDefinition(i) {
        /** @type {?} */
        const lookup = super.findIconDefinition(i);
        if (lookup != null && lookup.prefix !== 'fad') {
            throw new Error('The specified icon does not appear to be a Duotone icon. ' +
                'Check that you specified the correct style: ' +
                `<fa-duotone-icon [icon]="['fab', '${lookup.iconName}']"></fa-duotone-icon> ` +
                `or use: <fa-icon icon="${lookup.iconName}"></fa-icon> instead.`);
        }
        return lookup;
    }
    /**
     * @protected
     * @return {?}
     */
    buildParams() {
        /** @type {?} */
        const params = super.buildParams();
        if (this.swapOpacity === true || this.swapOpacity === 'true') {
            params.classes.push('fa-swap-opacity');
        }
        if (this.primaryOpacity != null) {
            params.styles['--fa-primary-opacity'] = this.primaryOpacity.toString();
        }
        if (this.secondaryOpacity != null) {
            params.styles['--fa-secondary-opacity'] = this.secondaryOpacity.toString();
        }
        if (this.primaryColor != null) {
            params.styles['--fa-primary-color'] = this.primaryColor;
        }
        if (this.secondaryColor != null) {
            params.styles['--fa-secondary-color'] = this.secondaryColor;
        }
        return params;
    }
}
FaDuotoneIconComponent.ɵfac = /*@__PURE__*/ function () { let ɵFaDuotoneIconComponent_BaseFactory; return function FaDuotoneIconComponent_Factory(t) { return (ɵFaDuotoneIconComponent_BaseFactory || (ɵFaDuotoneIconComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(FaDuotoneIconComponent)))(t || FaDuotoneIconComponent); }; }();
FaDuotoneIconComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FaDuotoneIconComponent, selectors: [["fa-duotone-icon"]], inputs: { swapOpacity: "swapOpacity", primaryOpacity: "primaryOpacity", secondaryOpacity: "secondaryOpacity", primaryColor: "primaryColor", secondaryColor: "secondaryColor" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function FaDuotoneIconComponent_Template(rf, ctx) { }, encapsulation: 2 });
FaDuotoneIconComponent.propDecorators = {
    swapOpacity: [{ type: Input }],
    primaryOpacity: [{ type: Input }],
    secondaryOpacity: [{ type: Input }],
    primaryColor: [{ type: Input }],
    secondaryColor: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FaDuotoneIconComponent, [{
        type: Component,
        args: [{
                selector: 'fa-duotone-icon',
                template: ``
            }]
    }], null, { swapOpacity: [{
            type: Input
        }], primaryOpacity: [{
            type: Input
        }], secondaryOpacity: [{
            type: Input
        }], primaryColor: [{
            type: Input
        }], secondaryColor: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Fontawesome layers.
 */
class FaLayersComponent {
    /**
     * @param {?} renderer
     * @param {?} elementRef
     */
    constructor(renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.renderer.addClass(this.elementRef.nativeElement, 'fa-layers');
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('size' in changes) {
            if (changes.size.currentValue != null) {
                this.renderer.addClass(this.elementRef.nativeElement, `fa-${changes.size.currentValue}`);
            }
            if (changes.size.previousValue != null) {
                this.renderer.removeClass(this.elementRef.nativeElement, `fa-${changes.size.previousValue}`);
            }
        }
    }
}
FaLayersComponent.ɵfac = function FaLayersComponent_Factory(t) { return new (t || FaLayersComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FaLayersComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FaLayersComponent, selectors: [["fa-layers"]], hostVars: 2, hostBindings: function FaLayersComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("fa-fw", ctx.fixedWidth);
    } }, inputs: { size: "size", fixedWidth: "fixedWidth" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c1, decls: 1, vars: 0, template: function FaLayersComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/** @nocollapse */
FaLayersComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
FaLayersComponent.propDecorators = {
    size: [{ type: Input }],
    fixedWidth: [{ type: Input }, { type: HostBinding, args: ['class.fa-fw',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FaLayersComponent, [{
        type: Component,
        args: [{
                selector: 'fa-layers',
                template: `<ng-content select="fa-icon, fa-duotone-icon, fa-layers-text, fa-layers-counter"></ng-content>`
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { size: [{
            type: Input
        }], fixedWidth: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.fa-fw']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Warns if parent component not existing.
 * @type {?}
 */
const faWarnIfParentNotExist = (/**
 * @param {?} parent
 * @param {?} parentName
 * @param {?} childName
 * @return {?}
 */
(parent, parentName, childName) => {
    if (!parent) {
        console.error(`FontAwesome: ${childName} should be used as child of ${parentName} only.`);
    }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class FaLayersTextBaseComponent {
    /**
     * @param {?} parent
     * @param {?} sanitizer
     */
    constructor(parent, sanitizer) {
        this.parent = parent;
        this.sanitizer = sanitizer;
        this.classes = [];
        faWarnIfParentNotExist(this.parent, 'FaLayersComponent', this.constructor.name);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes) {
            this.updateParams();
            this.updateContent();
        }
    }
    /**
     * Updating content by params and content.
     * @private
     * @return {?}
     */
    updateContent() {
        this.renderedHTML = this.sanitizer.bypassSecurityTrustHtml(this.renderFontawesomeObject(this.content || '', this.params).html.join('\n'));
    }
}
FaLayersTextBaseComponent.ɵfac = function FaLayersTextBaseComponent_Factory(t) { return new (t || FaLayersTextBaseComponent)(ɵngcc0.ɵɵinject(forwardRef(( /**
                 * @return {?}
                 */() => FaLayersComponent)), 8), ɵngcc0.ɵɵinject(ɵngcc1.DomSanitizer)); };
FaLayersTextBaseComponent.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: FaLayersTextBaseComponent, factory: FaLayersTextBaseComponent.ɵfac });
FaLayersTextBaseComponent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: FaLayersTextBaseComponent, hostVars: 1, hostBindings: function FaLayersTextBaseComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("innerHTML", ctx.renderedHTML, ɵngcc0.ɵɵsanitizeHtml);
    } }, inputs: { classes: "classes", content: "content", title: "title", styles: "styles" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
FaLayersTextBaseComponent.ctorParameters = () => [
    { type: FaLayersComponent, decorators: [{ type: Inject, args: [forwardRef((/**
                     * @return {?}
                     */
                    () => FaLayersComponent)),] }, { type: Optional }] },
    { type: DomSanitizer }
];
FaLayersTextBaseComponent.propDecorators = {
    renderedHTML: [{ type: HostBinding, args: ['innerHTML',] }],
    content: [{ type: Input }],
    title: [{ type: Input }],
    styles: [{ type: Input }],
    classes: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FaLayersTextBaseComponent, [{
        type: Injectable
    }], function () { return [{ type: FaLayersComponent, decorators: [{
                type: Inject,
                args: [forwardRef(( /**
                                     * @return {?}
                                     */() => FaLayersComponent))]
            }, {
                type: Optional
            }] }, { type: ɵngcc1.DomSanitizer }]; }, { classes: [{
            type: Input
        }], renderedHTML: [{
            type: HostBinding,
            args: ['innerHTML']
        }], content: [{
            type: Input
        }], title: [{
            type: Input
        }], styles: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FaLayersTextBaseComponent, [{
        type: Injectable
    }], function () { return [{ type: FaLayersComponent, decorators: [{
                type: Inject,
                args: [forwardRef(( /**
                                     * @return {?}
                                     */() => FaLayersComponent))]
            }, {
                type: Optional
            }] }, { type: ɵngcc1.DomSanitizer }]; }, { classes: [{
            type: Input
        }], renderedHTML: [{
            type: HostBinding,
            args: ['innerHTML']
        }], content: [{
            type: Input
        }], title: [{
            type: Input
        }], styles: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Fontawesome layers counter.
 */
class FaLayersCounterComponent extends FaLayersTextBaseComponent {
    /**
     * Updating params by component props.
     * @protected
     * @return {?}
     */
    updateParams() {
        this.params = {
            title: this.title,
            classes: this.classes,
            styles: this.styles,
        };
    }
    /**
     * @protected
     * @param {?} content
     * @param {?=} params
     * @return {?}
     */
    renderFontawesomeObject(content, params) {
        return counter(content, params);
    }
}
FaLayersCounterComponent.ɵfac = /*@__PURE__*/ function () { let ɵFaLayersCounterComponent_BaseFactory; return function FaLayersCounterComponent_Factory(t) { return (ɵFaLayersCounterComponent_BaseFactory || (ɵFaLayersCounterComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(FaLayersCounterComponent)))(t || FaLayersCounterComponent); }; }();
FaLayersCounterComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FaLayersCounterComponent, selectors: [["fa-layers-counter"]], hostAttrs: [1, "ng-fa-layers-counter"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function FaLayersCounterComponent_Template(rf, ctx) { }, encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FaLayersCounterComponent, [{
        type: Component,
        args: [{
                selector: 'fa-layers-counter',
                template: '',
                host: {
                    class: 'ng-fa-layers-counter'
                }
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Fontawesome layers text.
 */
class FaLayersTextComponent extends FaLayersTextBaseComponent {
    /**
     * Updating params by component props.
     * @protected
     * @return {?}
     */
    updateParams() {
        /** @type {?} */
        const classOpts = {
            flip: this.flip,
            spin: this.spin,
            pulse: this.pulse,
            border: this.border,
            inverse: this.inverse,
            listItem: this.listItem,
            size: this.size || null,
            pull: this.pull || null,
            rotate: this.rotate || null,
            fixedWidth: this.fixedWidth
        };
        /** @type {?} */
        const parsedTransform = typeof this.transform === 'string' ? parse.transform(this.transform) : this.transform;
        this.params = {
            transform: parsedTransform,
            classes: [...faClassList(classOpts), ...this.classes],
            title: this.title,
            styles: this.styles
        };
    }
    /**
     * @protected
     * @param {?} content
     * @param {?=} params
     * @return {?}
     */
    renderFontawesomeObject(content, params) {
        return text(content, params);
    }
}
FaLayersTextComponent.ɵfac = /*@__PURE__*/ function () { let ɵFaLayersTextComponent_BaseFactory; return function FaLayersTextComponent_Factory(t) { return (ɵFaLayersTextComponent_BaseFactory || (ɵFaLayersTextComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(FaLayersTextComponent)))(t || FaLayersTextComponent); }; }();
FaLayersTextComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FaLayersTextComponent, selectors: [["fa-layers-text"]], hostAttrs: [1, "ng-fa-layers-text"], inputs: { spin: "spin", pulse: "pulse", flip: "flip", size: "size", pull: "pull", border: "border", inverse: "inverse", listItem: "listItem", rotate: "rotate", fixedWidth: "fixedWidth", transform: "transform" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function FaLayersTextComponent_Template(rf, ctx) { }, encapsulation: 2 });
FaLayersTextComponent.propDecorators = {
    spin: [{ type: Input }],
    pulse: [{ type: Input }],
    flip: [{ type: Input }],
    size: [{ type: Input }],
    pull: [{ type: Input }],
    border: [{ type: Input }],
    inverse: [{ type: Input }],
    listItem: [{ type: Input }],
    rotate: [{ type: Input }],
    fixedWidth: [{ type: Input }],
    transform: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FaLayersTextComponent, [{
        type: Component,
        args: [{
                selector: 'fa-layers-text',
                template: '',
                host: {
                    class: 'ng-fa-layers-text'
                }
            }]
    }], null, { spin: [{
            type: Input
        }], pulse: [{
            type: Input
        }], flip: [{
            type: Input
        }], size: [{
            type: Input
        }], pull: [{
            type: Input
        }], border: [{
            type: Input
        }], inverse: [{
            type: Input
        }], listItem: [{
            type: Input
        }], rotate: [{
            type: Input
        }], fixedWidth: [{
            type: Input
        }], transform: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FaStackComponent {
    /**
     * @param {?} renderer
     * @param {?} elementRef
     */
    constructor(renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.renderer.addClass(this.elementRef.nativeElement, 'fa-stack');
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('size' in changes) {
            if (changes.size.currentValue != null) {
                this.renderer.addClass(this.elementRef.nativeElement, `fa-${changes.size.currentValue}`);
            }
            if (changes.size.previousValue != null) {
                this.renderer.removeClass(this.elementRef.nativeElement, `fa-${changes.size.previousValue}`);
            }
        }
    }
}
FaStackComponent.ɵfac = function FaStackComponent_Factory(t) { return new (t || FaStackComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
FaStackComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: FaStackComponent, selectors: [["fa-stack"]], inputs: { size: "size" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c3, decls: 1, vars: 0, template: function FaStackComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c2);
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/** @nocollapse */
FaStackComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
FaStackComponent.propDecorators = {
    size: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FaStackComponent, [{
        type: Component,
        args: [{
                selector: 'fa-stack',
                // TODO: See if it is better to select fa-icon and throw if it does not have stackItemSize directive
                template: `<ng-content select="fa-icon[stackItemSize],fa-duotone-icon[stackItemSize]"></ng-content>`
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { size: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FontAwesomeModule {
}
FontAwesomeModule.ɵfac = function FontAwesomeModule_Factory(t) { return new (t || FontAwesomeModule)(); };
FontAwesomeModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: FontAwesomeModule });
FontAwesomeModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FontAwesomeModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    FaIconComponent,
                    FaDuotoneIconComponent,
                    FaLayersComponent,
                    FaLayersTextComponent,
                    FaLayersCounterComponent,
                    FaStackComponent,
                    FaStackItemSizeDirective,
                ],
                exports: [
                    FaIconComponent,
                    FaDuotoneIconComponent,
                    FaLayersComponent,
                    FaLayersTextComponent,
                    FaLayersCounterComponent,
                    FaStackComponent,
                    FaStackItemSizeDirective,
                ],
                entryComponents: [
                    FaIconComponent,
                    FaDuotoneIconComponent,
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FontAwesomeModule, { declarations: [FaIconComponent, FaDuotoneIconComponent, FaLayersComponent, FaLayersTextComponent, FaLayersCounterComponent, FaStackComponent, FaStackItemSizeDirective], exports: [FaIconComponent, FaDuotoneIconComponent, FaLayersComponent, FaLayersTextComponent, FaLayersCounterComponent, FaStackComponent, FaStackItemSizeDirective] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated Since 0.5.0. Will be removed in 0.6.0. Use FaConfig directly.
 */
class FaIconService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @return {?}
     */
    get defaultPrefix() {
        return this.config.defaultPrefix;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultPrefix(value) {
        this.config.defaultPrefix = value;
    }
}
FaIconService.ɵfac = function FaIconService_Factory(t) { return new (t || FaIconService)(ɵngcc0.ɵɵinject(FaConfig)); };
FaIconService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: FaIconService, factory: FaIconService.ɵfac, providedIn: 'root' });
/** @nocollapse */
FaIconService.ctorParameters = () => [
    { type: FaConfig }
];
/** @nocollapse */ FaIconService.ngInjectableDef = ɵɵdefineInjectable({ factory: function FaIconService_Factory() { return new FaIconService(ɵɵinject(FaConfig)); }, token: FaIconService, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FaIconService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: FaConfig }]; }, null); })();

export { FaConfig, FaDuotoneIconComponent, FaIconComponent, FaIconLibrary, FaIconService, FaLayersComponent, FaLayersCounterComponent, FaLayersTextComponent, FaStackComponent, FaStackItemSizeDirective, FontAwesomeModule, FaLayersTextBaseComponent as ɵa };

//# sourceMappingURL=angular-fontawesome.js.map