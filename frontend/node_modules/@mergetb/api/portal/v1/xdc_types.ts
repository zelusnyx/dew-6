/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "portal.v1";

export interface XDCStorage {
  /** identify an XDC */
  name: string;
  project: string;
  creator: string;
  /** xdc configuration */
  memLimit: number;
  /** in cores */
  cpuLimit: number;
  image: string;
  /** Housekeeping */
  ver: number;
  materialization: string;
}

export interface XDCInfo {
  name: string;
  url: string;
  fqdn: string;
  creator: string;
  memlimit: number;
  cpulimit: number;
  image: string;
  materialization: string;
}

export interface ListXDCsRequest {
  project: string;
}

export interface ListXDCsResponse {
  XDCs: XDCInfo[];
}

export interface CreateXDCRequest {
  project: string;
  xdc: string;
  image: string;
  memlimit: number;
  cpulimit: number;
}

export interface CreateXDCResponse {
}

export interface DeleteXDCRequest {
  project: string;
  xdc: string;
}

export interface DeleteXDCResponse {
}

export interface AttachXDCRequest {
  xdc: string;
  project: string;
  experiment: string;
  realization: string;
}

export interface AttachXDCResponse {
}

export interface DetachXDCRequest {
  xdc: string;
  project: string;
  experiment: string;
  realization: string;
}

export interface DetachXDCResponse {
}

export interface XDCTunnelGatewayRequest {
  site: string;
}

export interface XDCTunnelGateway {
  key: string;
  endpoint: string;
  allowedips: string;
}

export interface XDCTunnelGatewayResponse {
  Gateways: XDCTunnelGateway[];
}

export interface GetXDCJumpHostsRequest {
}

export interface GetXDCJumpHostsResponse {
  JumpHosts: SSHJump[];
}

export interface SSHJump {
  name: string;
  port: number;
  fqdn: string;
  ver: number;
}

export interface JupyterCfg {
  token: string;
  /** full path including token, e.g, https://foo-bar.xdc.mergetb.io/jupyter/lab?token=... */
  url: string;
  host: string;
  domain: string;
  ver: number;
}

function createBaseXDCStorage(): XDCStorage {
  return { name: "", project: "", creator: "", memLimit: 0, cpuLimit: 0, image: "", ver: 0, materialization: "" };
}

export const XDCStorage = {
  encode(message: XDCStorage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.creator !== "") {
      writer.uint32(26).string(message.creator);
    }
    if (message.memLimit !== 0) {
      writer.uint32(32).int32(message.memLimit);
    }
    if (message.cpuLimit !== 0) {
      writer.uint32(40).int32(message.cpuLimit);
    }
    if (message.image !== "") {
      writer.uint32(50).string(message.image);
    }
    if (message.ver !== 0) {
      writer.uint32(64).int64(message.ver);
    }
    if (message.materialization !== "") {
      writer.uint32(74).string(message.materialization);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XDCStorage {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXDCStorage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.project = reader.string();
          break;
        case 3:
          message.creator = reader.string();
          break;
        case 4:
          message.memLimit = reader.int32();
          break;
        case 5:
          message.cpuLimit = reader.int32();
          break;
        case 6:
          message.image = reader.string();
          break;
        case 8:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        case 9:
          message.materialization = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): XDCStorage {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      project: isSet(object.project) ? String(object.project) : "",
      creator: isSet(object.creator) ? String(object.creator) : "",
      memLimit: isSet(object.memLimit) ? Number(object.memLimit) : 0,
      cpuLimit: isSet(object.cpuLimit) ? Number(object.cpuLimit) : 0,
      image: isSet(object.image) ? String(object.image) : "",
      ver: isSet(object.ver) ? Number(object.ver) : 0,
      materialization: isSet(object.materialization) ? String(object.materialization) : "",
    };
  },

  toJSON(message: XDCStorage): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.project !== undefined && (obj.project = message.project);
    message.creator !== undefined && (obj.creator = message.creator);
    message.memLimit !== undefined && (obj.memLimit = Math.round(message.memLimit));
    message.cpuLimit !== undefined && (obj.cpuLimit = Math.round(message.cpuLimit));
    message.image !== undefined && (obj.image = message.image);
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    message.materialization !== undefined && (obj.materialization = message.materialization);
    return obj;
  },

  create<I extends Exact<DeepPartial<XDCStorage>, I>>(base?: I): XDCStorage {
    return XDCStorage.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<XDCStorage>, I>>(object: I): XDCStorage {
    const message = createBaseXDCStorage();
    message.name = object.name ?? "";
    message.project = object.project ?? "";
    message.creator = object.creator ?? "";
    message.memLimit = object.memLimit ?? 0;
    message.cpuLimit = object.cpuLimit ?? 0;
    message.image = object.image ?? "";
    message.ver = object.ver ?? 0;
    message.materialization = object.materialization ?? "";
    return message;
  },
};

function createBaseXDCInfo(): XDCInfo {
  return { name: "", url: "", fqdn: "", creator: "", memlimit: 0, cpulimit: 0, image: "", materialization: "" };
}

export const XDCInfo = {
  encode(message: XDCInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.fqdn !== "") {
      writer.uint32(26).string(message.fqdn);
    }
    if (message.creator !== "") {
      writer.uint32(34).string(message.creator);
    }
    if (message.memlimit !== 0) {
      writer.uint32(40).int32(message.memlimit);
    }
    if (message.cpulimit !== 0) {
      writer.uint32(48).int32(message.cpulimit);
    }
    if (message.image !== "") {
      writer.uint32(58).string(message.image);
    }
    if (message.materialization !== "") {
      writer.uint32(66).string(message.materialization);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XDCInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXDCInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.url = reader.string();
          break;
        case 3:
          message.fqdn = reader.string();
          break;
        case 4:
          message.creator = reader.string();
          break;
        case 5:
          message.memlimit = reader.int32();
          break;
        case 6:
          message.cpulimit = reader.int32();
          break;
        case 7:
          message.image = reader.string();
          break;
        case 8:
          message.materialization = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): XDCInfo {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      url: isSet(object.url) ? String(object.url) : "",
      fqdn: isSet(object.fqdn) ? String(object.fqdn) : "",
      creator: isSet(object.creator) ? String(object.creator) : "",
      memlimit: isSet(object.memlimit) ? Number(object.memlimit) : 0,
      cpulimit: isSet(object.cpulimit) ? Number(object.cpulimit) : 0,
      image: isSet(object.image) ? String(object.image) : "",
      materialization: isSet(object.materialization) ? String(object.materialization) : "",
    };
  },

  toJSON(message: XDCInfo): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.url !== undefined && (obj.url = message.url);
    message.fqdn !== undefined && (obj.fqdn = message.fqdn);
    message.creator !== undefined && (obj.creator = message.creator);
    message.memlimit !== undefined && (obj.memlimit = Math.round(message.memlimit));
    message.cpulimit !== undefined && (obj.cpulimit = Math.round(message.cpulimit));
    message.image !== undefined && (obj.image = message.image);
    message.materialization !== undefined && (obj.materialization = message.materialization);
    return obj;
  },

  create<I extends Exact<DeepPartial<XDCInfo>, I>>(base?: I): XDCInfo {
    return XDCInfo.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<XDCInfo>, I>>(object: I): XDCInfo {
    const message = createBaseXDCInfo();
    message.name = object.name ?? "";
    message.url = object.url ?? "";
    message.fqdn = object.fqdn ?? "";
    message.creator = object.creator ?? "";
    message.memlimit = object.memlimit ?? 0;
    message.cpulimit = object.cpulimit ?? 0;
    message.image = object.image ?? "";
    message.materialization = object.materialization ?? "";
    return message;
  },
};

function createBaseListXDCsRequest(): ListXDCsRequest {
  return { project: "" };
}

export const ListXDCsRequest = {
  encode(message: ListXDCsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListXDCsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListXDCsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListXDCsRequest {
    return { project: isSet(object.project) ? String(object.project) : "" };
  },

  toJSON(message: ListXDCsRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    return obj;
  },

  create<I extends Exact<DeepPartial<ListXDCsRequest>, I>>(base?: I): ListXDCsRequest {
    return ListXDCsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ListXDCsRequest>, I>>(object: I): ListXDCsRequest {
    const message = createBaseListXDCsRequest();
    message.project = object.project ?? "";
    return message;
  },
};

function createBaseListXDCsResponse(): ListXDCsResponse {
  return { XDCs: [] };
}

export const ListXDCsResponse = {
  encode(message: ListXDCsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.XDCs) {
      XDCInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListXDCsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListXDCsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.XDCs.push(XDCInfo.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ListXDCsResponse {
    return { XDCs: Array.isArray(object?.XDCs) ? object.XDCs.map((e: any) => XDCInfo.fromJSON(e)) : [] };
  },

  toJSON(message: ListXDCsResponse): unknown {
    const obj: any = {};
    if (message.XDCs) {
      obj.XDCs = message.XDCs.map((e) => e ? XDCInfo.toJSON(e) : undefined);
    } else {
      obj.XDCs = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListXDCsResponse>, I>>(base?: I): ListXDCsResponse {
    return ListXDCsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ListXDCsResponse>, I>>(object: I): ListXDCsResponse {
    const message = createBaseListXDCsResponse();
    message.XDCs = object.XDCs?.map((e) => XDCInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateXDCRequest(): CreateXDCRequest {
  return { project: "", xdc: "", image: "", memlimit: 0, cpulimit: 0 };
}

export const CreateXDCRequest = {
  encode(message: CreateXDCRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.xdc !== "") {
      writer.uint32(18).string(message.xdc);
    }
    if (message.image !== "") {
      writer.uint32(26).string(message.image);
    }
    if (message.memlimit !== 0) {
      writer.uint32(32).int32(message.memlimit);
    }
    if (message.cpulimit !== 0) {
      writer.uint32(40).int32(message.cpulimit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateXDCRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateXDCRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.xdc = reader.string();
          break;
        case 3:
          message.image = reader.string();
          break;
        case 4:
          message.memlimit = reader.int32();
          break;
        case 5:
          message.cpulimit = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreateXDCRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      xdc: isSet(object.xdc) ? String(object.xdc) : "",
      image: isSet(object.image) ? String(object.image) : "",
      memlimit: isSet(object.memlimit) ? Number(object.memlimit) : 0,
      cpulimit: isSet(object.cpulimit) ? Number(object.cpulimit) : 0,
    };
  },

  toJSON(message: CreateXDCRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.xdc !== undefined && (obj.xdc = message.xdc);
    message.image !== undefined && (obj.image = message.image);
    message.memlimit !== undefined && (obj.memlimit = Math.round(message.memlimit));
    message.cpulimit !== undefined && (obj.cpulimit = Math.round(message.cpulimit));
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateXDCRequest>, I>>(base?: I): CreateXDCRequest {
    return CreateXDCRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CreateXDCRequest>, I>>(object: I): CreateXDCRequest {
    const message = createBaseCreateXDCRequest();
    message.project = object.project ?? "";
    message.xdc = object.xdc ?? "";
    message.image = object.image ?? "";
    message.memlimit = object.memlimit ?? 0;
    message.cpulimit = object.cpulimit ?? 0;
    return message;
  },
};

function createBaseCreateXDCResponse(): CreateXDCResponse {
  return {};
}

export const CreateXDCResponse = {
  encode(_: CreateXDCResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateXDCResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateXDCResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): CreateXDCResponse {
    return {};
  },

  toJSON(_: CreateXDCResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateXDCResponse>, I>>(base?: I): CreateXDCResponse {
    return CreateXDCResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CreateXDCResponse>, I>>(_: I): CreateXDCResponse {
    const message = createBaseCreateXDCResponse();
    return message;
  },
};

function createBaseDeleteXDCRequest(): DeleteXDCRequest {
  return { project: "", xdc: "" };
}

export const DeleteXDCRequest = {
  encode(message: DeleteXDCRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.xdc !== "") {
      writer.uint32(18).string(message.xdc);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteXDCRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteXDCRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.xdc = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteXDCRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      xdc: isSet(object.xdc) ? String(object.xdc) : "",
    };
  },

  toJSON(message: DeleteXDCRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.xdc !== undefined && (obj.xdc = message.xdc);
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteXDCRequest>, I>>(base?: I): DeleteXDCRequest {
    return DeleteXDCRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteXDCRequest>, I>>(object: I): DeleteXDCRequest {
    const message = createBaseDeleteXDCRequest();
    message.project = object.project ?? "";
    message.xdc = object.xdc ?? "";
    return message;
  },
};

function createBaseDeleteXDCResponse(): DeleteXDCResponse {
  return {};
}

export const DeleteXDCResponse = {
  encode(_: DeleteXDCResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteXDCResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteXDCResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteXDCResponse {
    return {};
  },

  toJSON(_: DeleteXDCResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteXDCResponse>, I>>(base?: I): DeleteXDCResponse {
    return DeleteXDCResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteXDCResponse>, I>>(_: I): DeleteXDCResponse {
    const message = createBaseDeleteXDCResponse();
    return message;
  },
};

function createBaseAttachXDCRequest(): AttachXDCRequest {
  return { xdc: "", project: "", experiment: "", realization: "" };
}

export const AttachXDCRequest = {
  encode(message: AttachXDCRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.xdc !== "") {
      writer.uint32(10).string(message.xdc);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(26).string(message.experiment);
    }
    if (message.realization !== "") {
      writer.uint32(34).string(message.realization);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AttachXDCRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachXDCRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.xdc = reader.string();
          break;
        case 2:
          message.project = reader.string();
          break;
        case 3:
          message.experiment = reader.string();
          break;
        case 4:
          message.realization = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AttachXDCRequest {
    return {
      xdc: isSet(object.xdc) ? String(object.xdc) : "",
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      realization: isSet(object.realization) ? String(object.realization) : "",
    };
  },

  toJSON(message: AttachXDCRequest): unknown {
    const obj: any = {};
    message.xdc !== undefined && (obj.xdc = message.xdc);
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.realization !== undefined && (obj.realization = message.realization);
    return obj;
  },

  create<I extends Exact<DeepPartial<AttachXDCRequest>, I>>(base?: I): AttachXDCRequest {
    return AttachXDCRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AttachXDCRequest>, I>>(object: I): AttachXDCRequest {
    const message = createBaseAttachXDCRequest();
    message.xdc = object.xdc ?? "";
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.realization = object.realization ?? "";
    return message;
  },
};

function createBaseAttachXDCResponse(): AttachXDCResponse {
  return {};
}

export const AttachXDCResponse = {
  encode(_: AttachXDCResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AttachXDCResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachXDCResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): AttachXDCResponse {
    return {};
  },

  toJSON(_: AttachXDCResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AttachXDCResponse>, I>>(base?: I): AttachXDCResponse {
    return AttachXDCResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AttachXDCResponse>, I>>(_: I): AttachXDCResponse {
    const message = createBaseAttachXDCResponse();
    return message;
  },
};

function createBaseDetachXDCRequest(): DetachXDCRequest {
  return { xdc: "", project: "", experiment: "", realization: "" };
}

export const DetachXDCRequest = {
  encode(message: DetachXDCRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.xdc !== "") {
      writer.uint32(10).string(message.xdc);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(26).string(message.experiment);
    }
    if (message.realization !== "") {
      writer.uint32(34).string(message.realization);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DetachXDCRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetachXDCRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.xdc = reader.string();
          break;
        case 2:
          message.project = reader.string();
          break;
        case 3:
          message.experiment = reader.string();
          break;
        case 4:
          message.realization = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DetachXDCRequest {
    return {
      xdc: isSet(object.xdc) ? String(object.xdc) : "",
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      realization: isSet(object.realization) ? String(object.realization) : "",
    };
  },

  toJSON(message: DetachXDCRequest): unknown {
    const obj: any = {};
    message.xdc !== undefined && (obj.xdc = message.xdc);
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.realization !== undefined && (obj.realization = message.realization);
    return obj;
  },

  create<I extends Exact<DeepPartial<DetachXDCRequest>, I>>(base?: I): DetachXDCRequest {
    return DetachXDCRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DetachXDCRequest>, I>>(object: I): DetachXDCRequest {
    const message = createBaseDetachXDCRequest();
    message.xdc = object.xdc ?? "";
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.realization = object.realization ?? "";
    return message;
  },
};

function createBaseDetachXDCResponse(): DetachXDCResponse {
  return {};
}

export const DetachXDCResponse = {
  encode(_: DetachXDCResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DetachXDCResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetachXDCResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DetachXDCResponse {
    return {};
  },

  toJSON(_: DetachXDCResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DetachXDCResponse>, I>>(base?: I): DetachXDCResponse {
    return DetachXDCResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DetachXDCResponse>, I>>(_: I): DetachXDCResponse {
    const message = createBaseDetachXDCResponse();
    return message;
  },
};

function createBaseXDCTunnelGatewayRequest(): XDCTunnelGatewayRequest {
  return { site: "" };
}

export const XDCTunnelGatewayRequest = {
  encode(message: XDCTunnelGatewayRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.site !== "") {
      writer.uint32(10).string(message.site);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XDCTunnelGatewayRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXDCTunnelGatewayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.site = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): XDCTunnelGatewayRequest {
    return { site: isSet(object.site) ? String(object.site) : "" };
  },

  toJSON(message: XDCTunnelGatewayRequest): unknown {
    const obj: any = {};
    message.site !== undefined && (obj.site = message.site);
    return obj;
  },

  create<I extends Exact<DeepPartial<XDCTunnelGatewayRequest>, I>>(base?: I): XDCTunnelGatewayRequest {
    return XDCTunnelGatewayRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<XDCTunnelGatewayRequest>, I>>(object: I): XDCTunnelGatewayRequest {
    const message = createBaseXDCTunnelGatewayRequest();
    message.site = object.site ?? "";
    return message;
  },
};

function createBaseXDCTunnelGateway(): XDCTunnelGateway {
  return { key: "", endpoint: "", allowedips: "" };
}

export const XDCTunnelGateway = {
  encode(message: XDCTunnelGateway, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.endpoint !== "") {
      writer.uint32(18).string(message.endpoint);
    }
    if (message.allowedips !== "") {
      writer.uint32(26).string(message.allowedips);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XDCTunnelGateway {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXDCTunnelGateway();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.endpoint = reader.string();
          break;
        case 3:
          message.allowedips = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): XDCTunnelGateway {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      endpoint: isSet(object.endpoint) ? String(object.endpoint) : "",
      allowedips: isSet(object.allowedips) ? String(object.allowedips) : "",
    };
  },

  toJSON(message: XDCTunnelGateway): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.endpoint !== undefined && (obj.endpoint = message.endpoint);
    message.allowedips !== undefined && (obj.allowedips = message.allowedips);
    return obj;
  },

  create<I extends Exact<DeepPartial<XDCTunnelGateway>, I>>(base?: I): XDCTunnelGateway {
    return XDCTunnelGateway.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<XDCTunnelGateway>, I>>(object: I): XDCTunnelGateway {
    const message = createBaseXDCTunnelGateway();
    message.key = object.key ?? "";
    message.endpoint = object.endpoint ?? "";
    message.allowedips = object.allowedips ?? "";
    return message;
  },
};

function createBaseXDCTunnelGatewayResponse(): XDCTunnelGatewayResponse {
  return { Gateways: [] };
}

export const XDCTunnelGatewayResponse = {
  encode(message: XDCTunnelGatewayResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.Gateways) {
      XDCTunnelGateway.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XDCTunnelGatewayResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXDCTunnelGatewayResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.Gateways.push(XDCTunnelGateway.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): XDCTunnelGatewayResponse {
    return {
      Gateways: Array.isArray(object?.Gateways) ? object.Gateways.map((e: any) => XDCTunnelGateway.fromJSON(e)) : [],
    };
  },

  toJSON(message: XDCTunnelGatewayResponse): unknown {
    const obj: any = {};
    if (message.Gateways) {
      obj.Gateways = message.Gateways.map((e) => e ? XDCTunnelGateway.toJSON(e) : undefined);
    } else {
      obj.Gateways = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<XDCTunnelGatewayResponse>, I>>(base?: I): XDCTunnelGatewayResponse {
    return XDCTunnelGatewayResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<XDCTunnelGatewayResponse>, I>>(object: I): XDCTunnelGatewayResponse {
    const message = createBaseXDCTunnelGatewayResponse();
    message.Gateways = object.Gateways?.map((e) => XDCTunnelGateway.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetXDCJumpHostsRequest(): GetXDCJumpHostsRequest {
  return {};
}

export const GetXDCJumpHostsRequest = {
  encode(_: GetXDCJumpHostsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetXDCJumpHostsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetXDCJumpHostsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetXDCJumpHostsRequest {
    return {};
  },

  toJSON(_: GetXDCJumpHostsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetXDCJumpHostsRequest>, I>>(base?: I): GetXDCJumpHostsRequest {
    return GetXDCJumpHostsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetXDCJumpHostsRequest>, I>>(_: I): GetXDCJumpHostsRequest {
    const message = createBaseGetXDCJumpHostsRequest();
    return message;
  },
};

function createBaseGetXDCJumpHostsResponse(): GetXDCJumpHostsResponse {
  return { JumpHosts: [] };
}

export const GetXDCJumpHostsResponse = {
  encode(message: GetXDCJumpHostsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.JumpHosts) {
      SSHJump.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetXDCJumpHostsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetXDCJumpHostsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.JumpHosts.push(SSHJump.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetXDCJumpHostsResponse {
    return { JumpHosts: Array.isArray(object?.JumpHosts) ? object.JumpHosts.map((e: any) => SSHJump.fromJSON(e)) : [] };
  },

  toJSON(message: GetXDCJumpHostsResponse): unknown {
    const obj: any = {};
    if (message.JumpHosts) {
      obj.JumpHosts = message.JumpHosts.map((e) => e ? SSHJump.toJSON(e) : undefined);
    } else {
      obj.JumpHosts = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetXDCJumpHostsResponse>, I>>(base?: I): GetXDCJumpHostsResponse {
    return GetXDCJumpHostsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetXDCJumpHostsResponse>, I>>(object: I): GetXDCJumpHostsResponse {
    const message = createBaseGetXDCJumpHostsResponse();
    message.JumpHosts = object.JumpHosts?.map((e) => SSHJump.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSSHJump(): SSHJump {
  return { name: "", port: 0, fqdn: "", ver: 0 };
}

export const SSHJump = {
  encode(message: SSHJump, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.port !== 0) {
      writer.uint32(16).uint32(message.port);
    }
    if (message.fqdn !== "") {
      writer.uint32(26).string(message.fqdn);
    }
    if (message.ver !== 0) {
      writer.uint32(32).int64(message.ver);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SSHJump {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSSHJump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.port = reader.uint32();
          break;
        case 3:
          message.fqdn = reader.string();
          break;
        case 4:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SSHJump {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      port: isSet(object.port) ? Number(object.port) : 0,
      fqdn: isSet(object.fqdn) ? String(object.fqdn) : "",
      ver: isSet(object.ver) ? Number(object.ver) : 0,
    };
  },

  toJSON(message: SSHJump): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.port !== undefined && (obj.port = Math.round(message.port));
    message.fqdn !== undefined && (obj.fqdn = message.fqdn);
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    return obj;
  },

  create<I extends Exact<DeepPartial<SSHJump>, I>>(base?: I): SSHJump {
    return SSHJump.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SSHJump>, I>>(object: I): SSHJump {
    const message = createBaseSSHJump();
    message.name = object.name ?? "";
    message.port = object.port ?? 0;
    message.fqdn = object.fqdn ?? "";
    message.ver = object.ver ?? 0;
    return message;
  },
};

function createBaseJupyterCfg(): JupyterCfg {
  return { token: "", url: "", host: "", domain: "", ver: 0 };
}

export const JupyterCfg = {
  encode(message: JupyterCfg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.host !== "") {
      writer.uint32(26).string(message.host);
    }
    if (message.domain !== "") {
      writer.uint32(34).string(message.domain);
    }
    if (message.ver !== 0) {
      writer.uint32(40).int64(message.ver);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): JupyterCfg {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJupyterCfg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.token = reader.string();
          break;
        case 2:
          message.url = reader.string();
          break;
        case 3:
          message.host = reader.string();
          break;
        case 4:
          message.domain = reader.string();
          break;
        case 5:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): JupyterCfg {
    return {
      token: isSet(object.token) ? String(object.token) : "",
      url: isSet(object.url) ? String(object.url) : "",
      host: isSet(object.host) ? String(object.host) : "",
      domain: isSet(object.domain) ? String(object.domain) : "",
      ver: isSet(object.ver) ? Number(object.ver) : 0,
    };
  },

  toJSON(message: JupyterCfg): unknown {
    const obj: any = {};
    message.token !== undefined && (obj.token = message.token);
    message.url !== undefined && (obj.url = message.url);
    message.host !== undefined && (obj.host = message.host);
    message.domain !== undefined && (obj.domain = message.domain);
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    return obj;
  },

  create<I extends Exact<DeepPartial<JupyterCfg>, I>>(base?: I): JupyterCfg {
    return JupyterCfg.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<JupyterCfg>, I>>(object: I): JupyterCfg {
    const message = createBaseJupyterCfg();
    message.token = object.token ?? "";
    message.url = object.url ?? "";
    message.host = object.host ?? "";
    message.domain = object.domain ?? "";
    message.ver = object.ver ?? 0;
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
