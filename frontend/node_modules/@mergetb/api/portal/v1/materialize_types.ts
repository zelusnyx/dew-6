/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { TaskForest, TaskSummary } from "../../mergetb/tech/reconcile/taskstatus";
import {
  Actuator as Actuator4,
  Bond as Bond3,
  Node,
  Phyo as Phyo1,
  Protocol,
  protocolFromJSON,
  protocolToJSON,
  ResourceAllocation,
  Sensor as Sensor2,
} from "../../mergetb/xir/v0.3/core";
import {
  ActuatorRealization,
  BondRealization,
  LinkEmulationParams,
  LinkRealization,
  PhyoRealization,
  SensorRealization,
} from "./realize_types";
import { FilterMode, filterModeFromJSON, filterModeToJSON } from "./workspace_types";

export const protobufPackage = "portal.v1";

export enum RebootMaterializationMode {
  Reboot = 0,
  Cycle = 1,
  Reimage = 2,
  UNRECOGNIZED = -1,
}

export function rebootMaterializationModeFromJSON(object: any): RebootMaterializationMode {
  switch (object) {
    case 0:
    case "Reboot":
      return RebootMaterializationMode.Reboot;
    case 1:
    case "Cycle":
      return RebootMaterializationMode.Cycle;
    case 2:
    case "Reimage":
      return RebootMaterializationMode.Reimage;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RebootMaterializationMode.UNRECOGNIZED;
  }
}

export function rebootMaterializationModeToJSON(object: RebootMaterializationMode): string {
  switch (object) {
    case RebootMaterializationMode.Reboot:
      return "Reboot";
    case RebootMaterializationMode.Cycle:
      return "Cycle";
    case RebootMaterializationMode.Reimage:
      return "Reimage";
    case RebootMaterializationMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface MzParameters {
  infrapodServer: string;
  infrapodPhy: string;
  infranetAddr: string;
  infranetSubnet: string;
  infranetGw: string;
  infranetVni: number;
  /** if true hostnames resolve on the experiment network */
  resolveExpnet: boolean;
}

export interface Materialization {
  rid: string;
  eid: string;
  pid: string;
  params:
    | MzParameters
    | undefined;
  /** Cyber */
  metal: BareMetal[];
  vms: VirtualMachine[];
  links: Link[];
  /** Physical */
  phyos: Phyo[];
  bonds: Bond[];
  sensors: Sensor[];
  actuators: Actuator[];
  /** Moa */
  linkEmulation: LinkEmulationParams | undefined;
}

export interface UserInfo {
  name: string;
  groups: string[];
  pubkeys: string[];
  privkeys: string[];
}

export interface BareMetal {
  facility: string;
  resource: string;
  model: Node | undefined;
  users: UserInfo[];
  inframac: string;
  infravid: number;
  infraport: string;
  infranetAddr: string;
  rootdev: string;
}

export interface VirtualMachine {
  vmAlloc: ResourceAllocation | undefined;
  users: UserInfo[];
  inframac: string;
  infranetAddr: string;
}

export interface Link {
  realization: LinkRealization | undefined;
}

export interface Phyo {
  realization: PhyoRealization | undefined;
  model: Phyo1 | undefined;
}

export interface Sensor {
  realization: SensorRealization | undefined;
  model: Sensor2 | undefined;
}

export interface Bond {
  realization: BondRealization | undefined;
  model: Bond3 | undefined;
}

export interface Actuator {
  realization: ActuatorRealization | undefined;
  model: Actuator4 | undefined;
}

export interface RebootMaterializationRequest {
  mode: RebootMaterializationMode;
  project: string;
  experiment: string;
  realization: string;
  hostnames: string[];
  allNodes: boolean;
  ver: number;
}

export interface RebootMaterializationResponse {
}

export interface GetMaterializationsRequest {
  /** NOTE: project and experiment are currently not used. API callers will get all mtzs. */
  project: string;
  experiment: string;
  /** from workspace_types */
  filter: FilterMode;
}

/** We translate the facility verison of this into something more user friendly. */
export interface Ingress {
  mzid: string;
  /** requested protocol of experiment node endpoint */
  protocol: string;
  /** experiment node name hosting the endpoint */
  hostname: string;
  /** port on the experiment node */
  hostport: number;
  /** exp host address (infranet) */
  hostaddr: string;
  /** fdqn of the gateway */
  gateway: string;
  /** external port on gateway (ingress port) */
  gatewayport: number;
  /** ingress path with port. */
  ingress: string;
}

export interface Ingresses {
  ingresses: Ingress[];
}

export interface GetMaterializationsResponse {
  materializations: Materialization[];
  statuses: TaskSummary[];
  ingresses: Ingresses[];
}

export interface GetMaterializationRequest {
  project: string;
  experiment: string;
  realization: string;
}

export interface GetMaterializationResponse {
  materialization: Materialization | undefined;
  status: TaskSummary | undefined;
  ingresses: Ingresses | undefined;
}

export interface GetMaterializationStatusRequest {
  project: string;
  experiment: string;
  realization: string;
}

export interface GetMaterializationStatusResponse {
  status: TaskForest | undefined;
}

export interface MaterializeRequest {
  project: string;
  experiment: string;
  realization: string;
  ver: number;
}

export interface MaterializeResponse {
  materialization: Materialization | undefined;
}

export interface DematerializeRequest {
  project: string;
  experiment: string;
  realization: string;
}

export interface DematerializeResponse {
}

export interface NewIngressRequest {
  project: string;
  experiment: string;
  realization: string;
  protocol: Protocol;
  host: string;
  port: number;
}

/** Should return the created ingress, but we have two async systems to route this message through... */
export interface NewIngressResponse {
}

export interface DeleteIngressRequest {
  project: string;
  experiment: string;
  realization: string;
  protocol: Protocol;
  host: string;
  port: number;
}

/** Should return the created ingress, but we have two async systems to route this message through... */
export interface DeleteIngressResponse {
}

function createBaseMzParameters(): MzParameters {
  return {
    infrapodServer: "",
    infrapodPhy: "",
    infranetAddr: "",
    infranetSubnet: "",
    infranetGw: "",
    infranetVni: 0,
    resolveExpnet: false,
  };
}

export const MzParameters = {
  encode(message: MzParameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.infrapodServer !== "") {
      writer.uint32(10).string(message.infrapodServer);
    }
    if (message.infrapodPhy !== "") {
      writer.uint32(18).string(message.infrapodPhy);
    }
    if (message.infranetAddr !== "") {
      writer.uint32(26).string(message.infranetAddr);
    }
    if (message.infranetSubnet !== "") {
      writer.uint32(34).string(message.infranetSubnet);
    }
    if (message.infranetGw !== "") {
      writer.uint32(42).string(message.infranetGw);
    }
    if (message.infranetVni !== 0) {
      writer.uint32(48).uint32(message.infranetVni);
    }
    if (message.resolveExpnet === true) {
      writer.uint32(56).bool(message.resolveExpnet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MzParameters {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMzParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.infrapodServer = reader.string();
          break;
        case 2:
          message.infrapodPhy = reader.string();
          break;
        case 3:
          message.infranetAddr = reader.string();
          break;
        case 4:
          message.infranetSubnet = reader.string();
          break;
        case 5:
          message.infranetGw = reader.string();
          break;
        case 6:
          message.infranetVni = reader.uint32();
          break;
        case 7:
          message.resolveExpnet = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MzParameters {
    return {
      infrapodServer: isSet(object.infrapodServer) ? String(object.infrapodServer) : "",
      infrapodPhy: isSet(object.infrapodPhy) ? String(object.infrapodPhy) : "",
      infranetAddr: isSet(object.infranetAddr) ? String(object.infranetAddr) : "",
      infranetSubnet: isSet(object.infranetSubnet) ? String(object.infranetSubnet) : "",
      infranetGw: isSet(object.infranetGw) ? String(object.infranetGw) : "",
      infranetVni: isSet(object.infranetVni) ? Number(object.infranetVni) : 0,
      resolveExpnet: isSet(object.resolveExpnet) ? Boolean(object.resolveExpnet) : false,
    };
  },

  toJSON(message: MzParameters): unknown {
    const obj: any = {};
    message.infrapodServer !== undefined && (obj.infrapodServer = message.infrapodServer);
    message.infrapodPhy !== undefined && (obj.infrapodPhy = message.infrapodPhy);
    message.infranetAddr !== undefined && (obj.infranetAddr = message.infranetAddr);
    message.infranetSubnet !== undefined && (obj.infranetSubnet = message.infranetSubnet);
    message.infranetGw !== undefined && (obj.infranetGw = message.infranetGw);
    message.infranetVni !== undefined && (obj.infranetVni = Math.round(message.infranetVni));
    message.resolveExpnet !== undefined && (obj.resolveExpnet = message.resolveExpnet);
    return obj;
  },

  create<I extends Exact<DeepPartial<MzParameters>, I>>(base?: I): MzParameters {
    return MzParameters.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<MzParameters>, I>>(object: I): MzParameters {
    const message = createBaseMzParameters();
    message.infrapodServer = object.infrapodServer ?? "";
    message.infrapodPhy = object.infrapodPhy ?? "";
    message.infranetAddr = object.infranetAddr ?? "";
    message.infranetSubnet = object.infranetSubnet ?? "";
    message.infranetGw = object.infranetGw ?? "";
    message.infranetVni = object.infranetVni ?? 0;
    message.resolveExpnet = object.resolveExpnet ?? false;
    return message;
  },
};

function createBaseMaterialization(): Materialization {
  return {
    rid: "",
    eid: "",
    pid: "",
    params: undefined,
    metal: [],
    vms: [],
    links: [],
    phyos: [],
    bonds: [],
    sensors: [],
    actuators: [],
    linkEmulation: undefined,
  };
}

export const Materialization = {
  encode(message: Materialization, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rid !== "") {
      writer.uint32(10).string(message.rid);
    }
    if (message.eid !== "") {
      writer.uint32(18).string(message.eid);
    }
    if (message.pid !== "") {
      writer.uint32(26).string(message.pid);
    }
    if (message.params !== undefined) {
      MzParameters.encode(message.params, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.metal) {
      BareMetal.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.vms) {
      VirtualMachine.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.links) {
      Link.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.phyos) {
      Phyo.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.bonds) {
      Bond.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.sensors) {
      Sensor.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    for (const v of message.actuators) {
      Actuator.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    if (message.linkEmulation !== undefined) {
      LinkEmulationParams.encode(message.linkEmulation, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Materialization {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaterialization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rid = reader.string();
          break;
        case 2:
          message.eid = reader.string();
          break;
        case 3:
          message.pid = reader.string();
          break;
        case 4:
          message.params = MzParameters.decode(reader, reader.uint32());
          break;
        case 5:
          message.metal.push(BareMetal.decode(reader, reader.uint32()));
          break;
        case 6:
          message.vms.push(VirtualMachine.decode(reader, reader.uint32()));
          break;
        case 7:
          message.links.push(Link.decode(reader, reader.uint32()));
          break;
        case 8:
          message.phyos.push(Phyo.decode(reader, reader.uint32()));
          break;
        case 9:
          message.bonds.push(Bond.decode(reader, reader.uint32()));
          break;
        case 10:
          message.sensors.push(Sensor.decode(reader, reader.uint32()));
          break;
        case 11:
          message.actuators.push(Actuator.decode(reader, reader.uint32()));
          break;
        case 12:
          message.linkEmulation = LinkEmulationParams.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Materialization {
    return {
      rid: isSet(object.rid) ? String(object.rid) : "",
      eid: isSet(object.eid) ? String(object.eid) : "",
      pid: isSet(object.pid) ? String(object.pid) : "",
      params: isSet(object.params) ? MzParameters.fromJSON(object.params) : undefined,
      metal: Array.isArray(object?.metal) ? object.metal.map((e: any) => BareMetal.fromJSON(e)) : [],
      vms: Array.isArray(object?.vms) ? object.vms.map((e: any) => VirtualMachine.fromJSON(e)) : [],
      links: Array.isArray(object?.links) ? object.links.map((e: any) => Link.fromJSON(e)) : [],
      phyos: Array.isArray(object?.phyos) ? object.phyos.map((e: any) => Phyo.fromJSON(e)) : [],
      bonds: Array.isArray(object?.bonds) ? object.bonds.map((e: any) => Bond.fromJSON(e)) : [],
      sensors: Array.isArray(object?.sensors) ? object.sensors.map((e: any) => Sensor.fromJSON(e)) : [],
      actuators: Array.isArray(object?.actuators) ? object.actuators.map((e: any) => Actuator.fromJSON(e)) : [],
      linkEmulation: isSet(object.linkEmulation) ? LinkEmulationParams.fromJSON(object.linkEmulation) : undefined,
    };
  },

  toJSON(message: Materialization): unknown {
    const obj: any = {};
    message.rid !== undefined && (obj.rid = message.rid);
    message.eid !== undefined && (obj.eid = message.eid);
    message.pid !== undefined && (obj.pid = message.pid);
    message.params !== undefined && (obj.params = message.params ? MzParameters.toJSON(message.params) : undefined);
    if (message.metal) {
      obj.metal = message.metal.map((e) => e ? BareMetal.toJSON(e) : undefined);
    } else {
      obj.metal = [];
    }
    if (message.vms) {
      obj.vms = message.vms.map((e) => e ? VirtualMachine.toJSON(e) : undefined);
    } else {
      obj.vms = [];
    }
    if (message.links) {
      obj.links = message.links.map((e) => e ? Link.toJSON(e) : undefined);
    } else {
      obj.links = [];
    }
    if (message.phyos) {
      obj.phyos = message.phyos.map((e) => e ? Phyo.toJSON(e) : undefined);
    } else {
      obj.phyos = [];
    }
    if (message.bonds) {
      obj.bonds = message.bonds.map((e) => e ? Bond.toJSON(e) : undefined);
    } else {
      obj.bonds = [];
    }
    if (message.sensors) {
      obj.sensors = message.sensors.map((e) => e ? Sensor.toJSON(e) : undefined);
    } else {
      obj.sensors = [];
    }
    if (message.actuators) {
      obj.actuators = message.actuators.map((e) => e ? Actuator.toJSON(e) : undefined);
    } else {
      obj.actuators = [];
    }
    message.linkEmulation !== undefined &&
      (obj.linkEmulation = message.linkEmulation ? LinkEmulationParams.toJSON(message.linkEmulation) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Materialization>, I>>(base?: I): Materialization {
    return Materialization.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Materialization>, I>>(object: I): Materialization {
    const message = createBaseMaterialization();
    message.rid = object.rid ?? "";
    message.eid = object.eid ?? "";
    message.pid = object.pid ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? MzParameters.fromPartial(object.params)
      : undefined;
    message.metal = object.metal?.map((e) => BareMetal.fromPartial(e)) || [];
    message.vms = object.vms?.map((e) => VirtualMachine.fromPartial(e)) || [];
    message.links = object.links?.map((e) => Link.fromPartial(e)) || [];
    message.phyos = object.phyos?.map((e) => Phyo.fromPartial(e)) || [];
    message.bonds = object.bonds?.map((e) => Bond.fromPartial(e)) || [];
    message.sensors = object.sensors?.map((e) => Sensor.fromPartial(e)) || [];
    message.actuators = object.actuators?.map((e) => Actuator.fromPartial(e)) || [];
    message.linkEmulation = (object.linkEmulation !== undefined && object.linkEmulation !== null)
      ? LinkEmulationParams.fromPartial(object.linkEmulation)
      : undefined;
    return message;
  },
};

function createBaseUserInfo(): UserInfo {
  return { name: "", groups: [], pubkeys: [], privkeys: [] };
}

export const UserInfo = {
  encode(message: UserInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.groups) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.pubkeys) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.privkeys) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.groups.push(reader.string());
          break;
        case 3:
          message.pubkeys.push(reader.string());
          break;
        case 4:
          message.privkeys.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      groups: Array.isArray(object?.groups) ? object.groups.map((e: any) => String(e)) : [],
      pubkeys: Array.isArray(object?.pubkeys) ? object.pubkeys.map((e: any) => String(e)) : [],
      privkeys: Array.isArray(object?.privkeys) ? object.privkeys.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    if (message.groups) {
      obj.groups = message.groups.map((e) => e);
    } else {
      obj.groups = [];
    }
    if (message.pubkeys) {
      obj.pubkeys = message.pubkeys.map((e) => e);
    } else {
      obj.pubkeys = [];
    }
    if (message.privkeys) {
      obj.privkeys = message.privkeys.map((e) => e);
    } else {
      obj.privkeys = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfo>, I>>(base?: I): UserInfo {
    return UserInfo.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UserInfo>, I>>(object: I): UserInfo {
    const message = createBaseUserInfo();
    message.name = object.name ?? "";
    message.groups = object.groups?.map((e) => e) || [];
    message.pubkeys = object.pubkeys?.map((e) => e) || [];
    message.privkeys = object.privkeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseBareMetal(): BareMetal {
  return {
    facility: "",
    resource: "",
    model: undefined,
    users: [],
    inframac: "",
    infravid: 0,
    infraport: "",
    infranetAddr: "",
    rootdev: "",
  };
}

export const BareMetal = {
  encode(message: BareMetal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.facility !== "") {
      writer.uint32(10).string(message.facility);
    }
    if (message.resource !== "") {
      writer.uint32(18).string(message.resource);
    }
    if (message.model !== undefined) {
      Node.encode(message.model, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.users) {
      UserInfo.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.inframac !== "") {
      writer.uint32(42).string(message.inframac);
    }
    if (message.infravid !== 0) {
      writer.uint32(48).uint32(message.infravid);
    }
    if (message.infraport !== "") {
      writer.uint32(58).string(message.infraport);
    }
    if (message.infranetAddr !== "") {
      writer.uint32(66).string(message.infranetAddr);
    }
    if (message.rootdev !== "") {
      writer.uint32(74).string(message.rootdev);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BareMetal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBareMetal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.facility = reader.string();
          break;
        case 2:
          message.resource = reader.string();
          break;
        case 3:
          message.model = Node.decode(reader, reader.uint32());
          break;
        case 4:
          message.users.push(UserInfo.decode(reader, reader.uint32()));
          break;
        case 5:
          message.inframac = reader.string();
          break;
        case 6:
          message.infravid = reader.uint32();
          break;
        case 7:
          message.infraport = reader.string();
          break;
        case 8:
          message.infranetAddr = reader.string();
          break;
        case 9:
          message.rootdev = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BareMetal {
    return {
      facility: isSet(object.facility) ? String(object.facility) : "",
      resource: isSet(object.resource) ? String(object.resource) : "",
      model: isSet(object.model) ? Node.fromJSON(object.model) : undefined,
      users: Array.isArray(object?.users) ? object.users.map((e: any) => UserInfo.fromJSON(e)) : [],
      inframac: isSet(object.inframac) ? String(object.inframac) : "",
      infravid: isSet(object.infravid) ? Number(object.infravid) : 0,
      infraport: isSet(object.infraport) ? String(object.infraport) : "",
      infranetAddr: isSet(object.infranetAddr) ? String(object.infranetAddr) : "",
      rootdev: isSet(object.rootdev) ? String(object.rootdev) : "",
    };
  },

  toJSON(message: BareMetal): unknown {
    const obj: any = {};
    message.facility !== undefined && (obj.facility = message.facility);
    message.resource !== undefined && (obj.resource = message.resource);
    message.model !== undefined && (obj.model = message.model ? Node.toJSON(message.model) : undefined);
    if (message.users) {
      obj.users = message.users.map((e) => e ? UserInfo.toJSON(e) : undefined);
    } else {
      obj.users = [];
    }
    message.inframac !== undefined && (obj.inframac = message.inframac);
    message.infravid !== undefined && (obj.infravid = Math.round(message.infravid));
    message.infraport !== undefined && (obj.infraport = message.infraport);
    message.infranetAddr !== undefined && (obj.infranetAddr = message.infranetAddr);
    message.rootdev !== undefined && (obj.rootdev = message.rootdev);
    return obj;
  },

  create<I extends Exact<DeepPartial<BareMetal>, I>>(base?: I): BareMetal {
    return BareMetal.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<BareMetal>, I>>(object: I): BareMetal {
    const message = createBaseBareMetal();
    message.facility = object.facility ?? "";
    message.resource = object.resource ?? "";
    message.model = (object.model !== undefined && object.model !== null) ? Node.fromPartial(object.model) : undefined;
    message.users = object.users?.map((e) => UserInfo.fromPartial(e)) || [];
    message.inframac = object.inframac ?? "";
    message.infravid = object.infravid ?? 0;
    message.infraport = object.infraport ?? "";
    message.infranetAddr = object.infranetAddr ?? "";
    message.rootdev = object.rootdev ?? "";
    return message;
  },
};

function createBaseVirtualMachine(): VirtualMachine {
  return { vmAlloc: undefined, users: [], inframac: "", infranetAddr: "" };
}

export const VirtualMachine = {
  encode(message: VirtualMachine, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.vmAlloc !== undefined) {
      ResourceAllocation.encode(message.vmAlloc, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.users) {
      UserInfo.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.inframac !== "") {
      writer.uint32(26).string(message.inframac);
    }
    if (message.infranetAddr !== "") {
      writer.uint32(34).string(message.infranetAddr);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VirtualMachine {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualMachine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.vmAlloc = ResourceAllocation.decode(reader, reader.uint32());
          break;
        case 2:
          message.users.push(UserInfo.decode(reader, reader.uint32()));
          break;
        case 3:
          message.inframac = reader.string();
          break;
        case 4:
          message.infranetAddr = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): VirtualMachine {
    return {
      vmAlloc: isSet(object.vmAlloc) ? ResourceAllocation.fromJSON(object.vmAlloc) : undefined,
      users: Array.isArray(object?.users) ? object.users.map((e: any) => UserInfo.fromJSON(e)) : [],
      inframac: isSet(object.inframac) ? String(object.inframac) : "",
      infranetAddr: isSet(object.infranetAddr) ? String(object.infranetAddr) : "",
    };
  },

  toJSON(message: VirtualMachine): unknown {
    const obj: any = {};
    message.vmAlloc !== undefined &&
      (obj.vmAlloc = message.vmAlloc ? ResourceAllocation.toJSON(message.vmAlloc) : undefined);
    if (message.users) {
      obj.users = message.users.map((e) => e ? UserInfo.toJSON(e) : undefined);
    } else {
      obj.users = [];
    }
    message.inframac !== undefined && (obj.inframac = message.inframac);
    message.infranetAddr !== undefined && (obj.infranetAddr = message.infranetAddr);
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualMachine>, I>>(base?: I): VirtualMachine {
    return VirtualMachine.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<VirtualMachine>, I>>(object: I): VirtualMachine {
    const message = createBaseVirtualMachine();
    message.vmAlloc = (object.vmAlloc !== undefined && object.vmAlloc !== null)
      ? ResourceAllocation.fromPartial(object.vmAlloc)
      : undefined;
    message.users = object.users?.map((e) => UserInfo.fromPartial(e)) || [];
    message.inframac = object.inframac ?? "";
    message.infranetAddr = object.infranetAddr ?? "";
    return message;
  },
};

function createBaseLink(): Link {
  return { realization: undefined };
}

export const Link = {
  encode(message: Link, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.realization !== undefined) {
      LinkRealization.encode(message.realization, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Link {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.realization = LinkRealization.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Link {
    return { realization: isSet(object.realization) ? LinkRealization.fromJSON(object.realization) : undefined };
  },

  toJSON(message: Link): unknown {
    const obj: any = {};
    message.realization !== undefined &&
      (obj.realization = message.realization ? LinkRealization.toJSON(message.realization) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Link>, I>>(base?: I): Link {
    return Link.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Link>, I>>(object: I): Link {
    const message = createBaseLink();
    message.realization = (object.realization !== undefined && object.realization !== null)
      ? LinkRealization.fromPartial(object.realization)
      : undefined;
    return message;
  },
};

function createBasePhyo(): Phyo {
  return { realization: undefined, model: undefined };
}

export const Phyo = {
  encode(message: Phyo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.realization !== undefined) {
      PhyoRealization.encode(message.realization, writer.uint32(10).fork()).ldelim();
    }
    if (message.model !== undefined) {
      Phyo1.encode(message.model, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Phyo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhyo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.realization = PhyoRealization.decode(reader, reader.uint32());
          break;
        case 2:
          message.model = Phyo1.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Phyo {
    return {
      realization: isSet(object.realization) ? PhyoRealization.fromJSON(object.realization) : undefined,
      model: isSet(object.model) ? Phyo1.fromJSON(object.model) : undefined,
    };
  },

  toJSON(message: Phyo): unknown {
    const obj: any = {};
    message.realization !== undefined &&
      (obj.realization = message.realization ? PhyoRealization.toJSON(message.realization) : undefined);
    message.model !== undefined && (obj.model = message.model ? Phyo1.toJSON(message.model) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Phyo>, I>>(base?: I): Phyo {
    return Phyo.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Phyo>, I>>(object: I): Phyo {
    const message = createBasePhyo();
    message.realization = (object.realization !== undefined && object.realization !== null)
      ? PhyoRealization.fromPartial(object.realization)
      : undefined;
    message.model = (object.model !== undefined && object.model !== null) ? Phyo1.fromPartial(object.model) : undefined;
    return message;
  },
};

function createBaseSensor(): Sensor {
  return { realization: undefined, model: undefined };
}

export const Sensor = {
  encode(message: Sensor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.realization !== undefined) {
      SensorRealization.encode(message.realization, writer.uint32(10).fork()).ldelim();
    }
    if (message.model !== undefined) {
      Sensor2.encode(message.model, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Sensor {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSensor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.realization = SensorRealization.decode(reader, reader.uint32());
          break;
        case 2:
          message.model = Sensor2.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Sensor {
    return {
      realization: isSet(object.realization) ? SensorRealization.fromJSON(object.realization) : undefined,
      model: isSet(object.model) ? Sensor2.fromJSON(object.model) : undefined,
    };
  },

  toJSON(message: Sensor): unknown {
    const obj: any = {};
    message.realization !== undefined &&
      (obj.realization = message.realization ? SensorRealization.toJSON(message.realization) : undefined);
    message.model !== undefined && (obj.model = message.model ? Sensor2.toJSON(message.model) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Sensor>, I>>(base?: I): Sensor {
    return Sensor.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Sensor>, I>>(object: I): Sensor {
    const message = createBaseSensor();
    message.realization = (object.realization !== undefined && object.realization !== null)
      ? SensorRealization.fromPartial(object.realization)
      : undefined;
    message.model = (object.model !== undefined && object.model !== null)
      ? Sensor2.fromPartial(object.model)
      : undefined;
    return message;
  },
};

function createBaseBond(): Bond {
  return { realization: undefined, model: undefined };
}

export const Bond = {
  encode(message: Bond, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.realization !== undefined) {
      BondRealization.encode(message.realization, writer.uint32(10).fork()).ldelim();
    }
    if (message.model !== undefined) {
      Bond3.encode(message.model, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bond {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBond();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.realization = BondRealization.decode(reader, reader.uint32());
          break;
        case 2:
          message.model = Bond3.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Bond {
    return {
      realization: isSet(object.realization) ? BondRealization.fromJSON(object.realization) : undefined,
      model: isSet(object.model) ? Bond3.fromJSON(object.model) : undefined,
    };
  },

  toJSON(message: Bond): unknown {
    const obj: any = {};
    message.realization !== undefined &&
      (obj.realization = message.realization ? BondRealization.toJSON(message.realization) : undefined);
    message.model !== undefined && (obj.model = message.model ? Bond3.toJSON(message.model) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Bond>, I>>(base?: I): Bond {
    return Bond.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Bond>, I>>(object: I): Bond {
    const message = createBaseBond();
    message.realization = (object.realization !== undefined && object.realization !== null)
      ? BondRealization.fromPartial(object.realization)
      : undefined;
    message.model = (object.model !== undefined && object.model !== null) ? Bond3.fromPartial(object.model) : undefined;
    return message;
  },
};

function createBaseActuator(): Actuator {
  return { realization: undefined, model: undefined };
}

export const Actuator = {
  encode(message: Actuator, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.realization !== undefined) {
      ActuatorRealization.encode(message.realization, writer.uint32(10).fork()).ldelim();
    }
    if (message.model !== undefined) {
      Actuator4.encode(message.model, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Actuator {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActuator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.realization = ActuatorRealization.decode(reader, reader.uint32());
          break;
        case 2:
          message.model = Actuator4.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Actuator {
    return {
      realization: isSet(object.realization) ? ActuatorRealization.fromJSON(object.realization) : undefined,
      model: isSet(object.model) ? Actuator4.fromJSON(object.model) : undefined,
    };
  },

  toJSON(message: Actuator): unknown {
    const obj: any = {};
    message.realization !== undefined &&
      (obj.realization = message.realization ? ActuatorRealization.toJSON(message.realization) : undefined);
    message.model !== undefined && (obj.model = message.model ? Actuator4.toJSON(message.model) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Actuator>, I>>(base?: I): Actuator {
    return Actuator.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Actuator>, I>>(object: I): Actuator {
    const message = createBaseActuator();
    message.realization = (object.realization !== undefined && object.realization !== null)
      ? ActuatorRealization.fromPartial(object.realization)
      : undefined;
    message.model = (object.model !== undefined && object.model !== null)
      ? Actuator4.fromPartial(object.model)
      : undefined;
    return message;
  },
};

function createBaseRebootMaterializationRequest(): RebootMaterializationRequest {
  return { mode: 0, project: "", experiment: "", realization: "", hostnames: [], allNodes: false, ver: 0 };
}

export const RebootMaterializationRequest = {
  encode(message: RebootMaterializationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(26).string(message.experiment);
    }
    if (message.realization !== "") {
      writer.uint32(34).string(message.realization);
    }
    for (const v of message.hostnames) {
      writer.uint32(42).string(v!);
    }
    if (message.allNodes === true) {
      writer.uint32(48).bool(message.allNodes);
    }
    if (message.ver !== 0) {
      writer.uint32(56).int64(message.ver);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebootMaterializationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebootMaterializationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mode = reader.int32() as any;
          break;
        case 2:
          message.project = reader.string();
          break;
        case 3:
          message.experiment = reader.string();
          break;
        case 4:
          message.realization = reader.string();
          break;
        case 5:
          message.hostnames.push(reader.string());
          break;
        case 6:
          message.allNodes = reader.bool();
          break;
        case 7:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RebootMaterializationRequest {
    return {
      mode: isSet(object.mode) ? rebootMaterializationModeFromJSON(object.mode) : 0,
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      realization: isSet(object.realization) ? String(object.realization) : "",
      hostnames: Array.isArray(object?.hostnames) ? object.hostnames.map((e: any) => String(e)) : [],
      allNodes: isSet(object.allNodes) ? Boolean(object.allNodes) : false,
      ver: isSet(object.ver) ? Number(object.ver) : 0,
    };
  },

  toJSON(message: RebootMaterializationRequest): unknown {
    const obj: any = {};
    message.mode !== undefined && (obj.mode = rebootMaterializationModeToJSON(message.mode));
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.realization !== undefined && (obj.realization = message.realization);
    if (message.hostnames) {
      obj.hostnames = message.hostnames.map((e) => e);
    } else {
      obj.hostnames = [];
    }
    message.allNodes !== undefined && (obj.allNodes = message.allNodes);
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    return obj;
  },

  create<I extends Exact<DeepPartial<RebootMaterializationRequest>, I>>(base?: I): RebootMaterializationRequest {
    return RebootMaterializationRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RebootMaterializationRequest>, I>>(object: I): RebootMaterializationRequest {
    const message = createBaseRebootMaterializationRequest();
    message.mode = object.mode ?? 0;
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.realization = object.realization ?? "";
    message.hostnames = object.hostnames?.map((e) => e) || [];
    message.allNodes = object.allNodes ?? false;
    message.ver = object.ver ?? 0;
    return message;
  },
};

function createBaseRebootMaterializationResponse(): RebootMaterializationResponse {
  return {};
}

export const RebootMaterializationResponse = {
  encode(_: RebootMaterializationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RebootMaterializationResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRebootMaterializationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): RebootMaterializationResponse {
    return {};
  },

  toJSON(_: RebootMaterializationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RebootMaterializationResponse>, I>>(base?: I): RebootMaterializationResponse {
    return RebootMaterializationResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RebootMaterializationResponse>, I>>(_: I): RebootMaterializationResponse {
    const message = createBaseRebootMaterializationResponse();
    return message;
  },
};

function createBaseGetMaterializationsRequest(): GetMaterializationsRequest {
  return { project: "", experiment: "", filter: 0 };
}

export const GetMaterializationsRequest = {
  encode(message: GetMaterializationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(18).string(message.experiment);
    }
    if (message.filter !== 0) {
      writer.uint32(24).int32(message.filter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMaterializationsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMaterializationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.experiment = reader.string();
          break;
        case 3:
          message.filter = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMaterializationsRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      filter: isSet(object.filter) ? filterModeFromJSON(object.filter) : 0,
    };
  },

  toJSON(message: GetMaterializationsRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.filter !== undefined && (obj.filter = filterModeToJSON(message.filter));
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMaterializationsRequest>, I>>(base?: I): GetMaterializationsRequest {
    return GetMaterializationsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetMaterializationsRequest>, I>>(object: I): GetMaterializationsRequest {
    const message = createBaseGetMaterializationsRequest();
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.filter = object.filter ?? 0;
    return message;
  },
};

function createBaseIngress(): Ingress {
  return { mzid: "", protocol: "", hostname: "", hostport: 0, hostaddr: "", gateway: "", gatewayport: 0, ingress: "" };
}

export const Ingress = {
  encode(message: Ingress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mzid !== "") {
      writer.uint32(10).string(message.mzid);
    }
    if (message.protocol !== "") {
      writer.uint32(18).string(message.protocol);
    }
    if (message.hostname !== "") {
      writer.uint32(26).string(message.hostname);
    }
    if (message.hostport !== 0) {
      writer.uint32(32).uint32(message.hostport);
    }
    if (message.hostaddr !== "") {
      writer.uint32(42).string(message.hostaddr);
    }
    if (message.gateway !== "") {
      writer.uint32(50).string(message.gateway);
    }
    if (message.gatewayport !== 0) {
      writer.uint32(56).uint32(message.gatewayport);
    }
    if (message.ingress !== "") {
      writer.uint32(66).string(message.ingress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Ingress {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mzid = reader.string();
          break;
        case 2:
          message.protocol = reader.string();
          break;
        case 3:
          message.hostname = reader.string();
          break;
        case 4:
          message.hostport = reader.uint32();
          break;
        case 5:
          message.hostaddr = reader.string();
          break;
        case 6:
          message.gateway = reader.string();
          break;
        case 7:
          message.gatewayport = reader.uint32();
          break;
        case 8:
          message.ingress = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Ingress {
    return {
      mzid: isSet(object.mzid) ? String(object.mzid) : "",
      protocol: isSet(object.protocol) ? String(object.protocol) : "",
      hostname: isSet(object.hostname) ? String(object.hostname) : "",
      hostport: isSet(object.hostport) ? Number(object.hostport) : 0,
      hostaddr: isSet(object.hostaddr) ? String(object.hostaddr) : "",
      gateway: isSet(object.gateway) ? String(object.gateway) : "",
      gatewayport: isSet(object.gatewayport) ? Number(object.gatewayport) : 0,
      ingress: isSet(object.ingress) ? String(object.ingress) : "",
    };
  },

  toJSON(message: Ingress): unknown {
    const obj: any = {};
    message.mzid !== undefined && (obj.mzid = message.mzid);
    message.protocol !== undefined && (obj.protocol = message.protocol);
    message.hostname !== undefined && (obj.hostname = message.hostname);
    message.hostport !== undefined && (obj.hostport = Math.round(message.hostport));
    message.hostaddr !== undefined && (obj.hostaddr = message.hostaddr);
    message.gateway !== undefined && (obj.gateway = message.gateway);
    message.gatewayport !== undefined && (obj.gatewayport = Math.round(message.gatewayport));
    message.ingress !== undefined && (obj.ingress = message.ingress);
    return obj;
  },

  create<I extends Exact<DeepPartial<Ingress>, I>>(base?: I): Ingress {
    return Ingress.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Ingress>, I>>(object: I): Ingress {
    const message = createBaseIngress();
    message.mzid = object.mzid ?? "";
    message.protocol = object.protocol ?? "";
    message.hostname = object.hostname ?? "";
    message.hostport = object.hostport ?? 0;
    message.hostaddr = object.hostaddr ?? "";
    message.gateway = object.gateway ?? "";
    message.gatewayport = object.gatewayport ?? 0;
    message.ingress = object.ingress ?? "";
    return message;
  },
};

function createBaseIngresses(): Ingresses {
  return { ingresses: [] };
}

export const Ingresses = {
  encode(message: Ingresses, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ingresses) {
      Ingress.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Ingresses {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngresses();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ingresses.push(Ingress.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Ingresses {
    return { ingresses: Array.isArray(object?.ingresses) ? object.ingresses.map((e: any) => Ingress.fromJSON(e)) : [] };
  },

  toJSON(message: Ingresses): unknown {
    const obj: any = {};
    if (message.ingresses) {
      obj.ingresses = message.ingresses.map((e) => e ? Ingress.toJSON(e) : undefined);
    } else {
      obj.ingresses = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ingresses>, I>>(base?: I): Ingresses {
    return Ingresses.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Ingresses>, I>>(object: I): Ingresses {
    const message = createBaseIngresses();
    message.ingresses = object.ingresses?.map((e) => Ingress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetMaterializationsResponse(): GetMaterializationsResponse {
  return { materializations: [], statuses: [], ingresses: [] };
}

export const GetMaterializationsResponse = {
  encode(message: GetMaterializationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.materializations) {
      Materialization.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.statuses) {
      TaskSummary.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.ingresses) {
      Ingresses.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMaterializationsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMaterializationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.materializations.push(Materialization.decode(reader, reader.uint32()));
          break;
        case 2:
          message.statuses.push(TaskSummary.decode(reader, reader.uint32()));
          break;
        case 3:
          message.ingresses.push(Ingresses.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMaterializationsResponse {
    return {
      materializations: Array.isArray(object?.materializations)
        ? object.materializations.map((e: any) => Materialization.fromJSON(e))
        : [],
      statuses: Array.isArray(object?.statuses) ? object.statuses.map((e: any) => TaskSummary.fromJSON(e)) : [],
      ingresses: Array.isArray(object?.ingresses) ? object.ingresses.map((e: any) => Ingresses.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetMaterializationsResponse): unknown {
    const obj: any = {};
    if (message.materializations) {
      obj.materializations = message.materializations.map((e) => e ? Materialization.toJSON(e) : undefined);
    } else {
      obj.materializations = [];
    }
    if (message.statuses) {
      obj.statuses = message.statuses.map((e) => e ? TaskSummary.toJSON(e) : undefined);
    } else {
      obj.statuses = [];
    }
    if (message.ingresses) {
      obj.ingresses = message.ingresses.map((e) => e ? Ingresses.toJSON(e) : undefined);
    } else {
      obj.ingresses = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMaterializationsResponse>, I>>(base?: I): GetMaterializationsResponse {
    return GetMaterializationsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetMaterializationsResponse>, I>>(object: I): GetMaterializationsResponse {
    const message = createBaseGetMaterializationsResponse();
    message.materializations = object.materializations?.map((e) => Materialization.fromPartial(e)) || [];
    message.statuses = object.statuses?.map((e) => TaskSummary.fromPartial(e)) || [];
    message.ingresses = object.ingresses?.map((e) => Ingresses.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetMaterializationRequest(): GetMaterializationRequest {
  return { project: "", experiment: "", realization: "" };
}

export const GetMaterializationRequest = {
  encode(message: GetMaterializationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(18).string(message.experiment);
    }
    if (message.realization !== "") {
      writer.uint32(26).string(message.realization);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMaterializationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMaterializationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.experiment = reader.string();
          break;
        case 3:
          message.realization = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMaterializationRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      realization: isSet(object.realization) ? String(object.realization) : "",
    };
  },

  toJSON(message: GetMaterializationRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.realization !== undefined && (obj.realization = message.realization);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMaterializationRequest>, I>>(base?: I): GetMaterializationRequest {
    return GetMaterializationRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetMaterializationRequest>, I>>(object: I): GetMaterializationRequest {
    const message = createBaseGetMaterializationRequest();
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.realization = object.realization ?? "";
    return message;
  },
};

function createBaseGetMaterializationResponse(): GetMaterializationResponse {
  return { materialization: undefined, status: undefined, ingresses: undefined };
}

export const GetMaterializationResponse = {
  encode(message: GetMaterializationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.materialization !== undefined) {
      Materialization.encode(message.materialization, writer.uint32(10).fork()).ldelim();
    }
    if (message.status !== undefined) {
      TaskSummary.encode(message.status, writer.uint32(18).fork()).ldelim();
    }
    if (message.ingresses !== undefined) {
      Ingresses.encode(message.ingresses, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMaterializationResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMaterializationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.materialization = Materialization.decode(reader, reader.uint32());
          break;
        case 2:
          message.status = TaskSummary.decode(reader, reader.uint32());
          break;
        case 3:
          message.ingresses = Ingresses.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMaterializationResponse {
    return {
      materialization: isSet(object.materialization) ? Materialization.fromJSON(object.materialization) : undefined,
      status: isSet(object.status) ? TaskSummary.fromJSON(object.status) : undefined,
      ingresses: isSet(object.ingresses) ? Ingresses.fromJSON(object.ingresses) : undefined,
    };
  },

  toJSON(message: GetMaterializationResponse): unknown {
    const obj: any = {};
    message.materialization !== undefined &&
      (obj.materialization = message.materialization ? Materialization.toJSON(message.materialization) : undefined);
    message.status !== undefined && (obj.status = message.status ? TaskSummary.toJSON(message.status) : undefined);
    message.ingresses !== undefined &&
      (obj.ingresses = message.ingresses ? Ingresses.toJSON(message.ingresses) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMaterializationResponse>, I>>(base?: I): GetMaterializationResponse {
    return GetMaterializationResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetMaterializationResponse>, I>>(object: I): GetMaterializationResponse {
    const message = createBaseGetMaterializationResponse();
    message.materialization = (object.materialization !== undefined && object.materialization !== null)
      ? Materialization.fromPartial(object.materialization)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? TaskSummary.fromPartial(object.status)
      : undefined;
    message.ingresses = (object.ingresses !== undefined && object.ingresses !== null)
      ? Ingresses.fromPartial(object.ingresses)
      : undefined;
    return message;
  },
};

function createBaseGetMaterializationStatusRequest(): GetMaterializationStatusRequest {
  return { project: "", experiment: "", realization: "" };
}

export const GetMaterializationStatusRequest = {
  encode(message: GetMaterializationStatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(18).string(message.experiment);
    }
    if (message.realization !== "") {
      writer.uint32(26).string(message.realization);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMaterializationStatusRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMaterializationStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.experiment = reader.string();
          break;
        case 3:
          message.realization = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMaterializationStatusRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      realization: isSet(object.realization) ? String(object.realization) : "",
    };
  },

  toJSON(message: GetMaterializationStatusRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.realization !== undefined && (obj.realization = message.realization);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMaterializationStatusRequest>, I>>(base?: I): GetMaterializationStatusRequest {
    return GetMaterializationStatusRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetMaterializationStatusRequest>, I>>(
    object: I,
  ): GetMaterializationStatusRequest {
    const message = createBaseGetMaterializationStatusRequest();
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.realization = object.realization ?? "";
    return message;
  },
};

function createBaseGetMaterializationStatusResponse(): GetMaterializationStatusResponse {
  return { status: undefined };
}

export const GetMaterializationStatusResponse = {
  encode(message: GetMaterializationStatusResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== undefined) {
      TaskForest.encode(message.status, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMaterializationStatusResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMaterializationStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.status = TaskForest.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMaterializationStatusResponse {
    return { status: isSet(object.status) ? TaskForest.fromJSON(object.status) : undefined };
  },

  toJSON(message: GetMaterializationStatusResponse): unknown {
    const obj: any = {};
    message.status !== undefined && (obj.status = message.status ? TaskForest.toJSON(message.status) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetMaterializationStatusResponse>, I>>(
    base?: I,
  ): GetMaterializationStatusResponse {
    return GetMaterializationStatusResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetMaterializationStatusResponse>, I>>(
    object: I,
  ): GetMaterializationStatusResponse {
    const message = createBaseGetMaterializationStatusResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? TaskForest.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseMaterializeRequest(): MaterializeRequest {
  return { project: "", experiment: "", realization: "", ver: 0 };
}

export const MaterializeRequest = {
  encode(message: MaterializeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(18).string(message.experiment);
    }
    if (message.realization !== "") {
      writer.uint32(26).string(message.realization);
    }
    if (message.ver !== 0) {
      writer.uint32(32).int64(message.ver);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MaterializeRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaterializeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.experiment = reader.string();
          break;
        case 3:
          message.realization = reader.string();
          break;
        case 4:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MaterializeRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      realization: isSet(object.realization) ? String(object.realization) : "",
      ver: isSet(object.ver) ? Number(object.ver) : 0,
    };
  },

  toJSON(message: MaterializeRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.realization !== undefined && (obj.realization = message.realization);
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    return obj;
  },

  create<I extends Exact<DeepPartial<MaterializeRequest>, I>>(base?: I): MaterializeRequest {
    return MaterializeRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<MaterializeRequest>, I>>(object: I): MaterializeRequest {
    const message = createBaseMaterializeRequest();
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.realization = object.realization ?? "";
    message.ver = object.ver ?? 0;
    return message;
  },
};

function createBaseMaterializeResponse(): MaterializeResponse {
  return { materialization: undefined };
}

export const MaterializeResponse = {
  encode(message: MaterializeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.materialization !== undefined) {
      Materialization.encode(message.materialization, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MaterializeResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaterializeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.materialization = Materialization.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MaterializeResponse {
    return {
      materialization: isSet(object.materialization) ? Materialization.fromJSON(object.materialization) : undefined,
    };
  },

  toJSON(message: MaterializeResponse): unknown {
    const obj: any = {};
    message.materialization !== undefined &&
      (obj.materialization = message.materialization ? Materialization.toJSON(message.materialization) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<MaterializeResponse>, I>>(base?: I): MaterializeResponse {
    return MaterializeResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<MaterializeResponse>, I>>(object: I): MaterializeResponse {
    const message = createBaseMaterializeResponse();
    message.materialization = (object.materialization !== undefined && object.materialization !== null)
      ? Materialization.fromPartial(object.materialization)
      : undefined;
    return message;
  },
};

function createBaseDematerializeRequest(): DematerializeRequest {
  return { project: "", experiment: "", realization: "" };
}

export const DematerializeRequest = {
  encode(message: DematerializeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(18).string(message.experiment);
    }
    if (message.realization !== "") {
      writer.uint32(26).string(message.realization);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DematerializeRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDematerializeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.experiment = reader.string();
          break;
        case 3:
          message.realization = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DematerializeRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      realization: isSet(object.realization) ? String(object.realization) : "",
    };
  },

  toJSON(message: DematerializeRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.realization !== undefined && (obj.realization = message.realization);
    return obj;
  },

  create<I extends Exact<DeepPartial<DematerializeRequest>, I>>(base?: I): DematerializeRequest {
    return DematerializeRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DematerializeRequest>, I>>(object: I): DematerializeRequest {
    const message = createBaseDematerializeRequest();
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.realization = object.realization ?? "";
    return message;
  },
};

function createBaseDematerializeResponse(): DematerializeResponse {
  return {};
}

export const DematerializeResponse = {
  encode(_: DematerializeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DematerializeResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDematerializeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DematerializeResponse {
    return {};
  },

  toJSON(_: DematerializeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DematerializeResponse>, I>>(base?: I): DematerializeResponse {
    return DematerializeResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DematerializeResponse>, I>>(_: I): DematerializeResponse {
    const message = createBaseDematerializeResponse();
    return message;
  },
};

function createBaseNewIngressRequest(): NewIngressRequest {
  return { project: "", experiment: "", realization: "", protocol: 0, host: "", port: 0 };
}

export const NewIngressRequest = {
  encode(message: NewIngressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(18).string(message.experiment);
    }
    if (message.realization !== "") {
      writer.uint32(26).string(message.realization);
    }
    if (message.protocol !== 0) {
      writer.uint32(32).int32(message.protocol);
    }
    if (message.host !== "") {
      writer.uint32(42).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(48).uint32(message.port);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NewIngressRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewIngressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.experiment = reader.string();
          break;
        case 3:
          message.realization = reader.string();
          break;
        case 4:
          message.protocol = reader.int32() as any;
          break;
        case 5:
          message.host = reader.string();
          break;
        case 6:
          message.port = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NewIngressRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      realization: isSet(object.realization) ? String(object.realization) : "",
      protocol: isSet(object.protocol) ? protocolFromJSON(object.protocol) : 0,
      host: isSet(object.host) ? String(object.host) : "",
      port: isSet(object.port) ? Number(object.port) : 0,
    };
  },

  toJSON(message: NewIngressRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.realization !== undefined && (obj.realization = message.realization);
    message.protocol !== undefined && (obj.protocol = protocolToJSON(message.protocol));
    message.host !== undefined && (obj.host = message.host);
    message.port !== undefined && (obj.port = Math.round(message.port));
    return obj;
  },

  create<I extends Exact<DeepPartial<NewIngressRequest>, I>>(base?: I): NewIngressRequest {
    return NewIngressRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<NewIngressRequest>, I>>(object: I): NewIngressRequest {
    const message = createBaseNewIngressRequest();
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.realization = object.realization ?? "";
    message.protocol = object.protocol ?? 0;
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseNewIngressResponse(): NewIngressResponse {
  return {};
}

export const NewIngressResponse = {
  encode(_: NewIngressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NewIngressResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewIngressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): NewIngressResponse {
    return {};
  },

  toJSON(_: NewIngressResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NewIngressResponse>, I>>(base?: I): NewIngressResponse {
    return NewIngressResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<NewIngressResponse>, I>>(_: I): NewIngressResponse {
    const message = createBaseNewIngressResponse();
    return message;
  },
};

function createBaseDeleteIngressRequest(): DeleteIngressRequest {
  return { project: "", experiment: "", realization: "", protocol: 0, host: "", port: 0 };
}

export const DeleteIngressRequest = {
  encode(message: DeleteIngressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(18).string(message.experiment);
    }
    if (message.realization !== "") {
      writer.uint32(26).string(message.realization);
    }
    if (message.protocol !== 0) {
      writer.uint32(32).int32(message.protocol);
    }
    if (message.host !== "") {
      writer.uint32(42).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(48).uint32(message.port);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteIngressRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteIngressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.experiment = reader.string();
          break;
        case 3:
          message.realization = reader.string();
          break;
        case 4:
          message.protocol = reader.int32() as any;
          break;
        case 5:
          message.host = reader.string();
          break;
        case 6:
          message.port = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteIngressRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      realization: isSet(object.realization) ? String(object.realization) : "",
      protocol: isSet(object.protocol) ? protocolFromJSON(object.protocol) : 0,
      host: isSet(object.host) ? String(object.host) : "",
      port: isSet(object.port) ? Number(object.port) : 0,
    };
  },

  toJSON(message: DeleteIngressRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.realization !== undefined && (obj.realization = message.realization);
    message.protocol !== undefined && (obj.protocol = protocolToJSON(message.protocol));
    message.host !== undefined && (obj.host = message.host);
    message.port !== undefined && (obj.port = Math.round(message.port));
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteIngressRequest>, I>>(base?: I): DeleteIngressRequest {
    return DeleteIngressRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteIngressRequest>, I>>(object: I): DeleteIngressRequest {
    const message = createBaseDeleteIngressRequest();
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.realization = object.realization ?? "";
    message.protocol = object.protocol ?? 0;
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseDeleteIngressResponse(): DeleteIngressResponse {
  return {};
}

export const DeleteIngressResponse = {
  encode(_: DeleteIngressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteIngressResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteIngressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteIngressResponse {
    return {};
  },

  toJSON(_: DeleteIngressResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteIngressResponse>, I>>(base?: I): DeleteIngressResponse {
    return DeleteIngressResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteIngressResponse>, I>>(_: I): DeleteIngressResponse {
    const message = createBaseDeleteIngressResponse();
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
