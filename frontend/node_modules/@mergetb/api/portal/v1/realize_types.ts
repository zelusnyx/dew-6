/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../google/protobuf/timestamp";
import {
  Emulation,
  emulationFromJSON,
  emulationToJSON,
  Link,
  Node,
  Resource as Resource1,
  ResourceAllocation,
} from "../../mergetb/xir/v0.3/core";
import { CountSet } from "./internal";
import { FilterMode, filterModeFromJSON, filterModeToJSON } from "./workspace_types";

export const protobufPackage = "portal.v1";

export enum DiagnosticLevel {
  DiagUnspec = 0,
  Error = 1,
  Warning = 2,
  Info = 3,
  Debug = 4,
  Trace = 5,
  UNRECOGNIZED = -1,
}

export function diagnosticLevelFromJSON(object: any): DiagnosticLevel {
  switch (object) {
    case 0:
    case "DiagUnspec":
      return DiagnosticLevel.DiagUnspec;
    case 1:
    case "Error":
      return DiagnosticLevel.Error;
    case 2:
    case "Warning":
      return DiagnosticLevel.Warning;
    case 3:
    case "Info":
      return DiagnosticLevel.Info;
    case 4:
    case "Debug":
      return DiagnosticLevel.Debug;
    case 5:
    case "Trace":
      return DiagnosticLevel.Trace;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DiagnosticLevel.UNRECOGNIZED;
  }
}

export function diagnosticLevelToJSON(object: DiagnosticLevel): string {
  switch (object) {
    case DiagnosticLevel.DiagUnspec:
      return "DiagUnspec";
    case DiagnosticLevel.Error:
      return "Error";
    case DiagnosticLevel.Warning:
      return "Warning";
    case DiagnosticLevel.Info:
      return "Info";
    case DiagnosticLevel.Debug:
      return "Debug";
    case DiagnosticLevel.Trace:
      return "Trace";
    case DiagnosticLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Realization {
  complete: boolean;
  id: string;
  eid: string;
  pid: string;
  xhash: string;
  nodes: { [key: string]: NodeRealization };
  links: { [key: string]: LinkRealization };
  phyos: { [key: string]: PhyoRealization };
  sensors: { [key: string]: SensorRealization };
  actuators: { [key: string]: ActuatorRealization };
  bonds: { [key: string]: BondRealization };
  infranet: InfranetEmbedding | undefined;
  creator: string;
  ver: number;
  linkEmulation: LinkEmulationParams | undefined;
  created: Date | undefined;
  expires: Date | undefined;
}

export interface Realization_NodesEntry {
  key: string;
  value: NodeRealization | undefined;
}

export interface Realization_LinksEntry {
  key: string;
  value: LinkRealization | undefined;
}

export interface Realization_PhyosEntry {
  key: string;
  value: PhyoRealization | undefined;
}

export interface Realization_SensorsEntry {
  key: string;
  value: SensorRealization | undefined;
}

export interface Realization_ActuatorsEntry {
  key: string;
  value: ActuatorRealization | undefined;
}

export interface Realization_BondsEntry {
  key: string;
  value: BondRealization | undefined;
}

export interface InfrapodConfig {
  phy: string;
  addr: string;
  subnet: string;
  gw: string;
  vid: number;
  mgmtPhy: string;
  vni: number;
}

/**
 * infrapod host -> addr
 * map<string,InfrapodConfig> infrapod_configs = 1;
 * map<string,InfranetSwitchConfig> switch_configs = 2;
 */
export interface InfranetEmbedding {
  /** hostname of infrapod server */
  InfrapodServer: string;
}

export interface BlockPoolAllocations {
  id: string;
  allocations: CountSet | undefined;
}

export interface Neighbor {
  prefixV4: string;
  prefixV6: string;
  nexthop: string;
  mac: string;
  name: string;
}

export interface NodeRealization {
  node: Node | undefined;
  resource: Resource1 | undefined;
  vmAlloc: ResourceAllocation | undefined;
  facility: string;
  kind: NodeRealization_Kind;
  infranetAddr: string;
}

export enum NodeRealization_Kind {
  Undefined = 0,
  BareMetal = 1,
  VirtualMachine = 2,
  UNRECOGNIZED = -1,
}

export function nodeRealization_KindFromJSON(object: any): NodeRealization_Kind {
  switch (object) {
    case 0:
    case "Undefined":
      return NodeRealization_Kind.Undefined;
    case 1:
    case "BareMetal":
      return NodeRealization_Kind.BareMetal;
    case 2:
    case "VirtualMachine":
      return NodeRealization_Kind.VirtualMachine;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodeRealization_Kind.UNRECOGNIZED;
  }
}

export function nodeRealization_KindToJSON(object: NodeRealization_Kind): string {
  switch (object) {
    case NodeRealization_Kind.Undefined:
      return "Undefined";
    case NodeRealization_Kind.BareMetal:
      return "BareMetal";
    case NodeRealization_Kind.VirtualMachine:
      return "VirtualMachine";
    case NodeRealization_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface LinkRealization {
  link: Link | undefined;
  segments: { [key: number]: LinkSegment };
}

export interface LinkRealization_SegmentsEntry {
  key: number;
  value: LinkSegment | undefined;
}

export interface PhyoRealization {
  simulator: string;
  facility: string;
}

export interface BondRealization {
  simulator: string;
  facility: string;
}

export interface SensorRealization {
  simulator: string;
  facility: string;
}

export interface ActuatorRealization {
  simulator: string;
  facility: string;
}

export interface LinkSegment {
  endpoints: Endpoint[];
  waypoints: Waypoint[];
}

export interface Endpoint {
  facility: string;
  host: string;
  node: string;
  bridge: BridgeMember | undefined;
  mac: string;
  phy?: PhysicalInterface | undefined;
  vlan?: VLANInterface | undefined;
  vtep?:
    | Vtep
    | undefined;
  /** xxx out of order */
  vf?:
    | VFInterface
    | undefined;
  /** ephemeral Endpoint represents a trunked local host's interface */
  trunk?: VLANTrunkPort | undefined;
  evpn: Evpn | undefined;
  mtu: number;
  virtual: boolean;
}

export interface Waypoint {
  facility: string;
  host: string;
  bridge: BridgeMember | undefined;
  access?: VLANAccessPort | undefined;
  trunk?: VLANTrunkPort | undefined;
  tap?: VLANTapPort | undefined;
  vtep?: Vtep | undefined;
  bgpPeer?: BGPPeer | undefined;
  mtu: number;
}

export interface BridgeMember {
  bridge: string;
  untagged: number[];
  tagged: number[];
  pvid: number;
}

export interface Evpn {
  mac: EvpnMacAdv | undefined;
  multicast: EvpnMulticastAdv | undefined;
}

export interface EvpnMacAdv {
  mac: string;
  tunnelIp: string;
  vni: number;
}

export interface EvpnMulticastAdv {
  tunnelIp: string;
  vni: number;
}

export interface PhysicalInterface {
  name: string;
  mac: string;
  portIndex: number;
}

export interface VirtualFunction {
  name: string;
  Pf: PhysicalInterface | undefined;
  VfIndex: number;
  mac: string;
}

export interface VLANInterface {
  name: string;
  vid: number;
  parent: PhysicalInterface | undefined;
  addrs: string[];
}

/** SRIOV: VF (Virtual Function interface) */
export interface VFInterface {
  /** frontend (vm) interface, e.g. eth0 */
  virtif:
    | PhysicalInterface
    | undefined;
  /** vf port data , e.g. enp3s0f1np1_1 */
  parent: VirtualFunction | undefined;
  vid: number;
  addrs: string[];
}

export interface Vtep {
  name: string;
  vni: number;
  parent:
    | PhysicalInterface
    | undefined;
  /** string service_ip = 5; */
  tunnelIp: string;
}

export interface BGPPeer {
  interface: PhysicalInterface | undefined;
  localAsn: number;
  remoteAsn: number;
  network: string;
}

export interface VLANAccessPort {
  port: PhysicalInterface | undefined;
  vid: number;
}

export interface VLANTrunkPort {
  port: PhysicalInterface | undefined;
  vids: number[];
}

/** A VLAN access port in the form of a TAP device */
export interface VLANTapPort {
  node: string;
  frontend: PhysicalInterface | undefined;
  vid: number;
}

/** SRIOV: VLANVfPort is a tagged VF seen by the VM as `frontend` */
export interface VLANVfPort {
  vf: VirtualFunction | undefined;
  frontend: PhysicalInterface | undefined;
  vid: number;
}

export interface Diagnostic {
  message: string;
  level: DiagnosticLevel;
  data: { [key: string]: string };
  guest: string;
  host: string;
}

export interface Diagnostic_DataEntry {
  key: string;
  value: string;
}

export interface DiagnosticList {
  value: Diagnostic[];
}

export interface LinkEmulation {
  /** percentage in range 0.0-1.0 */
  loss: number;
  /** units: bps */
  capacity: number;
  /** units: ms */
  latency: number;
  /** used for user to select this link via client */
  tags: string[];
  /** vteps on the emu server that belong to this link */
  interfaces: string[];
  /** exp node names attached to this link (for user use only) */
  nodes: string[];
  /** the network emulation server handling this link */
  server: string;
}

export interface LinkEmulationParams {
  /** emulation server for this realization (deprecated) */
  server: string;
  links: LinkEmulation[];
  /** which network emulation backend to use */
  backend: Emulation;
}

export interface RealizationResult {
  realization: Realization | undefined;
  diagnostics: DiagnosticList | undefined;
}

export interface GetRealizationsRequest {
  /** from workspace_types */
  filter: FilterMode;
}

export interface GetRealizationsResponse {
  results: RealizationResult[];
}

export interface GetRealizationRequest {
  project: string;
  experiment: string;
  realization: string;
}

export interface GetRealizationResponse {
  result: RealizationResult | undefined;
}

export interface RealizeRequest {
  /** The project this realization's experiment belongs to. */
  project: string;
  /** The name of the experiment this realization belongs to. */
  experiment: string;
  /** The name of the realization. */
  realization: string;
  /**
   * Experiment revision to realize.
   * Only one of revision, tag, or branch is allowed.
   */
  revision: string;
  /** The user who created this realization. */
  creator: string;
  /** The time this realization was submitted. */
  time: string;
  /** The version of this realization request object. */
  ver: number;
  /**
   * The git tag to use for this realization.
   * Only one of revision, tag, or branch is allowed.
   */
  tag: string;
  /**
   * The branch to use for this realization. HEAD revision will e realized.
   * Only one of revision, tag, or branch is allowed.
   */
  branch: string;
  duration: ReservationDuration | undefined;
}

export interface ReservationDuration {
  when: ReservationDuration_code;
  /**
   * How long to reserve the resources of the realization. After the duration
   * ends the realization is available to be forcibly relinquished to free
   * reserved resources.
   *
   * The format of the duration follows the golang time.ParseDuration with
   * extra fields for weeks and days prepending the golang duration.
   *
   * Example: 2 weeks, 3 days, 4 hours, 5 seconds is "2w3d4h5s".
   *
   * Any field may be absent. "2w4h" is 2 weeks for hours.
   * A day is 24 hours. A week is 7 days.
   *
   * Only used if "when" is "given".
   */
  duration: string;
}

export enum ReservationDuration_code {
  /** given - Use given duration string */
  given = 0,
  /** never - Never expire */
  never = 1,
  UNRECOGNIZED = -1,
}

export function reservationDuration_codeFromJSON(object: any): ReservationDuration_code {
  switch (object) {
    case 0:
    case "given":
      return ReservationDuration_code.given;
    case 1:
    case "never":
      return ReservationDuration_code.never;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReservationDuration_code.UNRECOGNIZED;
  }
}

export function reservationDuration_codeToJSON(object: ReservationDuration_code): string {
  switch (object) {
    case ReservationDuration_code.given:
      return "given";
    case ReservationDuration_code.never:
      return "never";
    case ReservationDuration_code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RealizeResponse {
  code: RealizeResponse_Code;
  diagnostics: Diagnostic[];
  realization: Realization | undefined;
}

export enum RealizeResponse_Code {
  Ok = 0,
  BadXir = 1,
  Unrealizable = 2,
  InternalError = 3,
  UNRECOGNIZED = -1,
}

export function realizeResponse_CodeFromJSON(object: any): RealizeResponse_Code {
  switch (object) {
    case 0:
    case "Ok":
      return RealizeResponse_Code.Ok;
    case 1:
    case "BadXir":
      return RealizeResponse_Code.BadXir;
    case 2:
    case "Unrealizable":
      return RealizeResponse_Code.Unrealizable;
    case 3:
    case "InternalError":
      return RealizeResponse_Code.InternalError;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RealizeResponse_Code.UNRECOGNIZED;
  }
}

export function realizeResponse_CodeToJSON(object: RealizeResponse_Code): string {
  switch (object) {
    case RealizeResponse_Code.Ok:
      return "Ok";
    case RealizeResponse_Code.BadXir:
      return "BadXir";
    case RealizeResponse_Code.Unrealizable:
      return "Unrealizable";
    case RealizeResponse_Code.InternalError:
      return "InternalError";
    case RealizeResponse_Code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RelinquishRequest {
  project: string;
  experiment: string;
  realization: string;
}

export interface RelinquishResponse {
}

/** End user view of realization resources */
export interface Allocation {
  /** realization */
  rid: string;
  /** experiment */
  eid: string;
  /** project */
  pid: string;
  /** user */
  uid: string;
  /** facility */
  fid: string;
  /** organization */
  oid: string;
  /** experiment node name */
  node: string;
  /** VM allocation */
  virt: boolean;
  /** number of cores used by the allocation */
  coresUsed: number;
  /** bytes of memory used by the allocation */
  memoryUsed: number;
}

export interface Resource {
  /** TbNodes and Hypervisors only */
  resource:
    | Resource1
    | undefined;
  /** all user allocations on the node */
  allocated: Allocation[];
}

export interface GetResourcesRequest {
}

export interface GetResourcesResponse {
  resources: Resource[];
}

export interface UpdateRealizationRequest {
  project: string;
  experiment: string;
  realization: string;
  duration: ReservationDuration | undefined;
}

export interface UpdateRealizationResponse {
  /** The new expiration time, if updated. */
  expires: Date | undefined;
}

function createBaseRealization(): Realization {
  return {
    complete: false,
    id: "",
    eid: "",
    pid: "",
    xhash: "",
    nodes: {},
    links: {},
    phyos: {},
    sensors: {},
    actuators: {},
    bonds: {},
    infranet: undefined,
    creator: "",
    ver: 0,
    linkEmulation: undefined,
    created: undefined,
    expires: undefined,
  };
}

export const Realization = {
  encode(message: Realization, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.complete === true) {
      writer.uint32(8).bool(message.complete);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.eid !== "") {
      writer.uint32(26).string(message.eid);
    }
    if (message.pid !== "") {
      writer.uint32(34).string(message.pid);
    }
    if (message.xhash !== "") {
      writer.uint32(42).string(message.xhash);
    }
    Object.entries(message.nodes).forEach(([key, value]) => {
      Realization_NodesEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).ldelim();
    });
    Object.entries(message.links).forEach(([key, value]) => {
      Realization_LinksEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    Object.entries(message.phyos).forEach(([key, value]) => {
      Realization_PhyosEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).ldelim();
    });
    Object.entries(message.sensors).forEach(([key, value]) => {
      Realization_SensorsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).ldelim();
    });
    Object.entries(message.actuators).forEach(([key, value]) => {
      Realization_ActuatorsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).ldelim();
    });
    Object.entries(message.bonds).forEach(([key, value]) => {
      Realization_BondsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).ldelim();
    });
    if (message.infranet !== undefined) {
      InfranetEmbedding.encode(message.infranet, writer.uint32(98).fork()).ldelim();
    }
    if (message.creator !== "") {
      writer.uint32(106).string(message.creator);
    }
    if (message.ver !== 0) {
      writer.uint32(112).int64(message.ver);
    }
    if (message.linkEmulation !== undefined) {
      LinkEmulationParams.encode(message.linkEmulation, writer.uint32(122).fork()).ldelim();
    }
    if (message.created !== undefined) {
      Timestamp.encode(toTimestamp(message.created), writer.uint32(130).fork()).ldelim();
    }
    if (message.expires !== undefined) {
      Timestamp.encode(toTimestamp(message.expires), writer.uint32(138).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Realization {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRealization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.complete = reader.bool();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.eid = reader.string();
          break;
        case 4:
          message.pid = reader.string();
          break;
        case 5:
          message.xhash = reader.string();
          break;
        case 6:
          const entry6 = Realization_NodesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.nodes[entry6.key] = entry6.value;
          }
          break;
        case 7:
          const entry7 = Realization_LinksEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.links[entry7.key] = entry7.value;
          }
          break;
        case 8:
          const entry8 = Realization_PhyosEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.phyos[entry8.key] = entry8.value;
          }
          break;
        case 9:
          const entry9 = Realization_SensorsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.sensors[entry9.key] = entry9.value;
          }
          break;
        case 10:
          const entry10 = Realization_ActuatorsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.actuators[entry10.key] = entry10.value;
          }
          break;
        case 11:
          const entry11 = Realization_BondsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.bonds[entry11.key] = entry11.value;
          }
          break;
        case 12:
          message.infranet = InfranetEmbedding.decode(reader, reader.uint32());
          break;
        case 13:
          message.creator = reader.string();
          break;
        case 14:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        case 15:
          message.linkEmulation = LinkEmulationParams.decode(reader, reader.uint32());
          break;
        case 16:
          message.created = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 17:
          message.expires = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Realization {
    return {
      complete: isSet(object.complete) ? Boolean(object.complete) : false,
      id: isSet(object.id) ? String(object.id) : "",
      eid: isSet(object.eid) ? String(object.eid) : "",
      pid: isSet(object.pid) ? String(object.pid) : "",
      xhash: isSet(object.xhash) ? String(object.xhash) : "",
      nodes: isObject(object.nodes)
        ? Object.entries(object.nodes).reduce<{ [key: string]: NodeRealization }>((acc, [key, value]) => {
          acc[key] = NodeRealization.fromJSON(value);
          return acc;
        }, {})
        : {},
      links: isObject(object.links)
        ? Object.entries(object.links).reduce<{ [key: string]: LinkRealization }>((acc, [key, value]) => {
          acc[key] = LinkRealization.fromJSON(value);
          return acc;
        }, {})
        : {},
      phyos: isObject(object.phyos)
        ? Object.entries(object.phyos).reduce<{ [key: string]: PhyoRealization }>((acc, [key, value]) => {
          acc[key] = PhyoRealization.fromJSON(value);
          return acc;
        }, {})
        : {},
      sensors: isObject(object.sensors)
        ? Object.entries(object.sensors).reduce<{ [key: string]: SensorRealization }>((acc, [key, value]) => {
          acc[key] = SensorRealization.fromJSON(value);
          return acc;
        }, {})
        : {},
      actuators: isObject(object.actuators)
        ? Object.entries(object.actuators).reduce<{ [key: string]: ActuatorRealization }>((acc, [key, value]) => {
          acc[key] = ActuatorRealization.fromJSON(value);
          return acc;
        }, {})
        : {},
      bonds: isObject(object.bonds)
        ? Object.entries(object.bonds).reduce<{ [key: string]: BondRealization }>((acc, [key, value]) => {
          acc[key] = BondRealization.fromJSON(value);
          return acc;
        }, {})
        : {},
      infranet: isSet(object.infranet) ? InfranetEmbedding.fromJSON(object.infranet) : undefined,
      creator: isSet(object.creator) ? String(object.creator) : "",
      ver: isSet(object.ver) ? Number(object.ver) : 0,
      linkEmulation: isSet(object.linkEmulation) ? LinkEmulationParams.fromJSON(object.linkEmulation) : undefined,
      created: isSet(object.created) ? fromJsonTimestamp(object.created) : undefined,
      expires: isSet(object.expires) ? fromJsonTimestamp(object.expires) : undefined,
    };
  },

  toJSON(message: Realization): unknown {
    const obj: any = {};
    message.complete !== undefined && (obj.complete = message.complete);
    message.id !== undefined && (obj.id = message.id);
    message.eid !== undefined && (obj.eid = message.eid);
    message.pid !== undefined && (obj.pid = message.pid);
    message.xhash !== undefined && (obj.xhash = message.xhash);
    obj.nodes = {};
    if (message.nodes) {
      Object.entries(message.nodes).forEach(([k, v]) => {
        obj.nodes[k] = NodeRealization.toJSON(v);
      });
    }
    obj.links = {};
    if (message.links) {
      Object.entries(message.links).forEach(([k, v]) => {
        obj.links[k] = LinkRealization.toJSON(v);
      });
    }
    obj.phyos = {};
    if (message.phyos) {
      Object.entries(message.phyos).forEach(([k, v]) => {
        obj.phyos[k] = PhyoRealization.toJSON(v);
      });
    }
    obj.sensors = {};
    if (message.sensors) {
      Object.entries(message.sensors).forEach(([k, v]) => {
        obj.sensors[k] = SensorRealization.toJSON(v);
      });
    }
    obj.actuators = {};
    if (message.actuators) {
      Object.entries(message.actuators).forEach(([k, v]) => {
        obj.actuators[k] = ActuatorRealization.toJSON(v);
      });
    }
    obj.bonds = {};
    if (message.bonds) {
      Object.entries(message.bonds).forEach(([k, v]) => {
        obj.bonds[k] = BondRealization.toJSON(v);
      });
    }
    message.infranet !== undefined &&
      (obj.infranet = message.infranet ? InfranetEmbedding.toJSON(message.infranet) : undefined);
    message.creator !== undefined && (obj.creator = message.creator);
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    message.linkEmulation !== undefined &&
      (obj.linkEmulation = message.linkEmulation ? LinkEmulationParams.toJSON(message.linkEmulation) : undefined);
    message.created !== undefined && (obj.created = message.created.toISOString());
    message.expires !== undefined && (obj.expires = message.expires.toISOString());
    return obj;
  },

  create<I extends Exact<DeepPartial<Realization>, I>>(base?: I): Realization {
    return Realization.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Realization>, I>>(object: I): Realization {
    const message = createBaseRealization();
    message.complete = object.complete ?? false;
    message.id = object.id ?? "";
    message.eid = object.eid ?? "";
    message.pid = object.pid ?? "";
    message.xhash = object.xhash ?? "";
    message.nodes = Object.entries(object.nodes ?? {}).reduce<{ [key: string]: NodeRealization }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = NodeRealization.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.links = Object.entries(object.links ?? {}).reduce<{ [key: string]: LinkRealization }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = LinkRealization.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.phyos = Object.entries(object.phyos ?? {}).reduce<{ [key: string]: PhyoRealization }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = PhyoRealization.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.sensors = Object.entries(object.sensors ?? {}).reduce<{ [key: string]: SensorRealization }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SensorRealization.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.actuators = Object.entries(object.actuators ?? {}).reduce<{ [key: string]: ActuatorRealization }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ActuatorRealization.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.bonds = Object.entries(object.bonds ?? {}).reduce<{ [key: string]: BondRealization }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = BondRealization.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.infranet = (object.infranet !== undefined && object.infranet !== null)
      ? InfranetEmbedding.fromPartial(object.infranet)
      : undefined;
    message.creator = object.creator ?? "";
    message.ver = object.ver ?? 0;
    message.linkEmulation = (object.linkEmulation !== undefined && object.linkEmulation !== null)
      ? LinkEmulationParams.fromPartial(object.linkEmulation)
      : undefined;
    message.created = object.created ?? undefined;
    message.expires = object.expires ?? undefined;
    return message;
  },
};

function createBaseRealization_NodesEntry(): Realization_NodesEntry {
  return { key: "", value: undefined };
}

export const Realization_NodesEntry = {
  encode(message: Realization_NodesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      NodeRealization.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Realization_NodesEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRealization_NodesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = NodeRealization.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Realization_NodesEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? NodeRealization.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Realization_NodesEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? NodeRealization.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Realization_NodesEntry>, I>>(base?: I): Realization_NodesEntry {
    return Realization_NodesEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Realization_NodesEntry>, I>>(object: I): Realization_NodesEntry {
    const message = createBaseRealization_NodesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? NodeRealization.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRealization_LinksEntry(): Realization_LinksEntry {
  return { key: "", value: undefined };
}

export const Realization_LinksEntry = {
  encode(message: Realization_LinksEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      LinkRealization.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Realization_LinksEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRealization_LinksEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = LinkRealization.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Realization_LinksEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? LinkRealization.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Realization_LinksEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? LinkRealization.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Realization_LinksEntry>, I>>(base?: I): Realization_LinksEntry {
    return Realization_LinksEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Realization_LinksEntry>, I>>(object: I): Realization_LinksEntry {
    const message = createBaseRealization_LinksEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? LinkRealization.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRealization_PhyosEntry(): Realization_PhyosEntry {
  return { key: "", value: undefined };
}

export const Realization_PhyosEntry = {
  encode(message: Realization_PhyosEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      PhyoRealization.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Realization_PhyosEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRealization_PhyosEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = PhyoRealization.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Realization_PhyosEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? PhyoRealization.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Realization_PhyosEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? PhyoRealization.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Realization_PhyosEntry>, I>>(base?: I): Realization_PhyosEntry {
    return Realization_PhyosEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Realization_PhyosEntry>, I>>(object: I): Realization_PhyosEntry {
    const message = createBaseRealization_PhyosEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? PhyoRealization.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRealization_SensorsEntry(): Realization_SensorsEntry {
  return { key: "", value: undefined };
}

export const Realization_SensorsEntry = {
  encode(message: Realization_SensorsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SensorRealization.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Realization_SensorsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRealization_SensorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = SensorRealization.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Realization_SensorsEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? SensorRealization.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Realization_SensorsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? SensorRealization.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Realization_SensorsEntry>, I>>(base?: I): Realization_SensorsEntry {
    return Realization_SensorsEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Realization_SensorsEntry>, I>>(object: I): Realization_SensorsEntry {
    const message = createBaseRealization_SensorsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SensorRealization.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRealization_ActuatorsEntry(): Realization_ActuatorsEntry {
  return { key: "", value: undefined };
}

export const Realization_ActuatorsEntry = {
  encode(message: Realization_ActuatorsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ActuatorRealization.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Realization_ActuatorsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRealization_ActuatorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ActuatorRealization.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Realization_ActuatorsEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? ActuatorRealization.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Realization_ActuatorsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? ActuatorRealization.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Realization_ActuatorsEntry>, I>>(base?: I): Realization_ActuatorsEntry {
    return Realization_ActuatorsEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Realization_ActuatorsEntry>, I>>(object: I): Realization_ActuatorsEntry {
    const message = createBaseRealization_ActuatorsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ActuatorRealization.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRealization_BondsEntry(): Realization_BondsEntry {
  return { key: "", value: undefined };
}

export const Realization_BondsEntry = {
  encode(message: Realization_BondsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      BondRealization.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Realization_BondsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRealization_BondsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = BondRealization.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Realization_BondsEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? BondRealization.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Realization_BondsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? BondRealization.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Realization_BondsEntry>, I>>(base?: I): Realization_BondsEntry {
    return Realization_BondsEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Realization_BondsEntry>, I>>(object: I): Realization_BondsEntry {
    const message = createBaseRealization_BondsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? BondRealization.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseInfrapodConfig(): InfrapodConfig {
  return { phy: "", addr: "", subnet: "", gw: "", vid: 0, mgmtPhy: "", vni: 0 };
}

export const InfrapodConfig = {
  encode(message: InfrapodConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.phy !== "") {
      writer.uint32(10).string(message.phy);
    }
    if (message.addr !== "") {
      writer.uint32(18).string(message.addr);
    }
    if (message.subnet !== "") {
      writer.uint32(26).string(message.subnet);
    }
    if (message.gw !== "") {
      writer.uint32(34).string(message.gw);
    }
    if (message.vid !== 0) {
      writer.uint32(40).uint32(message.vid);
    }
    if (message.mgmtPhy !== "") {
      writer.uint32(50).string(message.mgmtPhy);
    }
    if (message.vni !== 0) {
      writer.uint32(56).uint32(message.vni);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InfrapodConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInfrapodConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.phy = reader.string();
          break;
        case 2:
          message.addr = reader.string();
          break;
        case 3:
          message.subnet = reader.string();
          break;
        case 4:
          message.gw = reader.string();
          break;
        case 5:
          message.vid = reader.uint32();
          break;
        case 6:
          message.mgmtPhy = reader.string();
          break;
        case 7:
          message.vni = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InfrapodConfig {
    return {
      phy: isSet(object.phy) ? String(object.phy) : "",
      addr: isSet(object.addr) ? String(object.addr) : "",
      subnet: isSet(object.subnet) ? String(object.subnet) : "",
      gw: isSet(object.gw) ? String(object.gw) : "",
      vid: isSet(object.vid) ? Number(object.vid) : 0,
      mgmtPhy: isSet(object.mgmtPhy) ? String(object.mgmtPhy) : "",
      vni: isSet(object.vni) ? Number(object.vni) : 0,
    };
  },

  toJSON(message: InfrapodConfig): unknown {
    const obj: any = {};
    message.phy !== undefined && (obj.phy = message.phy);
    message.addr !== undefined && (obj.addr = message.addr);
    message.subnet !== undefined && (obj.subnet = message.subnet);
    message.gw !== undefined && (obj.gw = message.gw);
    message.vid !== undefined && (obj.vid = Math.round(message.vid));
    message.mgmtPhy !== undefined && (obj.mgmtPhy = message.mgmtPhy);
    message.vni !== undefined && (obj.vni = Math.round(message.vni));
    return obj;
  },

  create<I extends Exact<DeepPartial<InfrapodConfig>, I>>(base?: I): InfrapodConfig {
    return InfrapodConfig.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<InfrapodConfig>, I>>(object: I): InfrapodConfig {
    const message = createBaseInfrapodConfig();
    message.phy = object.phy ?? "";
    message.addr = object.addr ?? "";
    message.subnet = object.subnet ?? "";
    message.gw = object.gw ?? "";
    message.vid = object.vid ?? 0;
    message.mgmtPhy = object.mgmtPhy ?? "";
    message.vni = object.vni ?? 0;
    return message;
  },
};

function createBaseInfranetEmbedding(): InfranetEmbedding {
  return { InfrapodServer: "" };
}

export const InfranetEmbedding = {
  encode(message: InfranetEmbedding, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.InfrapodServer !== "") {
      writer.uint32(10).string(message.InfrapodServer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InfranetEmbedding {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInfranetEmbedding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.InfrapodServer = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InfranetEmbedding {
    return { InfrapodServer: isSet(object.InfrapodServer) ? String(object.InfrapodServer) : "" };
  },

  toJSON(message: InfranetEmbedding): unknown {
    const obj: any = {};
    message.InfrapodServer !== undefined && (obj.InfrapodServer = message.InfrapodServer);
    return obj;
  },

  create<I extends Exact<DeepPartial<InfranetEmbedding>, I>>(base?: I): InfranetEmbedding {
    return InfranetEmbedding.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<InfranetEmbedding>, I>>(object: I): InfranetEmbedding {
    const message = createBaseInfranetEmbedding();
    message.InfrapodServer = object.InfrapodServer ?? "";
    return message;
  },
};

function createBaseBlockPoolAllocations(): BlockPoolAllocations {
  return { id: "", allocations: undefined };
}

export const BlockPoolAllocations = {
  encode(message: BlockPoolAllocations, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.allocations !== undefined) {
      CountSet.encode(message.allocations, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockPoolAllocations {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockPoolAllocations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.allocations = CountSet.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BlockPoolAllocations {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      allocations: isSet(object.allocations) ? CountSet.fromJSON(object.allocations) : undefined,
    };
  },

  toJSON(message: BlockPoolAllocations): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.allocations !== undefined &&
      (obj.allocations = message.allocations ? CountSet.toJSON(message.allocations) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockPoolAllocations>, I>>(base?: I): BlockPoolAllocations {
    return BlockPoolAllocations.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<BlockPoolAllocations>, I>>(object: I): BlockPoolAllocations {
    const message = createBaseBlockPoolAllocations();
    message.id = object.id ?? "";
    message.allocations = (object.allocations !== undefined && object.allocations !== null)
      ? CountSet.fromPartial(object.allocations)
      : undefined;
    return message;
  },
};

function createBaseNeighbor(): Neighbor {
  return { prefixV4: "", prefixV6: "", nexthop: "", mac: "", name: "" };
}

export const Neighbor = {
  encode(message: Neighbor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.prefixV4 !== "") {
      writer.uint32(10).string(message.prefixV4);
    }
    if (message.prefixV6 !== "") {
      writer.uint32(18).string(message.prefixV6);
    }
    if (message.nexthop !== "") {
      writer.uint32(26).string(message.nexthop);
    }
    if (message.mac !== "") {
      writer.uint32(34).string(message.mac);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Neighbor {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNeighbor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.prefixV4 = reader.string();
          break;
        case 2:
          message.prefixV6 = reader.string();
          break;
        case 3:
          message.nexthop = reader.string();
          break;
        case 4:
          message.mac = reader.string();
          break;
        case 5:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Neighbor {
    return {
      prefixV4: isSet(object.prefixV4) ? String(object.prefixV4) : "",
      prefixV6: isSet(object.prefixV6) ? String(object.prefixV6) : "",
      nexthop: isSet(object.nexthop) ? String(object.nexthop) : "",
      mac: isSet(object.mac) ? String(object.mac) : "",
      name: isSet(object.name) ? String(object.name) : "",
    };
  },

  toJSON(message: Neighbor): unknown {
    const obj: any = {};
    message.prefixV4 !== undefined && (obj.prefixV4 = message.prefixV4);
    message.prefixV6 !== undefined && (obj.prefixV6 = message.prefixV6);
    message.nexthop !== undefined && (obj.nexthop = message.nexthop);
    message.mac !== undefined && (obj.mac = message.mac);
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  create<I extends Exact<DeepPartial<Neighbor>, I>>(base?: I): Neighbor {
    return Neighbor.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Neighbor>, I>>(object: I): Neighbor {
    const message = createBaseNeighbor();
    message.prefixV4 = object.prefixV4 ?? "";
    message.prefixV6 = object.prefixV6 ?? "";
    message.nexthop = object.nexthop ?? "";
    message.mac = object.mac ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseNodeRealization(): NodeRealization {
  return { node: undefined, resource: undefined, vmAlloc: undefined, facility: "", kind: 0, infranetAddr: "" };
}

export const NodeRealization = {
  encode(message: NodeRealization, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(10).fork()).ldelim();
    }
    if (message.resource !== undefined) {
      Resource1.encode(message.resource, writer.uint32(18).fork()).ldelim();
    }
    if (message.vmAlloc !== undefined) {
      ResourceAllocation.encode(message.vmAlloc, writer.uint32(26).fork()).ldelim();
    }
    if (message.facility !== "") {
      writer.uint32(34).string(message.facility);
    }
    if (message.kind !== 0) {
      writer.uint32(40).int32(message.kind);
    }
    if (message.infranetAddr !== "") {
      writer.uint32(50).string(message.infranetAddr);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeRealization {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeRealization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.node = Node.decode(reader, reader.uint32());
          break;
        case 2:
          message.resource = Resource1.decode(reader, reader.uint32());
          break;
        case 3:
          message.vmAlloc = ResourceAllocation.decode(reader, reader.uint32());
          break;
        case 4:
          message.facility = reader.string();
          break;
        case 5:
          message.kind = reader.int32() as any;
          break;
        case 6:
          message.infranetAddr = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NodeRealization {
    return {
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      resource: isSet(object.resource) ? Resource1.fromJSON(object.resource) : undefined,
      vmAlloc: isSet(object.vmAlloc) ? ResourceAllocation.fromJSON(object.vmAlloc) : undefined,
      facility: isSet(object.facility) ? String(object.facility) : "",
      kind: isSet(object.kind) ? nodeRealization_KindFromJSON(object.kind) : 0,
      infranetAddr: isSet(object.infranetAddr) ? String(object.infranetAddr) : "",
    };
  },

  toJSON(message: NodeRealization): unknown {
    const obj: any = {};
    message.node !== undefined && (obj.node = message.node ? Node.toJSON(message.node) : undefined);
    message.resource !== undefined &&
      (obj.resource = message.resource ? Resource1.toJSON(message.resource) : undefined);
    message.vmAlloc !== undefined &&
      (obj.vmAlloc = message.vmAlloc ? ResourceAllocation.toJSON(message.vmAlloc) : undefined);
    message.facility !== undefined && (obj.facility = message.facility);
    message.kind !== undefined && (obj.kind = nodeRealization_KindToJSON(message.kind));
    message.infranetAddr !== undefined && (obj.infranetAddr = message.infranetAddr);
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeRealization>, I>>(base?: I): NodeRealization {
    return NodeRealization.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<NodeRealization>, I>>(object: I): NodeRealization {
    const message = createBaseNodeRealization();
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource1.fromPartial(object.resource)
      : undefined;
    message.vmAlloc = (object.vmAlloc !== undefined && object.vmAlloc !== null)
      ? ResourceAllocation.fromPartial(object.vmAlloc)
      : undefined;
    message.facility = object.facility ?? "";
    message.kind = object.kind ?? 0;
    message.infranetAddr = object.infranetAddr ?? "";
    return message;
  },
};

function createBaseLinkRealization(): LinkRealization {
  return { link: undefined, segments: {} };
}

export const LinkRealization = {
  encode(message: LinkRealization, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.link !== undefined) {
      Link.encode(message.link, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.segments).forEach(([key, value]) => {
      LinkRealization_SegmentsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LinkRealization {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkRealization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.link = Link.decode(reader, reader.uint32());
          break;
        case 2:
          const entry2 = LinkRealization_SegmentsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.segments[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LinkRealization {
    return {
      link: isSet(object.link) ? Link.fromJSON(object.link) : undefined,
      segments: isObject(object.segments)
        ? Object.entries(object.segments).reduce<{ [key: number]: LinkSegment }>((acc, [key, value]) => {
          acc[Number(key)] = LinkSegment.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: LinkRealization): unknown {
    const obj: any = {};
    message.link !== undefined && (obj.link = message.link ? Link.toJSON(message.link) : undefined);
    obj.segments = {};
    if (message.segments) {
      Object.entries(message.segments).forEach(([k, v]) => {
        obj.segments[k] = LinkSegment.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkRealization>, I>>(base?: I): LinkRealization {
    return LinkRealization.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<LinkRealization>, I>>(object: I): LinkRealization {
    const message = createBaseLinkRealization();
    message.link = (object.link !== undefined && object.link !== null) ? Link.fromPartial(object.link) : undefined;
    message.segments = Object.entries(object.segments ?? {}).reduce<{ [key: number]: LinkSegment }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[Number(key)] = LinkSegment.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseLinkRealization_SegmentsEntry(): LinkRealization_SegmentsEntry {
  return { key: 0, value: undefined };
}

export const LinkRealization_SegmentsEntry = {
  encode(message: LinkRealization_SegmentsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== 0) {
      writer.uint32(8).uint64(message.key);
    }
    if (message.value !== undefined) {
      LinkSegment.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LinkRealization_SegmentsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkRealization_SegmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = longToNumber(reader.uint64() as Long);
          break;
        case 2:
          message.value = LinkSegment.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LinkRealization_SegmentsEntry {
    return {
      key: isSet(object.key) ? Number(object.key) : 0,
      value: isSet(object.value) ? LinkSegment.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: LinkRealization_SegmentsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = Math.round(message.key));
    message.value !== undefined && (obj.value = message.value ? LinkSegment.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkRealization_SegmentsEntry>, I>>(base?: I): LinkRealization_SegmentsEntry {
    return LinkRealization_SegmentsEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<LinkRealization_SegmentsEntry>, I>>(
    object: I,
  ): LinkRealization_SegmentsEntry {
    const message = createBaseLinkRealization_SegmentsEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? LinkSegment.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePhyoRealization(): PhyoRealization {
  return { simulator: "", facility: "" };
}

export const PhyoRealization = {
  encode(message: PhyoRealization, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.simulator !== "") {
      writer.uint32(10).string(message.simulator);
    }
    if (message.facility !== "") {
      writer.uint32(18).string(message.facility);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PhyoRealization {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhyoRealization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.simulator = reader.string();
          break;
        case 2:
          message.facility = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PhyoRealization {
    return {
      simulator: isSet(object.simulator) ? String(object.simulator) : "",
      facility: isSet(object.facility) ? String(object.facility) : "",
    };
  },

  toJSON(message: PhyoRealization): unknown {
    const obj: any = {};
    message.simulator !== undefined && (obj.simulator = message.simulator);
    message.facility !== undefined && (obj.facility = message.facility);
    return obj;
  },

  create<I extends Exact<DeepPartial<PhyoRealization>, I>>(base?: I): PhyoRealization {
    return PhyoRealization.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<PhyoRealization>, I>>(object: I): PhyoRealization {
    const message = createBasePhyoRealization();
    message.simulator = object.simulator ?? "";
    message.facility = object.facility ?? "";
    return message;
  },
};

function createBaseBondRealization(): BondRealization {
  return { simulator: "", facility: "" };
}

export const BondRealization = {
  encode(message: BondRealization, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.simulator !== "") {
      writer.uint32(10).string(message.simulator);
    }
    if (message.facility !== "") {
      writer.uint32(18).string(message.facility);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BondRealization {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBondRealization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.simulator = reader.string();
          break;
        case 2:
          message.facility = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BondRealization {
    return {
      simulator: isSet(object.simulator) ? String(object.simulator) : "",
      facility: isSet(object.facility) ? String(object.facility) : "",
    };
  },

  toJSON(message: BondRealization): unknown {
    const obj: any = {};
    message.simulator !== undefined && (obj.simulator = message.simulator);
    message.facility !== undefined && (obj.facility = message.facility);
    return obj;
  },

  create<I extends Exact<DeepPartial<BondRealization>, I>>(base?: I): BondRealization {
    return BondRealization.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<BondRealization>, I>>(object: I): BondRealization {
    const message = createBaseBondRealization();
    message.simulator = object.simulator ?? "";
    message.facility = object.facility ?? "";
    return message;
  },
};

function createBaseSensorRealization(): SensorRealization {
  return { simulator: "", facility: "" };
}

export const SensorRealization = {
  encode(message: SensorRealization, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.simulator !== "") {
      writer.uint32(10).string(message.simulator);
    }
    if (message.facility !== "") {
      writer.uint32(18).string(message.facility);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SensorRealization {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSensorRealization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.simulator = reader.string();
          break;
        case 2:
          message.facility = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SensorRealization {
    return {
      simulator: isSet(object.simulator) ? String(object.simulator) : "",
      facility: isSet(object.facility) ? String(object.facility) : "",
    };
  },

  toJSON(message: SensorRealization): unknown {
    const obj: any = {};
    message.simulator !== undefined && (obj.simulator = message.simulator);
    message.facility !== undefined && (obj.facility = message.facility);
    return obj;
  },

  create<I extends Exact<DeepPartial<SensorRealization>, I>>(base?: I): SensorRealization {
    return SensorRealization.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SensorRealization>, I>>(object: I): SensorRealization {
    const message = createBaseSensorRealization();
    message.simulator = object.simulator ?? "";
    message.facility = object.facility ?? "";
    return message;
  },
};

function createBaseActuatorRealization(): ActuatorRealization {
  return { simulator: "", facility: "" };
}

export const ActuatorRealization = {
  encode(message: ActuatorRealization, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.simulator !== "") {
      writer.uint32(10).string(message.simulator);
    }
    if (message.facility !== "") {
      writer.uint32(18).string(message.facility);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActuatorRealization {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActuatorRealization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.simulator = reader.string();
          break;
        case 2:
          message.facility = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ActuatorRealization {
    return {
      simulator: isSet(object.simulator) ? String(object.simulator) : "",
      facility: isSet(object.facility) ? String(object.facility) : "",
    };
  },

  toJSON(message: ActuatorRealization): unknown {
    const obj: any = {};
    message.simulator !== undefined && (obj.simulator = message.simulator);
    message.facility !== undefined && (obj.facility = message.facility);
    return obj;
  },

  create<I extends Exact<DeepPartial<ActuatorRealization>, I>>(base?: I): ActuatorRealization {
    return ActuatorRealization.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ActuatorRealization>, I>>(object: I): ActuatorRealization {
    const message = createBaseActuatorRealization();
    message.simulator = object.simulator ?? "";
    message.facility = object.facility ?? "";
    return message;
  },
};

function createBaseLinkSegment(): LinkSegment {
  return { endpoints: [], waypoints: [] };
}

export const LinkSegment = {
  encode(message: LinkSegment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.endpoints) {
      Endpoint.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.waypoints) {
      Waypoint.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LinkSegment {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.endpoints.push(Endpoint.decode(reader, reader.uint32()));
          break;
        case 2:
          message.waypoints.push(Waypoint.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LinkSegment {
    return {
      endpoints: Array.isArray(object?.endpoints) ? object.endpoints.map((e: any) => Endpoint.fromJSON(e)) : [],
      waypoints: Array.isArray(object?.waypoints) ? object.waypoints.map((e: any) => Waypoint.fromJSON(e)) : [],
    };
  },

  toJSON(message: LinkSegment): unknown {
    const obj: any = {};
    if (message.endpoints) {
      obj.endpoints = message.endpoints.map((e) => e ? Endpoint.toJSON(e) : undefined);
    } else {
      obj.endpoints = [];
    }
    if (message.waypoints) {
      obj.waypoints = message.waypoints.map((e) => e ? Waypoint.toJSON(e) : undefined);
    } else {
      obj.waypoints = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkSegment>, I>>(base?: I): LinkSegment {
    return LinkSegment.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<LinkSegment>, I>>(object: I): LinkSegment {
    const message = createBaseLinkSegment();
    message.endpoints = object.endpoints?.map((e) => Endpoint.fromPartial(e)) || [];
    message.waypoints = object.waypoints?.map((e) => Waypoint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEndpoint(): Endpoint {
  return {
    facility: "",
    host: "",
    node: "",
    bridge: undefined,
    mac: "",
    phy: undefined,
    vlan: undefined,
    vtep: undefined,
    vf: undefined,
    trunk: undefined,
    evpn: undefined,
    mtu: 0,
    virtual: false,
  };
}

export const Endpoint = {
  encode(message: Endpoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.facility !== "") {
      writer.uint32(10).string(message.facility);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.node !== "") {
      writer.uint32(26).string(message.node);
    }
    if (message.bridge !== undefined) {
      BridgeMember.encode(message.bridge, writer.uint32(34).fork()).ldelim();
    }
    if (message.mac !== "") {
      writer.uint32(42).string(message.mac);
    }
    if (message.phy !== undefined) {
      PhysicalInterface.encode(message.phy, writer.uint32(50).fork()).ldelim();
    }
    if (message.vlan !== undefined) {
      VLANInterface.encode(message.vlan, writer.uint32(58).fork()).ldelim();
    }
    if (message.vtep !== undefined) {
      Vtep.encode(message.vtep, writer.uint32(66).fork()).ldelim();
    }
    if (message.vf !== undefined) {
      VFInterface.encode(message.vf, writer.uint32(98).fork()).ldelim();
    }
    if (message.trunk !== undefined) {
      VLANTrunkPort.encode(message.trunk, writer.uint32(106).fork()).ldelim();
    }
    if (message.evpn !== undefined) {
      Evpn.encode(message.evpn, writer.uint32(74).fork()).ldelim();
    }
    if (message.mtu !== 0) {
      writer.uint32(80).uint32(message.mtu);
    }
    if (message.virtual === true) {
      writer.uint32(88).bool(message.virtual);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Endpoint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.facility = reader.string();
          break;
        case 2:
          message.host = reader.string();
          break;
        case 3:
          message.node = reader.string();
          break;
        case 4:
          message.bridge = BridgeMember.decode(reader, reader.uint32());
          break;
        case 5:
          message.mac = reader.string();
          break;
        case 6:
          message.phy = PhysicalInterface.decode(reader, reader.uint32());
          break;
        case 7:
          message.vlan = VLANInterface.decode(reader, reader.uint32());
          break;
        case 8:
          message.vtep = Vtep.decode(reader, reader.uint32());
          break;
        case 12:
          message.vf = VFInterface.decode(reader, reader.uint32());
          break;
        case 13:
          message.trunk = VLANTrunkPort.decode(reader, reader.uint32());
          break;
        case 9:
          message.evpn = Evpn.decode(reader, reader.uint32());
          break;
        case 10:
          message.mtu = reader.uint32();
          break;
        case 11:
          message.virtual = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Endpoint {
    return {
      facility: isSet(object.facility) ? String(object.facility) : "",
      host: isSet(object.host) ? String(object.host) : "",
      node: isSet(object.node) ? String(object.node) : "",
      bridge: isSet(object.bridge) ? BridgeMember.fromJSON(object.bridge) : undefined,
      mac: isSet(object.mac) ? String(object.mac) : "",
      phy: isSet(object.phy) ? PhysicalInterface.fromJSON(object.phy) : undefined,
      vlan: isSet(object.vlan) ? VLANInterface.fromJSON(object.vlan) : undefined,
      vtep: isSet(object.vtep) ? Vtep.fromJSON(object.vtep) : undefined,
      vf: isSet(object.vf) ? VFInterface.fromJSON(object.vf) : undefined,
      trunk: isSet(object.trunk) ? VLANTrunkPort.fromJSON(object.trunk) : undefined,
      evpn: isSet(object.evpn) ? Evpn.fromJSON(object.evpn) : undefined,
      mtu: isSet(object.mtu) ? Number(object.mtu) : 0,
      virtual: isSet(object.virtual) ? Boolean(object.virtual) : false,
    };
  },

  toJSON(message: Endpoint): unknown {
    const obj: any = {};
    message.facility !== undefined && (obj.facility = message.facility);
    message.host !== undefined && (obj.host = message.host);
    message.node !== undefined && (obj.node = message.node);
    message.bridge !== undefined && (obj.bridge = message.bridge ? BridgeMember.toJSON(message.bridge) : undefined);
    message.mac !== undefined && (obj.mac = message.mac);
    message.phy !== undefined && (obj.phy = message.phy ? PhysicalInterface.toJSON(message.phy) : undefined);
    message.vlan !== undefined && (obj.vlan = message.vlan ? VLANInterface.toJSON(message.vlan) : undefined);
    message.vtep !== undefined && (obj.vtep = message.vtep ? Vtep.toJSON(message.vtep) : undefined);
    message.vf !== undefined && (obj.vf = message.vf ? VFInterface.toJSON(message.vf) : undefined);
    message.trunk !== undefined && (obj.trunk = message.trunk ? VLANTrunkPort.toJSON(message.trunk) : undefined);
    message.evpn !== undefined && (obj.evpn = message.evpn ? Evpn.toJSON(message.evpn) : undefined);
    message.mtu !== undefined && (obj.mtu = Math.round(message.mtu));
    message.virtual !== undefined && (obj.virtual = message.virtual);
    return obj;
  },

  create<I extends Exact<DeepPartial<Endpoint>, I>>(base?: I): Endpoint {
    return Endpoint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Endpoint>, I>>(object: I): Endpoint {
    const message = createBaseEndpoint();
    message.facility = object.facility ?? "";
    message.host = object.host ?? "";
    message.node = object.node ?? "";
    message.bridge = (object.bridge !== undefined && object.bridge !== null)
      ? BridgeMember.fromPartial(object.bridge)
      : undefined;
    message.mac = object.mac ?? "";
    message.phy = (object.phy !== undefined && object.phy !== null)
      ? PhysicalInterface.fromPartial(object.phy)
      : undefined;
    message.vlan = (object.vlan !== undefined && object.vlan !== null)
      ? VLANInterface.fromPartial(object.vlan)
      : undefined;
    message.vtep = (object.vtep !== undefined && object.vtep !== null) ? Vtep.fromPartial(object.vtep) : undefined;
    message.vf = (object.vf !== undefined && object.vf !== null) ? VFInterface.fromPartial(object.vf) : undefined;
    message.trunk = (object.trunk !== undefined && object.trunk !== null)
      ? VLANTrunkPort.fromPartial(object.trunk)
      : undefined;
    message.evpn = (object.evpn !== undefined && object.evpn !== null) ? Evpn.fromPartial(object.evpn) : undefined;
    message.mtu = object.mtu ?? 0;
    message.virtual = object.virtual ?? false;
    return message;
  },
};

function createBaseWaypoint(): Waypoint {
  return {
    facility: "",
    host: "",
    bridge: undefined,
    access: undefined,
    trunk: undefined,
    tap: undefined,
    vtep: undefined,
    bgpPeer: undefined,
    mtu: 0,
  };
}

export const Waypoint = {
  encode(message: Waypoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.facility !== "") {
      writer.uint32(10).string(message.facility);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.bridge !== undefined) {
      BridgeMember.encode(message.bridge, writer.uint32(26).fork()).ldelim();
    }
    if (message.access !== undefined) {
      VLANAccessPort.encode(message.access, writer.uint32(34).fork()).ldelim();
    }
    if (message.trunk !== undefined) {
      VLANTrunkPort.encode(message.trunk, writer.uint32(42).fork()).ldelim();
    }
    if (message.tap !== undefined) {
      VLANTapPort.encode(message.tap, writer.uint32(50).fork()).ldelim();
    }
    if (message.vtep !== undefined) {
      Vtep.encode(message.vtep, writer.uint32(58).fork()).ldelim();
    }
    if (message.bgpPeer !== undefined) {
      BGPPeer.encode(message.bgpPeer, writer.uint32(66).fork()).ldelim();
    }
    if (message.mtu !== 0) {
      writer.uint32(72).uint32(message.mtu);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Waypoint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaypoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.facility = reader.string();
          break;
        case 2:
          message.host = reader.string();
          break;
        case 3:
          message.bridge = BridgeMember.decode(reader, reader.uint32());
          break;
        case 4:
          message.access = VLANAccessPort.decode(reader, reader.uint32());
          break;
        case 5:
          message.trunk = VLANTrunkPort.decode(reader, reader.uint32());
          break;
        case 6:
          message.tap = VLANTapPort.decode(reader, reader.uint32());
          break;
        case 7:
          message.vtep = Vtep.decode(reader, reader.uint32());
          break;
        case 8:
          message.bgpPeer = BGPPeer.decode(reader, reader.uint32());
          break;
        case 9:
          message.mtu = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Waypoint {
    return {
      facility: isSet(object.facility) ? String(object.facility) : "",
      host: isSet(object.host) ? String(object.host) : "",
      bridge: isSet(object.bridge) ? BridgeMember.fromJSON(object.bridge) : undefined,
      access: isSet(object.access) ? VLANAccessPort.fromJSON(object.access) : undefined,
      trunk: isSet(object.trunk) ? VLANTrunkPort.fromJSON(object.trunk) : undefined,
      tap: isSet(object.tap) ? VLANTapPort.fromJSON(object.tap) : undefined,
      vtep: isSet(object.vtep) ? Vtep.fromJSON(object.vtep) : undefined,
      bgpPeer: isSet(object.bgpPeer) ? BGPPeer.fromJSON(object.bgpPeer) : undefined,
      mtu: isSet(object.mtu) ? Number(object.mtu) : 0,
    };
  },

  toJSON(message: Waypoint): unknown {
    const obj: any = {};
    message.facility !== undefined && (obj.facility = message.facility);
    message.host !== undefined && (obj.host = message.host);
    message.bridge !== undefined && (obj.bridge = message.bridge ? BridgeMember.toJSON(message.bridge) : undefined);
    message.access !== undefined && (obj.access = message.access ? VLANAccessPort.toJSON(message.access) : undefined);
    message.trunk !== undefined && (obj.trunk = message.trunk ? VLANTrunkPort.toJSON(message.trunk) : undefined);
    message.tap !== undefined && (obj.tap = message.tap ? VLANTapPort.toJSON(message.tap) : undefined);
    message.vtep !== undefined && (obj.vtep = message.vtep ? Vtep.toJSON(message.vtep) : undefined);
    message.bgpPeer !== undefined && (obj.bgpPeer = message.bgpPeer ? BGPPeer.toJSON(message.bgpPeer) : undefined);
    message.mtu !== undefined && (obj.mtu = Math.round(message.mtu));
    return obj;
  },

  create<I extends Exact<DeepPartial<Waypoint>, I>>(base?: I): Waypoint {
    return Waypoint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Waypoint>, I>>(object: I): Waypoint {
    const message = createBaseWaypoint();
    message.facility = object.facility ?? "";
    message.host = object.host ?? "";
    message.bridge = (object.bridge !== undefined && object.bridge !== null)
      ? BridgeMember.fromPartial(object.bridge)
      : undefined;
    message.access = (object.access !== undefined && object.access !== null)
      ? VLANAccessPort.fromPartial(object.access)
      : undefined;
    message.trunk = (object.trunk !== undefined && object.trunk !== null)
      ? VLANTrunkPort.fromPartial(object.trunk)
      : undefined;
    message.tap = (object.tap !== undefined && object.tap !== null) ? VLANTapPort.fromPartial(object.tap) : undefined;
    message.vtep = (object.vtep !== undefined && object.vtep !== null) ? Vtep.fromPartial(object.vtep) : undefined;
    message.bgpPeer = (object.bgpPeer !== undefined && object.bgpPeer !== null)
      ? BGPPeer.fromPartial(object.bgpPeer)
      : undefined;
    message.mtu = object.mtu ?? 0;
    return message;
  },
};

function createBaseBridgeMember(): BridgeMember {
  return { bridge: "", untagged: [], tagged: [], pvid: 0 };
}

export const BridgeMember = {
  encode(message: BridgeMember, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bridge !== "") {
      writer.uint32(10).string(message.bridge);
    }
    writer.uint32(18).fork();
    for (const v of message.untagged) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.tagged) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.pvid !== 0) {
      writer.uint32(32).uint32(message.pvid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BridgeMember {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBridgeMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bridge = reader.string();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.untagged.push(reader.uint32());
            }
          } else {
            message.untagged.push(reader.uint32());
          }
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.tagged.push(reader.uint32());
            }
          } else {
            message.tagged.push(reader.uint32());
          }
          break;
        case 4:
          message.pvid = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BridgeMember {
    return {
      bridge: isSet(object.bridge) ? String(object.bridge) : "",
      untagged: Array.isArray(object?.untagged) ? object.untagged.map((e: any) => Number(e)) : [],
      tagged: Array.isArray(object?.tagged) ? object.tagged.map((e: any) => Number(e)) : [],
      pvid: isSet(object.pvid) ? Number(object.pvid) : 0,
    };
  },

  toJSON(message: BridgeMember): unknown {
    const obj: any = {};
    message.bridge !== undefined && (obj.bridge = message.bridge);
    if (message.untagged) {
      obj.untagged = message.untagged.map((e) => Math.round(e));
    } else {
      obj.untagged = [];
    }
    if (message.tagged) {
      obj.tagged = message.tagged.map((e) => Math.round(e));
    } else {
      obj.tagged = [];
    }
    message.pvid !== undefined && (obj.pvid = Math.round(message.pvid));
    return obj;
  },

  create<I extends Exact<DeepPartial<BridgeMember>, I>>(base?: I): BridgeMember {
    return BridgeMember.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<BridgeMember>, I>>(object: I): BridgeMember {
    const message = createBaseBridgeMember();
    message.bridge = object.bridge ?? "";
    message.untagged = object.untagged?.map((e) => e) || [];
    message.tagged = object.tagged?.map((e) => e) || [];
    message.pvid = object.pvid ?? 0;
    return message;
  },
};

function createBaseEvpn(): Evpn {
  return { mac: undefined, multicast: undefined };
}

export const Evpn = {
  encode(message: Evpn, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mac !== undefined) {
      EvpnMacAdv.encode(message.mac, writer.uint32(10).fork()).ldelim();
    }
    if (message.multicast !== undefined) {
      EvpnMulticastAdv.encode(message.multicast, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Evpn {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvpn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mac = EvpnMacAdv.decode(reader, reader.uint32());
          break;
        case 2:
          message.multicast = EvpnMulticastAdv.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Evpn {
    return {
      mac: isSet(object.mac) ? EvpnMacAdv.fromJSON(object.mac) : undefined,
      multicast: isSet(object.multicast) ? EvpnMulticastAdv.fromJSON(object.multicast) : undefined,
    };
  },

  toJSON(message: Evpn): unknown {
    const obj: any = {};
    message.mac !== undefined && (obj.mac = message.mac ? EvpnMacAdv.toJSON(message.mac) : undefined);
    message.multicast !== undefined &&
      (obj.multicast = message.multicast ? EvpnMulticastAdv.toJSON(message.multicast) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Evpn>, I>>(base?: I): Evpn {
    return Evpn.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Evpn>, I>>(object: I): Evpn {
    const message = createBaseEvpn();
    message.mac = (object.mac !== undefined && object.mac !== null) ? EvpnMacAdv.fromPartial(object.mac) : undefined;
    message.multicast = (object.multicast !== undefined && object.multicast !== null)
      ? EvpnMulticastAdv.fromPartial(object.multicast)
      : undefined;
    return message;
  },
};

function createBaseEvpnMacAdv(): EvpnMacAdv {
  return { mac: "", tunnelIp: "", vni: 0 };
}

export const EvpnMacAdv = {
  encode(message: EvpnMacAdv, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mac !== "") {
      writer.uint32(10).string(message.mac);
    }
    if (message.tunnelIp !== "") {
      writer.uint32(18).string(message.tunnelIp);
    }
    if (message.vni !== 0) {
      writer.uint32(24).uint32(message.vni);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EvpnMacAdv {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvpnMacAdv();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mac = reader.string();
          break;
        case 2:
          message.tunnelIp = reader.string();
          break;
        case 3:
          message.vni = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EvpnMacAdv {
    return {
      mac: isSet(object.mac) ? String(object.mac) : "",
      tunnelIp: isSet(object.tunnelIp) ? String(object.tunnelIp) : "",
      vni: isSet(object.vni) ? Number(object.vni) : 0,
    };
  },

  toJSON(message: EvpnMacAdv): unknown {
    const obj: any = {};
    message.mac !== undefined && (obj.mac = message.mac);
    message.tunnelIp !== undefined && (obj.tunnelIp = message.tunnelIp);
    message.vni !== undefined && (obj.vni = Math.round(message.vni));
    return obj;
  },

  create<I extends Exact<DeepPartial<EvpnMacAdv>, I>>(base?: I): EvpnMacAdv {
    return EvpnMacAdv.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<EvpnMacAdv>, I>>(object: I): EvpnMacAdv {
    const message = createBaseEvpnMacAdv();
    message.mac = object.mac ?? "";
    message.tunnelIp = object.tunnelIp ?? "";
    message.vni = object.vni ?? 0;
    return message;
  },
};

function createBaseEvpnMulticastAdv(): EvpnMulticastAdv {
  return { tunnelIp: "", vni: 0 };
}

export const EvpnMulticastAdv = {
  encode(message: EvpnMulticastAdv, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tunnelIp !== "") {
      writer.uint32(10).string(message.tunnelIp);
    }
    if (message.vni !== 0) {
      writer.uint32(16).uint32(message.vni);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EvpnMulticastAdv {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvpnMulticastAdv();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tunnelIp = reader.string();
          break;
        case 2:
          message.vni = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EvpnMulticastAdv {
    return {
      tunnelIp: isSet(object.tunnelIp) ? String(object.tunnelIp) : "",
      vni: isSet(object.vni) ? Number(object.vni) : 0,
    };
  },

  toJSON(message: EvpnMulticastAdv): unknown {
    const obj: any = {};
    message.tunnelIp !== undefined && (obj.tunnelIp = message.tunnelIp);
    message.vni !== undefined && (obj.vni = Math.round(message.vni));
    return obj;
  },

  create<I extends Exact<DeepPartial<EvpnMulticastAdv>, I>>(base?: I): EvpnMulticastAdv {
    return EvpnMulticastAdv.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<EvpnMulticastAdv>, I>>(object: I): EvpnMulticastAdv {
    const message = createBaseEvpnMulticastAdv();
    message.tunnelIp = object.tunnelIp ?? "";
    message.vni = object.vni ?? 0;
    return message;
  },
};

function createBasePhysicalInterface(): PhysicalInterface {
  return { name: "", mac: "", portIndex: 0 };
}

export const PhysicalInterface = {
  encode(message: PhysicalInterface, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.mac !== "") {
      writer.uint32(18).string(message.mac);
    }
    if (message.portIndex !== 0) {
      writer.uint32(24).uint32(message.portIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PhysicalInterface {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhysicalInterface();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.mac = reader.string();
          break;
        case 3:
          message.portIndex = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PhysicalInterface {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      mac: isSet(object.mac) ? String(object.mac) : "",
      portIndex: isSet(object.portIndex) ? Number(object.portIndex) : 0,
    };
  },

  toJSON(message: PhysicalInterface): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.mac !== undefined && (obj.mac = message.mac);
    message.portIndex !== undefined && (obj.portIndex = Math.round(message.portIndex));
    return obj;
  },

  create<I extends Exact<DeepPartial<PhysicalInterface>, I>>(base?: I): PhysicalInterface {
    return PhysicalInterface.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<PhysicalInterface>, I>>(object: I): PhysicalInterface {
    const message = createBasePhysicalInterface();
    message.name = object.name ?? "";
    message.mac = object.mac ?? "";
    message.portIndex = object.portIndex ?? 0;
    return message;
  },
};

function createBaseVirtualFunction(): VirtualFunction {
  return { name: "", Pf: undefined, VfIndex: 0, mac: "" };
}

export const VirtualFunction = {
  encode(message: VirtualFunction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.Pf !== undefined) {
      PhysicalInterface.encode(message.Pf, writer.uint32(18).fork()).ldelim();
    }
    if (message.VfIndex !== 0) {
      writer.uint32(24).uint32(message.VfIndex);
    }
    if (message.mac !== "") {
      writer.uint32(34).string(message.mac);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VirtualFunction {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualFunction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.Pf = PhysicalInterface.decode(reader, reader.uint32());
          break;
        case 3:
          message.VfIndex = reader.uint32();
          break;
        case 4:
          message.mac = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): VirtualFunction {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      Pf: isSet(object.Pf) ? PhysicalInterface.fromJSON(object.Pf) : undefined,
      VfIndex: isSet(object.VfIndex) ? Number(object.VfIndex) : 0,
      mac: isSet(object.mac) ? String(object.mac) : "",
    };
  },

  toJSON(message: VirtualFunction): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.Pf !== undefined && (obj.Pf = message.Pf ? PhysicalInterface.toJSON(message.Pf) : undefined);
    message.VfIndex !== undefined && (obj.VfIndex = Math.round(message.VfIndex));
    message.mac !== undefined && (obj.mac = message.mac);
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtualFunction>, I>>(base?: I): VirtualFunction {
    return VirtualFunction.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<VirtualFunction>, I>>(object: I): VirtualFunction {
    const message = createBaseVirtualFunction();
    message.name = object.name ?? "";
    message.Pf = (object.Pf !== undefined && object.Pf !== null) ? PhysicalInterface.fromPartial(object.Pf) : undefined;
    message.VfIndex = object.VfIndex ?? 0;
    message.mac = object.mac ?? "";
    return message;
  },
};

function createBaseVLANInterface(): VLANInterface {
  return { name: "", vid: 0, parent: undefined, addrs: [] };
}

export const VLANInterface = {
  encode(message: VLANInterface, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.vid !== 0) {
      writer.uint32(16).uint32(message.vid);
    }
    if (message.parent !== undefined) {
      PhysicalInterface.encode(message.parent, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.addrs) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VLANInterface {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVLANInterface();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.vid = reader.uint32();
          break;
        case 3:
          message.parent = PhysicalInterface.decode(reader, reader.uint32());
          break;
        case 4:
          message.addrs.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): VLANInterface {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      vid: isSet(object.vid) ? Number(object.vid) : 0,
      parent: isSet(object.parent) ? PhysicalInterface.fromJSON(object.parent) : undefined,
      addrs: Array.isArray(object?.addrs) ? object.addrs.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: VLANInterface): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.vid !== undefined && (obj.vid = Math.round(message.vid));
    message.parent !== undefined &&
      (obj.parent = message.parent ? PhysicalInterface.toJSON(message.parent) : undefined);
    if (message.addrs) {
      obj.addrs = message.addrs.map((e) => e);
    } else {
      obj.addrs = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VLANInterface>, I>>(base?: I): VLANInterface {
    return VLANInterface.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<VLANInterface>, I>>(object: I): VLANInterface {
    const message = createBaseVLANInterface();
    message.name = object.name ?? "";
    message.vid = object.vid ?? 0;
    message.parent = (object.parent !== undefined && object.parent !== null)
      ? PhysicalInterface.fromPartial(object.parent)
      : undefined;
    message.addrs = object.addrs?.map((e) => e) || [];
    return message;
  },
};

function createBaseVFInterface(): VFInterface {
  return { virtif: undefined, parent: undefined, vid: 0, addrs: [] };
}

export const VFInterface = {
  encode(message: VFInterface, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.virtif !== undefined) {
      PhysicalInterface.encode(message.virtif, writer.uint32(10).fork()).ldelim();
    }
    if (message.parent !== undefined) {
      VirtualFunction.encode(message.parent, writer.uint32(18).fork()).ldelim();
    }
    if (message.vid !== 0) {
      writer.uint32(24).uint32(message.vid);
    }
    for (const v of message.addrs) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VFInterface {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVFInterface();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.virtif = PhysicalInterface.decode(reader, reader.uint32());
          break;
        case 2:
          message.parent = VirtualFunction.decode(reader, reader.uint32());
          break;
        case 3:
          message.vid = reader.uint32();
          break;
        case 4:
          message.addrs.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): VFInterface {
    return {
      virtif: isSet(object.virtif) ? PhysicalInterface.fromJSON(object.virtif) : undefined,
      parent: isSet(object.parent) ? VirtualFunction.fromJSON(object.parent) : undefined,
      vid: isSet(object.vid) ? Number(object.vid) : 0,
      addrs: Array.isArray(object?.addrs) ? object.addrs.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: VFInterface): unknown {
    const obj: any = {};
    message.virtif !== undefined &&
      (obj.virtif = message.virtif ? PhysicalInterface.toJSON(message.virtif) : undefined);
    message.parent !== undefined && (obj.parent = message.parent ? VirtualFunction.toJSON(message.parent) : undefined);
    message.vid !== undefined && (obj.vid = Math.round(message.vid));
    if (message.addrs) {
      obj.addrs = message.addrs.map((e) => e);
    } else {
      obj.addrs = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VFInterface>, I>>(base?: I): VFInterface {
    return VFInterface.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<VFInterface>, I>>(object: I): VFInterface {
    const message = createBaseVFInterface();
    message.virtif = (object.virtif !== undefined && object.virtif !== null)
      ? PhysicalInterface.fromPartial(object.virtif)
      : undefined;
    message.parent = (object.parent !== undefined && object.parent !== null)
      ? VirtualFunction.fromPartial(object.parent)
      : undefined;
    message.vid = object.vid ?? 0;
    message.addrs = object.addrs?.map((e) => e) || [];
    return message;
  },
};

function createBaseVtep(): Vtep {
  return { name: "", vni: 0, parent: undefined, tunnelIp: "" };
}

export const Vtep = {
  encode(message: Vtep, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.vni !== 0) {
      writer.uint32(16).uint32(message.vni);
    }
    if (message.parent !== undefined) {
      PhysicalInterface.encode(message.parent, writer.uint32(26).fork()).ldelim();
    }
    if (message.tunnelIp !== "") {
      writer.uint32(34).string(message.tunnelIp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Vtep {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVtep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.vni = reader.uint32();
          break;
        case 3:
          message.parent = PhysicalInterface.decode(reader, reader.uint32());
          break;
        case 4:
          message.tunnelIp = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Vtep {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      vni: isSet(object.vni) ? Number(object.vni) : 0,
      parent: isSet(object.parent) ? PhysicalInterface.fromJSON(object.parent) : undefined,
      tunnelIp: isSet(object.tunnelIp) ? String(object.tunnelIp) : "",
    };
  },

  toJSON(message: Vtep): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.vni !== undefined && (obj.vni = Math.round(message.vni));
    message.parent !== undefined &&
      (obj.parent = message.parent ? PhysicalInterface.toJSON(message.parent) : undefined);
    message.tunnelIp !== undefined && (obj.tunnelIp = message.tunnelIp);
    return obj;
  },

  create<I extends Exact<DeepPartial<Vtep>, I>>(base?: I): Vtep {
    return Vtep.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Vtep>, I>>(object: I): Vtep {
    const message = createBaseVtep();
    message.name = object.name ?? "";
    message.vni = object.vni ?? 0;
    message.parent = (object.parent !== undefined && object.parent !== null)
      ? PhysicalInterface.fromPartial(object.parent)
      : undefined;
    message.tunnelIp = object.tunnelIp ?? "";
    return message;
  },
};

function createBaseBGPPeer(): BGPPeer {
  return { interface: undefined, localAsn: 0, remoteAsn: 0, network: "" };
}

export const BGPPeer = {
  encode(message: BGPPeer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.interface !== undefined) {
      PhysicalInterface.encode(message.interface, writer.uint32(10).fork()).ldelim();
    }
    if (message.localAsn !== 0) {
      writer.uint32(16).uint32(message.localAsn);
    }
    if (message.remoteAsn !== 0) {
      writer.uint32(24).uint32(message.remoteAsn);
    }
    if (message.network !== "") {
      writer.uint32(34).string(message.network);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BGPPeer {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBGPPeer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.interface = PhysicalInterface.decode(reader, reader.uint32());
          break;
        case 2:
          message.localAsn = reader.uint32();
          break;
        case 3:
          message.remoteAsn = reader.uint32();
          break;
        case 4:
          message.network = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BGPPeer {
    return {
      interface: isSet(object.interface) ? PhysicalInterface.fromJSON(object.interface) : undefined,
      localAsn: isSet(object.localAsn) ? Number(object.localAsn) : 0,
      remoteAsn: isSet(object.remoteAsn) ? Number(object.remoteAsn) : 0,
      network: isSet(object.network) ? String(object.network) : "",
    };
  },

  toJSON(message: BGPPeer): unknown {
    const obj: any = {};
    message.interface !== undefined &&
      (obj.interface = message.interface ? PhysicalInterface.toJSON(message.interface) : undefined);
    message.localAsn !== undefined && (obj.localAsn = Math.round(message.localAsn));
    message.remoteAsn !== undefined && (obj.remoteAsn = Math.round(message.remoteAsn));
    message.network !== undefined && (obj.network = message.network);
    return obj;
  },

  create<I extends Exact<DeepPartial<BGPPeer>, I>>(base?: I): BGPPeer {
    return BGPPeer.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<BGPPeer>, I>>(object: I): BGPPeer {
    const message = createBaseBGPPeer();
    message.interface = (object.interface !== undefined && object.interface !== null)
      ? PhysicalInterface.fromPartial(object.interface)
      : undefined;
    message.localAsn = object.localAsn ?? 0;
    message.remoteAsn = object.remoteAsn ?? 0;
    message.network = object.network ?? "";
    return message;
  },
};

function createBaseVLANAccessPort(): VLANAccessPort {
  return { port: undefined, vid: 0 };
}

export const VLANAccessPort = {
  encode(message: VLANAccessPort, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.port !== undefined) {
      PhysicalInterface.encode(message.port, writer.uint32(10).fork()).ldelim();
    }
    if (message.vid !== 0) {
      writer.uint32(16).uint32(message.vid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VLANAccessPort {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVLANAccessPort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.port = PhysicalInterface.decode(reader, reader.uint32());
          break;
        case 2:
          message.vid = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): VLANAccessPort {
    return {
      port: isSet(object.port) ? PhysicalInterface.fromJSON(object.port) : undefined,
      vid: isSet(object.vid) ? Number(object.vid) : 0,
    };
  },

  toJSON(message: VLANAccessPort): unknown {
    const obj: any = {};
    message.port !== undefined && (obj.port = message.port ? PhysicalInterface.toJSON(message.port) : undefined);
    message.vid !== undefined && (obj.vid = Math.round(message.vid));
    return obj;
  },

  create<I extends Exact<DeepPartial<VLANAccessPort>, I>>(base?: I): VLANAccessPort {
    return VLANAccessPort.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<VLANAccessPort>, I>>(object: I): VLANAccessPort {
    const message = createBaseVLANAccessPort();
    message.port = (object.port !== undefined && object.port !== null)
      ? PhysicalInterface.fromPartial(object.port)
      : undefined;
    message.vid = object.vid ?? 0;
    return message;
  },
};

function createBaseVLANTrunkPort(): VLANTrunkPort {
  return { port: undefined, vids: [] };
}

export const VLANTrunkPort = {
  encode(message: VLANTrunkPort, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.port !== undefined) {
      PhysicalInterface.encode(message.port, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).fork();
    for (const v of message.vids) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VLANTrunkPort {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVLANTrunkPort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.port = PhysicalInterface.decode(reader, reader.uint32());
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vids.push(reader.uint32());
            }
          } else {
            message.vids.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): VLANTrunkPort {
    return {
      port: isSet(object.port) ? PhysicalInterface.fromJSON(object.port) : undefined,
      vids: Array.isArray(object?.vids) ? object.vids.map((e: any) => Number(e)) : [],
    };
  },

  toJSON(message: VLANTrunkPort): unknown {
    const obj: any = {};
    message.port !== undefined && (obj.port = message.port ? PhysicalInterface.toJSON(message.port) : undefined);
    if (message.vids) {
      obj.vids = message.vids.map((e) => Math.round(e));
    } else {
      obj.vids = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VLANTrunkPort>, I>>(base?: I): VLANTrunkPort {
    return VLANTrunkPort.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<VLANTrunkPort>, I>>(object: I): VLANTrunkPort {
    const message = createBaseVLANTrunkPort();
    message.port = (object.port !== undefined && object.port !== null)
      ? PhysicalInterface.fromPartial(object.port)
      : undefined;
    message.vids = object.vids?.map((e) => e) || [];
    return message;
  },
};

function createBaseVLANTapPort(): VLANTapPort {
  return { node: "", frontend: undefined, vid: 0 };
}

export const VLANTapPort = {
  encode(message: VLANTapPort, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.node !== "") {
      writer.uint32(10).string(message.node);
    }
    if (message.frontend !== undefined) {
      PhysicalInterface.encode(message.frontend, writer.uint32(18).fork()).ldelim();
    }
    if (message.vid !== 0) {
      writer.uint32(24).uint32(message.vid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VLANTapPort {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVLANTapPort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.node = reader.string();
          break;
        case 2:
          message.frontend = PhysicalInterface.decode(reader, reader.uint32());
          break;
        case 3:
          message.vid = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): VLANTapPort {
    return {
      node: isSet(object.node) ? String(object.node) : "",
      frontend: isSet(object.frontend) ? PhysicalInterface.fromJSON(object.frontend) : undefined,
      vid: isSet(object.vid) ? Number(object.vid) : 0,
    };
  },

  toJSON(message: VLANTapPort): unknown {
    const obj: any = {};
    message.node !== undefined && (obj.node = message.node);
    message.frontend !== undefined &&
      (obj.frontend = message.frontend ? PhysicalInterface.toJSON(message.frontend) : undefined);
    message.vid !== undefined && (obj.vid = Math.round(message.vid));
    return obj;
  },

  create<I extends Exact<DeepPartial<VLANTapPort>, I>>(base?: I): VLANTapPort {
    return VLANTapPort.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<VLANTapPort>, I>>(object: I): VLANTapPort {
    const message = createBaseVLANTapPort();
    message.node = object.node ?? "";
    message.frontend = (object.frontend !== undefined && object.frontend !== null)
      ? PhysicalInterface.fromPartial(object.frontend)
      : undefined;
    message.vid = object.vid ?? 0;
    return message;
  },
};

function createBaseVLANVfPort(): VLANVfPort {
  return { vf: undefined, frontend: undefined, vid: 0 };
}

export const VLANVfPort = {
  encode(message: VLANVfPort, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.vf !== undefined) {
      VirtualFunction.encode(message.vf, writer.uint32(10).fork()).ldelim();
    }
    if (message.frontend !== undefined) {
      PhysicalInterface.encode(message.frontend, writer.uint32(18).fork()).ldelim();
    }
    if (message.vid !== 0) {
      writer.uint32(24).uint32(message.vid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VLANVfPort {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVLANVfPort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.vf = VirtualFunction.decode(reader, reader.uint32());
          break;
        case 2:
          message.frontend = PhysicalInterface.decode(reader, reader.uint32());
          break;
        case 3:
          message.vid = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): VLANVfPort {
    return {
      vf: isSet(object.vf) ? VirtualFunction.fromJSON(object.vf) : undefined,
      frontend: isSet(object.frontend) ? PhysicalInterface.fromJSON(object.frontend) : undefined,
      vid: isSet(object.vid) ? Number(object.vid) : 0,
    };
  },

  toJSON(message: VLANVfPort): unknown {
    const obj: any = {};
    message.vf !== undefined && (obj.vf = message.vf ? VirtualFunction.toJSON(message.vf) : undefined);
    message.frontend !== undefined &&
      (obj.frontend = message.frontend ? PhysicalInterface.toJSON(message.frontend) : undefined);
    message.vid !== undefined && (obj.vid = Math.round(message.vid));
    return obj;
  },

  create<I extends Exact<DeepPartial<VLANVfPort>, I>>(base?: I): VLANVfPort {
    return VLANVfPort.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<VLANVfPort>, I>>(object: I): VLANVfPort {
    const message = createBaseVLANVfPort();
    message.vf = (object.vf !== undefined && object.vf !== null) ? VirtualFunction.fromPartial(object.vf) : undefined;
    message.frontend = (object.frontend !== undefined && object.frontend !== null)
      ? PhysicalInterface.fromPartial(object.frontend)
      : undefined;
    message.vid = object.vid ?? 0;
    return message;
  },
};

function createBaseDiagnostic(): Diagnostic {
  return { message: "", level: 0, data: {}, guest: "", host: "" };
}

export const Diagnostic = {
  encode(message: Diagnostic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.level !== 0) {
      writer.uint32(16).int32(message.level);
    }
    Object.entries(message.data).forEach(([key, value]) => {
      Diagnostic_DataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.guest !== "") {
      writer.uint32(34).string(message.guest);
    }
    if (message.host !== "") {
      writer.uint32(42).string(message.host);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Diagnostic {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnostic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.message = reader.string();
          break;
        case 2:
          message.level = reader.int32() as any;
          break;
        case 3:
          const entry3 = Diagnostic_DataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.data[entry3.key] = entry3.value;
          }
          break;
        case 4:
          message.guest = reader.string();
          break;
        case 5:
          message.host = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Diagnostic {
    return {
      message: isSet(object.message) ? String(object.message) : "",
      level: isSet(object.level) ? diagnosticLevelFromJSON(object.level) : 0,
      data: isObject(object.data)
        ? Object.entries(object.data).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      guest: isSet(object.guest) ? String(object.guest) : "",
      host: isSet(object.host) ? String(object.host) : "",
    };
  },

  toJSON(message: Diagnostic): unknown {
    const obj: any = {};
    message.message !== undefined && (obj.message = message.message);
    message.level !== undefined && (obj.level = diagnosticLevelToJSON(message.level));
    obj.data = {};
    if (message.data) {
      Object.entries(message.data).forEach(([k, v]) => {
        obj.data[k] = v;
      });
    }
    message.guest !== undefined && (obj.guest = message.guest);
    message.host !== undefined && (obj.host = message.host);
    return obj;
  },

  create<I extends Exact<DeepPartial<Diagnostic>, I>>(base?: I): Diagnostic {
    return Diagnostic.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Diagnostic>, I>>(object: I): Diagnostic {
    const message = createBaseDiagnostic();
    message.message = object.message ?? "";
    message.level = object.level ?? 0;
    message.data = Object.entries(object.data ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = String(value);
      }
      return acc;
    }, {});
    message.guest = object.guest ?? "";
    message.host = object.host ?? "";
    return message;
  },
};

function createBaseDiagnostic_DataEntry(): Diagnostic_DataEntry {
  return { key: "", value: "" };
}

export const Diagnostic_DataEntry = {
  encode(message: Diagnostic_DataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Diagnostic_DataEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnostic_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Diagnostic_DataEntry {
    return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
  },

  toJSON(message: Diagnostic_DataEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  create<I extends Exact<DeepPartial<Diagnostic_DataEntry>, I>>(base?: I): Diagnostic_DataEntry {
    return Diagnostic_DataEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Diagnostic_DataEntry>, I>>(object: I): Diagnostic_DataEntry {
    const message = createBaseDiagnostic_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDiagnosticList(): DiagnosticList {
  return { value: [] };
}

export const DiagnosticList = {
  encode(message: DiagnosticList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.value) {
      Diagnostic.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DiagnosticList {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnosticList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value.push(Diagnostic.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DiagnosticList {
    return { value: Array.isArray(object?.value) ? object.value.map((e: any) => Diagnostic.fromJSON(e)) : [] };
  },

  toJSON(message: DiagnosticList): unknown {
    const obj: any = {};
    if (message.value) {
      obj.value = message.value.map((e) => e ? Diagnostic.toJSON(e) : undefined);
    } else {
      obj.value = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiagnosticList>, I>>(base?: I): DiagnosticList {
    return DiagnosticList.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DiagnosticList>, I>>(object: I): DiagnosticList {
    const message = createBaseDiagnosticList();
    message.value = object.value?.map((e) => Diagnostic.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLinkEmulation(): LinkEmulation {
  return { loss: 0, capacity: 0, latency: 0, tags: [], interfaces: [], nodes: [], server: "" };
}

export const LinkEmulation = {
  encode(message: LinkEmulation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.loss !== 0) {
      writer.uint32(13).float(message.loss);
    }
    if (message.capacity !== 0) {
      writer.uint32(16).uint64(message.capacity);
    }
    if (message.latency !== 0) {
      writer.uint32(24).uint64(message.latency);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.interfaces) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.nodes) {
      writer.uint32(50).string(v!);
    }
    if (message.server !== "") {
      writer.uint32(58).string(message.server);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LinkEmulation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkEmulation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.loss = reader.float();
          break;
        case 2:
          message.capacity = longToNumber(reader.uint64() as Long);
          break;
        case 3:
          message.latency = longToNumber(reader.uint64() as Long);
          break;
        case 4:
          message.tags.push(reader.string());
          break;
        case 5:
          message.interfaces.push(reader.string());
          break;
        case 6:
          message.nodes.push(reader.string());
          break;
        case 7:
          message.server = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LinkEmulation {
    return {
      loss: isSet(object.loss) ? Number(object.loss) : 0,
      capacity: isSet(object.capacity) ? Number(object.capacity) : 0,
      latency: isSet(object.latency) ? Number(object.latency) : 0,
      tags: Array.isArray(object?.tags) ? object.tags.map((e: any) => String(e)) : [],
      interfaces: Array.isArray(object?.interfaces) ? object.interfaces.map((e: any) => String(e)) : [],
      nodes: Array.isArray(object?.nodes) ? object.nodes.map((e: any) => String(e)) : [],
      server: isSet(object.server) ? String(object.server) : "",
    };
  },

  toJSON(message: LinkEmulation): unknown {
    const obj: any = {};
    message.loss !== undefined && (obj.loss = message.loss);
    message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
    message.latency !== undefined && (obj.latency = Math.round(message.latency));
    if (message.tags) {
      obj.tags = message.tags.map((e) => e);
    } else {
      obj.tags = [];
    }
    if (message.interfaces) {
      obj.interfaces = message.interfaces.map((e) => e);
    } else {
      obj.interfaces = [];
    }
    if (message.nodes) {
      obj.nodes = message.nodes.map((e) => e);
    } else {
      obj.nodes = [];
    }
    message.server !== undefined && (obj.server = message.server);
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkEmulation>, I>>(base?: I): LinkEmulation {
    return LinkEmulation.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<LinkEmulation>, I>>(object: I): LinkEmulation {
    const message = createBaseLinkEmulation();
    message.loss = object.loss ?? 0;
    message.capacity = object.capacity ?? 0;
    message.latency = object.latency ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.interfaces = object.interfaces?.map((e) => e) || [];
    message.nodes = object.nodes?.map((e) => e) || [];
    message.server = object.server ?? "";
    return message;
  },
};

function createBaseLinkEmulationParams(): LinkEmulationParams {
  return { server: "", links: [], backend: 0 };
}

export const LinkEmulationParams = {
  encode(message: LinkEmulationParams, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.server !== "") {
      writer.uint32(10).string(message.server);
    }
    for (const v of message.links) {
      LinkEmulation.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.backend !== 0) {
      writer.uint32(24).int32(message.backend);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LinkEmulationParams {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkEmulationParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.server = reader.string();
          break;
        case 2:
          message.links.push(LinkEmulation.decode(reader, reader.uint32()));
          break;
        case 3:
          message.backend = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LinkEmulationParams {
    return {
      server: isSet(object.server) ? String(object.server) : "",
      links: Array.isArray(object?.links) ? object.links.map((e: any) => LinkEmulation.fromJSON(e)) : [],
      backend: isSet(object.backend) ? emulationFromJSON(object.backend) : 0,
    };
  },

  toJSON(message: LinkEmulationParams): unknown {
    const obj: any = {};
    message.server !== undefined && (obj.server = message.server);
    if (message.links) {
      obj.links = message.links.map((e) => e ? LinkEmulation.toJSON(e) : undefined);
    } else {
      obj.links = [];
    }
    message.backend !== undefined && (obj.backend = emulationToJSON(message.backend));
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkEmulationParams>, I>>(base?: I): LinkEmulationParams {
    return LinkEmulationParams.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<LinkEmulationParams>, I>>(object: I): LinkEmulationParams {
    const message = createBaseLinkEmulationParams();
    message.server = object.server ?? "";
    message.links = object.links?.map((e) => LinkEmulation.fromPartial(e)) || [];
    message.backend = object.backend ?? 0;
    return message;
  },
};

function createBaseRealizationResult(): RealizationResult {
  return { realization: undefined, diagnostics: undefined };
}

export const RealizationResult = {
  encode(message: RealizationResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.realization !== undefined) {
      Realization.encode(message.realization, writer.uint32(10).fork()).ldelim();
    }
    if (message.diagnostics !== undefined) {
      DiagnosticList.encode(message.diagnostics, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RealizationResult {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRealizationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.realization = Realization.decode(reader, reader.uint32());
          break;
        case 2:
          message.diagnostics = DiagnosticList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RealizationResult {
    return {
      realization: isSet(object.realization) ? Realization.fromJSON(object.realization) : undefined,
      diagnostics: isSet(object.diagnostics) ? DiagnosticList.fromJSON(object.diagnostics) : undefined,
    };
  },

  toJSON(message: RealizationResult): unknown {
    const obj: any = {};
    message.realization !== undefined &&
      (obj.realization = message.realization ? Realization.toJSON(message.realization) : undefined);
    message.diagnostics !== undefined &&
      (obj.diagnostics = message.diagnostics ? DiagnosticList.toJSON(message.diagnostics) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<RealizationResult>, I>>(base?: I): RealizationResult {
    return RealizationResult.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RealizationResult>, I>>(object: I): RealizationResult {
    const message = createBaseRealizationResult();
    message.realization = (object.realization !== undefined && object.realization !== null)
      ? Realization.fromPartial(object.realization)
      : undefined;
    message.diagnostics = (object.diagnostics !== undefined && object.diagnostics !== null)
      ? DiagnosticList.fromPartial(object.diagnostics)
      : undefined;
    return message;
  },
};

function createBaseGetRealizationsRequest(): GetRealizationsRequest {
  return { filter: 0 };
}

export const GetRealizationsRequest = {
  encode(message: GetRealizationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filter !== 0) {
      writer.uint32(8).int32(message.filter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRealizationsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRealizationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.filter = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetRealizationsRequest {
    return { filter: isSet(object.filter) ? filterModeFromJSON(object.filter) : 0 };
  },

  toJSON(message: GetRealizationsRequest): unknown {
    const obj: any = {};
    message.filter !== undefined && (obj.filter = filterModeToJSON(message.filter));
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRealizationsRequest>, I>>(base?: I): GetRealizationsRequest {
    return GetRealizationsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetRealizationsRequest>, I>>(object: I): GetRealizationsRequest {
    const message = createBaseGetRealizationsRequest();
    message.filter = object.filter ?? 0;
    return message;
  },
};

function createBaseGetRealizationsResponse(): GetRealizationsResponse {
  return { results: [] };
}

export const GetRealizationsResponse = {
  encode(message: GetRealizationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      RealizationResult.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRealizationsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRealizationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.results.push(RealizationResult.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetRealizationsResponse {
    return {
      results: Array.isArray(object?.results) ? object.results.map((e: any) => RealizationResult.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetRealizationsResponse): unknown {
    const obj: any = {};
    if (message.results) {
      obj.results = message.results.map((e) => e ? RealizationResult.toJSON(e) : undefined);
    } else {
      obj.results = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRealizationsResponse>, I>>(base?: I): GetRealizationsResponse {
    return GetRealizationsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetRealizationsResponse>, I>>(object: I): GetRealizationsResponse {
    const message = createBaseGetRealizationsResponse();
    message.results = object.results?.map((e) => RealizationResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetRealizationRequest(): GetRealizationRequest {
  return { project: "", experiment: "", realization: "" };
}

export const GetRealizationRequest = {
  encode(message: GetRealizationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(18).string(message.experiment);
    }
    if (message.realization !== "") {
      writer.uint32(26).string(message.realization);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRealizationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRealizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.experiment = reader.string();
          break;
        case 3:
          message.realization = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetRealizationRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      realization: isSet(object.realization) ? String(object.realization) : "",
    };
  },

  toJSON(message: GetRealizationRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.realization !== undefined && (obj.realization = message.realization);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRealizationRequest>, I>>(base?: I): GetRealizationRequest {
    return GetRealizationRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetRealizationRequest>, I>>(object: I): GetRealizationRequest {
    const message = createBaseGetRealizationRequest();
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.realization = object.realization ?? "";
    return message;
  },
};

function createBaseGetRealizationResponse(): GetRealizationResponse {
  return { result: undefined };
}

export const GetRealizationResponse = {
  encode(message: GetRealizationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      RealizationResult.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRealizationResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRealizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.result = RealizationResult.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetRealizationResponse {
    return { result: isSet(object.result) ? RealizationResult.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetRealizationResponse): unknown {
    const obj: any = {};
    message.result !== undefined &&
      (obj.result = message.result ? RealizationResult.toJSON(message.result) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRealizationResponse>, I>>(base?: I): GetRealizationResponse {
    return GetRealizationResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetRealizationResponse>, I>>(object: I): GetRealizationResponse {
    const message = createBaseGetRealizationResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? RealizationResult.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseRealizeRequest(): RealizeRequest {
  return {
    project: "",
    experiment: "",
    realization: "",
    revision: "",
    creator: "",
    time: "",
    ver: 0,
    tag: "",
    branch: "",
    duration: undefined,
  };
}

export const RealizeRequest = {
  encode(message: RealizeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(18).string(message.experiment);
    }
    if (message.realization !== "") {
      writer.uint32(26).string(message.realization);
    }
    if (message.revision !== "") {
      writer.uint32(34).string(message.revision);
    }
    if (message.creator !== "") {
      writer.uint32(42).string(message.creator);
    }
    if (message.time !== "") {
      writer.uint32(50).string(message.time);
    }
    if (message.ver !== 0) {
      writer.uint32(56).int64(message.ver);
    }
    if (message.tag !== "") {
      writer.uint32(66).string(message.tag);
    }
    if (message.branch !== "") {
      writer.uint32(74).string(message.branch);
    }
    if (message.duration !== undefined) {
      ReservationDuration.encode(message.duration, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RealizeRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRealizeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.experiment = reader.string();
          break;
        case 3:
          message.realization = reader.string();
          break;
        case 4:
          message.revision = reader.string();
          break;
        case 5:
          message.creator = reader.string();
          break;
        case 6:
          message.time = reader.string();
          break;
        case 7:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        case 8:
          message.tag = reader.string();
          break;
        case 9:
          message.branch = reader.string();
          break;
        case 10:
          message.duration = ReservationDuration.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RealizeRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      realization: isSet(object.realization) ? String(object.realization) : "",
      revision: isSet(object.revision) ? String(object.revision) : "",
      creator: isSet(object.creator) ? String(object.creator) : "",
      time: isSet(object.time) ? String(object.time) : "",
      ver: isSet(object.ver) ? Number(object.ver) : 0,
      tag: isSet(object.tag) ? String(object.tag) : "",
      branch: isSet(object.branch) ? String(object.branch) : "",
      duration: isSet(object.duration) ? ReservationDuration.fromJSON(object.duration) : undefined,
    };
  },

  toJSON(message: RealizeRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.realization !== undefined && (obj.realization = message.realization);
    message.revision !== undefined && (obj.revision = message.revision);
    message.creator !== undefined && (obj.creator = message.creator);
    message.time !== undefined && (obj.time = message.time);
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    message.tag !== undefined && (obj.tag = message.tag);
    message.branch !== undefined && (obj.branch = message.branch);
    message.duration !== undefined &&
      (obj.duration = message.duration ? ReservationDuration.toJSON(message.duration) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<RealizeRequest>, I>>(base?: I): RealizeRequest {
    return RealizeRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RealizeRequest>, I>>(object: I): RealizeRequest {
    const message = createBaseRealizeRequest();
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.realization = object.realization ?? "";
    message.revision = object.revision ?? "";
    message.creator = object.creator ?? "";
    message.time = object.time ?? "";
    message.ver = object.ver ?? 0;
    message.tag = object.tag ?? "";
    message.branch = object.branch ?? "";
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? ReservationDuration.fromPartial(object.duration)
      : undefined;
    return message;
  },
};

function createBaseReservationDuration(): ReservationDuration {
  return { when: 0, duration: "" };
}

export const ReservationDuration = {
  encode(message: ReservationDuration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.when !== 0) {
      writer.uint32(8).int32(message.when);
    }
    if (message.duration !== "") {
      writer.uint32(18).string(message.duration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReservationDuration {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReservationDuration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.when = reader.int32() as any;
          break;
        case 2:
          message.duration = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ReservationDuration {
    return {
      when: isSet(object.when) ? reservationDuration_codeFromJSON(object.when) : 0,
      duration: isSet(object.duration) ? String(object.duration) : "",
    };
  },

  toJSON(message: ReservationDuration): unknown {
    const obj: any = {};
    message.when !== undefined && (obj.when = reservationDuration_codeToJSON(message.when));
    message.duration !== undefined && (obj.duration = message.duration);
    return obj;
  },

  create<I extends Exact<DeepPartial<ReservationDuration>, I>>(base?: I): ReservationDuration {
    return ReservationDuration.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ReservationDuration>, I>>(object: I): ReservationDuration {
    const message = createBaseReservationDuration();
    message.when = object.when ?? 0;
    message.duration = object.duration ?? "";
    return message;
  },
};

function createBaseRealizeResponse(): RealizeResponse {
  return { code: 0, diagnostics: [], realization: undefined };
}

export const RealizeResponse = {
  encode(message: RealizeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    for (const v of message.diagnostics) {
      Diagnostic.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.realization !== undefined) {
      Realization.encode(message.realization, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RealizeResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRealizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.code = reader.int32() as any;
          break;
        case 2:
          message.diagnostics.push(Diagnostic.decode(reader, reader.uint32()));
          break;
        case 3:
          message.realization = Realization.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RealizeResponse {
    return {
      code: isSet(object.code) ? realizeResponse_CodeFromJSON(object.code) : 0,
      diagnostics: Array.isArray(object?.diagnostics) ? object.diagnostics.map((e: any) => Diagnostic.fromJSON(e)) : [],
      realization: isSet(object.realization) ? Realization.fromJSON(object.realization) : undefined,
    };
  },

  toJSON(message: RealizeResponse): unknown {
    const obj: any = {};
    message.code !== undefined && (obj.code = realizeResponse_CodeToJSON(message.code));
    if (message.diagnostics) {
      obj.diagnostics = message.diagnostics.map((e) => e ? Diagnostic.toJSON(e) : undefined);
    } else {
      obj.diagnostics = [];
    }
    message.realization !== undefined &&
      (obj.realization = message.realization ? Realization.toJSON(message.realization) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<RealizeResponse>, I>>(base?: I): RealizeResponse {
    return RealizeResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RealizeResponse>, I>>(object: I): RealizeResponse {
    const message = createBaseRealizeResponse();
    message.code = object.code ?? 0;
    message.diagnostics = object.diagnostics?.map((e) => Diagnostic.fromPartial(e)) || [];
    message.realization = (object.realization !== undefined && object.realization !== null)
      ? Realization.fromPartial(object.realization)
      : undefined;
    return message;
  },
};

function createBaseRelinquishRequest(): RelinquishRequest {
  return { project: "", experiment: "", realization: "" };
}

export const RelinquishRequest = {
  encode(message: RelinquishRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(18).string(message.experiment);
    }
    if (message.realization !== "") {
      writer.uint32(26).string(message.realization);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RelinquishRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelinquishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.experiment = reader.string();
          break;
        case 3:
          message.realization = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RelinquishRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      realization: isSet(object.realization) ? String(object.realization) : "",
    };
  },

  toJSON(message: RelinquishRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.realization !== undefined && (obj.realization = message.realization);
    return obj;
  },

  create<I extends Exact<DeepPartial<RelinquishRequest>, I>>(base?: I): RelinquishRequest {
    return RelinquishRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RelinquishRequest>, I>>(object: I): RelinquishRequest {
    const message = createBaseRelinquishRequest();
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.realization = object.realization ?? "";
    return message;
  },
};

function createBaseRelinquishResponse(): RelinquishResponse {
  return {};
}

export const RelinquishResponse = {
  encode(_: RelinquishResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RelinquishResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelinquishResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): RelinquishResponse {
    return {};
  },

  toJSON(_: RelinquishResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RelinquishResponse>, I>>(base?: I): RelinquishResponse {
    return RelinquishResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RelinquishResponse>, I>>(_: I): RelinquishResponse {
    const message = createBaseRelinquishResponse();
    return message;
  },
};

function createBaseAllocation(): Allocation {
  return { rid: "", eid: "", pid: "", uid: "", fid: "", oid: "", node: "", virt: false, coresUsed: 0, memoryUsed: 0 };
}

export const Allocation = {
  encode(message: Allocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rid !== "") {
      writer.uint32(10).string(message.rid);
    }
    if (message.eid !== "") {
      writer.uint32(18).string(message.eid);
    }
    if (message.pid !== "") {
      writer.uint32(26).string(message.pid);
    }
    if (message.uid !== "") {
      writer.uint32(34).string(message.uid);
    }
    if (message.fid !== "") {
      writer.uint32(42).string(message.fid);
    }
    if (message.oid !== "") {
      writer.uint32(50).string(message.oid);
    }
    if (message.node !== "") {
      writer.uint32(58).string(message.node);
    }
    if (message.virt === true) {
      writer.uint32(64).bool(message.virt);
    }
    if (message.coresUsed !== 0) {
      writer.uint32(72).uint32(message.coresUsed);
    }
    if (message.memoryUsed !== 0) {
      writer.uint32(80).uint64(message.memoryUsed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Allocation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rid = reader.string();
          break;
        case 2:
          message.eid = reader.string();
          break;
        case 3:
          message.pid = reader.string();
          break;
        case 4:
          message.uid = reader.string();
          break;
        case 5:
          message.fid = reader.string();
          break;
        case 6:
          message.oid = reader.string();
          break;
        case 7:
          message.node = reader.string();
          break;
        case 8:
          message.virt = reader.bool();
          break;
        case 9:
          message.coresUsed = reader.uint32();
          break;
        case 10:
          message.memoryUsed = longToNumber(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Allocation {
    return {
      rid: isSet(object.rid) ? String(object.rid) : "",
      eid: isSet(object.eid) ? String(object.eid) : "",
      pid: isSet(object.pid) ? String(object.pid) : "",
      uid: isSet(object.uid) ? String(object.uid) : "",
      fid: isSet(object.fid) ? String(object.fid) : "",
      oid: isSet(object.oid) ? String(object.oid) : "",
      node: isSet(object.node) ? String(object.node) : "",
      virt: isSet(object.virt) ? Boolean(object.virt) : false,
      coresUsed: isSet(object.coresUsed) ? Number(object.coresUsed) : 0,
      memoryUsed: isSet(object.memoryUsed) ? Number(object.memoryUsed) : 0,
    };
  },

  toJSON(message: Allocation): unknown {
    const obj: any = {};
    message.rid !== undefined && (obj.rid = message.rid);
    message.eid !== undefined && (obj.eid = message.eid);
    message.pid !== undefined && (obj.pid = message.pid);
    message.uid !== undefined && (obj.uid = message.uid);
    message.fid !== undefined && (obj.fid = message.fid);
    message.oid !== undefined && (obj.oid = message.oid);
    message.node !== undefined && (obj.node = message.node);
    message.virt !== undefined && (obj.virt = message.virt);
    message.coresUsed !== undefined && (obj.coresUsed = Math.round(message.coresUsed));
    message.memoryUsed !== undefined && (obj.memoryUsed = Math.round(message.memoryUsed));
    return obj;
  },

  create<I extends Exact<DeepPartial<Allocation>, I>>(base?: I): Allocation {
    return Allocation.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Allocation>, I>>(object: I): Allocation {
    const message = createBaseAllocation();
    message.rid = object.rid ?? "";
    message.eid = object.eid ?? "";
    message.pid = object.pid ?? "";
    message.uid = object.uid ?? "";
    message.fid = object.fid ?? "";
    message.oid = object.oid ?? "";
    message.node = object.node ?? "";
    message.virt = object.virt ?? false;
    message.coresUsed = object.coresUsed ?? 0;
    message.memoryUsed = object.memoryUsed ?? 0;
    return message;
  },
};

function createBaseResource(): Resource {
  return { resource: undefined, allocated: [] };
}

export const Resource = {
  encode(message: Resource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resource !== undefined) {
      Resource1.encode(message.resource, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.allocated) {
      Allocation.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Resource {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.resource = Resource1.decode(reader, reader.uint32());
          break;
        case 2:
          message.allocated.push(Allocation.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Resource {
    return {
      resource: isSet(object.resource) ? Resource1.fromJSON(object.resource) : undefined,
      allocated: Array.isArray(object?.allocated) ? object.allocated.map((e: any) => Allocation.fromJSON(e)) : [],
    };
  },

  toJSON(message: Resource): unknown {
    const obj: any = {};
    message.resource !== undefined &&
      (obj.resource = message.resource ? Resource1.toJSON(message.resource) : undefined);
    if (message.allocated) {
      obj.allocated = message.allocated.map((e) => e ? Allocation.toJSON(e) : undefined);
    } else {
      obj.allocated = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resource>, I>>(base?: I): Resource {
    return Resource.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Resource>, I>>(object: I): Resource {
    const message = createBaseResource();
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource1.fromPartial(object.resource)
      : undefined;
    message.allocated = object.allocated?.map((e) => Allocation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetResourcesRequest(): GetResourcesRequest {
  return {};
}

export const GetResourcesRequest = {
  encode(_: GetResourcesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetResourcesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetResourcesRequest {
    return {};
  },

  toJSON(_: GetResourcesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResourcesRequest>, I>>(base?: I): GetResourcesRequest {
    return GetResourcesRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetResourcesRequest>, I>>(_: I): GetResourcesRequest {
    const message = createBaseGetResourcesRequest();
    return message;
  },
};

function createBaseGetResourcesResponse(): GetResourcesResponse {
  return { resources: [] };
}

export const GetResourcesResponse = {
  encode(message: GetResourcesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.resources) {
      Resource.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetResourcesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.resources.push(Resource.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetResourcesResponse {
    return {
      resources: Array.isArray(object?.resources) ? object.resources.map((e: any) => Resource.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetResourcesResponse): unknown {
    const obj: any = {};
    if (message.resources) {
      obj.resources = message.resources.map((e) => e ? Resource.toJSON(e) : undefined);
    } else {
      obj.resources = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResourcesResponse>, I>>(base?: I): GetResourcesResponse {
    return GetResourcesResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetResourcesResponse>, I>>(object: I): GetResourcesResponse {
    const message = createBaseGetResourcesResponse();
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateRealizationRequest(): UpdateRealizationRequest {
  return { project: "", experiment: "", realization: "", duration: undefined };
}

export const UpdateRealizationRequest = {
  encode(message: UpdateRealizationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(18).string(message.experiment);
    }
    if (message.realization !== "") {
      writer.uint32(26).string(message.realization);
    }
    if (message.duration !== undefined) {
      ReservationDuration.encode(message.duration, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateRealizationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRealizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.experiment = reader.string();
          break;
        case 3:
          message.realization = reader.string();
          break;
        case 4:
          message.duration = ReservationDuration.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateRealizationRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      realization: isSet(object.realization) ? String(object.realization) : "",
      duration: isSet(object.duration) ? ReservationDuration.fromJSON(object.duration) : undefined,
    };
  },

  toJSON(message: UpdateRealizationRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.realization !== undefined && (obj.realization = message.realization);
    message.duration !== undefined &&
      (obj.duration = message.duration ? ReservationDuration.toJSON(message.duration) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRealizationRequest>, I>>(base?: I): UpdateRealizationRequest {
    return UpdateRealizationRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateRealizationRequest>, I>>(object: I): UpdateRealizationRequest {
    const message = createBaseUpdateRealizationRequest();
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.realization = object.realization ?? "";
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? ReservationDuration.fromPartial(object.duration)
      : undefined;
    return message;
  },
};

function createBaseUpdateRealizationResponse(): UpdateRealizationResponse {
  return { expires: undefined };
}

export const UpdateRealizationResponse = {
  encode(message: UpdateRealizationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.expires !== undefined) {
      Timestamp.encode(toTimestamp(message.expires), writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateRealizationResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRealizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.expires = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateRealizationResponse {
    return { expires: isSet(object.expires) ? fromJsonTimestamp(object.expires) : undefined };
  },

  toJSON(message: UpdateRealizationResponse): unknown {
    const obj: any = {};
    message.expires !== undefined && (obj.expires = message.expires.toISOString());
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRealizationResponse>, I>>(base?: I): UpdateRealizationResponse {
    return UpdateRealizationResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateRealizationResponse>, I>>(object: I): UpdateRealizationResponse {
    const message = createBaseUpdateRealizationResponse();
    message.expires = object.expires ?? undefined;
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = date.getTime() / 1_000;
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = t.seconds * 1_000;
  millis += t.nanos / 1_000_000;
  return new Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
