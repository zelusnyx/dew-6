/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "../../google/protobuf/timestamp";
import { TaskForest } from "../../mergetb/tech/reconcile/taskstatus";
import { Network } from "../../mergetb/xir/v0.3/core";
import { PatchStrategy } from "./patch_types";

export const protobufPackage = "portal.v1";

export enum AccessMode {
  Public = 0,
  Protected = 1,
  Private = 2,
  UNRECOGNIZED = -1,
}

export function accessModeFromJSON(object: any): AccessMode {
  switch (object) {
    case 0:
    case "Public":
      return AccessMode.Public;
    case 1:
    case "Protected":
      return AccessMode.Protected;
    case 2:
    case "Private":
      return AccessMode.Private;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessMode.UNRECOGNIZED;
  }
}

export function accessModeToJSON(object: AccessMode): string {
  switch (object) {
    case AccessMode.Public:
      return "Public";
    case AccessMode.Protected:
      return "Protected";
    case AccessMode.Private:
      return "Private";
    case AccessMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** NOTE: FilterMode supports bitwise ORing options together. */
export enum FilterMode {
  ByUser = 0,
  ByAll = 1,
  UNRECOGNIZED = -1,
}

export function filterModeFromJSON(object: any): FilterMode {
  switch (object) {
    case 0:
    case "ByUser":
      return FilterMode.ByUser;
    case 1:
    case "ByAll":
      return FilterMode.ByAll;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FilterMode.UNRECOGNIZED;
  }
}

export function filterModeToJSON(object: FilterMode): string {
  switch (object) {
    case FilterMode.ByUser:
      return "ByUser";
    case FilterMode.ByAll:
      return "ByAll";
    case FilterMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MembershipType {
  UserMember = 0,
  ProjectMember = 1,
  UNRECOGNIZED = -1,
}

export function membershipTypeFromJSON(object: any): MembershipType {
  switch (object) {
    case 0:
    case "UserMember":
      return MembershipType.UserMember;
    case 1:
    case "ProjectMember":
      return MembershipType.ProjectMember;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MembershipType.UNRECOGNIZED;
  }
}

export function membershipTypeToJSON(object: MembershipType): string {
  switch (object) {
    case MembershipType.UserMember:
      return "UserMember";
    case MembershipType.ProjectMember:
      return "ProjectMember";
    case MembershipType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A users state broadly determines what they are authorized to do. */
export enum UserState {
  /**
   * NotSet - We need a NotSet state for updates, which may not include state and
   * we need to distinguish between 0 = Pending and 0 = not included in
   * messages which use this enum.
   */
  NotSet = 0,
  /**
   * Pending - User has not been activated yet. Most API calls are not available to
   * users in this state.
   */
  Pending = 1,
  /**
   * Frozen - User has been frozen by a organization maintainer or portal admin. All
   * API calls are forbidden to users in this state.
   */
  Frozen = 2,
  /**
   * Active - User is active. API calls are governed by the portal's policy
   * definitions.
   */
  Active = 3,
  UNRECOGNIZED = -1,
}

export function userStateFromJSON(object: any): UserState {
  switch (object) {
    case 0:
    case "NotSet":
      return UserState.NotSet;
    case 1:
    case "Pending":
      return UserState.Pending;
    case 2:
    case "Frozen":
      return UserState.Frozen;
    case 3:
    case "Active":
      return UserState.Active;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserState.UNRECOGNIZED;
  }
}

export function userStateToJSON(object: UserState): string {
  switch (object) {
    case UserState.NotSet:
      return "NotSet";
    case UserState.Pending:
      return "Pending";
    case UserState.Frozen:
      return "Frozen";
    case UserState.Active:
      return "Active";
    case UserState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AccessModeUpdate {
  value: AccessMode;
}

export interface UserStateUpdate {
  value: UserState;
}

export interface Member {
  role: Member_Role;
  state: Member_State;
}

export enum Member_Role {
  Member = 0,
  Maintainer = 1,
  Creator = 2,
  UNRECOGNIZED = -1,
}

export function member_RoleFromJSON(object: any): Member_Role {
  switch (object) {
    case 0:
    case "Member":
      return Member_Role.Member;
    case 1:
    case "Maintainer":
      return Member_Role.Maintainer;
    case 2:
    case "Creator":
      return Member_Role.Creator;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Member_Role.UNRECOGNIZED;
  }
}

export function member_RoleToJSON(object: Member_Role): string {
  switch (object) {
    case Member_Role.Member:
      return "Member";
    case Member_Role.Maintainer:
      return "Maintainer";
    case Member_Role.Creator:
      return "Creator";
    case Member_Role.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Member_State {
  Pending = 0,
  Active = 1,
  MemberRequested = 2,
  EntityRequested = 3,
  UNRECOGNIZED = -1,
}

export function member_StateFromJSON(object: any): Member_State {
  switch (object) {
    case 0:
    case "Pending":
      return Member_State.Pending;
    case 1:
    case "Active":
      return Member_State.Active;
    case 2:
    case "MemberRequested":
      return Member_State.MemberRequested;
    case 3:
    case "EntityRequested":
      return Member_State.EntityRequested;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Member_State.UNRECOGNIZED;
  }
}

export function member_StateToJSON(object: Member_State): string {
  switch (object) {
    case Member_State.Pending:
      return "Pending";
    case Member_State.Active:
      return "Active";
    case Member_State.MemberRequested:
      return "MemberRequested";
    case Member_State.EntityRequested:
      return "EntityRequested";
    case Member_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface MembershipUpdate {
  /** A list of entities to remove a member from. */
  remove: string[];
  /**
   * A set of entities to add a member to. If the member is already present
   * within the entity, their membership status is overwritten with the
   * provided value.
   */
  set: { [key: string]: Member };
}

export interface MembershipUpdate_SetEntry {
  key: string;
  value: Member | undefined;
}

/**
 * This is the definition of a user in MergeTB that is used for storage of
 * record and messaging between applications.
 */
export interface User {
  /** The users unique identifier. */
  username: string;
  /** Full name of the user. */
  name: string;
  /** What state the user account is in. */
  state: UserState;
  /** The visibility of the user account. */
  accessMode: AccessMode;
  /** MergeFS user id. */
  uid: number;
  /** MergeFS group id. */
  gid: number;
  /** Projects the user is a member of. */
  projects: { [key: string]: Member };
  /** Experiments the user is a creator or maintainer of. */
  experiments: string[];
  /** Organizations the user is a member of. */
  organizations: { [key: string]: Member };
  /** Facilities this user is a member of. */
  facilities: { [key: string]: Member };
  admin: boolean;
  /** Revision counter for this object. */
  ver: number;
  /** User Traits. */
  institution: string;
  category: string;
  email: string;
  country: string;
  usstate: string;
}

export interface User_ProjectsEntry {
  key: string;
  value: Member | undefined;
}

export interface User_OrganizationsEntry {
  key: string;
  value: Member | undefined;
}

export interface User_FacilitiesEntry {
  key: string;
  value: Member | undefined;
}

export interface InitUserRequest {
  /** The user to initialize. */
  username: string;
  status: boolean;
}

export interface InitUserResponse {
  status: TaskForest | undefined;
}

export interface ActivateUserRequest {
  username: string;
}

export interface ActivateUserResponse {
}

export interface FreezeUserRequest {
  username: string;
}

export interface FreezeUserResponse {
}

export interface GetUsersRequest {
  filter: FilterMode;
}

export interface GetUsersResponse {
  /** A list of users. */
  users: User[];
}

export interface GetUserRequest {
  /** The identity of the user. */
  username: string;
}

export interface GetUserResponse {
  /** The requested user. */
  user: User | undefined;
}

export interface UpdateUserRequest {
  /** The id of the user to update. */
  username: string;
  /** The colloquial name of the user. */
  name: string;
  /** Optional state update */
  state:
    | UserStateUpdate
    | undefined;
  /** Optional access mode update. */
  accessMode:
    | AccessModeUpdate
    | undefined;
  /** Optional organization membership update. */
  organizations:
    | MembershipUpdate
    | undefined;
  /** Optional project membership update. */
  projects:
    | MembershipUpdate
    | undefined;
  /** Optional facility membership update. */
  facilities:
    | MembershipUpdate
    | undefined;
  /** Optional experiment membership update. */
  experiments: string[];
  /** If true, toggle the user's admin state. */
  toggleAdmin: boolean;
}

export interface UpdateUserResponse {
}

export interface DeleteUserRequest {
  /** The identity of the user. */
  user: string;
}

export interface DeleteUserResponse {
}

/** UserStatus - keeps track of active user status on the portal (currently just if they are logged in or not) */
export interface UserStatus {
  username: string;
  loggedin: boolean;
  ver: number;
}

export interface PublicKey {
  /** SHA256 fingerprint of the SSH key. */
  fingerprint: string;
  /** The ssh-rsa key. */
  key: string;
}

export interface GetUserPublicKeysRequest {
  /** The user to fetch keys for. */
  user: string;
}

export interface GetUserPublicKeysResponse {
  /** The public keys for the specified user. */
  keys: PublicKey[];
}

export interface AddUserPublicKeyRequest {
  /** The user to add a new public key for. */
  user: string;
  /** An ssh-rsa public key. */
  key: string;
}

export interface AddUserPublicKeyResponse {
}

export interface DeleteUserPublicKeyRequest {
  /** The user to remove the public key from. */
  user: string;
  /** The SHA256 fingerprint of the key to remove. */
  fingerprint: string;
}

export interface DeleteUserPublicKeyResponse {
}

export interface DeleteUserPublicKeysRequest {
  /** User to delete to remove public keys for. */
  user: string;
}

export interface DeleteUserPublicKeysResponse {
}

export interface Project {
  name: string;
  description: string;
  members: { [key: string]: Member };
  experiments: string[];
  accessMode: AccessMode;
  gid: number;
  /** here for backwards compatibility */
  deprecated: string[];
  ver: number;
  organization: string;
  orgMembership: Member | undefined;
  category: string;
  subcategory: string;
}

export interface Project_MembersEntry {
  key: string;
  value: Member | undefined;
}

export interface GetProjectsRequest {
  filter: FilterMode;
}

export interface GetProjectsResponse {
  projects: Project[];
}

export interface GetProjectRequest {
  name: string;
}

export interface GetProjectResponse {
  project: Project | undefined;
}

export interface DeleteProjectRequest {
  user: string;
  name: string;
}

export interface DeleteProjectResponse {
}

export interface CreateProjectRequest {
  user: string;
  project:
    | Project
    | undefined;
  /** if given, ask for status of any tasks created by a previous request. */
  status: boolean;
}

export interface CreateProjectResponse {
  status: TaskForest | undefined;
}

export interface DescriptionUpdate {
  value: string;
}

export interface UpdateProjectRequest {
  /** Name of the project to update. */
  name: string;
  /** Optional description update. */
  description:
    | DescriptionUpdate
    | undefined;
  /** Optional access mode update. */
  accessMode:
    | AccessModeUpdate
    | undefined;
  /** Optional project membership update. */
  members:
    | MembershipUpdate
    | undefined;
  /** Optional organization membership update. */
  organization: MembershipUpdate | undefined;
}

export interface UpdateProjectResponse {
}

export interface GetProjectMembersRequest {
  name: string;
}

export interface GetProjectMembersResponse {
  members: Member[];
}

export interface GetProjectMemberRequest {
  project: string;
  member: string;
}

export interface GetProjectMemberResponse {
  member: Member | undefined;
}

export interface AddProjectMemberRequest {
  project: string;
  username: string;
  member: Member | undefined;
}

export interface AddProjectMemberResponse {
}

export interface UpdateProjectMemberRequest {
  project: string;
  username: string;
  member: Member | undefined;
}

export interface UpdateProjectMemberResponse {
}

export interface DeleteProjectMemberRequest {
  project: string;
  member: string;
}

export interface DeleteProjectMemberResponse {
}

export interface ExperimentModel {
  compiled: boolean;
  msg: string;
  realizations: string[];
  compileTime: Date | undefined;
}

export interface Experiment {
  /** Name of the experiment. */
  name: string;
  /** Project this experiment belongs to. */
  project: string;
  /** A short description. */
  description: string;
  /** A map of source revisions to their model and realization status */
  models: { [key: string]: ExperimentModel };
  /** Visibility of this experiment. */
  accessMode: AccessMode;
  /** Git repository where this experiments source is held. */
  repository: string;
  creator: string;
  maintainers: string[];
  /** Experiment version, increments each time experiment metadata is updated. */
  ver: number;
}

export interface Experiment_ModelsEntry {
  key: string;
  value: ExperimentModel | undefined;
}

export interface GetExperimentsRequest {
  filter: FilterMode;
}

export interface GetExperimentsResponse {
  experiments: Experiment[];
}

export interface GetProjectExperimentsRequest {
  project: string;
}

export interface GetProjectExperimentsResponse {
  experiments: Experiment[];
}

export interface GetExperimentRequest {
  project: string;
  experiment: string;
  withModels: boolean;
}

export interface XpNetModel {
  compiled: boolean;
  model: Network | undefined;
}

export interface GetExperimentResponse {
  experiment: Experiment | undefined;
  models: { [key: string]: XpNetModel };
}

export interface GetExperimentResponse_ModelsEntry {
  key: string;
  value: XpNetModel | undefined;
}

export interface UpdateExperimentRequest {
  /** Name of the experiment to update */
  name: string;
  /** Name of the project the experiment is in */
  project: string;
  /** Optional description update. */
  description:
    | DescriptionUpdate
    | undefined;
  /** Optional access mode update. */
  accessMode:
    | AccessModeUpdate
    | undefined;
  /** set experiment creator */
  creator: string;
  /** experiment maintainers have some privledges depending on the active policy */
  maintainers: string[];
}

export interface UpdateExperimentResponse {
}

export interface CreateExperimentRequest {
  experiment: Experiment | undefined;
}

export interface CreateExperimentResponse {
}

export interface DeleteExperimentRequest {
  project: string;
  experiment: string;
}

export interface DeleteExperimentResponse {
}

export interface GetRevisionRequest {
  project: string;
  experiment: string;
  revision: string;
  encoding: GetRevisionRequest_Encoding;
}

export enum GetRevisionRequest_Encoding {
  NONE = 0,
  /** XIRB64 - base 64 encoded xir.Network */
  XIRB64 = 1,
  /** DOT - graphviz DOT format */
  DOT = 2,
  UNRECOGNIZED = -1,
}

export function getRevisionRequest_EncodingFromJSON(object: any): GetRevisionRequest_Encoding {
  switch (object) {
    case 0:
    case "NONE":
      return GetRevisionRequest_Encoding.NONE;
    case 1:
    case "XIRB64":
      return GetRevisionRequest_Encoding.XIRB64;
    case 2:
    case "DOT":
      return GetRevisionRequest_Encoding.DOT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GetRevisionRequest_Encoding.UNRECOGNIZED;
  }
}

export function getRevisionRequest_EncodingToJSON(object: GetRevisionRequest_Encoding): string {
  switch (object) {
    case GetRevisionRequest_Encoding.NONE:
      return "NONE";
    case GetRevisionRequest_Encoding.XIRB64:
      return "XIRB64";
    case GetRevisionRequest_Encoding.DOT:
      return "DOT";
    case GetRevisionRequest_Encoding.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GetRevisionResponse {
  model: XpNetModel | undefined;
  encoding: string;
  ModelFile: string;
}

export interface Organization {
  name: string;
  description: string;
  oid: number;
  members: { [key: string]: Member };
  projects: { [key: string]: Member };
  state: UserState;
  accessMode: AccessMode;
  /** Revision counter for this object. */
  ver: number;
  category: string;
  subcategory: string;
}

export interface Organization_MembersEntry {
  key: string;
  value: Member | undefined;
}

export interface Organization_ProjectsEntry {
  key: string;
  value: Member | undefined;
}

export interface ActivateOrganizationRequest {
  organization: string;
}

export interface ActivateOrganizationResponse {
}

export interface FreezeOrganizationRequest {
  organization: string;
}

export interface FreezeOrganizationResponse {
}

export interface GetOrganizationsRequest {
  filter: FilterMode;
}

export interface GetOrganizationsResponse {
  organizations: Organization[];
}

export interface GetOrganizationRequest {
  name: string;
}

export interface GetOrganizationResponse {
  organization: Organization | undefined;
}

export interface DeleteOrganizationRequest {
  user: string;
  name: string;
}

export interface DeleteOrganizationResponse {
}

export interface CreateOrganizationRequest {
  user: string;
  organization: Organization | undefined;
}

export interface CreateOrganizationResponse {
}

export interface UpdateOrganizationRequest {
  /** Name of the organization to update. */
  name: string;
  /** Optional description update. */
  description:
    | DescriptionUpdate
    | undefined;
  /** Optional state update */
  state:
    | UserStateUpdate
    | undefined;
  /** Optional access mode update. */
  accessMode:
    | AccessModeUpdate
    | undefined;
  /** Optional user membership update. */
  members:
    | MembershipUpdate
    | undefined;
  /** Optional project membership update. */
  projects: MembershipUpdate | undefined;
}

export interface UpdateOrganizationResponse {
}

export interface GetOrganizationMembersRequest {
  organization: string;
}

export interface GetOrganizationMembersResponse {
  members: Member[];
}

export interface GetOrganizationMemberRequest {
  organization: string;
  username: string;
}

export interface GetOrganizationMemberResponse {
  member: Member | undefined;
}

export interface RequestOrganizationMembershipRequest {
  organization: string;
  id: string;
  kind: MembershipType;
  member: Member | undefined;
}

export interface RequestOrganizationMembershipResponse {
  member: Member | undefined;
}

export interface ConfirmOrganizationMembershipRequest {
  organization: string;
  id: string;
  kind: MembershipType;
}

export interface ConfirmOrganizationMembershipResponse {
  member: Member | undefined;
}

export interface UpdateOrganizationMemberRequest {
  organization: string;
  username: string;
  member: Member | undefined;
}

export interface UpdateOrganizationMemberResponse {
  member: Member | undefined;
}

export interface DeleteOrganizationMemberRequest {
  organization: string;
  username: string;
}

export interface DeleteOrganizationMemberResponse {
}

export interface GetOrganizationProjectsRequest {
  name: string;
}

export interface GetOrganizationProjectsResponse {
  projects: Member[];
}

export interface GetOrganizationProjectRequest {
  organization: string;
  project: string;
}

export interface GetOrganizationProjectResponse {
  member: Member | undefined;
}

export interface AddOrganizationProjectRequest {
  organization: string;
  project: string;
  member: Member | undefined;
}

export interface AddOrganizationProjectResponse {
}

export interface UpdateOrganizationProjectRequest {
  organization: string;
  project: string;
  member: Member | undefined;
}

export interface UpdateOrganizationProjectResponse {
}

export interface DeleteOrganizationProjectRequest {
  organization: string;
  project: string;
}

export interface DeleteOrganizationProjectResponse {
}

export interface GetUserConfigurationsRequest {
}

export interface GetUserConfigurationsResponse {
  institutions: string[];
  countries: GetUserConfigurationsResponse_Country[];
  usstates: GetUserConfigurationsResponse_USState[];
  categories: string[];
}

export interface GetUserConfigurationsResponse_Country {
  name: string;
  ISO2: string;
}

export interface GetUserConfigurationsResponse_USState {
  name: string;
  USPS2: string;
}

export interface UpdateUserConfigurationsRequest {
  institutions: string[];
  categories: string[];
  patchstrategy: PatchStrategy | undefined;
}

export interface UpdateUserConfigurationsResponse {
}

export interface GetEntityTypeConfigurationsRequest {
}

export interface EntityType {
  etype: string;
  subtypes: string[];
}

export interface GetEntityTypeConfigurationsResponse {
  Types: EntityType[];
}

export interface UpdateEntityTypeConfigurationsRequest {
  Types: EntityType[];
  /** How to update types */
  patchstrategy: PatchStrategy | undefined;
}

export interface UpdateEntityTypeConfigurationsResponse {
}

export interface GetPolicyRequest {
}

export interface GetPolicyResponse {
  policy: string;
}

/** Health ===================================================================== */
export interface HealthRequest {
}

export interface HealthResponse {
  status: string;
}

function createBaseAccessModeUpdate(): AccessModeUpdate {
  return { value: 0 };
}

export const AccessModeUpdate = {
  encode(message: AccessModeUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccessModeUpdate {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessModeUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AccessModeUpdate {
    return { value: isSet(object.value) ? accessModeFromJSON(object.value) : 0 };
  },

  toJSON(message: AccessModeUpdate): unknown {
    const obj: any = {};
    message.value !== undefined && (obj.value = accessModeToJSON(message.value));
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessModeUpdate>, I>>(base?: I): AccessModeUpdate {
    return AccessModeUpdate.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AccessModeUpdate>, I>>(object: I): AccessModeUpdate {
    const message = createBaseAccessModeUpdate();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseUserStateUpdate(): UserStateUpdate {
  return { value: 0 };
}

export const UserStateUpdate = {
  encode(message: UserStateUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserStateUpdate {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserStateUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UserStateUpdate {
    return { value: isSet(object.value) ? userStateFromJSON(object.value) : 0 };
  },

  toJSON(message: UserStateUpdate): unknown {
    const obj: any = {};
    message.value !== undefined && (obj.value = userStateToJSON(message.value));
    return obj;
  },

  create<I extends Exact<DeepPartial<UserStateUpdate>, I>>(base?: I): UserStateUpdate {
    return UserStateUpdate.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UserStateUpdate>, I>>(object: I): UserStateUpdate {
    const message = createBaseUserStateUpdate();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseMember(): Member {
  return { role: 0, state: 0 };
}

export const Member = {
  encode(message: Member, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.role !== 0) {
      writer.uint32(16).int32(message.role);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Member {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.role = reader.int32() as any;
          break;
        case 3:
          message.state = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Member {
    return {
      role: isSet(object.role) ? member_RoleFromJSON(object.role) : 0,
      state: isSet(object.state) ? member_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: Member): unknown {
    const obj: any = {};
    message.role !== undefined && (obj.role = member_RoleToJSON(message.role));
    message.state !== undefined && (obj.state = member_StateToJSON(message.state));
    return obj;
  },

  create<I extends Exact<DeepPartial<Member>, I>>(base?: I): Member {
    return Member.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Member>, I>>(object: I): Member {
    const message = createBaseMember();
    message.role = object.role ?? 0;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseMembershipUpdate(): MembershipUpdate {
  return { remove: [], set: {} };
}

export const MembershipUpdate = {
  encode(message: MembershipUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.remove) {
      writer.uint32(10).string(v!);
    }
    Object.entries(message.set).forEach(([key, value]) => {
      MembershipUpdate_SetEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MembershipUpdate {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.remove.push(reader.string());
          break;
        case 2:
          const entry2 = MembershipUpdate_SetEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.set[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MembershipUpdate {
    return {
      remove: Array.isArray(object?.remove) ? object.remove.map((e: any) => String(e)) : [],
      set: isObject(object.set)
        ? Object.entries(object.set).reduce<{ [key: string]: Member }>((acc, [key, value]) => {
          acc[key] = Member.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MembershipUpdate): unknown {
    const obj: any = {};
    if (message.remove) {
      obj.remove = message.remove.map((e) => e);
    } else {
      obj.remove = [];
    }
    obj.set = {};
    if (message.set) {
      Object.entries(message.set).forEach(([k, v]) => {
        obj.set[k] = Member.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MembershipUpdate>, I>>(base?: I): MembershipUpdate {
    return MembershipUpdate.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<MembershipUpdate>, I>>(object: I): MembershipUpdate {
    const message = createBaseMembershipUpdate();
    message.remove = object.remove?.map((e) => e) || [];
    message.set = Object.entries(object.set ?? {}).reduce<{ [key: string]: Member }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Member.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMembershipUpdate_SetEntry(): MembershipUpdate_SetEntry {
  return { key: "", value: undefined };
}

export const MembershipUpdate_SetEntry = {
  encode(message: MembershipUpdate_SetEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Member.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MembershipUpdate_SetEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipUpdate_SetEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MembershipUpdate_SetEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Member.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MembershipUpdate_SetEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? Member.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<MembershipUpdate_SetEntry>, I>>(base?: I): MembershipUpdate_SetEntry {
    return MembershipUpdate_SetEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<MembershipUpdate_SetEntry>, I>>(object: I): MembershipUpdate_SetEntry {
    const message = createBaseMembershipUpdate_SetEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Member.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseUser(): User {
  return {
    username: "",
    name: "",
    state: 0,
    accessMode: 0,
    uid: 0,
    gid: 0,
    projects: {},
    experiments: [],
    organizations: {},
    facilities: {},
    admin: false,
    ver: 0,
    institution: "",
    category: "",
    email: "",
    country: "",
    usstate: "",
  };
}

export const User = {
  encode(message: User, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.accessMode !== 0) {
      writer.uint32(32).int32(message.accessMode);
    }
    if (message.uid !== 0) {
      writer.uint32(40).uint32(message.uid);
    }
    if (message.gid !== 0) {
      writer.uint32(48).uint32(message.gid);
    }
    Object.entries(message.projects).forEach(([key, value]) => {
      User_ProjectsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    for (const v of message.experiments) {
      writer.uint32(66).string(v!);
    }
    Object.entries(message.organizations).forEach(([key, value]) => {
      User_OrganizationsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).ldelim();
    });
    Object.entries(message.facilities).forEach(([key, value]) => {
      User_FacilitiesEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).ldelim();
    });
    if (message.admin === true) {
      writer.uint32(88).bool(message.admin);
    }
    if (message.ver !== 0) {
      writer.uint32(96).int64(message.ver);
    }
    if (message.institution !== "") {
      writer.uint32(106).string(message.institution);
    }
    if (message.category !== "") {
      writer.uint32(114).string(message.category);
    }
    if (message.email !== "") {
      writer.uint32(122).string(message.email);
    }
    if (message.country !== "") {
      writer.uint32(130).string(message.country);
    }
    if (message.usstate !== "") {
      writer.uint32(138).string(message.usstate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): User {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.username = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.state = reader.int32() as any;
          break;
        case 4:
          message.accessMode = reader.int32() as any;
          break;
        case 5:
          message.uid = reader.uint32();
          break;
        case 6:
          message.gid = reader.uint32();
          break;
        case 7:
          const entry7 = User_ProjectsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.projects[entry7.key] = entry7.value;
          }
          break;
        case 8:
          message.experiments.push(reader.string());
          break;
        case 9:
          const entry9 = User_OrganizationsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.organizations[entry9.key] = entry9.value;
          }
          break;
        case 10:
          const entry10 = User_FacilitiesEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.facilities[entry10.key] = entry10.value;
          }
          break;
        case 11:
          message.admin = reader.bool();
          break;
        case 12:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        case 13:
          message.institution = reader.string();
          break;
        case 14:
          message.category = reader.string();
          break;
        case 15:
          message.email = reader.string();
          break;
        case 16:
          message.country = reader.string();
          break;
        case 17:
          message.usstate = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      username: isSet(object.username) ? String(object.username) : "",
      name: isSet(object.name) ? String(object.name) : "",
      state: isSet(object.state) ? userStateFromJSON(object.state) : 0,
      accessMode: isSet(object.accessMode) ? accessModeFromJSON(object.accessMode) : 0,
      uid: isSet(object.uid) ? Number(object.uid) : 0,
      gid: isSet(object.gid) ? Number(object.gid) : 0,
      projects: isObject(object.projects)
        ? Object.entries(object.projects).reduce<{ [key: string]: Member }>((acc, [key, value]) => {
          acc[key] = Member.fromJSON(value);
          return acc;
        }, {})
        : {},
      experiments: Array.isArray(object?.experiments) ? object.experiments.map((e: any) => String(e)) : [],
      organizations: isObject(object.organizations)
        ? Object.entries(object.organizations).reduce<{ [key: string]: Member }>((acc, [key, value]) => {
          acc[key] = Member.fromJSON(value);
          return acc;
        }, {})
        : {},
      facilities: isObject(object.facilities)
        ? Object.entries(object.facilities).reduce<{ [key: string]: Member }>((acc, [key, value]) => {
          acc[key] = Member.fromJSON(value);
          return acc;
        }, {})
        : {},
      admin: isSet(object.admin) ? Boolean(object.admin) : false,
      ver: isSet(object.ver) ? Number(object.ver) : 0,
      institution: isSet(object.institution) ? String(object.institution) : "",
      category: isSet(object.category) ? String(object.category) : "",
      email: isSet(object.email) ? String(object.email) : "",
      country: isSet(object.country) ? String(object.country) : "",
      usstate: isSet(object.usstate) ? String(object.usstate) : "",
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    message.username !== undefined && (obj.username = message.username);
    message.name !== undefined && (obj.name = message.name);
    message.state !== undefined && (obj.state = userStateToJSON(message.state));
    message.accessMode !== undefined && (obj.accessMode = accessModeToJSON(message.accessMode));
    message.uid !== undefined && (obj.uid = Math.round(message.uid));
    message.gid !== undefined && (obj.gid = Math.round(message.gid));
    obj.projects = {};
    if (message.projects) {
      Object.entries(message.projects).forEach(([k, v]) => {
        obj.projects[k] = Member.toJSON(v);
      });
    }
    if (message.experiments) {
      obj.experiments = message.experiments.map((e) => e);
    } else {
      obj.experiments = [];
    }
    obj.organizations = {};
    if (message.organizations) {
      Object.entries(message.organizations).forEach(([k, v]) => {
        obj.organizations[k] = Member.toJSON(v);
      });
    }
    obj.facilities = {};
    if (message.facilities) {
      Object.entries(message.facilities).forEach(([k, v]) => {
        obj.facilities[k] = Member.toJSON(v);
      });
    }
    message.admin !== undefined && (obj.admin = message.admin);
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    message.institution !== undefined && (obj.institution = message.institution);
    message.category !== undefined && (obj.category = message.category);
    message.email !== undefined && (obj.email = message.email);
    message.country !== undefined && (obj.country = message.country);
    message.usstate !== undefined && (obj.usstate = message.usstate);
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.username = object.username ?? "";
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.accessMode = object.accessMode ?? 0;
    message.uid = object.uid ?? 0;
    message.gid = object.gid ?? 0;
    message.projects = Object.entries(object.projects ?? {}).reduce<{ [key: string]: Member }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Member.fromPartial(value);
      }
      return acc;
    }, {});
    message.experiments = object.experiments?.map((e) => e) || [];
    message.organizations = Object.entries(object.organizations ?? {}).reduce<{ [key: string]: Member }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Member.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.facilities = Object.entries(object.facilities ?? {}).reduce<{ [key: string]: Member }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Member.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.admin = object.admin ?? false;
    message.ver = object.ver ?? 0;
    message.institution = object.institution ?? "";
    message.category = object.category ?? "";
    message.email = object.email ?? "";
    message.country = object.country ?? "";
    message.usstate = object.usstate ?? "";
    return message;
  },
};

function createBaseUser_ProjectsEntry(): User_ProjectsEntry {
  return { key: "", value: undefined };
}

export const User_ProjectsEntry = {
  encode(message: User_ProjectsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Member.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): User_ProjectsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_ProjectsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): User_ProjectsEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Member.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: User_ProjectsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? Member.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<User_ProjectsEntry>, I>>(base?: I): User_ProjectsEntry {
    return User_ProjectsEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<User_ProjectsEntry>, I>>(object: I): User_ProjectsEntry {
    const message = createBaseUser_ProjectsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Member.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseUser_OrganizationsEntry(): User_OrganizationsEntry {
  return { key: "", value: undefined };
}

export const User_OrganizationsEntry = {
  encode(message: User_OrganizationsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Member.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): User_OrganizationsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_OrganizationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): User_OrganizationsEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Member.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: User_OrganizationsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? Member.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<User_OrganizationsEntry>, I>>(base?: I): User_OrganizationsEntry {
    return User_OrganizationsEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<User_OrganizationsEntry>, I>>(object: I): User_OrganizationsEntry {
    const message = createBaseUser_OrganizationsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Member.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseUser_FacilitiesEntry(): User_FacilitiesEntry {
  return { key: "", value: undefined };
}

export const User_FacilitiesEntry = {
  encode(message: User_FacilitiesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Member.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): User_FacilitiesEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_FacilitiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): User_FacilitiesEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Member.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: User_FacilitiesEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? Member.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<User_FacilitiesEntry>, I>>(base?: I): User_FacilitiesEntry {
    return User_FacilitiesEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<User_FacilitiesEntry>, I>>(object: I): User_FacilitiesEntry {
    const message = createBaseUser_FacilitiesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Member.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseInitUserRequest(): InitUserRequest {
  return { username: "", status: false };
}

export const InitUserRequest = {
  encode(message: InitUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.status === true) {
      writer.uint32(16).bool(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InitUserRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.username = reader.string();
          break;
        case 2:
          message.status = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InitUserRequest {
    return {
      username: isSet(object.username) ? String(object.username) : "",
      status: isSet(object.status) ? Boolean(object.status) : false,
    };
  },

  toJSON(message: InitUserRequest): unknown {
    const obj: any = {};
    message.username !== undefined && (obj.username = message.username);
    message.status !== undefined && (obj.status = message.status);
    return obj;
  },

  create<I extends Exact<DeepPartial<InitUserRequest>, I>>(base?: I): InitUserRequest {
    return InitUserRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<InitUserRequest>, I>>(object: I): InitUserRequest {
    const message = createBaseInitUserRequest();
    message.username = object.username ?? "";
    message.status = object.status ?? false;
    return message;
  },
};

function createBaseInitUserResponse(): InitUserResponse {
  return { status: undefined };
}

export const InitUserResponse = {
  encode(message: InitUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== undefined) {
      TaskForest.encode(message.status, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InitUserResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.status = TaskForest.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InitUserResponse {
    return { status: isSet(object.status) ? TaskForest.fromJSON(object.status) : undefined };
  },

  toJSON(message: InitUserResponse): unknown {
    const obj: any = {};
    message.status !== undefined && (obj.status = message.status ? TaskForest.toJSON(message.status) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<InitUserResponse>, I>>(base?: I): InitUserResponse {
    return InitUserResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<InitUserResponse>, I>>(object: I): InitUserResponse {
    const message = createBaseInitUserResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? TaskForest.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseActivateUserRequest(): ActivateUserRequest {
  return { username: "" };
}

export const ActivateUserRequest = {
  encode(message: ActivateUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActivateUserRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ActivateUserRequest {
    return { username: isSet(object.username) ? String(object.username) : "" };
  },

  toJSON(message: ActivateUserRequest): unknown {
    const obj: any = {};
    message.username !== undefined && (obj.username = message.username);
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivateUserRequest>, I>>(base?: I): ActivateUserRequest {
    return ActivateUserRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ActivateUserRequest>, I>>(object: I): ActivateUserRequest {
    const message = createBaseActivateUserRequest();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseActivateUserResponse(): ActivateUserResponse {
  return {};
}

export const ActivateUserResponse = {
  encode(_: ActivateUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActivateUserResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): ActivateUserResponse {
    return {};
  },

  toJSON(_: ActivateUserResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivateUserResponse>, I>>(base?: I): ActivateUserResponse {
    return ActivateUserResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ActivateUserResponse>, I>>(_: I): ActivateUserResponse {
    const message = createBaseActivateUserResponse();
    return message;
  },
};

function createBaseFreezeUserRequest(): FreezeUserRequest {
  return { username: "" };
}

export const FreezeUserRequest = {
  encode(message: FreezeUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FreezeUserRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreezeUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FreezeUserRequest {
    return { username: isSet(object.username) ? String(object.username) : "" };
  },

  toJSON(message: FreezeUserRequest): unknown {
    const obj: any = {};
    message.username !== undefined && (obj.username = message.username);
    return obj;
  },

  create<I extends Exact<DeepPartial<FreezeUserRequest>, I>>(base?: I): FreezeUserRequest {
    return FreezeUserRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<FreezeUserRequest>, I>>(object: I): FreezeUserRequest {
    const message = createBaseFreezeUserRequest();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseFreezeUserResponse(): FreezeUserResponse {
  return {};
}

export const FreezeUserResponse = {
  encode(_: FreezeUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FreezeUserResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreezeUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): FreezeUserResponse {
    return {};
  },

  toJSON(_: FreezeUserResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<FreezeUserResponse>, I>>(base?: I): FreezeUserResponse {
    return FreezeUserResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<FreezeUserResponse>, I>>(_: I): FreezeUserResponse {
    const message = createBaseFreezeUserResponse();
    return message;
  },
};

function createBaseGetUsersRequest(): GetUsersRequest {
  return { filter: 0 };
}

export const GetUsersRequest = {
  encode(message: GetUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filter !== 0) {
      writer.uint32(8).int32(message.filter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUsersRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.filter = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetUsersRequest {
    return { filter: isSet(object.filter) ? filterModeFromJSON(object.filter) : 0 };
  },

  toJSON(message: GetUsersRequest): unknown {
    const obj: any = {};
    message.filter !== undefined && (obj.filter = filterModeToJSON(message.filter));
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUsersRequest>, I>>(base?: I): GetUsersRequest {
    return GetUsersRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetUsersRequest>, I>>(object: I): GetUsersRequest {
    const message = createBaseGetUsersRequest();
    message.filter = object.filter ?? 0;
    return message;
  },
};

function createBaseGetUsersResponse(): GetUsersResponse {
  return { users: [] };
}

export const GetUsersResponse = {
  encode(message: GetUsersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUsersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.users.push(User.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetUsersResponse {
    return { users: Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [] };
  },

  toJSON(message: GetUsersResponse): unknown {
    const obj: any = {};
    if (message.users) {
      obj.users = message.users.map((e) => e ? User.toJSON(e) : undefined);
    } else {
      obj.users = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUsersResponse>, I>>(base?: I): GetUsersResponse {
    return GetUsersResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetUsersResponse>, I>>(object: I): GetUsersResponse {
    const message = createBaseGetUsersResponse();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetUserRequest(): GetUserRequest {
  return { username: "" };
}

export const GetUserRequest = {
  encode(message: GetUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetUserRequest {
    return { username: isSet(object.username) ? String(object.username) : "" };
  },

  toJSON(message: GetUserRequest): unknown {
    const obj: any = {};
    message.username !== undefined && (obj.username = message.username);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserRequest>, I>>(base?: I): GetUserRequest {
    return GetUserRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetUserRequest>, I>>(object: I): GetUserRequest {
    const message = createBaseGetUserRequest();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseGetUserResponse(): GetUserResponse {
  return { user: undefined };
}

export const GetUserResponse = {
  encode(message: GetUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = User.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetUserResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: GetUserResponse): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user ? User.toJSON(message.user) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserResponse>, I>>(base?: I): GetUserResponse {
    return GetUserResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetUserResponse>, I>>(object: I): GetUserResponse {
    const message = createBaseGetUserResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseUpdateUserRequest(): UpdateUserRequest {
  return {
    username: "",
    name: "",
    state: undefined,
    accessMode: undefined,
    organizations: undefined,
    projects: undefined,
    facilities: undefined,
    experiments: [],
    toggleAdmin: false,
  };
}

export const UpdateUserRequest = {
  encode(message: UpdateUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.state !== undefined) {
      UserStateUpdate.encode(message.state, writer.uint32(26).fork()).ldelim();
    }
    if (message.accessMode !== undefined) {
      AccessModeUpdate.encode(message.accessMode, writer.uint32(34).fork()).ldelim();
    }
    if (message.organizations !== undefined) {
      MembershipUpdate.encode(message.organizations, writer.uint32(42).fork()).ldelim();
    }
    if (message.projects !== undefined) {
      MembershipUpdate.encode(message.projects, writer.uint32(50).fork()).ldelim();
    }
    if (message.facilities !== undefined) {
      MembershipUpdate.encode(message.facilities, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.experiments) {
      writer.uint32(66).string(v!);
    }
    if (message.toggleAdmin === true) {
      writer.uint32(72).bool(message.toggleAdmin);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.username = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.state = UserStateUpdate.decode(reader, reader.uint32());
          break;
        case 4:
          message.accessMode = AccessModeUpdate.decode(reader, reader.uint32());
          break;
        case 5:
          message.organizations = MembershipUpdate.decode(reader, reader.uint32());
          break;
        case 6:
          message.projects = MembershipUpdate.decode(reader, reader.uint32());
          break;
        case 7:
          message.facilities = MembershipUpdate.decode(reader, reader.uint32());
          break;
        case 8:
          message.experiments.push(reader.string());
          break;
        case 9:
          message.toggleAdmin = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateUserRequest {
    return {
      username: isSet(object.username) ? String(object.username) : "",
      name: isSet(object.name) ? String(object.name) : "",
      state: isSet(object.state) ? UserStateUpdate.fromJSON(object.state) : undefined,
      accessMode: isSet(object.accessMode) ? AccessModeUpdate.fromJSON(object.accessMode) : undefined,
      organizations: isSet(object.organizations) ? MembershipUpdate.fromJSON(object.organizations) : undefined,
      projects: isSet(object.projects) ? MembershipUpdate.fromJSON(object.projects) : undefined,
      facilities: isSet(object.facilities) ? MembershipUpdate.fromJSON(object.facilities) : undefined,
      experiments: Array.isArray(object?.experiments) ? object.experiments.map((e: any) => String(e)) : [],
      toggleAdmin: isSet(object.toggleAdmin) ? Boolean(object.toggleAdmin) : false,
    };
  },

  toJSON(message: UpdateUserRequest): unknown {
    const obj: any = {};
    message.username !== undefined && (obj.username = message.username);
    message.name !== undefined && (obj.name = message.name);
    message.state !== undefined && (obj.state = message.state ? UserStateUpdate.toJSON(message.state) : undefined);
    message.accessMode !== undefined &&
      (obj.accessMode = message.accessMode ? AccessModeUpdate.toJSON(message.accessMode) : undefined);
    message.organizations !== undefined &&
      (obj.organizations = message.organizations ? MembershipUpdate.toJSON(message.organizations) : undefined);
    message.projects !== undefined &&
      (obj.projects = message.projects ? MembershipUpdate.toJSON(message.projects) : undefined);
    message.facilities !== undefined &&
      (obj.facilities = message.facilities ? MembershipUpdate.toJSON(message.facilities) : undefined);
    if (message.experiments) {
      obj.experiments = message.experiments.map((e) => e);
    } else {
      obj.experiments = [];
    }
    message.toggleAdmin !== undefined && (obj.toggleAdmin = message.toggleAdmin);
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserRequest>, I>>(base?: I): UpdateUserRequest {
    return UpdateUserRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateUserRequest>, I>>(object: I): UpdateUserRequest {
    const message = createBaseUpdateUserRequest();
    message.username = object.username ?? "";
    message.name = object.name ?? "";
    message.state = (object.state !== undefined && object.state !== null)
      ? UserStateUpdate.fromPartial(object.state)
      : undefined;
    message.accessMode = (object.accessMode !== undefined && object.accessMode !== null)
      ? AccessModeUpdate.fromPartial(object.accessMode)
      : undefined;
    message.organizations = (object.organizations !== undefined && object.organizations !== null)
      ? MembershipUpdate.fromPartial(object.organizations)
      : undefined;
    message.projects = (object.projects !== undefined && object.projects !== null)
      ? MembershipUpdate.fromPartial(object.projects)
      : undefined;
    message.facilities = (object.facilities !== undefined && object.facilities !== null)
      ? MembershipUpdate.fromPartial(object.facilities)
      : undefined;
    message.experiments = object.experiments?.map((e) => e) || [];
    message.toggleAdmin = object.toggleAdmin ?? false;
    return message;
  },
};

function createBaseUpdateUserResponse(): UpdateUserResponse {
  return {};
}

export const UpdateUserResponse = {
  encode(_: UpdateUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): UpdateUserResponse {
    return {};
  },

  toJSON(_: UpdateUserResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserResponse>, I>>(base?: I): UpdateUserResponse {
    return UpdateUserResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateUserResponse>, I>>(_: I): UpdateUserResponse {
    const message = createBaseUpdateUserResponse();
    return message;
  },
};

function createBaseDeleteUserRequest(): DeleteUserRequest {
  return { user: "" };
}

export const DeleteUserRequest = {
  encode(message: DeleteUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteUserRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteUserRequest {
    return { user: isSet(object.user) ? String(object.user) : "" };
  },

  toJSON(message: DeleteUserRequest): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user);
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(base?: I): DeleteUserRequest {
    return DeleteUserRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(object: I): DeleteUserRequest {
    const message = createBaseDeleteUserRequest();
    message.user = object.user ?? "";
    return message;
  },
};

function createBaseDeleteUserResponse(): DeleteUserResponse {
  return {};
}

export const DeleteUserResponse = {
  encode(_: DeleteUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteUserResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteUserResponse {
    return {};
  },

  toJSON(_: DeleteUserResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(base?: I): DeleteUserResponse {
    return DeleteUserResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(_: I): DeleteUserResponse {
    const message = createBaseDeleteUserResponse();
    return message;
  },
};

function createBaseUserStatus(): UserStatus {
  return { username: "", loggedin: false, ver: 0 };
}

export const UserStatus = {
  encode(message: UserStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.loggedin === true) {
      writer.uint32(16).bool(message.loggedin);
    }
    if (message.ver !== 0) {
      writer.uint32(24).int64(message.ver);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.username = reader.string();
          break;
        case 2:
          message.loggedin = reader.bool();
          break;
        case 3:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UserStatus {
    return {
      username: isSet(object.username) ? String(object.username) : "",
      loggedin: isSet(object.loggedin) ? Boolean(object.loggedin) : false,
      ver: isSet(object.ver) ? Number(object.ver) : 0,
    };
  },

  toJSON(message: UserStatus): unknown {
    const obj: any = {};
    message.username !== undefined && (obj.username = message.username);
    message.loggedin !== undefined && (obj.loggedin = message.loggedin);
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    return obj;
  },

  create<I extends Exact<DeepPartial<UserStatus>, I>>(base?: I): UserStatus {
    return UserStatus.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UserStatus>, I>>(object: I): UserStatus {
    const message = createBaseUserStatus();
    message.username = object.username ?? "";
    message.loggedin = object.loggedin ?? false;
    message.ver = object.ver ?? 0;
    return message;
  },
};

function createBasePublicKey(): PublicKey {
  return { fingerprint: "", key: "" };
}

export const PublicKey = {
  encode(message: PublicKey, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fingerprint !== "") {
      writer.uint32(10).string(message.fingerprint);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublicKey {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fingerprint = reader.string();
          break;
        case 2:
          message.key = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PublicKey {
    return {
      fingerprint: isSet(object.fingerprint) ? String(object.fingerprint) : "",
      key: isSet(object.key) ? String(object.key) : "",
    };
  },

  toJSON(message: PublicKey): unknown {
    const obj: any = {};
    message.fingerprint !== undefined && (obj.fingerprint = message.fingerprint);
    message.key !== undefined && (obj.key = message.key);
    return obj;
  },

  create<I extends Exact<DeepPartial<PublicKey>, I>>(base?: I): PublicKey {
    return PublicKey.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<PublicKey>, I>>(object: I): PublicKey {
    const message = createBasePublicKey();
    message.fingerprint = object.fingerprint ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseGetUserPublicKeysRequest(): GetUserPublicKeysRequest {
  return { user: "" };
}

export const GetUserPublicKeysRequest = {
  encode(message: GetUserPublicKeysRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserPublicKeysRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserPublicKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetUserPublicKeysRequest {
    return { user: isSet(object.user) ? String(object.user) : "" };
  },

  toJSON(message: GetUserPublicKeysRequest): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserPublicKeysRequest>, I>>(base?: I): GetUserPublicKeysRequest {
    return GetUserPublicKeysRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetUserPublicKeysRequest>, I>>(object: I): GetUserPublicKeysRequest {
    const message = createBaseGetUserPublicKeysRequest();
    message.user = object.user ?? "";
    return message;
  },
};

function createBaseGetUserPublicKeysResponse(): GetUserPublicKeysResponse {
  return { keys: [] };
}

export const GetUserPublicKeysResponse = {
  encode(message: GetUserPublicKeysResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.keys) {
      PublicKey.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserPublicKeysResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserPublicKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.keys.push(PublicKey.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetUserPublicKeysResponse {
    return { keys: Array.isArray(object?.keys) ? object.keys.map((e: any) => PublicKey.fromJSON(e)) : [] };
  },

  toJSON(message: GetUserPublicKeysResponse): unknown {
    const obj: any = {};
    if (message.keys) {
      obj.keys = message.keys.map((e) => e ? PublicKey.toJSON(e) : undefined);
    } else {
      obj.keys = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserPublicKeysResponse>, I>>(base?: I): GetUserPublicKeysResponse {
    return GetUserPublicKeysResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetUserPublicKeysResponse>, I>>(object: I): GetUserPublicKeysResponse {
    const message = createBaseGetUserPublicKeysResponse();
    message.keys = object.keys?.map((e) => PublicKey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddUserPublicKeyRequest(): AddUserPublicKeyRequest {
  return { user: "", key: "" };
}

export const AddUserPublicKeyRequest = {
  encode(message: AddUserPublicKeyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddUserPublicKeyRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddUserPublicKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = reader.string();
          break;
        case 2:
          message.key = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AddUserPublicKeyRequest {
    return { user: isSet(object.user) ? String(object.user) : "", key: isSet(object.key) ? String(object.key) : "" };
  },

  toJSON(message: AddUserPublicKeyRequest): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user);
    message.key !== undefined && (obj.key = message.key);
    return obj;
  },

  create<I extends Exact<DeepPartial<AddUserPublicKeyRequest>, I>>(base?: I): AddUserPublicKeyRequest {
    return AddUserPublicKeyRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddUserPublicKeyRequest>, I>>(object: I): AddUserPublicKeyRequest {
    const message = createBaseAddUserPublicKeyRequest();
    message.user = object.user ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseAddUserPublicKeyResponse(): AddUserPublicKeyResponse {
  return {};
}

export const AddUserPublicKeyResponse = {
  encode(_: AddUserPublicKeyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddUserPublicKeyResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddUserPublicKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): AddUserPublicKeyResponse {
    return {};
  },

  toJSON(_: AddUserPublicKeyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AddUserPublicKeyResponse>, I>>(base?: I): AddUserPublicKeyResponse {
    return AddUserPublicKeyResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddUserPublicKeyResponse>, I>>(_: I): AddUserPublicKeyResponse {
    const message = createBaseAddUserPublicKeyResponse();
    return message;
  },
};

function createBaseDeleteUserPublicKeyRequest(): DeleteUserPublicKeyRequest {
  return { user: "", fingerprint: "" };
}

export const DeleteUserPublicKeyRequest = {
  encode(message: DeleteUserPublicKeyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    if (message.fingerprint !== "") {
      writer.uint32(18).string(message.fingerprint);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteUserPublicKeyRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserPublicKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = reader.string();
          break;
        case 2:
          message.fingerprint = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteUserPublicKeyRequest {
    return {
      user: isSet(object.user) ? String(object.user) : "",
      fingerprint: isSet(object.fingerprint) ? String(object.fingerprint) : "",
    };
  },

  toJSON(message: DeleteUserPublicKeyRequest): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user);
    message.fingerprint !== undefined && (obj.fingerprint = message.fingerprint);
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserPublicKeyRequest>, I>>(base?: I): DeleteUserPublicKeyRequest {
    return DeleteUserPublicKeyRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteUserPublicKeyRequest>, I>>(object: I): DeleteUserPublicKeyRequest {
    const message = createBaseDeleteUserPublicKeyRequest();
    message.user = object.user ?? "";
    message.fingerprint = object.fingerprint ?? "";
    return message;
  },
};

function createBaseDeleteUserPublicKeyResponse(): DeleteUserPublicKeyResponse {
  return {};
}

export const DeleteUserPublicKeyResponse = {
  encode(_: DeleteUserPublicKeyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteUserPublicKeyResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserPublicKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteUserPublicKeyResponse {
    return {};
  },

  toJSON(_: DeleteUserPublicKeyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserPublicKeyResponse>, I>>(base?: I): DeleteUserPublicKeyResponse {
    return DeleteUserPublicKeyResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteUserPublicKeyResponse>, I>>(_: I): DeleteUserPublicKeyResponse {
    const message = createBaseDeleteUserPublicKeyResponse();
    return message;
  },
};

function createBaseDeleteUserPublicKeysRequest(): DeleteUserPublicKeysRequest {
  return { user: "" };
}

export const DeleteUserPublicKeysRequest = {
  encode(message: DeleteUserPublicKeysRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteUserPublicKeysRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserPublicKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteUserPublicKeysRequest {
    return { user: isSet(object.user) ? String(object.user) : "" };
  },

  toJSON(message: DeleteUserPublicKeysRequest): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user);
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserPublicKeysRequest>, I>>(base?: I): DeleteUserPublicKeysRequest {
    return DeleteUserPublicKeysRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteUserPublicKeysRequest>, I>>(object: I): DeleteUserPublicKeysRequest {
    const message = createBaseDeleteUserPublicKeysRequest();
    message.user = object.user ?? "";
    return message;
  },
};

function createBaseDeleteUserPublicKeysResponse(): DeleteUserPublicKeysResponse {
  return {};
}

export const DeleteUserPublicKeysResponse = {
  encode(_: DeleteUserPublicKeysResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteUserPublicKeysResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserPublicKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteUserPublicKeysResponse {
    return {};
  },

  toJSON(_: DeleteUserPublicKeysResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserPublicKeysResponse>, I>>(base?: I): DeleteUserPublicKeysResponse {
    return DeleteUserPublicKeysResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteUserPublicKeysResponse>, I>>(_: I): DeleteUserPublicKeysResponse {
    const message = createBaseDeleteUserPublicKeysResponse();
    return message;
  },
};

function createBaseProject(): Project {
  return {
    name: "",
    description: "",
    members: {},
    experiments: [],
    accessMode: 0,
    gid: 0,
    deprecated: [],
    ver: 0,
    organization: "",
    orgMembership: undefined,
    category: "",
    subcategory: "",
  };
}

export const Project = {
  encode(message: Project, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    Object.entries(message.members).forEach(([key, value]) => {
      Project_MembersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    for (const v of message.experiments) {
      writer.uint32(34).string(v!);
    }
    if (message.accessMode !== 0) {
      writer.uint32(40).int32(message.accessMode);
    }
    if (message.gid !== 0) {
      writer.uint32(48).uint32(message.gid);
    }
    for (const v of message.deprecated) {
      writer.uint32(58).string(v!);
    }
    if (message.ver !== 0) {
      writer.uint32(64).int64(message.ver);
    }
    if (message.organization !== "") {
      writer.uint32(74).string(message.organization);
    }
    if (message.orgMembership !== undefined) {
      Member.encode(message.orgMembership, writer.uint32(82).fork()).ldelim();
    }
    if (message.category !== "") {
      writer.uint32(90).string(message.category);
    }
    if (message.subcategory !== "") {
      writer.uint32(98).string(message.subcategory);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Project {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          const entry3 = Project_MembersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.members[entry3.key] = entry3.value;
          }
          break;
        case 4:
          message.experiments.push(reader.string());
          break;
        case 5:
          message.accessMode = reader.int32() as any;
          break;
        case 6:
          message.gid = reader.uint32();
          break;
        case 7:
          message.deprecated.push(reader.string());
          break;
        case 8:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        case 9:
          message.organization = reader.string();
          break;
        case 10:
          message.orgMembership = Member.decode(reader, reader.uint32());
          break;
        case 11:
          message.category = reader.string();
          break;
        case 12:
          message.subcategory = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Project {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? String(object.description) : "",
      members: isObject(object.members)
        ? Object.entries(object.members).reduce<{ [key: string]: Member }>((acc, [key, value]) => {
          acc[key] = Member.fromJSON(value);
          return acc;
        }, {})
        : {},
      experiments: Array.isArray(object?.experiments) ? object.experiments.map((e: any) => String(e)) : [],
      accessMode: isSet(object.accessMode) ? accessModeFromJSON(object.accessMode) : 0,
      gid: isSet(object.gid) ? Number(object.gid) : 0,
      deprecated: Array.isArray(object?.deprecated) ? object.deprecated.map((e: any) => String(e)) : [],
      ver: isSet(object.ver) ? Number(object.ver) : 0,
      organization: isSet(object.organization) ? String(object.organization) : "",
      orgMembership: isSet(object.orgMembership) ? Member.fromJSON(object.orgMembership) : undefined,
      category: isSet(object.category) ? String(object.category) : "",
      subcategory: isSet(object.subcategory) ? String(object.subcategory) : "",
    };
  },

  toJSON(message: Project): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.description !== undefined && (obj.description = message.description);
    obj.members = {};
    if (message.members) {
      Object.entries(message.members).forEach(([k, v]) => {
        obj.members[k] = Member.toJSON(v);
      });
    }
    if (message.experiments) {
      obj.experiments = message.experiments.map((e) => e);
    } else {
      obj.experiments = [];
    }
    message.accessMode !== undefined && (obj.accessMode = accessModeToJSON(message.accessMode));
    message.gid !== undefined && (obj.gid = Math.round(message.gid));
    if (message.deprecated) {
      obj.deprecated = message.deprecated.map((e) => e);
    } else {
      obj.deprecated = [];
    }
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    message.organization !== undefined && (obj.organization = message.organization);
    message.orgMembership !== undefined &&
      (obj.orgMembership = message.orgMembership ? Member.toJSON(message.orgMembership) : undefined);
    message.category !== undefined && (obj.category = message.category);
    message.subcategory !== undefined && (obj.subcategory = message.subcategory);
    return obj;
  },

  create<I extends Exact<DeepPartial<Project>, I>>(base?: I): Project {
    return Project.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Project>, I>>(object: I): Project {
    const message = createBaseProject();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.members = Object.entries(object.members ?? {}).reduce<{ [key: string]: Member }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Member.fromPartial(value);
      }
      return acc;
    }, {});
    message.experiments = object.experiments?.map((e) => e) || [];
    message.accessMode = object.accessMode ?? 0;
    message.gid = object.gid ?? 0;
    message.deprecated = object.deprecated?.map((e) => e) || [];
    message.ver = object.ver ?? 0;
    message.organization = object.organization ?? "";
    message.orgMembership = (object.orgMembership !== undefined && object.orgMembership !== null)
      ? Member.fromPartial(object.orgMembership)
      : undefined;
    message.category = object.category ?? "";
    message.subcategory = object.subcategory ?? "";
    return message;
  },
};

function createBaseProject_MembersEntry(): Project_MembersEntry {
  return { key: "", value: undefined };
}

export const Project_MembersEntry = {
  encode(message: Project_MembersEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Member.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Project_MembersEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProject_MembersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Project_MembersEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Member.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Project_MembersEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? Member.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Project_MembersEntry>, I>>(base?: I): Project_MembersEntry {
    return Project_MembersEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Project_MembersEntry>, I>>(object: I): Project_MembersEntry {
    const message = createBaseProject_MembersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Member.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetProjectsRequest(): GetProjectsRequest {
  return { filter: 0 };
}

export const GetProjectsRequest = {
  encode(message: GetProjectsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filter !== 0) {
      writer.uint32(8).int32(message.filter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProjectsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProjectsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.filter = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetProjectsRequest {
    return { filter: isSet(object.filter) ? filterModeFromJSON(object.filter) : 0 };
  },

  toJSON(message: GetProjectsRequest): unknown {
    const obj: any = {};
    message.filter !== undefined && (obj.filter = filterModeToJSON(message.filter));
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProjectsRequest>, I>>(base?: I): GetProjectsRequest {
    return GetProjectsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetProjectsRequest>, I>>(object: I): GetProjectsRequest {
    const message = createBaseGetProjectsRequest();
    message.filter = object.filter ?? 0;
    return message;
  },
};

function createBaseGetProjectsResponse(): GetProjectsResponse {
  return { projects: [] };
}

export const GetProjectsResponse = {
  encode(message: GetProjectsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.projects) {
      Project.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProjectsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProjectsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.projects.push(Project.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetProjectsResponse {
    return { projects: Array.isArray(object?.projects) ? object.projects.map((e: any) => Project.fromJSON(e)) : [] };
  },

  toJSON(message: GetProjectsResponse): unknown {
    const obj: any = {};
    if (message.projects) {
      obj.projects = message.projects.map((e) => e ? Project.toJSON(e) : undefined);
    } else {
      obj.projects = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProjectsResponse>, I>>(base?: I): GetProjectsResponse {
    return GetProjectsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetProjectsResponse>, I>>(object: I): GetProjectsResponse {
    const message = createBaseGetProjectsResponse();
    message.projects = object.projects?.map((e) => Project.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetProjectRequest(): GetProjectRequest {
  return { name: "" };
}

export const GetProjectRequest = {
  encode(message: GetProjectRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProjectRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetProjectRequest {
    return { name: isSet(object.name) ? String(object.name) : "" };
  },

  toJSON(message: GetProjectRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProjectRequest>, I>>(base?: I): GetProjectRequest {
    return GetProjectRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetProjectRequest>, I>>(object: I): GetProjectRequest {
    const message = createBaseGetProjectRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetProjectResponse(): GetProjectResponse {
  return { project: undefined };
}

export const GetProjectResponse = {
  encode(message: GetProjectResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== undefined) {
      Project.encode(message.project, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProjectResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = Project.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetProjectResponse {
    return { project: isSet(object.project) ? Project.fromJSON(object.project) : undefined };
  },

  toJSON(message: GetProjectResponse): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project ? Project.toJSON(message.project) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProjectResponse>, I>>(base?: I): GetProjectResponse {
    return GetProjectResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetProjectResponse>, I>>(object: I): GetProjectResponse {
    const message = createBaseGetProjectResponse();
    message.project = (object.project !== undefined && object.project !== null)
      ? Project.fromPartial(object.project)
      : undefined;
    return message;
  },
};

function createBaseDeleteProjectRequest(): DeleteProjectRequest {
  return { user: "", name: "" };
}

export const DeleteProjectRequest = {
  encode(message: DeleteProjectRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteProjectRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteProjectRequest {
    return { user: isSet(object.user) ? String(object.user) : "", name: isSet(object.name) ? String(object.name) : "" };
  },

  toJSON(message: DeleteProjectRequest): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user);
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProjectRequest>, I>>(base?: I): DeleteProjectRequest {
    return DeleteProjectRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteProjectRequest>, I>>(object: I): DeleteProjectRequest {
    const message = createBaseDeleteProjectRequest();
    message.user = object.user ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteProjectResponse(): DeleteProjectResponse {
  return {};
}

export const DeleteProjectResponse = {
  encode(_: DeleteProjectResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteProjectResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteProjectResponse {
    return {};
  },

  toJSON(_: DeleteProjectResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProjectResponse>, I>>(base?: I): DeleteProjectResponse {
    return DeleteProjectResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteProjectResponse>, I>>(_: I): DeleteProjectResponse {
    const message = createBaseDeleteProjectResponse();
    return message;
  },
};

function createBaseCreateProjectRequest(): CreateProjectRequest {
  return { user: "", project: undefined, status: false };
}

export const CreateProjectRequest = {
  encode(message: CreateProjectRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    if (message.project !== undefined) {
      Project.encode(message.project, writer.uint32(18).fork()).ldelim();
    }
    if (message.status === true) {
      writer.uint32(24).bool(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateProjectRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = reader.string();
          break;
        case 2:
          message.project = Project.decode(reader, reader.uint32());
          break;
        case 3:
          message.status = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreateProjectRequest {
    return {
      user: isSet(object.user) ? String(object.user) : "",
      project: isSet(object.project) ? Project.fromJSON(object.project) : undefined,
      status: isSet(object.status) ? Boolean(object.status) : false,
    };
  },

  toJSON(message: CreateProjectRequest): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user);
    message.project !== undefined && (obj.project = message.project ? Project.toJSON(message.project) : undefined);
    message.status !== undefined && (obj.status = message.status);
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProjectRequest>, I>>(base?: I): CreateProjectRequest {
    return CreateProjectRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CreateProjectRequest>, I>>(object: I): CreateProjectRequest {
    const message = createBaseCreateProjectRequest();
    message.user = object.user ?? "";
    message.project = (object.project !== undefined && object.project !== null)
      ? Project.fromPartial(object.project)
      : undefined;
    message.status = object.status ?? false;
    return message;
  },
};

function createBaseCreateProjectResponse(): CreateProjectResponse {
  return { status: undefined };
}

export const CreateProjectResponse = {
  encode(message: CreateProjectResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== undefined) {
      TaskForest.encode(message.status, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateProjectResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.status = TaskForest.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreateProjectResponse {
    return { status: isSet(object.status) ? TaskForest.fromJSON(object.status) : undefined };
  },

  toJSON(message: CreateProjectResponse): unknown {
    const obj: any = {};
    message.status !== undefined && (obj.status = message.status ? TaskForest.toJSON(message.status) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProjectResponse>, I>>(base?: I): CreateProjectResponse {
    return CreateProjectResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CreateProjectResponse>, I>>(object: I): CreateProjectResponse {
    const message = createBaseCreateProjectResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? TaskForest.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseDescriptionUpdate(): DescriptionUpdate {
  return { value: "" };
}

export const DescriptionUpdate = {
  encode(message: DescriptionUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DescriptionUpdate {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDescriptionUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DescriptionUpdate {
    return { value: isSet(object.value) ? String(object.value) : "" };
  },

  toJSON(message: DescriptionUpdate): unknown {
    const obj: any = {};
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  create<I extends Exact<DeepPartial<DescriptionUpdate>, I>>(base?: I): DescriptionUpdate {
    return DescriptionUpdate.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DescriptionUpdate>, I>>(object: I): DescriptionUpdate {
    const message = createBaseDescriptionUpdate();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUpdateProjectRequest(): UpdateProjectRequest {
  return { name: "", description: undefined, accessMode: undefined, members: undefined, organization: undefined };
}

export const UpdateProjectRequest = {
  encode(message: UpdateProjectRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== undefined) {
      DescriptionUpdate.encode(message.description, writer.uint32(18).fork()).ldelim();
    }
    if (message.accessMode !== undefined) {
      AccessModeUpdate.encode(message.accessMode, writer.uint32(26).fork()).ldelim();
    }
    if (message.members !== undefined) {
      MembershipUpdate.encode(message.members, writer.uint32(34).fork()).ldelim();
    }
    if (message.organization !== undefined) {
      MembershipUpdate.encode(message.organization, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateProjectRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.description = DescriptionUpdate.decode(reader, reader.uint32());
          break;
        case 3:
          message.accessMode = AccessModeUpdate.decode(reader, reader.uint32());
          break;
        case 4:
          message.members = MembershipUpdate.decode(reader, reader.uint32());
          break;
        case 5:
          message.organization = MembershipUpdate.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateProjectRequest {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? DescriptionUpdate.fromJSON(object.description) : undefined,
      accessMode: isSet(object.accessMode) ? AccessModeUpdate.fromJSON(object.accessMode) : undefined,
      members: isSet(object.members) ? MembershipUpdate.fromJSON(object.members) : undefined,
      organization: isSet(object.organization) ? MembershipUpdate.fromJSON(object.organization) : undefined,
    };
  },

  toJSON(message: UpdateProjectRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.description !== undefined &&
      (obj.description = message.description ? DescriptionUpdate.toJSON(message.description) : undefined);
    message.accessMode !== undefined &&
      (obj.accessMode = message.accessMode ? AccessModeUpdate.toJSON(message.accessMode) : undefined);
    message.members !== undefined &&
      (obj.members = message.members ? MembershipUpdate.toJSON(message.members) : undefined);
    message.organization !== undefined &&
      (obj.organization = message.organization ? MembershipUpdate.toJSON(message.organization) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProjectRequest>, I>>(base?: I): UpdateProjectRequest {
    return UpdateProjectRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateProjectRequest>, I>>(object: I): UpdateProjectRequest {
    const message = createBaseUpdateProjectRequest();
    message.name = object.name ?? "";
    message.description = (object.description !== undefined && object.description !== null)
      ? DescriptionUpdate.fromPartial(object.description)
      : undefined;
    message.accessMode = (object.accessMode !== undefined && object.accessMode !== null)
      ? AccessModeUpdate.fromPartial(object.accessMode)
      : undefined;
    message.members = (object.members !== undefined && object.members !== null)
      ? MembershipUpdate.fromPartial(object.members)
      : undefined;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? MembershipUpdate.fromPartial(object.organization)
      : undefined;
    return message;
  },
};

function createBaseUpdateProjectResponse(): UpdateProjectResponse {
  return {};
}

export const UpdateProjectResponse = {
  encode(_: UpdateProjectResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateProjectResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): UpdateProjectResponse {
    return {};
  },

  toJSON(_: UpdateProjectResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProjectResponse>, I>>(base?: I): UpdateProjectResponse {
    return UpdateProjectResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateProjectResponse>, I>>(_: I): UpdateProjectResponse {
    const message = createBaseUpdateProjectResponse();
    return message;
  },
};

function createBaseGetProjectMembersRequest(): GetProjectMembersRequest {
  return { name: "" };
}

export const GetProjectMembersRequest = {
  encode(message: GetProjectMembersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProjectMembersRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProjectMembersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetProjectMembersRequest {
    return { name: isSet(object.name) ? String(object.name) : "" };
  },

  toJSON(message: GetProjectMembersRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProjectMembersRequest>, I>>(base?: I): GetProjectMembersRequest {
    return GetProjectMembersRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetProjectMembersRequest>, I>>(object: I): GetProjectMembersRequest {
    const message = createBaseGetProjectMembersRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetProjectMembersResponse(): GetProjectMembersResponse {
  return { members: [] };
}

export const GetProjectMembersResponse = {
  encode(message: GetProjectMembersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.members) {
      Member.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProjectMembersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProjectMembersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.members.push(Member.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetProjectMembersResponse {
    return { members: Array.isArray(object?.members) ? object.members.map((e: any) => Member.fromJSON(e)) : [] };
  },

  toJSON(message: GetProjectMembersResponse): unknown {
    const obj: any = {};
    if (message.members) {
      obj.members = message.members.map((e) => e ? Member.toJSON(e) : undefined);
    } else {
      obj.members = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProjectMembersResponse>, I>>(base?: I): GetProjectMembersResponse {
    return GetProjectMembersResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetProjectMembersResponse>, I>>(object: I): GetProjectMembersResponse {
    const message = createBaseGetProjectMembersResponse();
    message.members = object.members?.map((e) => Member.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetProjectMemberRequest(): GetProjectMemberRequest {
  return { project: "", member: "" };
}

export const GetProjectMemberRequest = {
  encode(message: GetProjectMemberRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.member !== "") {
      writer.uint32(18).string(message.member);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProjectMemberRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProjectMemberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.member = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetProjectMemberRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      member: isSet(object.member) ? String(object.member) : "",
    };
  },

  toJSON(message: GetProjectMemberRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.member !== undefined && (obj.member = message.member);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProjectMemberRequest>, I>>(base?: I): GetProjectMemberRequest {
    return GetProjectMemberRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetProjectMemberRequest>, I>>(object: I): GetProjectMemberRequest {
    const message = createBaseGetProjectMemberRequest();
    message.project = object.project ?? "";
    message.member = object.member ?? "";
    return message;
  },
};

function createBaseGetProjectMemberResponse(): GetProjectMemberResponse {
  return { member: undefined };
}

export const GetProjectMemberResponse = {
  encode(message: GetProjectMemberResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.member !== undefined) {
      Member.encode(message.member, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProjectMemberResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProjectMemberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.member = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetProjectMemberResponse {
    return { member: isSet(object.member) ? Member.fromJSON(object.member) : undefined };
  },

  toJSON(message: GetProjectMemberResponse): unknown {
    const obj: any = {};
    message.member !== undefined && (obj.member = message.member ? Member.toJSON(message.member) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProjectMemberResponse>, I>>(base?: I): GetProjectMemberResponse {
    return GetProjectMemberResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetProjectMemberResponse>, I>>(object: I): GetProjectMemberResponse {
    const message = createBaseGetProjectMemberResponse();
    message.member = (object.member !== undefined && object.member !== null)
      ? Member.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseAddProjectMemberRequest(): AddProjectMemberRequest {
  return { project: "", username: "", member: undefined };
}

export const AddProjectMemberRequest = {
  encode(message: AddProjectMemberRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.member !== undefined) {
      Member.encode(message.member, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddProjectMemberRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddProjectMemberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.username = reader.string();
          break;
        case 3:
          message.member = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AddProjectMemberRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      username: isSet(object.username) ? String(object.username) : "",
      member: isSet(object.member) ? Member.fromJSON(object.member) : undefined,
    };
  },

  toJSON(message: AddProjectMemberRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.username !== undefined && (obj.username = message.username);
    message.member !== undefined && (obj.member = message.member ? Member.toJSON(message.member) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<AddProjectMemberRequest>, I>>(base?: I): AddProjectMemberRequest {
    return AddProjectMemberRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddProjectMemberRequest>, I>>(object: I): AddProjectMemberRequest {
    const message = createBaseAddProjectMemberRequest();
    message.project = object.project ?? "";
    message.username = object.username ?? "";
    message.member = (object.member !== undefined && object.member !== null)
      ? Member.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseAddProjectMemberResponse(): AddProjectMemberResponse {
  return {};
}

export const AddProjectMemberResponse = {
  encode(_: AddProjectMemberResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddProjectMemberResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddProjectMemberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): AddProjectMemberResponse {
    return {};
  },

  toJSON(_: AddProjectMemberResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AddProjectMemberResponse>, I>>(base?: I): AddProjectMemberResponse {
    return AddProjectMemberResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddProjectMemberResponse>, I>>(_: I): AddProjectMemberResponse {
    const message = createBaseAddProjectMemberResponse();
    return message;
  },
};

function createBaseUpdateProjectMemberRequest(): UpdateProjectMemberRequest {
  return { project: "", username: "", member: undefined };
}

export const UpdateProjectMemberRequest = {
  encode(message: UpdateProjectMemberRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.member !== undefined) {
      Member.encode(message.member, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateProjectMemberRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProjectMemberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.username = reader.string();
          break;
        case 3:
          message.member = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateProjectMemberRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      username: isSet(object.username) ? String(object.username) : "",
      member: isSet(object.member) ? Member.fromJSON(object.member) : undefined,
    };
  },

  toJSON(message: UpdateProjectMemberRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.username !== undefined && (obj.username = message.username);
    message.member !== undefined && (obj.member = message.member ? Member.toJSON(message.member) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProjectMemberRequest>, I>>(base?: I): UpdateProjectMemberRequest {
    return UpdateProjectMemberRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateProjectMemberRequest>, I>>(object: I): UpdateProjectMemberRequest {
    const message = createBaseUpdateProjectMemberRequest();
    message.project = object.project ?? "";
    message.username = object.username ?? "";
    message.member = (object.member !== undefined && object.member !== null)
      ? Member.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseUpdateProjectMemberResponse(): UpdateProjectMemberResponse {
  return {};
}

export const UpdateProjectMemberResponse = {
  encode(_: UpdateProjectMemberResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateProjectMemberResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProjectMemberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): UpdateProjectMemberResponse {
    return {};
  },

  toJSON(_: UpdateProjectMemberResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProjectMemberResponse>, I>>(base?: I): UpdateProjectMemberResponse {
    return UpdateProjectMemberResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateProjectMemberResponse>, I>>(_: I): UpdateProjectMemberResponse {
    const message = createBaseUpdateProjectMemberResponse();
    return message;
  },
};

function createBaseDeleteProjectMemberRequest(): DeleteProjectMemberRequest {
  return { project: "", member: "" };
}

export const DeleteProjectMemberRequest = {
  encode(message: DeleteProjectMemberRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.member !== "") {
      writer.uint32(18).string(message.member);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteProjectMemberRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProjectMemberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.member = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteProjectMemberRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      member: isSet(object.member) ? String(object.member) : "",
    };
  },

  toJSON(message: DeleteProjectMemberRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.member !== undefined && (obj.member = message.member);
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProjectMemberRequest>, I>>(base?: I): DeleteProjectMemberRequest {
    return DeleteProjectMemberRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteProjectMemberRequest>, I>>(object: I): DeleteProjectMemberRequest {
    const message = createBaseDeleteProjectMemberRequest();
    message.project = object.project ?? "";
    message.member = object.member ?? "";
    return message;
  },
};

function createBaseDeleteProjectMemberResponse(): DeleteProjectMemberResponse {
  return {};
}

export const DeleteProjectMemberResponse = {
  encode(_: DeleteProjectMemberResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteProjectMemberResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProjectMemberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteProjectMemberResponse {
    return {};
  },

  toJSON(_: DeleteProjectMemberResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProjectMemberResponse>, I>>(base?: I): DeleteProjectMemberResponse {
    return DeleteProjectMemberResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteProjectMemberResponse>, I>>(_: I): DeleteProjectMemberResponse {
    const message = createBaseDeleteProjectMemberResponse();
    return message;
  },
};

function createBaseExperimentModel(): ExperimentModel {
  return { compiled: false, msg: "", realizations: [], compileTime: undefined };
}

export const ExperimentModel = {
  encode(message: ExperimentModel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.compiled === true) {
      writer.uint32(8).bool(message.compiled);
    }
    if (message.msg !== "") {
      writer.uint32(18).string(message.msg);
    }
    for (const v of message.realizations) {
      writer.uint32(26).string(v!);
    }
    if (message.compileTime !== undefined) {
      Timestamp.encode(toTimestamp(message.compileTime), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExperimentModel {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExperimentModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.compiled = reader.bool();
          break;
        case 2:
          message.msg = reader.string();
          break;
        case 3:
          message.realizations.push(reader.string());
          break;
        case 4:
          message.compileTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ExperimentModel {
    return {
      compiled: isSet(object.compiled) ? Boolean(object.compiled) : false,
      msg: isSet(object.msg) ? String(object.msg) : "",
      realizations: Array.isArray(object?.realizations) ? object.realizations.map((e: any) => String(e)) : [],
      compileTime: isSet(object.compileTime) ? fromJsonTimestamp(object.compileTime) : undefined,
    };
  },

  toJSON(message: ExperimentModel): unknown {
    const obj: any = {};
    message.compiled !== undefined && (obj.compiled = message.compiled);
    message.msg !== undefined && (obj.msg = message.msg);
    if (message.realizations) {
      obj.realizations = message.realizations.map((e) => e);
    } else {
      obj.realizations = [];
    }
    message.compileTime !== undefined && (obj.compileTime = message.compileTime.toISOString());
    return obj;
  },

  create<I extends Exact<DeepPartial<ExperimentModel>, I>>(base?: I): ExperimentModel {
    return ExperimentModel.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ExperimentModel>, I>>(object: I): ExperimentModel {
    const message = createBaseExperimentModel();
    message.compiled = object.compiled ?? false;
    message.msg = object.msg ?? "";
    message.realizations = object.realizations?.map((e) => e) || [];
    message.compileTime = object.compileTime ?? undefined;
    return message;
  },
};

function createBaseExperiment(): Experiment {
  return {
    name: "",
    project: "",
    description: "",
    models: {},
    accessMode: 0,
    repository: "",
    creator: "",
    maintainers: [],
    ver: 0,
  };
}

export const Experiment = {
  encode(message: Experiment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    Object.entries(message.models).forEach(([key, value]) => {
      Experiment_ModelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    if (message.accessMode !== 0) {
      writer.uint32(40).int32(message.accessMode);
    }
    if (message.repository !== "") {
      writer.uint32(50).string(message.repository);
    }
    if (message.creator !== "") {
      writer.uint32(58).string(message.creator);
    }
    for (const v of message.maintainers) {
      writer.uint32(66).string(v!);
    }
    if (message.ver !== 0) {
      writer.uint32(72).int64(message.ver);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Experiment {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExperiment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.project = reader.string();
          break;
        case 3:
          message.description = reader.string();
          break;
        case 4:
          const entry4 = Experiment_ModelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.models[entry4.key] = entry4.value;
          }
          break;
        case 5:
          message.accessMode = reader.int32() as any;
          break;
        case 6:
          message.repository = reader.string();
          break;
        case 7:
          message.creator = reader.string();
          break;
        case 8:
          message.maintainers.push(reader.string());
          break;
        case 9:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Experiment {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      project: isSet(object.project) ? String(object.project) : "",
      description: isSet(object.description) ? String(object.description) : "",
      models: isObject(object.models)
        ? Object.entries(object.models).reduce<{ [key: string]: ExperimentModel }>((acc, [key, value]) => {
          acc[key] = ExperimentModel.fromJSON(value);
          return acc;
        }, {})
        : {},
      accessMode: isSet(object.accessMode) ? accessModeFromJSON(object.accessMode) : 0,
      repository: isSet(object.repository) ? String(object.repository) : "",
      creator: isSet(object.creator) ? String(object.creator) : "",
      maintainers: Array.isArray(object?.maintainers) ? object.maintainers.map((e: any) => String(e)) : [],
      ver: isSet(object.ver) ? Number(object.ver) : 0,
    };
  },

  toJSON(message: Experiment): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.project !== undefined && (obj.project = message.project);
    message.description !== undefined && (obj.description = message.description);
    obj.models = {};
    if (message.models) {
      Object.entries(message.models).forEach(([k, v]) => {
        obj.models[k] = ExperimentModel.toJSON(v);
      });
    }
    message.accessMode !== undefined && (obj.accessMode = accessModeToJSON(message.accessMode));
    message.repository !== undefined && (obj.repository = message.repository);
    message.creator !== undefined && (obj.creator = message.creator);
    if (message.maintainers) {
      obj.maintainers = message.maintainers.map((e) => e);
    } else {
      obj.maintainers = [];
    }
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    return obj;
  },

  create<I extends Exact<DeepPartial<Experiment>, I>>(base?: I): Experiment {
    return Experiment.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Experiment>, I>>(object: I): Experiment {
    const message = createBaseExperiment();
    message.name = object.name ?? "";
    message.project = object.project ?? "";
    message.description = object.description ?? "";
    message.models = Object.entries(object.models ?? {}).reduce<{ [key: string]: ExperimentModel }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ExperimentModel.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.accessMode = object.accessMode ?? 0;
    message.repository = object.repository ?? "";
    message.creator = object.creator ?? "";
    message.maintainers = object.maintainers?.map((e) => e) || [];
    message.ver = object.ver ?? 0;
    return message;
  },
};

function createBaseExperiment_ModelsEntry(): Experiment_ModelsEntry {
  return { key: "", value: undefined };
}

export const Experiment_ModelsEntry = {
  encode(message: Experiment_ModelsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ExperimentModel.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Experiment_ModelsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExperiment_ModelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ExperimentModel.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Experiment_ModelsEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? ExperimentModel.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Experiment_ModelsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? ExperimentModel.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Experiment_ModelsEntry>, I>>(base?: I): Experiment_ModelsEntry {
    return Experiment_ModelsEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Experiment_ModelsEntry>, I>>(object: I): Experiment_ModelsEntry {
    const message = createBaseExperiment_ModelsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ExperimentModel.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetExperimentsRequest(): GetExperimentsRequest {
  return { filter: 0 };
}

export const GetExperimentsRequest = {
  encode(message: GetExperimentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filter !== 0) {
      writer.uint32(8).int32(message.filter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExperimentsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExperimentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.filter = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetExperimentsRequest {
    return { filter: isSet(object.filter) ? filterModeFromJSON(object.filter) : 0 };
  },

  toJSON(message: GetExperimentsRequest): unknown {
    const obj: any = {};
    message.filter !== undefined && (obj.filter = filterModeToJSON(message.filter));
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExperimentsRequest>, I>>(base?: I): GetExperimentsRequest {
    return GetExperimentsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetExperimentsRequest>, I>>(object: I): GetExperimentsRequest {
    const message = createBaseGetExperimentsRequest();
    message.filter = object.filter ?? 0;
    return message;
  },
};

function createBaseGetExperimentsResponse(): GetExperimentsResponse {
  return { experiments: [] };
}

export const GetExperimentsResponse = {
  encode(message: GetExperimentsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.experiments) {
      Experiment.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExperimentsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExperimentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.experiments.push(Experiment.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetExperimentsResponse {
    return {
      experiments: Array.isArray(object?.experiments) ? object.experiments.map((e: any) => Experiment.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetExperimentsResponse): unknown {
    const obj: any = {};
    if (message.experiments) {
      obj.experiments = message.experiments.map((e) => e ? Experiment.toJSON(e) : undefined);
    } else {
      obj.experiments = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExperimentsResponse>, I>>(base?: I): GetExperimentsResponse {
    return GetExperimentsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetExperimentsResponse>, I>>(object: I): GetExperimentsResponse {
    const message = createBaseGetExperimentsResponse();
    message.experiments = object.experiments?.map((e) => Experiment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetProjectExperimentsRequest(): GetProjectExperimentsRequest {
  return { project: "" };
}

export const GetProjectExperimentsRequest = {
  encode(message: GetProjectExperimentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProjectExperimentsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProjectExperimentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetProjectExperimentsRequest {
    return { project: isSet(object.project) ? String(object.project) : "" };
  },

  toJSON(message: GetProjectExperimentsRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProjectExperimentsRequest>, I>>(base?: I): GetProjectExperimentsRequest {
    return GetProjectExperimentsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetProjectExperimentsRequest>, I>>(object: I): GetProjectExperimentsRequest {
    const message = createBaseGetProjectExperimentsRequest();
    message.project = object.project ?? "";
    return message;
  },
};

function createBaseGetProjectExperimentsResponse(): GetProjectExperimentsResponse {
  return { experiments: [] };
}

export const GetProjectExperimentsResponse = {
  encode(message: GetProjectExperimentsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.experiments) {
      Experiment.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProjectExperimentsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProjectExperimentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.experiments.push(Experiment.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetProjectExperimentsResponse {
    return {
      experiments: Array.isArray(object?.experiments) ? object.experiments.map((e: any) => Experiment.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetProjectExperimentsResponse): unknown {
    const obj: any = {};
    if (message.experiments) {
      obj.experiments = message.experiments.map((e) => e ? Experiment.toJSON(e) : undefined);
    } else {
      obj.experiments = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProjectExperimentsResponse>, I>>(base?: I): GetProjectExperimentsResponse {
    return GetProjectExperimentsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetProjectExperimentsResponse>, I>>(
    object: I,
  ): GetProjectExperimentsResponse {
    const message = createBaseGetProjectExperimentsResponse();
    message.experiments = object.experiments?.map((e) => Experiment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetExperimentRequest(): GetExperimentRequest {
  return { project: "", experiment: "", withModels: false };
}

export const GetExperimentRequest = {
  encode(message: GetExperimentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(18).string(message.experiment);
    }
    if (message.withModels === true) {
      writer.uint32(24).bool(message.withModels);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExperimentRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExperimentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.experiment = reader.string();
          break;
        case 3:
          message.withModels = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetExperimentRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      withModels: isSet(object.withModels) ? Boolean(object.withModels) : false,
    };
  },

  toJSON(message: GetExperimentRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.withModels !== undefined && (obj.withModels = message.withModels);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExperimentRequest>, I>>(base?: I): GetExperimentRequest {
    return GetExperimentRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetExperimentRequest>, I>>(object: I): GetExperimentRequest {
    const message = createBaseGetExperimentRequest();
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.withModels = object.withModels ?? false;
    return message;
  },
};

function createBaseXpNetModel(): XpNetModel {
  return { compiled: false, model: undefined };
}

export const XpNetModel = {
  encode(message: XpNetModel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.compiled === true) {
      writer.uint32(8).bool(message.compiled);
    }
    if (message.model !== undefined) {
      Network.encode(message.model, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XpNetModel {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXpNetModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.compiled = reader.bool();
          break;
        case 2:
          message.model = Network.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): XpNetModel {
    return {
      compiled: isSet(object.compiled) ? Boolean(object.compiled) : false,
      model: isSet(object.model) ? Network.fromJSON(object.model) : undefined,
    };
  },

  toJSON(message: XpNetModel): unknown {
    const obj: any = {};
    message.compiled !== undefined && (obj.compiled = message.compiled);
    message.model !== undefined && (obj.model = message.model ? Network.toJSON(message.model) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<XpNetModel>, I>>(base?: I): XpNetModel {
    return XpNetModel.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<XpNetModel>, I>>(object: I): XpNetModel {
    const message = createBaseXpNetModel();
    message.compiled = object.compiled ?? false;
    message.model = (object.model !== undefined && object.model !== null)
      ? Network.fromPartial(object.model)
      : undefined;
    return message;
  },
};

function createBaseGetExperimentResponse(): GetExperimentResponse {
  return { experiment: undefined, models: {} };
}

export const GetExperimentResponse = {
  encode(message: GetExperimentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.experiment !== undefined) {
      Experiment.encode(message.experiment, writer.uint32(10).fork()).ldelim();
    }
    Object.entries(message.models).forEach(([key, value]) => {
      GetExperimentResponse_ModelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExperimentResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExperimentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.experiment = Experiment.decode(reader, reader.uint32());
          break;
        case 2:
          const entry2 = GetExperimentResponse_ModelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.models[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetExperimentResponse {
    return {
      experiment: isSet(object.experiment) ? Experiment.fromJSON(object.experiment) : undefined,
      models: isObject(object.models)
        ? Object.entries(object.models).reduce<{ [key: string]: XpNetModel }>((acc, [key, value]) => {
          acc[key] = XpNetModel.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetExperimentResponse): unknown {
    const obj: any = {};
    message.experiment !== undefined &&
      (obj.experiment = message.experiment ? Experiment.toJSON(message.experiment) : undefined);
    obj.models = {};
    if (message.models) {
      Object.entries(message.models).forEach(([k, v]) => {
        obj.models[k] = XpNetModel.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExperimentResponse>, I>>(base?: I): GetExperimentResponse {
    return GetExperimentResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetExperimentResponse>, I>>(object: I): GetExperimentResponse {
    const message = createBaseGetExperimentResponse();
    message.experiment = (object.experiment !== undefined && object.experiment !== null)
      ? Experiment.fromPartial(object.experiment)
      : undefined;
    message.models = Object.entries(object.models ?? {}).reduce<{ [key: string]: XpNetModel }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = XpNetModel.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetExperimentResponse_ModelsEntry(): GetExperimentResponse_ModelsEntry {
  return { key: "", value: undefined };
}

export const GetExperimentResponse_ModelsEntry = {
  encode(message: GetExperimentResponse_ModelsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      XpNetModel.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExperimentResponse_ModelsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExperimentResponse_ModelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = XpNetModel.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetExperimentResponse_ModelsEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? XpNetModel.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetExperimentResponse_ModelsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? XpNetModel.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExperimentResponse_ModelsEntry>, I>>(
    base?: I,
  ): GetExperimentResponse_ModelsEntry {
    return GetExperimentResponse_ModelsEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetExperimentResponse_ModelsEntry>, I>>(
    object: I,
  ): GetExperimentResponse_ModelsEntry {
    const message = createBaseGetExperimentResponse_ModelsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? XpNetModel.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseUpdateExperimentRequest(): UpdateExperimentRequest {
  return { name: "", project: "", description: undefined, accessMode: undefined, creator: "", maintainers: [] };
}

export const UpdateExperimentRequest = {
  encode(message: UpdateExperimentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.description !== undefined) {
      DescriptionUpdate.encode(message.description, writer.uint32(26).fork()).ldelim();
    }
    if (message.accessMode !== undefined) {
      AccessModeUpdate.encode(message.accessMode, writer.uint32(34).fork()).ldelim();
    }
    if (message.creator !== "") {
      writer.uint32(42).string(message.creator);
    }
    for (const v of message.maintainers) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateExperimentRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateExperimentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.project = reader.string();
          break;
        case 3:
          message.description = DescriptionUpdate.decode(reader, reader.uint32());
          break;
        case 4:
          message.accessMode = AccessModeUpdate.decode(reader, reader.uint32());
          break;
        case 5:
          message.creator = reader.string();
          break;
        case 6:
          message.maintainers.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateExperimentRequest {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      project: isSet(object.project) ? String(object.project) : "",
      description: isSet(object.description) ? DescriptionUpdate.fromJSON(object.description) : undefined,
      accessMode: isSet(object.accessMode) ? AccessModeUpdate.fromJSON(object.accessMode) : undefined,
      creator: isSet(object.creator) ? String(object.creator) : "",
      maintainers: Array.isArray(object?.maintainers) ? object.maintainers.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: UpdateExperimentRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.project !== undefined && (obj.project = message.project);
    message.description !== undefined &&
      (obj.description = message.description ? DescriptionUpdate.toJSON(message.description) : undefined);
    message.accessMode !== undefined &&
      (obj.accessMode = message.accessMode ? AccessModeUpdate.toJSON(message.accessMode) : undefined);
    message.creator !== undefined && (obj.creator = message.creator);
    if (message.maintainers) {
      obj.maintainers = message.maintainers.map((e) => e);
    } else {
      obj.maintainers = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateExperimentRequest>, I>>(base?: I): UpdateExperimentRequest {
    return UpdateExperimentRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateExperimentRequest>, I>>(object: I): UpdateExperimentRequest {
    const message = createBaseUpdateExperimentRequest();
    message.name = object.name ?? "";
    message.project = object.project ?? "";
    message.description = (object.description !== undefined && object.description !== null)
      ? DescriptionUpdate.fromPartial(object.description)
      : undefined;
    message.accessMode = (object.accessMode !== undefined && object.accessMode !== null)
      ? AccessModeUpdate.fromPartial(object.accessMode)
      : undefined;
    message.creator = object.creator ?? "";
    message.maintainers = object.maintainers?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateExperimentResponse(): UpdateExperimentResponse {
  return {};
}

export const UpdateExperimentResponse = {
  encode(_: UpdateExperimentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateExperimentResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateExperimentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): UpdateExperimentResponse {
    return {};
  },

  toJSON(_: UpdateExperimentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateExperimentResponse>, I>>(base?: I): UpdateExperimentResponse {
    return UpdateExperimentResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateExperimentResponse>, I>>(_: I): UpdateExperimentResponse {
    const message = createBaseUpdateExperimentResponse();
    return message;
  },
};

function createBaseCreateExperimentRequest(): CreateExperimentRequest {
  return { experiment: undefined };
}

export const CreateExperimentRequest = {
  encode(message: CreateExperimentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.experiment !== undefined) {
      Experiment.encode(message.experiment, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateExperimentRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateExperimentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.experiment = Experiment.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreateExperimentRequest {
    return { experiment: isSet(object.experiment) ? Experiment.fromJSON(object.experiment) : undefined };
  },

  toJSON(message: CreateExperimentRequest): unknown {
    const obj: any = {};
    message.experiment !== undefined &&
      (obj.experiment = message.experiment ? Experiment.toJSON(message.experiment) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateExperimentRequest>, I>>(base?: I): CreateExperimentRequest {
    return CreateExperimentRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CreateExperimentRequest>, I>>(object: I): CreateExperimentRequest {
    const message = createBaseCreateExperimentRequest();
    message.experiment = (object.experiment !== undefined && object.experiment !== null)
      ? Experiment.fromPartial(object.experiment)
      : undefined;
    return message;
  },
};

function createBaseCreateExperimentResponse(): CreateExperimentResponse {
  return {};
}

export const CreateExperimentResponse = {
  encode(_: CreateExperimentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateExperimentResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateExperimentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): CreateExperimentResponse {
    return {};
  },

  toJSON(_: CreateExperimentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateExperimentResponse>, I>>(base?: I): CreateExperimentResponse {
    return CreateExperimentResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CreateExperimentResponse>, I>>(_: I): CreateExperimentResponse {
    const message = createBaseCreateExperimentResponse();
    return message;
  },
};

function createBaseDeleteExperimentRequest(): DeleteExperimentRequest {
  return { project: "", experiment: "" };
}

export const DeleteExperimentRequest = {
  encode(message: DeleteExperimentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(18).string(message.experiment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteExperimentRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteExperimentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.experiment = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteExperimentRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
    };
  },

  toJSON(message: DeleteExperimentRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteExperimentRequest>, I>>(base?: I): DeleteExperimentRequest {
    return DeleteExperimentRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteExperimentRequest>, I>>(object: I): DeleteExperimentRequest {
    const message = createBaseDeleteExperimentRequest();
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    return message;
  },
};

function createBaseDeleteExperimentResponse(): DeleteExperimentResponse {
  return {};
}

export const DeleteExperimentResponse = {
  encode(_: DeleteExperimentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteExperimentResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteExperimentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteExperimentResponse {
    return {};
  },

  toJSON(_: DeleteExperimentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteExperimentResponse>, I>>(base?: I): DeleteExperimentResponse {
    return DeleteExperimentResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteExperimentResponse>, I>>(_: I): DeleteExperimentResponse {
    const message = createBaseDeleteExperimentResponse();
    return message;
  },
};

function createBaseGetRevisionRequest(): GetRevisionRequest {
  return { project: "", experiment: "", revision: "", encoding: 0 };
}

export const GetRevisionRequest = {
  encode(message: GetRevisionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.experiment !== "") {
      writer.uint32(18).string(message.experiment);
    }
    if (message.revision !== "") {
      writer.uint32(26).string(message.revision);
    }
    if (message.encoding !== 0) {
      writer.uint32(32).int32(message.encoding);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRevisionRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRevisionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.project = reader.string();
          break;
        case 2:
          message.experiment = reader.string();
          break;
        case 3:
          message.revision = reader.string();
          break;
        case 4:
          message.encoding = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetRevisionRequest {
    return {
      project: isSet(object.project) ? String(object.project) : "",
      experiment: isSet(object.experiment) ? String(object.experiment) : "",
      revision: isSet(object.revision) ? String(object.revision) : "",
      encoding: isSet(object.encoding) ? getRevisionRequest_EncodingFromJSON(object.encoding) : 0,
    };
  },

  toJSON(message: GetRevisionRequest): unknown {
    const obj: any = {};
    message.project !== undefined && (obj.project = message.project);
    message.experiment !== undefined && (obj.experiment = message.experiment);
    message.revision !== undefined && (obj.revision = message.revision);
    message.encoding !== undefined && (obj.encoding = getRevisionRequest_EncodingToJSON(message.encoding));
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRevisionRequest>, I>>(base?: I): GetRevisionRequest {
    return GetRevisionRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetRevisionRequest>, I>>(object: I): GetRevisionRequest {
    const message = createBaseGetRevisionRequest();
    message.project = object.project ?? "";
    message.experiment = object.experiment ?? "";
    message.revision = object.revision ?? "";
    message.encoding = object.encoding ?? 0;
    return message;
  },
};

function createBaseGetRevisionResponse(): GetRevisionResponse {
  return { model: undefined, encoding: "", ModelFile: "" };
}

export const GetRevisionResponse = {
  encode(message: GetRevisionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.model !== undefined) {
      XpNetModel.encode(message.model, writer.uint32(10).fork()).ldelim();
    }
    if (message.encoding !== "") {
      writer.uint32(18).string(message.encoding);
    }
    if (message.ModelFile !== "") {
      writer.uint32(26).string(message.ModelFile);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRevisionResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRevisionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.model = XpNetModel.decode(reader, reader.uint32());
          break;
        case 2:
          message.encoding = reader.string();
          break;
        case 3:
          message.ModelFile = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetRevisionResponse {
    return {
      model: isSet(object.model) ? XpNetModel.fromJSON(object.model) : undefined,
      encoding: isSet(object.encoding) ? String(object.encoding) : "",
      ModelFile: isSet(object.ModelFile) ? String(object.ModelFile) : "",
    };
  },

  toJSON(message: GetRevisionResponse): unknown {
    const obj: any = {};
    message.model !== undefined && (obj.model = message.model ? XpNetModel.toJSON(message.model) : undefined);
    message.encoding !== undefined && (obj.encoding = message.encoding);
    message.ModelFile !== undefined && (obj.ModelFile = message.ModelFile);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRevisionResponse>, I>>(base?: I): GetRevisionResponse {
    return GetRevisionResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetRevisionResponse>, I>>(object: I): GetRevisionResponse {
    const message = createBaseGetRevisionResponse();
    message.model = (object.model !== undefined && object.model !== null)
      ? XpNetModel.fromPartial(object.model)
      : undefined;
    message.encoding = object.encoding ?? "";
    message.ModelFile = object.ModelFile ?? "";
    return message;
  },
};

function createBaseOrganization(): Organization {
  return {
    name: "",
    description: "",
    oid: 0,
    members: {},
    projects: {},
    state: 0,
    accessMode: 0,
    ver: 0,
    category: "",
    subcategory: "",
  };
}

export const Organization = {
  encode(message: Organization, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.oid !== 0) {
      writer.uint32(24).uint32(message.oid);
    }
    Object.entries(message.members).forEach(([key, value]) => {
      Organization_MembersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    Object.entries(message.projects).forEach(([key, value]) => {
      Organization_ProjectsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.accessMode !== 0) {
      writer.uint32(56).int32(message.accessMode);
    }
    if (message.ver !== 0) {
      writer.uint32(64).int64(message.ver);
    }
    if (message.category !== "") {
      writer.uint32(74).string(message.category);
    }
    if (message.subcategory !== "") {
      writer.uint32(82).string(message.subcategory);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Organization {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.oid = reader.uint32();
          break;
        case 4:
          const entry4 = Organization_MembersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.members[entry4.key] = entry4.value;
          }
          break;
        case 5:
          const entry5 = Organization_ProjectsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.projects[entry5.key] = entry5.value;
          }
          break;
        case 6:
          message.state = reader.int32() as any;
          break;
        case 7:
          message.accessMode = reader.int32() as any;
          break;
        case 8:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        case 9:
          message.category = reader.string();
          break;
        case 10:
          message.subcategory = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Organization {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? String(object.description) : "",
      oid: isSet(object.oid) ? Number(object.oid) : 0,
      members: isObject(object.members)
        ? Object.entries(object.members).reduce<{ [key: string]: Member }>((acc, [key, value]) => {
          acc[key] = Member.fromJSON(value);
          return acc;
        }, {})
        : {},
      projects: isObject(object.projects)
        ? Object.entries(object.projects).reduce<{ [key: string]: Member }>((acc, [key, value]) => {
          acc[key] = Member.fromJSON(value);
          return acc;
        }, {})
        : {},
      state: isSet(object.state) ? userStateFromJSON(object.state) : 0,
      accessMode: isSet(object.accessMode) ? accessModeFromJSON(object.accessMode) : 0,
      ver: isSet(object.ver) ? Number(object.ver) : 0,
      category: isSet(object.category) ? String(object.category) : "",
      subcategory: isSet(object.subcategory) ? String(object.subcategory) : "",
    };
  },

  toJSON(message: Organization): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.description !== undefined && (obj.description = message.description);
    message.oid !== undefined && (obj.oid = Math.round(message.oid));
    obj.members = {};
    if (message.members) {
      Object.entries(message.members).forEach(([k, v]) => {
        obj.members[k] = Member.toJSON(v);
      });
    }
    obj.projects = {};
    if (message.projects) {
      Object.entries(message.projects).forEach(([k, v]) => {
        obj.projects[k] = Member.toJSON(v);
      });
    }
    message.state !== undefined && (obj.state = userStateToJSON(message.state));
    message.accessMode !== undefined && (obj.accessMode = accessModeToJSON(message.accessMode));
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    message.category !== undefined && (obj.category = message.category);
    message.subcategory !== undefined && (obj.subcategory = message.subcategory);
    return obj;
  },

  create<I extends Exact<DeepPartial<Organization>, I>>(base?: I): Organization {
    return Organization.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Organization>, I>>(object: I): Organization {
    const message = createBaseOrganization();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.oid = object.oid ?? 0;
    message.members = Object.entries(object.members ?? {}).reduce<{ [key: string]: Member }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Member.fromPartial(value);
      }
      return acc;
    }, {});
    message.projects = Object.entries(object.projects ?? {}).reduce<{ [key: string]: Member }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Member.fromPartial(value);
      }
      return acc;
    }, {});
    message.state = object.state ?? 0;
    message.accessMode = object.accessMode ?? 0;
    message.ver = object.ver ?? 0;
    message.category = object.category ?? "";
    message.subcategory = object.subcategory ?? "";
    return message;
  },
};

function createBaseOrganization_MembersEntry(): Organization_MembersEntry {
  return { key: "", value: undefined };
}

export const Organization_MembersEntry = {
  encode(message: Organization_MembersEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Member.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Organization_MembersEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganization_MembersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Organization_MembersEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Member.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Organization_MembersEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? Member.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Organization_MembersEntry>, I>>(base?: I): Organization_MembersEntry {
    return Organization_MembersEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Organization_MembersEntry>, I>>(object: I): Organization_MembersEntry {
    const message = createBaseOrganization_MembersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Member.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseOrganization_ProjectsEntry(): Organization_ProjectsEntry {
  return { key: "", value: undefined };
}

export const Organization_ProjectsEntry = {
  encode(message: Organization_ProjectsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Member.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Organization_ProjectsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganization_ProjectsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Organization_ProjectsEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Member.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Organization_ProjectsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? Member.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Organization_ProjectsEntry>, I>>(base?: I): Organization_ProjectsEntry {
    return Organization_ProjectsEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Organization_ProjectsEntry>, I>>(object: I): Organization_ProjectsEntry {
    const message = createBaseOrganization_ProjectsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Member.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseActivateOrganizationRequest(): ActivateOrganizationRequest {
  return { organization: "" };
}

export const ActivateOrganizationRequest = {
  encode(message: ActivateOrganizationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organization !== "") {
      writer.uint32(10).string(message.organization);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActivateOrganizationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateOrganizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.organization = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ActivateOrganizationRequest {
    return { organization: isSet(object.organization) ? String(object.organization) : "" };
  },

  toJSON(message: ActivateOrganizationRequest): unknown {
    const obj: any = {};
    message.organization !== undefined && (obj.organization = message.organization);
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivateOrganizationRequest>, I>>(base?: I): ActivateOrganizationRequest {
    return ActivateOrganizationRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ActivateOrganizationRequest>, I>>(object: I): ActivateOrganizationRequest {
    const message = createBaseActivateOrganizationRequest();
    message.organization = object.organization ?? "";
    return message;
  },
};

function createBaseActivateOrganizationResponse(): ActivateOrganizationResponse {
  return {};
}

export const ActivateOrganizationResponse = {
  encode(_: ActivateOrganizationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActivateOrganizationResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateOrganizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): ActivateOrganizationResponse {
    return {};
  },

  toJSON(_: ActivateOrganizationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivateOrganizationResponse>, I>>(base?: I): ActivateOrganizationResponse {
    return ActivateOrganizationResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ActivateOrganizationResponse>, I>>(_: I): ActivateOrganizationResponse {
    const message = createBaseActivateOrganizationResponse();
    return message;
  },
};

function createBaseFreezeOrganizationRequest(): FreezeOrganizationRequest {
  return { organization: "" };
}

export const FreezeOrganizationRequest = {
  encode(message: FreezeOrganizationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organization !== "") {
      writer.uint32(10).string(message.organization);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FreezeOrganizationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreezeOrganizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.organization = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FreezeOrganizationRequest {
    return { organization: isSet(object.organization) ? String(object.organization) : "" };
  },

  toJSON(message: FreezeOrganizationRequest): unknown {
    const obj: any = {};
    message.organization !== undefined && (obj.organization = message.organization);
    return obj;
  },

  create<I extends Exact<DeepPartial<FreezeOrganizationRequest>, I>>(base?: I): FreezeOrganizationRequest {
    return FreezeOrganizationRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<FreezeOrganizationRequest>, I>>(object: I): FreezeOrganizationRequest {
    const message = createBaseFreezeOrganizationRequest();
    message.organization = object.organization ?? "";
    return message;
  },
};

function createBaseFreezeOrganizationResponse(): FreezeOrganizationResponse {
  return {};
}

export const FreezeOrganizationResponse = {
  encode(_: FreezeOrganizationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FreezeOrganizationResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreezeOrganizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): FreezeOrganizationResponse {
    return {};
  },

  toJSON(_: FreezeOrganizationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<FreezeOrganizationResponse>, I>>(base?: I): FreezeOrganizationResponse {
    return FreezeOrganizationResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<FreezeOrganizationResponse>, I>>(_: I): FreezeOrganizationResponse {
    const message = createBaseFreezeOrganizationResponse();
    return message;
  },
};

function createBaseGetOrganizationsRequest(): GetOrganizationsRequest {
  return { filter: 0 };
}

export const GetOrganizationsRequest = {
  encode(message: GetOrganizationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filter !== 0) {
      writer.uint32(8).int32(message.filter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOrganizationsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.filter = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationsRequest {
    return { filter: isSet(object.filter) ? filterModeFromJSON(object.filter) : 0 };
  },

  toJSON(message: GetOrganizationsRequest): unknown {
    const obj: any = {};
    message.filter !== undefined && (obj.filter = filterModeToJSON(message.filter));
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrganizationsRequest>, I>>(base?: I): GetOrganizationsRequest {
    return GetOrganizationsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetOrganizationsRequest>, I>>(object: I): GetOrganizationsRequest {
    const message = createBaseGetOrganizationsRequest();
    message.filter = object.filter ?? 0;
    return message;
  },
};

function createBaseGetOrganizationsResponse(): GetOrganizationsResponse {
  return { organizations: [] };
}

export const GetOrganizationsResponse = {
  encode(message: GetOrganizationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.organizations) {
      Organization.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOrganizationsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.organizations.push(Organization.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationsResponse {
    return {
      organizations: Array.isArray(object?.organizations)
        ? object.organizations.map((e: any) => Organization.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetOrganizationsResponse): unknown {
    const obj: any = {};
    if (message.organizations) {
      obj.organizations = message.organizations.map((e) => e ? Organization.toJSON(e) : undefined);
    } else {
      obj.organizations = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrganizationsResponse>, I>>(base?: I): GetOrganizationsResponse {
    return GetOrganizationsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetOrganizationsResponse>, I>>(object: I): GetOrganizationsResponse {
    const message = createBaseGetOrganizationsResponse();
    message.organizations = object.organizations?.map((e) => Organization.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetOrganizationRequest(): GetOrganizationRequest {
  return { name: "" };
}

export const GetOrganizationRequest = {
  encode(message: GetOrganizationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOrganizationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationRequest {
    return { name: isSet(object.name) ? String(object.name) : "" };
  },

  toJSON(message: GetOrganizationRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrganizationRequest>, I>>(base?: I): GetOrganizationRequest {
    return GetOrganizationRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetOrganizationRequest>, I>>(object: I): GetOrganizationRequest {
    const message = createBaseGetOrganizationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetOrganizationResponse(): GetOrganizationResponse {
  return { organization: undefined };
}

export const GetOrganizationResponse = {
  encode(message: GetOrganizationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organization !== undefined) {
      Organization.encode(message.organization, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOrganizationResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.organization = Organization.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationResponse {
    return { organization: isSet(object.organization) ? Organization.fromJSON(object.organization) : undefined };
  },

  toJSON(message: GetOrganizationResponse): unknown {
    const obj: any = {};
    message.organization !== undefined &&
      (obj.organization = message.organization ? Organization.toJSON(message.organization) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrganizationResponse>, I>>(base?: I): GetOrganizationResponse {
    return GetOrganizationResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetOrganizationResponse>, I>>(object: I): GetOrganizationResponse {
    const message = createBaseGetOrganizationResponse();
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? Organization.fromPartial(object.organization)
      : undefined;
    return message;
  },
};

function createBaseDeleteOrganizationRequest(): DeleteOrganizationRequest {
  return { user: "", name: "" };
}

export const DeleteOrganizationRequest = {
  encode(message: DeleteOrganizationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteOrganizationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteOrganizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = reader.string();
          break;
        case 2:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteOrganizationRequest {
    return { user: isSet(object.user) ? String(object.user) : "", name: isSet(object.name) ? String(object.name) : "" };
  },

  toJSON(message: DeleteOrganizationRequest): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user);
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteOrganizationRequest>, I>>(base?: I): DeleteOrganizationRequest {
    return DeleteOrganizationRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteOrganizationRequest>, I>>(object: I): DeleteOrganizationRequest {
    const message = createBaseDeleteOrganizationRequest();
    message.user = object.user ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteOrganizationResponse(): DeleteOrganizationResponse {
  return {};
}

export const DeleteOrganizationResponse = {
  encode(_: DeleteOrganizationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteOrganizationResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteOrganizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteOrganizationResponse {
    return {};
  },

  toJSON(_: DeleteOrganizationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteOrganizationResponse>, I>>(base?: I): DeleteOrganizationResponse {
    return DeleteOrganizationResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteOrganizationResponse>, I>>(_: I): DeleteOrganizationResponse {
    const message = createBaseDeleteOrganizationResponse();
    return message;
  },
};

function createBaseCreateOrganizationRequest(): CreateOrganizationRequest {
  return { user: "", organization: undefined };
}

export const CreateOrganizationRequest = {
  encode(message: CreateOrganizationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    if (message.organization !== undefined) {
      Organization.encode(message.organization, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOrganizationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrganizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = reader.string();
          break;
        case 2:
          message.organization = Organization.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreateOrganizationRequest {
    return {
      user: isSet(object.user) ? String(object.user) : "",
      organization: isSet(object.organization) ? Organization.fromJSON(object.organization) : undefined,
    };
  },

  toJSON(message: CreateOrganizationRequest): unknown {
    const obj: any = {};
    message.user !== undefined && (obj.user = message.user);
    message.organization !== undefined &&
      (obj.organization = message.organization ? Organization.toJSON(message.organization) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOrganizationRequest>, I>>(base?: I): CreateOrganizationRequest {
    return CreateOrganizationRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CreateOrganizationRequest>, I>>(object: I): CreateOrganizationRequest {
    const message = createBaseCreateOrganizationRequest();
    message.user = object.user ?? "";
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? Organization.fromPartial(object.organization)
      : undefined;
    return message;
  },
};

function createBaseCreateOrganizationResponse(): CreateOrganizationResponse {
  return {};
}

export const CreateOrganizationResponse = {
  encode(_: CreateOrganizationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOrganizationResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrganizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): CreateOrganizationResponse {
    return {};
  },

  toJSON(_: CreateOrganizationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOrganizationResponse>, I>>(base?: I): CreateOrganizationResponse {
    return CreateOrganizationResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CreateOrganizationResponse>, I>>(_: I): CreateOrganizationResponse {
    const message = createBaseCreateOrganizationResponse();
    return message;
  },
};

function createBaseUpdateOrganizationRequest(): UpdateOrganizationRequest {
  return {
    name: "",
    description: undefined,
    state: undefined,
    accessMode: undefined,
    members: undefined,
    projects: undefined,
  };
}

export const UpdateOrganizationRequest = {
  encode(message: UpdateOrganizationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== undefined) {
      DescriptionUpdate.encode(message.description, writer.uint32(18).fork()).ldelim();
    }
    if (message.state !== undefined) {
      UserStateUpdate.encode(message.state, writer.uint32(26).fork()).ldelim();
    }
    if (message.accessMode !== undefined) {
      AccessModeUpdate.encode(message.accessMode, writer.uint32(34).fork()).ldelim();
    }
    if (message.members !== undefined) {
      MembershipUpdate.encode(message.members, writer.uint32(42).fork()).ldelim();
    }
    if (message.projects !== undefined) {
      MembershipUpdate.encode(message.projects, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateOrganizationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrganizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.description = DescriptionUpdate.decode(reader, reader.uint32());
          break;
        case 3:
          message.state = UserStateUpdate.decode(reader, reader.uint32());
          break;
        case 4:
          message.accessMode = AccessModeUpdate.decode(reader, reader.uint32());
          break;
        case 5:
          message.members = MembershipUpdate.decode(reader, reader.uint32());
          break;
        case 6:
          message.projects = MembershipUpdate.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateOrganizationRequest {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? DescriptionUpdate.fromJSON(object.description) : undefined,
      state: isSet(object.state) ? UserStateUpdate.fromJSON(object.state) : undefined,
      accessMode: isSet(object.accessMode) ? AccessModeUpdate.fromJSON(object.accessMode) : undefined,
      members: isSet(object.members) ? MembershipUpdate.fromJSON(object.members) : undefined,
      projects: isSet(object.projects) ? MembershipUpdate.fromJSON(object.projects) : undefined,
    };
  },

  toJSON(message: UpdateOrganizationRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.description !== undefined &&
      (obj.description = message.description ? DescriptionUpdate.toJSON(message.description) : undefined);
    message.state !== undefined && (obj.state = message.state ? UserStateUpdate.toJSON(message.state) : undefined);
    message.accessMode !== undefined &&
      (obj.accessMode = message.accessMode ? AccessModeUpdate.toJSON(message.accessMode) : undefined);
    message.members !== undefined &&
      (obj.members = message.members ? MembershipUpdate.toJSON(message.members) : undefined);
    message.projects !== undefined &&
      (obj.projects = message.projects ? MembershipUpdate.toJSON(message.projects) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOrganizationRequest>, I>>(base?: I): UpdateOrganizationRequest {
    return UpdateOrganizationRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateOrganizationRequest>, I>>(object: I): UpdateOrganizationRequest {
    const message = createBaseUpdateOrganizationRequest();
    message.name = object.name ?? "";
    message.description = (object.description !== undefined && object.description !== null)
      ? DescriptionUpdate.fromPartial(object.description)
      : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? UserStateUpdate.fromPartial(object.state)
      : undefined;
    message.accessMode = (object.accessMode !== undefined && object.accessMode !== null)
      ? AccessModeUpdate.fromPartial(object.accessMode)
      : undefined;
    message.members = (object.members !== undefined && object.members !== null)
      ? MembershipUpdate.fromPartial(object.members)
      : undefined;
    message.projects = (object.projects !== undefined && object.projects !== null)
      ? MembershipUpdate.fromPartial(object.projects)
      : undefined;
    return message;
  },
};

function createBaseUpdateOrganizationResponse(): UpdateOrganizationResponse {
  return {};
}

export const UpdateOrganizationResponse = {
  encode(_: UpdateOrganizationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateOrganizationResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrganizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): UpdateOrganizationResponse {
    return {};
  },

  toJSON(_: UpdateOrganizationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOrganizationResponse>, I>>(base?: I): UpdateOrganizationResponse {
    return UpdateOrganizationResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateOrganizationResponse>, I>>(_: I): UpdateOrganizationResponse {
    const message = createBaseUpdateOrganizationResponse();
    return message;
  },
};

function createBaseGetOrganizationMembersRequest(): GetOrganizationMembersRequest {
  return { organization: "" };
}

export const GetOrganizationMembersRequest = {
  encode(message: GetOrganizationMembersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organization !== "") {
      writer.uint32(10).string(message.organization);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOrganizationMembersRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationMembersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.organization = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationMembersRequest {
    return { organization: isSet(object.organization) ? String(object.organization) : "" };
  },

  toJSON(message: GetOrganizationMembersRequest): unknown {
    const obj: any = {};
    message.organization !== undefined && (obj.organization = message.organization);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrganizationMembersRequest>, I>>(base?: I): GetOrganizationMembersRequest {
    return GetOrganizationMembersRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetOrganizationMembersRequest>, I>>(
    object: I,
  ): GetOrganizationMembersRequest {
    const message = createBaseGetOrganizationMembersRequest();
    message.organization = object.organization ?? "";
    return message;
  },
};

function createBaseGetOrganizationMembersResponse(): GetOrganizationMembersResponse {
  return { members: [] };
}

export const GetOrganizationMembersResponse = {
  encode(message: GetOrganizationMembersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.members) {
      Member.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOrganizationMembersResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationMembersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.members.push(Member.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationMembersResponse {
    return { members: Array.isArray(object?.members) ? object.members.map((e: any) => Member.fromJSON(e)) : [] };
  },

  toJSON(message: GetOrganizationMembersResponse): unknown {
    const obj: any = {};
    if (message.members) {
      obj.members = message.members.map((e) => e ? Member.toJSON(e) : undefined);
    } else {
      obj.members = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrganizationMembersResponse>, I>>(base?: I): GetOrganizationMembersResponse {
    return GetOrganizationMembersResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetOrganizationMembersResponse>, I>>(
    object: I,
  ): GetOrganizationMembersResponse {
    const message = createBaseGetOrganizationMembersResponse();
    message.members = object.members?.map((e) => Member.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetOrganizationMemberRequest(): GetOrganizationMemberRequest {
  return { organization: "", username: "" };
}

export const GetOrganizationMemberRequest = {
  encode(message: GetOrganizationMemberRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organization !== "") {
      writer.uint32(10).string(message.organization);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOrganizationMemberRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationMemberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.organization = reader.string();
          break;
        case 2:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationMemberRequest {
    return {
      organization: isSet(object.organization) ? String(object.organization) : "",
      username: isSet(object.username) ? String(object.username) : "",
    };
  },

  toJSON(message: GetOrganizationMemberRequest): unknown {
    const obj: any = {};
    message.organization !== undefined && (obj.organization = message.organization);
    message.username !== undefined && (obj.username = message.username);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrganizationMemberRequest>, I>>(base?: I): GetOrganizationMemberRequest {
    return GetOrganizationMemberRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetOrganizationMemberRequest>, I>>(object: I): GetOrganizationMemberRequest {
    const message = createBaseGetOrganizationMemberRequest();
    message.organization = object.organization ?? "";
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseGetOrganizationMemberResponse(): GetOrganizationMemberResponse {
  return { member: undefined };
}

export const GetOrganizationMemberResponse = {
  encode(message: GetOrganizationMemberResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.member !== undefined) {
      Member.encode(message.member, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOrganizationMemberResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationMemberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.member = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationMemberResponse {
    return { member: isSet(object.member) ? Member.fromJSON(object.member) : undefined };
  },

  toJSON(message: GetOrganizationMemberResponse): unknown {
    const obj: any = {};
    message.member !== undefined && (obj.member = message.member ? Member.toJSON(message.member) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrganizationMemberResponse>, I>>(base?: I): GetOrganizationMemberResponse {
    return GetOrganizationMemberResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetOrganizationMemberResponse>, I>>(
    object: I,
  ): GetOrganizationMemberResponse {
    const message = createBaseGetOrganizationMemberResponse();
    message.member = (object.member !== undefined && object.member !== null)
      ? Member.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseRequestOrganizationMembershipRequest(): RequestOrganizationMembershipRequest {
  return { organization: "", id: "", kind: 0, member: undefined };
}

export const RequestOrganizationMembershipRequest = {
  encode(message: RequestOrganizationMembershipRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organization !== "") {
      writer.uint32(10).string(message.organization);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.kind !== 0) {
      writer.uint32(24).int32(message.kind);
    }
    if (message.member !== undefined) {
      Member.encode(message.member, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestOrganizationMembershipRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestOrganizationMembershipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.organization = reader.string();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.kind = reader.int32() as any;
          break;
        case 4:
          message.member = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RequestOrganizationMembershipRequest {
    return {
      organization: isSet(object.organization) ? String(object.organization) : "",
      id: isSet(object.id) ? String(object.id) : "",
      kind: isSet(object.kind) ? membershipTypeFromJSON(object.kind) : 0,
      member: isSet(object.member) ? Member.fromJSON(object.member) : undefined,
    };
  },

  toJSON(message: RequestOrganizationMembershipRequest): unknown {
    const obj: any = {};
    message.organization !== undefined && (obj.organization = message.organization);
    message.id !== undefined && (obj.id = message.id);
    message.kind !== undefined && (obj.kind = membershipTypeToJSON(message.kind));
    message.member !== undefined && (obj.member = message.member ? Member.toJSON(message.member) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestOrganizationMembershipRequest>, I>>(
    base?: I,
  ): RequestOrganizationMembershipRequest {
    return RequestOrganizationMembershipRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RequestOrganizationMembershipRequest>, I>>(
    object: I,
  ): RequestOrganizationMembershipRequest {
    const message = createBaseRequestOrganizationMembershipRequest();
    message.organization = object.organization ?? "";
    message.id = object.id ?? "";
    message.kind = object.kind ?? 0;
    message.member = (object.member !== undefined && object.member !== null)
      ? Member.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseRequestOrganizationMembershipResponse(): RequestOrganizationMembershipResponse {
  return { member: undefined };
}

export const RequestOrganizationMembershipResponse = {
  encode(message: RequestOrganizationMembershipResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.member !== undefined) {
      Member.encode(message.member, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestOrganizationMembershipResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestOrganizationMembershipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.member = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RequestOrganizationMembershipResponse {
    return { member: isSet(object.member) ? Member.fromJSON(object.member) : undefined };
  },

  toJSON(message: RequestOrganizationMembershipResponse): unknown {
    const obj: any = {};
    message.member !== undefined && (obj.member = message.member ? Member.toJSON(message.member) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestOrganizationMembershipResponse>, I>>(
    base?: I,
  ): RequestOrganizationMembershipResponse {
    return RequestOrganizationMembershipResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RequestOrganizationMembershipResponse>, I>>(
    object: I,
  ): RequestOrganizationMembershipResponse {
    const message = createBaseRequestOrganizationMembershipResponse();
    message.member = (object.member !== undefined && object.member !== null)
      ? Member.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseConfirmOrganizationMembershipRequest(): ConfirmOrganizationMembershipRequest {
  return { organization: "", id: "", kind: 0 };
}

export const ConfirmOrganizationMembershipRequest = {
  encode(message: ConfirmOrganizationMembershipRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organization !== "") {
      writer.uint32(10).string(message.organization);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.kind !== 0) {
      writer.uint32(24).int32(message.kind);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmOrganizationMembershipRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmOrganizationMembershipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.organization = reader.string();
          break;
        case 2:
          message.id = reader.string();
          break;
        case 3:
          message.kind = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ConfirmOrganizationMembershipRequest {
    return {
      organization: isSet(object.organization) ? String(object.organization) : "",
      id: isSet(object.id) ? String(object.id) : "",
      kind: isSet(object.kind) ? membershipTypeFromJSON(object.kind) : 0,
    };
  },

  toJSON(message: ConfirmOrganizationMembershipRequest): unknown {
    const obj: any = {};
    message.organization !== undefined && (obj.organization = message.organization);
    message.id !== undefined && (obj.id = message.id);
    message.kind !== undefined && (obj.kind = membershipTypeToJSON(message.kind));
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmOrganizationMembershipRequest>, I>>(
    base?: I,
  ): ConfirmOrganizationMembershipRequest {
    return ConfirmOrganizationMembershipRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ConfirmOrganizationMembershipRequest>, I>>(
    object: I,
  ): ConfirmOrganizationMembershipRequest {
    const message = createBaseConfirmOrganizationMembershipRequest();
    message.organization = object.organization ?? "";
    message.id = object.id ?? "";
    message.kind = object.kind ?? 0;
    return message;
  },
};

function createBaseConfirmOrganizationMembershipResponse(): ConfirmOrganizationMembershipResponse {
  return { member: undefined };
}

export const ConfirmOrganizationMembershipResponse = {
  encode(message: ConfirmOrganizationMembershipResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.member !== undefined) {
      Member.encode(message.member, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfirmOrganizationMembershipResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmOrganizationMembershipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.member = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ConfirmOrganizationMembershipResponse {
    return { member: isSet(object.member) ? Member.fromJSON(object.member) : undefined };
  },

  toJSON(message: ConfirmOrganizationMembershipResponse): unknown {
    const obj: any = {};
    message.member !== undefined && (obj.member = message.member ? Member.toJSON(message.member) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmOrganizationMembershipResponse>, I>>(
    base?: I,
  ): ConfirmOrganizationMembershipResponse {
    return ConfirmOrganizationMembershipResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ConfirmOrganizationMembershipResponse>, I>>(
    object: I,
  ): ConfirmOrganizationMembershipResponse {
    const message = createBaseConfirmOrganizationMembershipResponse();
    message.member = (object.member !== undefined && object.member !== null)
      ? Member.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseUpdateOrganizationMemberRequest(): UpdateOrganizationMemberRequest {
  return { organization: "", username: "", member: undefined };
}

export const UpdateOrganizationMemberRequest = {
  encode(message: UpdateOrganizationMemberRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organization !== "") {
      writer.uint32(10).string(message.organization);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.member !== undefined) {
      Member.encode(message.member, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateOrganizationMemberRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrganizationMemberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.organization = reader.string();
          break;
        case 2:
          message.username = reader.string();
          break;
        case 3:
          message.member = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateOrganizationMemberRequest {
    return {
      organization: isSet(object.organization) ? String(object.organization) : "",
      username: isSet(object.username) ? String(object.username) : "",
      member: isSet(object.member) ? Member.fromJSON(object.member) : undefined,
    };
  },

  toJSON(message: UpdateOrganizationMemberRequest): unknown {
    const obj: any = {};
    message.organization !== undefined && (obj.organization = message.organization);
    message.username !== undefined && (obj.username = message.username);
    message.member !== undefined && (obj.member = message.member ? Member.toJSON(message.member) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOrganizationMemberRequest>, I>>(base?: I): UpdateOrganizationMemberRequest {
    return UpdateOrganizationMemberRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateOrganizationMemberRequest>, I>>(
    object: I,
  ): UpdateOrganizationMemberRequest {
    const message = createBaseUpdateOrganizationMemberRequest();
    message.organization = object.organization ?? "";
    message.username = object.username ?? "";
    message.member = (object.member !== undefined && object.member !== null)
      ? Member.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseUpdateOrganizationMemberResponse(): UpdateOrganizationMemberResponse {
  return { member: undefined };
}

export const UpdateOrganizationMemberResponse = {
  encode(message: UpdateOrganizationMemberResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.member !== undefined) {
      Member.encode(message.member, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateOrganizationMemberResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrganizationMemberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.member = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateOrganizationMemberResponse {
    return { member: isSet(object.member) ? Member.fromJSON(object.member) : undefined };
  },

  toJSON(message: UpdateOrganizationMemberResponse): unknown {
    const obj: any = {};
    message.member !== undefined && (obj.member = message.member ? Member.toJSON(message.member) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOrganizationMemberResponse>, I>>(
    base?: I,
  ): UpdateOrganizationMemberResponse {
    return UpdateOrganizationMemberResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateOrganizationMemberResponse>, I>>(
    object: I,
  ): UpdateOrganizationMemberResponse {
    const message = createBaseUpdateOrganizationMemberResponse();
    message.member = (object.member !== undefined && object.member !== null)
      ? Member.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseDeleteOrganizationMemberRequest(): DeleteOrganizationMemberRequest {
  return { organization: "", username: "" };
}

export const DeleteOrganizationMemberRequest = {
  encode(message: DeleteOrganizationMemberRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organization !== "") {
      writer.uint32(10).string(message.organization);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteOrganizationMemberRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteOrganizationMemberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.organization = reader.string();
          break;
        case 2:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteOrganizationMemberRequest {
    return {
      organization: isSet(object.organization) ? String(object.organization) : "",
      username: isSet(object.username) ? String(object.username) : "",
    };
  },

  toJSON(message: DeleteOrganizationMemberRequest): unknown {
    const obj: any = {};
    message.organization !== undefined && (obj.organization = message.organization);
    message.username !== undefined && (obj.username = message.username);
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteOrganizationMemberRequest>, I>>(base?: I): DeleteOrganizationMemberRequest {
    return DeleteOrganizationMemberRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteOrganizationMemberRequest>, I>>(
    object: I,
  ): DeleteOrganizationMemberRequest {
    const message = createBaseDeleteOrganizationMemberRequest();
    message.organization = object.organization ?? "";
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseDeleteOrganizationMemberResponse(): DeleteOrganizationMemberResponse {
  return {};
}

export const DeleteOrganizationMemberResponse = {
  encode(_: DeleteOrganizationMemberResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteOrganizationMemberResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteOrganizationMemberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteOrganizationMemberResponse {
    return {};
  },

  toJSON(_: DeleteOrganizationMemberResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteOrganizationMemberResponse>, I>>(
    base?: I,
  ): DeleteOrganizationMemberResponse {
    return DeleteOrganizationMemberResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteOrganizationMemberResponse>, I>>(
    _: I,
  ): DeleteOrganizationMemberResponse {
    const message = createBaseDeleteOrganizationMemberResponse();
    return message;
  },
};

function createBaseGetOrganizationProjectsRequest(): GetOrganizationProjectsRequest {
  return { name: "" };
}

export const GetOrganizationProjectsRequest = {
  encode(message: GetOrganizationProjectsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOrganizationProjectsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationProjectsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationProjectsRequest {
    return { name: isSet(object.name) ? String(object.name) : "" };
  },

  toJSON(message: GetOrganizationProjectsRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrganizationProjectsRequest>, I>>(base?: I): GetOrganizationProjectsRequest {
    return GetOrganizationProjectsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetOrganizationProjectsRequest>, I>>(
    object: I,
  ): GetOrganizationProjectsRequest {
    const message = createBaseGetOrganizationProjectsRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetOrganizationProjectsResponse(): GetOrganizationProjectsResponse {
  return { projects: [] };
}

export const GetOrganizationProjectsResponse = {
  encode(message: GetOrganizationProjectsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.projects) {
      Member.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOrganizationProjectsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationProjectsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.projects.push(Member.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationProjectsResponse {
    return { projects: Array.isArray(object?.projects) ? object.projects.map((e: any) => Member.fromJSON(e)) : [] };
  },

  toJSON(message: GetOrganizationProjectsResponse): unknown {
    const obj: any = {};
    if (message.projects) {
      obj.projects = message.projects.map((e) => e ? Member.toJSON(e) : undefined);
    } else {
      obj.projects = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrganizationProjectsResponse>, I>>(base?: I): GetOrganizationProjectsResponse {
    return GetOrganizationProjectsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetOrganizationProjectsResponse>, I>>(
    object: I,
  ): GetOrganizationProjectsResponse {
    const message = createBaseGetOrganizationProjectsResponse();
    message.projects = object.projects?.map((e) => Member.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetOrganizationProjectRequest(): GetOrganizationProjectRequest {
  return { organization: "", project: "" };
}

export const GetOrganizationProjectRequest = {
  encode(message: GetOrganizationProjectRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organization !== "") {
      writer.uint32(10).string(message.organization);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOrganizationProjectRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.organization = reader.string();
          break;
        case 2:
          message.project = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationProjectRequest {
    return {
      organization: isSet(object.organization) ? String(object.organization) : "",
      project: isSet(object.project) ? String(object.project) : "",
    };
  },

  toJSON(message: GetOrganizationProjectRequest): unknown {
    const obj: any = {};
    message.organization !== undefined && (obj.organization = message.organization);
    message.project !== undefined && (obj.project = message.project);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrganizationProjectRequest>, I>>(base?: I): GetOrganizationProjectRequest {
    return GetOrganizationProjectRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetOrganizationProjectRequest>, I>>(
    object: I,
  ): GetOrganizationProjectRequest {
    const message = createBaseGetOrganizationProjectRequest();
    message.organization = object.organization ?? "";
    message.project = object.project ?? "";
    return message;
  },
};

function createBaseGetOrganizationProjectResponse(): GetOrganizationProjectResponse {
  return { member: undefined };
}

export const GetOrganizationProjectResponse = {
  encode(message: GetOrganizationProjectResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.member !== undefined) {
      Member.encode(message.member, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOrganizationProjectResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationProjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.member = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationProjectResponse {
    return { member: isSet(object.member) ? Member.fromJSON(object.member) : undefined };
  },

  toJSON(message: GetOrganizationProjectResponse): unknown {
    const obj: any = {};
    message.member !== undefined && (obj.member = message.member ? Member.toJSON(message.member) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrganizationProjectResponse>, I>>(base?: I): GetOrganizationProjectResponse {
    return GetOrganizationProjectResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetOrganizationProjectResponse>, I>>(
    object: I,
  ): GetOrganizationProjectResponse {
    const message = createBaseGetOrganizationProjectResponse();
    message.member = (object.member !== undefined && object.member !== null)
      ? Member.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseAddOrganizationProjectRequest(): AddOrganizationProjectRequest {
  return { organization: "", project: "", member: undefined };
}

export const AddOrganizationProjectRequest = {
  encode(message: AddOrganizationProjectRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organization !== "") {
      writer.uint32(10).string(message.organization);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.member !== undefined) {
      Member.encode(message.member, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddOrganizationProjectRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddOrganizationProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.organization = reader.string();
          break;
        case 2:
          message.project = reader.string();
          break;
        case 3:
          message.member = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AddOrganizationProjectRequest {
    return {
      organization: isSet(object.organization) ? String(object.organization) : "",
      project: isSet(object.project) ? String(object.project) : "",
      member: isSet(object.member) ? Member.fromJSON(object.member) : undefined,
    };
  },

  toJSON(message: AddOrganizationProjectRequest): unknown {
    const obj: any = {};
    message.organization !== undefined && (obj.organization = message.organization);
    message.project !== undefined && (obj.project = message.project);
    message.member !== undefined && (obj.member = message.member ? Member.toJSON(message.member) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<AddOrganizationProjectRequest>, I>>(base?: I): AddOrganizationProjectRequest {
    return AddOrganizationProjectRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddOrganizationProjectRequest>, I>>(
    object: I,
  ): AddOrganizationProjectRequest {
    const message = createBaseAddOrganizationProjectRequest();
    message.organization = object.organization ?? "";
    message.project = object.project ?? "";
    message.member = (object.member !== undefined && object.member !== null)
      ? Member.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseAddOrganizationProjectResponse(): AddOrganizationProjectResponse {
  return {};
}

export const AddOrganizationProjectResponse = {
  encode(_: AddOrganizationProjectResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddOrganizationProjectResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddOrganizationProjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): AddOrganizationProjectResponse {
    return {};
  },

  toJSON(_: AddOrganizationProjectResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AddOrganizationProjectResponse>, I>>(base?: I): AddOrganizationProjectResponse {
    return AddOrganizationProjectResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddOrganizationProjectResponse>, I>>(_: I): AddOrganizationProjectResponse {
    const message = createBaseAddOrganizationProjectResponse();
    return message;
  },
};

function createBaseUpdateOrganizationProjectRequest(): UpdateOrganizationProjectRequest {
  return { organization: "", project: "", member: undefined };
}

export const UpdateOrganizationProjectRequest = {
  encode(message: UpdateOrganizationProjectRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organization !== "") {
      writer.uint32(10).string(message.organization);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    if (message.member !== undefined) {
      Member.encode(message.member, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateOrganizationProjectRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrganizationProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.organization = reader.string();
          break;
        case 2:
          message.project = reader.string();
          break;
        case 3:
          message.member = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateOrganizationProjectRequest {
    return {
      organization: isSet(object.organization) ? String(object.organization) : "",
      project: isSet(object.project) ? String(object.project) : "",
      member: isSet(object.member) ? Member.fromJSON(object.member) : undefined,
    };
  },

  toJSON(message: UpdateOrganizationProjectRequest): unknown {
    const obj: any = {};
    message.organization !== undefined && (obj.organization = message.organization);
    message.project !== undefined && (obj.project = message.project);
    message.member !== undefined && (obj.member = message.member ? Member.toJSON(message.member) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOrganizationProjectRequest>, I>>(
    base?: I,
  ): UpdateOrganizationProjectRequest {
    return UpdateOrganizationProjectRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateOrganizationProjectRequest>, I>>(
    object: I,
  ): UpdateOrganizationProjectRequest {
    const message = createBaseUpdateOrganizationProjectRequest();
    message.organization = object.organization ?? "";
    message.project = object.project ?? "";
    message.member = (object.member !== undefined && object.member !== null)
      ? Member.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseUpdateOrganizationProjectResponse(): UpdateOrganizationProjectResponse {
  return {};
}

export const UpdateOrganizationProjectResponse = {
  encode(_: UpdateOrganizationProjectResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateOrganizationProjectResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrganizationProjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): UpdateOrganizationProjectResponse {
    return {};
  },

  toJSON(_: UpdateOrganizationProjectResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOrganizationProjectResponse>, I>>(
    base?: I,
  ): UpdateOrganizationProjectResponse {
    return UpdateOrganizationProjectResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateOrganizationProjectResponse>, I>>(
    _: I,
  ): UpdateOrganizationProjectResponse {
    const message = createBaseUpdateOrganizationProjectResponse();
    return message;
  },
};

function createBaseDeleteOrganizationProjectRequest(): DeleteOrganizationProjectRequest {
  return { organization: "", project: "" };
}

export const DeleteOrganizationProjectRequest = {
  encode(message: DeleteOrganizationProjectRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.organization !== "") {
      writer.uint32(10).string(message.organization);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteOrganizationProjectRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteOrganizationProjectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.organization = reader.string();
          break;
        case 2:
          message.project = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteOrganizationProjectRequest {
    return {
      organization: isSet(object.organization) ? String(object.organization) : "",
      project: isSet(object.project) ? String(object.project) : "",
    };
  },

  toJSON(message: DeleteOrganizationProjectRequest): unknown {
    const obj: any = {};
    message.organization !== undefined && (obj.organization = message.organization);
    message.project !== undefined && (obj.project = message.project);
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteOrganizationProjectRequest>, I>>(
    base?: I,
  ): DeleteOrganizationProjectRequest {
    return DeleteOrganizationProjectRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteOrganizationProjectRequest>, I>>(
    object: I,
  ): DeleteOrganizationProjectRequest {
    const message = createBaseDeleteOrganizationProjectRequest();
    message.organization = object.organization ?? "";
    message.project = object.project ?? "";
    return message;
  },
};

function createBaseDeleteOrganizationProjectResponse(): DeleteOrganizationProjectResponse {
  return {};
}

export const DeleteOrganizationProjectResponse = {
  encode(_: DeleteOrganizationProjectResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteOrganizationProjectResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteOrganizationProjectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteOrganizationProjectResponse {
    return {};
  },

  toJSON(_: DeleteOrganizationProjectResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteOrganizationProjectResponse>, I>>(
    base?: I,
  ): DeleteOrganizationProjectResponse {
    return DeleteOrganizationProjectResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteOrganizationProjectResponse>, I>>(
    _: I,
  ): DeleteOrganizationProjectResponse {
    const message = createBaseDeleteOrganizationProjectResponse();
    return message;
  },
};

function createBaseGetUserConfigurationsRequest(): GetUserConfigurationsRequest {
  return {};
}

export const GetUserConfigurationsRequest = {
  encode(_: GetUserConfigurationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserConfigurationsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserConfigurationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetUserConfigurationsRequest {
    return {};
  },

  toJSON(_: GetUserConfigurationsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserConfigurationsRequest>, I>>(base?: I): GetUserConfigurationsRequest {
    return GetUserConfigurationsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetUserConfigurationsRequest>, I>>(_: I): GetUserConfigurationsRequest {
    const message = createBaseGetUserConfigurationsRequest();
    return message;
  },
};

function createBaseGetUserConfigurationsResponse(): GetUserConfigurationsResponse {
  return { institutions: [], countries: [], usstates: [], categories: [] };
}

export const GetUserConfigurationsResponse = {
  encode(message: GetUserConfigurationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.institutions) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.countries) {
      GetUserConfigurationsResponse_Country.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.usstates) {
      GetUserConfigurationsResponse_USState.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.categories) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserConfigurationsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserConfigurationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.institutions.push(reader.string());
          break;
        case 2:
          message.countries.push(GetUserConfigurationsResponse_Country.decode(reader, reader.uint32()));
          break;
        case 3:
          message.usstates.push(GetUserConfigurationsResponse_USState.decode(reader, reader.uint32()));
          break;
        case 4:
          message.categories.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetUserConfigurationsResponse {
    return {
      institutions: Array.isArray(object?.institutions) ? object.institutions.map((e: any) => String(e)) : [],
      countries: Array.isArray(object?.countries)
        ? object.countries.map((e: any) => GetUserConfigurationsResponse_Country.fromJSON(e))
        : [],
      usstates: Array.isArray(object?.usstates)
        ? object.usstates.map((e: any) => GetUserConfigurationsResponse_USState.fromJSON(e))
        : [],
      categories: Array.isArray(object?.categories) ? object.categories.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: GetUserConfigurationsResponse): unknown {
    const obj: any = {};
    if (message.institutions) {
      obj.institutions = message.institutions.map((e) => e);
    } else {
      obj.institutions = [];
    }
    if (message.countries) {
      obj.countries = message.countries.map((e) => e ? GetUserConfigurationsResponse_Country.toJSON(e) : undefined);
    } else {
      obj.countries = [];
    }
    if (message.usstates) {
      obj.usstates = message.usstates.map((e) => e ? GetUserConfigurationsResponse_USState.toJSON(e) : undefined);
    } else {
      obj.usstates = [];
    }
    if (message.categories) {
      obj.categories = message.categories.map((e) => e);
    } else {
      obj.categories = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserConfigurationsResponse>, I>>(base?: I): GetUserConfigurationsResponse {
    return GetUserConfigurationsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetUserConfigurationsResponse>, I>>(
    object: I,
  ): GetUserConfigurationsResponse {
    const message = createBaseGetUserConfigurationsResponse();
    message.institutions = object.institutions?.map((e) => e) || [];
    message.countries = object.countries?.map((e) => GetUserConfigurationsResponse_Country.fromPartial(e)) || [];
    message.usstates = object.usstates?.map((e) => GetUserConfigurationsResponse_USState.fromPartial(e)) || [];
    message.categories = object.categories?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetUserConfigurationsResponse_Country(): GetUserConfigurationsResponse_Country {
  return { name: "", ISO2: "" };
}

export const GetUserConfigurationsResponse_Country = {
  encode(message: GetUserConfigurationsResponse_Country, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ISO2 !== "") {
      writer.uint32(18).string(message.ISO2);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserConfigurationsResponse_Country {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserConfigurationsResponse_Country();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.ISO2 = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetUserConfigurationsResponse_Country {
    return { name: isSet(object.name) ? String(object.name) : "", ISO2: isSet(object.ISO2) ? String(object.ISO2) : "" };
  },

  toJSON(message: GetUserConfigurationsResponse_Country): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.ISO2 !== undefined && (obj.ISO2 = message.ISO2);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserConfigurationsResponse_Country>, I>>(
    base?: I,
  ): GetUserConfigurationsResponse_Country {
    return GetUserConfigurationsResponse_Country.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetUserConfigurationsResponse_Country>, I>>(
    object: I,
  ): GetUserConfigurationsResponse_Country {
    const message = createBaseGetUserConfigurationsResponse_Country();
    message.name = object.name ?? "";
    message.ISO2 = object.ISO2 ?? "";
    return message;
  },
};

function createBaseGetUserConfigurationsResponse_USState(): GetUserConfigurationsResponse_USState {
  return { name: "", USPS2: "" };
}

export const GetUserConfigurationsResponse_USState = {
  encode(message: GetUserConfigurationsResponse_USState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.USPS2 !== "") {
      writer.uint32(18).string(message.USPS2);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserConfigurationsResponse_USState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserConfigurationsResponse_USState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.USPS2 = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetUserConfigurationsResponse_USState {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      USPS2: isSet(object.USPS2) ? String(object.USPS2) : "",
    };
  },

  toJSON(message: GetUserConfigurationsResponse_USState): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.USPS2 !== undefined && (obj.USPS2 = message.USPS2);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserConfigurationsResponse_USState>, I>>(
    base?: I,
  ): GetUserConfigurationsResponse_USState {
    return GetUserConfigurationsResponse_USState.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetUserConfigurationsResponse_USState>, I>>(
    object: I,
  ): GetUserConfigurationsResponse_USState {
    const message = createBaseGetUserConfigurationsResponse_USState();
    message.name = object.name ?? "";
    message.USPS2 = object.USPS2 ?? "";
    return message;
  },
};

function createBaseUpdateUserConfigurationsRequest(): UpdateUserConfigurationsRequest {
  return { institutions: [], categories: [], patchstrategy: undefined };
}

export const UpdateUserConfigurationsRequest = {
  encode(message: UpdateUserConfigurationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.institutions) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.categories) {
      writer.uint32(18).string(v!);
    }
    if (message.patchstrategy !== undefined) {
      PatchStrategy.encode(message.patchstrategy, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserConfigurationsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserConfigurationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.institutions.push(reader.string());
          break;
        case 2:
          message.categories.push(reader.string());
          break;
        case 3:
          message.patchstrategy = PatchStrategy.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateUserConfigurationsRequest {
    return {
      institutions: Array.isArray(object?.institutions) ? object.institutions.map((e: any) => String(e)) : [],
      categories: Array.isArray(object?.categories) ? object.categories.map((e: any) => String(e)) : [],
      patchstrategy: isSet(object.patchstrategy) ? PatchStrategy.fromJSON(object.patchstrategy) : undefined,
    };
  },

  toJSON(message: UpdateUserConfigurationsRequest): unknown {
    const obj: any = {};
    if (message.institutions) {
      obj.institutions = message.institutions.map((e) => e);
    } else {
      obj.institutions = [];
    }
    if (message.categories) {
      obj.categories = message.categories.map((e) => e);
    } else {
      obj.categories = [];
    }
    message.patchstrategy !== undefined &&
      (obj.patchstrategy = message.patchstrategy ? PatchStrategy.toJSON(message.patchstrategy) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserConfigurationsRequest>, I>>(base?: I): UpdateUserConfigurationsRequest {
    return UpdateUserConfigurationsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateUserConfigurationsRequest>, I>>(
    object: I,
  ): UpdateUserConfigurationsRequest {
    const message = createBaseUpdateUserConfigurationsRequest();
    message.institutions = object.institutions?.map((e) => e) || [];
    message.categories = object.categories?.map((e) => e) || [];
    message.patchstrategy = (object.patchstrategy !== undefined && object.patchstrategy !== null)
      ? PatchStrategy.fromPartial(object.patchstrategy)
      : undefined;
    return message;
  },
};

function createBaseUpdateUserConfigurationsResponse(): UpdateUserConfigurationsResponse {
  return {};
}

export const UpdateUserConfigurationsResponse = {
  encode(_: UpdateUserConfigurationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserConfigurationsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserConfigurationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): UpdateUserConfigurationsResponse {
    return {};
  },

  toJSON(_: UpdateUserConfigurationsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserConfigurationsResponse>, I>>(
    base?: I,
  ): UpdateUserConfigurationsResponse {
    return UpdateUserConfigurationsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateUserConfigurationsResponse>, I>>(
    _: I,
  ): UpdateUserConfigurationsResponse {
    const message = createBaseUpdateUserConfigurationsResponse();
    return message;
  },
};

function createBaseGetEntityTypeConfigurationsRequest(): GetEntityTypeConfigurationsRequest {
  return {};
}

export const GetEntityTypeConfigurationsRequest = {
  encode(_: GetEntityTypeConfigurationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetEntityTypeConfigurationsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEntityTypeConfigurationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetEntityTypeConfigurationsRequest {
    return {};
  },

  toJSON(_: GetEntityTypeConfigurationsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEntityTypeConfigurationsRequest>, I>>(
    base?: I,
  ): GetEntityTypeConfigurationsRequest {
    return GetEntityTypeConfigurationsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetEntityTypeConfigurationsRequest>, I>>(
    _: I,
  ): GetEntityTypeConfigurationsRequest {
    const message = createBaseGetEntityTypeConfigurationsRequest();
    return message;
  },
};

function createBaseEntityType(): EntityType {
  return { etype: "", subtypes: [] };
}

export const EntityType = {
  encode(message: EntityType, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.etype !== "") {
      writer.uint32(10).string(message.etype);
    }
    for (const v of message.subtypes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EntityType {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.etype = reader.string();
          break;
        case 2:
          message.subtypes.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EntityType {
    return {
      etype: isSet(object.etype) ? String(object.etype) : "",
      subtypes: Array.isArray(object?.subtypes) ? object.subtypes.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: EntityType): unknown {
    const obj: any = {};
    message.etype !== undefined && (obj.etype = message.etype);
    if (message.subtypes) {
      obj.subtypes = message.subtypes.map((e) => e);
    } else {
      obj.subtypes = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EntityType>, I>>(base?: I): EntityType {
    return EntityType.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<EntityType>, I>>(object: I): EntityType {
    const message = createBaseEntityType();
    message.etype = object.etype ?? "";
    message.subtypes = object.subtypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetEntityTypeConfigurationsResponse(): GetEntityTypeConfigurationsResponse {
  return { Types: [] };
}

export const GetEntityTypeConfigurationsResponse = {
  encode(message: GetEntityTypeConfigurationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.Types) {
      EntityType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetEntityTypeConfigurationsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEntityTypeConfigurationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.Types.push(EntityType.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetEntityTypeConfigurationsResponse {
    return { Types: Array.isArray(object?.Types) ? object.Types.map((e: any) => EntityType.fromJSON(e)) : [] };
  },

  toJSON(message: GetEntityTypeConfigurationsResponse): unknown {
    const obj: any = {};
    if (message.Types) {
      obj.Types = message.Types.map((e) => e ? EntityType.toJSON(e) : undefined);
    } else {
      obj.Types = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEntityTypeConfigurationsResponse>, I>>(
    base?: I,
  ): GetEntityTypeConfigurationsResponse {
    return GetEntityTypeConfigurationsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetEntityTypeConfigurationsResponse>, I>>(
    object: I,
  ): GetEntityTypeConfigurationsResponse {
    const message = createBaseGetEntityTypeConfigurationsResponse();
    message.Types = object.Types?.map((e) => EntityType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateEntityTypeConfigurationsRequest(): UpdateEntityTypeConfigurationsRequest {
  return { Types: [], patchstrategy: undefined };
}

export const UpdateEntityTypeConfigurationsRequest = {
  encode(message: UpdateEntityTypeConfigurationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.Types) {
      EntityType.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.patchstrategy !== undefined) {
      PatchStrategy.encode(message.patchstrategy, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateEntityTypeConfigurationsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEntityTypeConfigurationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.Types.push(EntityType.decode(reader, reader.uint32()));
          break;
        case 2:
          message.patchstrategy = PatchStrategy.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateEntityTypeConfigurationsRequest {
    return {
      Types: Array.isArray(object?.Types) ? object.Types.map((e: any) => EntityType.fromJSON(e)) : [],
      patchstrategy: isSet(object.patchstrategy) ? PatchStrategy.fromJSON(object.patchstrategy) : undefined,
    };
  },

  toJSON(message: UpdateEntityTypeConfigurationsRequest): unknown {
    const obj: any = {};
    if (message.Types) {
      obj.Types = message.Types.map((e) => e ? EntityType.toJSON(e) : undefined);
    } else {
      obj.Types = [];
    }
    message.patchstrategy !== undefined &&
      (obj.patchstrategy = message.patchstrategy ? PatchStrategy.toJSON(message.patchstrategy) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateEntityTypeConfigurationsRequest>, I>>(
    base?: I,
  ): UpdateEntityTypeConfigurationsRequest {
    return UpdateEntityTypeConfigurationsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateEntityTypeConfigurationsRequest>, I>>(
    object: I,
  ): UpdateEntityTypeConfigurationsRequest {
    const message = createBaseUpdateEntityTypeConfigurationsRequest();
    message.Types = object.Types?.map((e) => EntityType.fromPartial(e)) || [];
    message.patchstrategy = (object.patchstrategy !== undefined && object.patchstrategy !== null)
      ? PatchStrategy.fromPartial(object.patchstrategy)
      : undefined;
    return message;
  },
};

function createBaseUpdateEntityTypeConfigurationsResponse(): UpdateEntityTypeConfigurationsResponse {
  return {};
}

export const UpdateEntityTypeConfigurationsResponse = {
  encode(_: UpdateEntityTypeConfigurationsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateEntityTypeConfigurationsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEntityTypeConfigurationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): UpdateEntityTypeConfigurationsResponse {
    return {};
  },

  toJSON(_: UpdateEntityTypeConfigurationsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateEntityTypeConfigurationsResponse>, I>>(
    base?: I,
  ): UpdateEntityTypeConfigurationsResponse {
    return UpdateEntityTypeConfigurationsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateEntityTypeConfigurationsResponse>, I>>(
    _: I,
  ): UpdateEntityTypeConfigurationsResponse {
    const message = createBaseUpdateEntityTypeConfigurationsResponse();
    return message;
  },
};

function createBaseGetPolicyRequest(): GetPolicyRequest {
  return {};
}

export const GetPolicyRequest = {
  encode(_: GetPolicyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPolicyRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetPolicyRequest {
    return {};
  },

  toJSON(_: GetPolicyRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPolicyRequest>, I>>(base?: I): GetPolicyRequest {
    return GetPolicyRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetPolicyRequest>, I>>(_: I): GetPolicyRequest {
    const message = createBaseGetPolicyRequest();
    return message;
  },
};

function createBaseGetPolicyResponse(): GetPolicyResponse {
  return { policy: "" };
}

export const GetPolicyResponse = {
  encode(message: GetPolicyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.policy !== "") {
      writer.uint32(10).string(message.policy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPolicyResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.policy = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetPolicyResponse {
    return { policy: isSet(object.policy) ? String(object.policy) : "" };
  },

  toJSON(message: GetPolicyResponse): unknown {
    const obj: any = {};
    message.policy !== undefined && (obj.policy = message.policy);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPolicyResponse>, I>>(base?: I): GetPolicyResponse {
    return GetPolicyResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetPolicyResponse>, I>>(object: I): GetPolicyResponse {
    const message = createBaseGetPolicyResponse();
    message.policy = object.policy ?? "";
    return message;
  },
};

function createBaseHealthRequest(): HealthRequest {
  return {};
}

export const HealthRequest = {
  encode(_: HealthRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): HealthRequest {
    return {};
  },

  toJSON(_: HealthRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthRequest>, I>>(base?: I): HealthRequest {
    return HealthRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<HealthRequest>, I>>(_: I): HealthRequest {
    const message = createBaseHealthRequest();
    return message;
  },
};

function createBaseHealthResponse(): HealthResponse {
  return { status: "" };
}

export const HealthResponse = {
  encode(message: HealthResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.status = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): HealthResponse {
    return { status: isSet(object.status) ? String(object.status) : "" };
  },

  toJSON(message: HealthResponse): unknown {
    const obj: any = {};
    message.status !== undefined && (obj.status = message.status);
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthResponse>, I>>(base?: I): HealthResponse {
    return HealthResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<HealthResponse>, I>>(object: I): HealthResponse {
    const message = createBaseHealthResponse();
    message.status = object.status ?? "";
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = date.getTime() / 1_000;
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = t.seconds * 1_000;
  millis += t.nanos / 1_000_000;
  return new Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
