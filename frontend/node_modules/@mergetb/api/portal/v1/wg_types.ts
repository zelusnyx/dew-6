/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "portal.v1";

export interface WgEnclave {
  enclaveid: string;
  gateways: { [key: string]: WgIfConfig };
  clients: { [key: string]: WgIfConfig };
  Ver: number;
  gatewayIps: { [key: string]: string };
  clientIps: { [key: string]: string };
}

export interface WgEnclave_GatewaysEntry {
  key: string;
  value: WgIfConfig | undefined;
}

export interface WgEnclave_ClientsEntry {
  key: string;
  value: WgIfConfig | undefined;
}

export interface WgEnclave_GatewayIpsEntry {
  key: string;
  value: string;
}

export interface WgEnclave_ClientIpsEntry {
  key: string;
  value: string;
}

export interface WgIfConfig {
  endpoint: string;
  key: string;
  allowedips: string[];
  accessaddr: string;
}

export interface AddWgIfConfigRequest {
  enclaveid: string;
  config: WgIfConfig | undefined;
  gateway: boolean;
}

export interface AddWgIfConfigResponse {
}

export interface DelWgIfConfigRequest {
  enclaveid: string;
  key: string;
}

export interface DelWgIfConfigResponse {
}

export interface GetWgIfConfigRequest {
  enclaveid: string;
  key: string;
}

export interface GetWgIfConfigResponse {
  enclaveid: string;
  endpoint: string;
}

export interface GetWgEnclaveRequest {
  enclaveid: string;
}

export interface GetWgEnclaveResponse {
  enclave: WgEnclave | undefined;
}

function createBaseWgEnclave(): WgEnclave {
  return { enclaveid: "", gateways: {}, clients: {}, Ver: 0, gatewayIps: {}, clientIps: {} };
}

export const WgEnclave = {
  encode(message: WgEnclave, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enclaveid !== "") {
      writer.uint32(10).string(message.enclaveid);
    }
    Object.entries(message.gateways).forEach(([key, value]) => {
      WgEnclave_GatewaysEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    Object.entries(message.clients).forEach(([key, value]) => {
      WgEnclave_ClientsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.Ver !== 0) {
      writer.uint32(32).int64(message.Ver);
    }
    Object.entries(message.gatewayIps).forEach(([key, value]) => {
      WgEnclave_GatewayIpsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    Object.entries(message.clientIps).forEach(([key, value]) => {
      WgEnclave_ClientIpsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WgEnclave {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWgEnclave();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.enclaveid = reader.string();
          break;
        case 2:
          const entry2 = WgEnclave_GatewaysEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.gateways[entry2.key] = entry2.value;
          }
          break;
        case 3:
          const entry3 = WgEnclave_ClientsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.clients[entry3.key] = entry3.value;
          }
          break;
        case 4:
          message.Ver = longToNumber(reader.int64() as Long);
          break;
        case 5:
          const entry5 = WgEnclave_GatewayIpsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.gatewayIps[entry5.key] = entry5.value;
          }
          break;
        case 6:
          const entry6 = WgEnclave_ClientIpsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.clientIps[entry6.key] = entry6.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): WgEnclave {
    return {
      enclaveid: isSet(object.enclaveid) ? String(object.enclaveid) : "",
      gateways: isObject(object.gateways)
        ? Object.entries(object.gateways).reduce<{ [key: string]: WgIfConfig }>((acc, [key, value]) => {
          acc[key] = WgIfConfig.fromJSON(value);
          return acc;
        }, {})
        : {},
      clients: isObject(object.clients)
        ? Object.entries(object.clients).reduce<{ [key: string]: WgIfConfig }>((acc, [key, value]) => {
          acc[key] = WgIfConfig.fromJSON(value);
          return acc;
        }, {})
        : {},
      Ver: isSet(object.Ver) ? Number(object.Ver) : 0,
      gatewayIps: isObject(object.gatewayIps)
        ? Object.entries(object.gatewayIps).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      clientIps: isObject(object.clientIps)
        ? Object.entries(object.clientIps).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: WgEnclave): unknown {
    const obj: any = {};
    message.enclaveid !== undefined && (obj.enclaveid = message.enclaveid);
    obj.gateways = {};
    if (message.gateways) {
      Object.entries(message.gateways).forEach(([k, v]) => {
        obj.gateways[k] = WgIfConfig.toJSON(v);
      });
    }
    obj.clients = {};
    if (message.clients) {
      Object.entries(message.clients).forEach(([k, v]) => {
        obj.clients[k] = WgIfConfig.toJSON(v);
      });
    }
    message.Ver !== undefined && (obj.Ver = Math.round(message.Ver));
    obj.gatewayIps = {};
    if (message.gatewayIps) {
      Object.entries(message.gatewayIps).forEach(([k, v]) => {
        obj.gatewayIps[k] = v;
      });
    }
    obj.clientIps = {};
    if (message.clientIps) {
      Object.entries(message.clientIps).forEach(([k, v]) => {
        obj.clientIps[k] = v;
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WgEnclave>, I>>(base?: I): WgEnclave {
    return WgEnclave.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<WgEnclave>, I>>(object: I): WgEnclave {
    const message = createBaseWgEnclave();
    message.enclaveid = object.enclaveid ?? "";
    message.gateways = Object.entries(object.gateways ?? {}).reduce<{ [key: string]: WgIfConfig }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = WgIfConfig.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.clients = Object.entries(object.clients ?? {}).reduce<{ [key: string]: WgIfConfig }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = WgIfConfig.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.Ver = object.Ver ?? 0;
    message.gatewayIps = Object.entries(object.gatewayIps ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = String(value);
        }
        return acc;
      },
      {},
    );
    message.clientIps = Object.entries(object.clientIps ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseWgEnclave_GatewaysEntry(): WgEnclave_GatewaysEntry {
  return { key: "", value: undefined };
}

export const WgEnclave_GatewaysEntry = {
  encode(message: WgEnclave_GatewaysEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      WgIfConfig.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WgEnclave_GatewaysEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWgEnclave_GatewaysEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = WgIfConfig.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): WgEnclave_GatewaysEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? WgIfConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: WgEnclave_GatewaysEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? WgIfConfig.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<WgEnclave_GatewaysEntry>, I>>(base?: I): WgEnclave_GatewaysEntry {
    return WgEnclave_GatewaysEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<WgEnclave_GatewaysEntry>, I>>(object: I): WgEnclave_GatewaysEntry {
    const message = createBaseWgEnclave_GatewaysEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? WgIfConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseWgEnclave_ClientsEntry(): WgEnclave_ClientsEntry {
  return { key: "", value: undefined };
}

export const WgEnclave_ClientsEntry = {
  encode(message: WgEnclave_ClientsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      WgIfConfig.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WgEnclave_ClientsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWgEnclave_ClientsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = WgIfConfig.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): WgEnclave_ClientsEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? WgIfConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: WgEnclave_ClientsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? WgIfConfig.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<WgEnclave_ClientsEntry>, I>>(base?: I): WgEnclave_ClientsEntry {
    return WgEnclave_ClientsEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<WgEnclave_ClientsEntry>, I>>(object: I): WgEnclave_ClientsEntry {
    const message = createBaseWgEnclave_ClientsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? WgIfConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseWgEnclave_GatewayIpsEntry(): WgEnclave_GatewayIpsEntry {
  return { key: "", value: "" };
}

export const WgEnclave_GatewayIpsEntry = {
  encode(message: WgEnclave_GatewayIpsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WgEnclave_GatewayIpsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWgEnclave_GatewayIpsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): WgEnclave_GatewayIpsEntry {
    return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
  },

  toJSON(message: WgEnclave_GatewayIpsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  create<I extends Exact<DeepPartial<WgEnclave_GatewayIpsEntry>, I>>(base?: I): WgEnclave_GatewayIpsEntry {
    return WgEnclave_GatewayIpsEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<WgEnclave_GatewayIpsEntry>, I>>(object: I): WgEnclave_GatewayIpsEntry {
    const message = createBaseWgEnclave_GatewayIpsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWgEnclave_ClientIpsEntry(): WgEnclave_ClientIpsEntry {
  return { key: "", value: "" };
}

export const WgEnclave_ClientIpsEntry = {
  encode(message: WgEnclave_ClientIpsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WgEnclave_ClientIpsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWgEnclave_ClientIpsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): WgEnclave_ClientIpsEntry {
    return { key: isSet(object.key) ? String(object.key) : "", value: isSet(object.value) ? String(object.value) : "" };
  },

  toJSON(message: WgEnclave_ClientIpsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  create<I extends Exact<DeepPartial<WgEnclave_ClientIpsEntry>, I>>(base?: I): WgEnclave_ClientIpsEntry {
    return WgEnclave_ClientIpsEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<WgEnclave_ClientIpsEntry>, I>>(object: I): WgEnclave_ClientIpsEntry {
    const message = createBaseWgEnclave_ClientIpsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWgIfConfig(): WgIfConfig {
  return { endpoint: "", key: "", allowedips: [], accessaddr: "" };
}

export const WgIfConfig = {
  encode(message: WgIfConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.endpoint !== "") {
      writer.uint32(10).string(message.endpoint);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    for (const v of message.allowedips) {
      writer.uint32(26).string(v!);
    }
    if (message.accessaddr !== "") {
      writer.uint32(34).string(message.accessaddr);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WgIfConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWgIfConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.endpoint = reader.string();
          break;
        case 2:
          message.key = reader.string();
          break;
        case 3:
          message.allowedips.push(reader.string());
          break;
        case 4:
          message.accessaddr = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): WgIfConfig {
    return {
      endpoint: isSet(object.endpoint) ? String(object.endpoint) : "",
      key: isSet(object.key) ? String(object.key) : "",
      allowedips: Array.isArray(object?.allowedips) ? object.allowedips.map((e: any) => String(e)) : [],
      accessaddr: isSet(object.accessaddr) ? String(object.accessaddr) : "",
    };
  },

  toJSON(message: WgIfConfig): unknown {
    const obj: any = {};
    message.endpoint !== undefined && (obj.endpoint = message.endpoint);
    message.key !== undefined && (obj.key = message.key);
    if (message.allowedips) {
      obj.allowedips = message.allowedips.map((e) => e);
    } else {
      obj.allowedips = [];
    }
    message.accessaddr !== undefined && (obj.accessaddr = message.accessaddr);
    return obj;
  },

  create<I extends Exact<DeepPartial<WgIfConfig>, I>>(base?: I): WgIfConfig {
    return WgIfConfig.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<WgIfConfig>, I>>(object: I): WgIfConfig {
    const message = createBaseWgIfConfig();
    message.endpoint = object.endpoint ?? "";
    message.key = object.key ?? "";
    message.allowedips = object.allowedips?.map((e) => e) || [];
    message.accessaddr = object.accessaddr ?? "";
    return message;
  },
};

function createBaseAddWgIfConfigRequest(): AddWgIfConfigRequest {
  return { enclaveid: "", config: undefined, gateway: false };
}

export const AddWgIfConfigRequest = {
  encode(message: AddWgIfConfigRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enclaveid !== "") {
      writer.uint32(10).string(message.enclaveid);
    }
    if (message.config !== undefined) {
      WgIfConfig.encode(message.config, writer.uint32(18).fork()).ldelim();
    }
    if (message.gateway === true) {
      writer.uint32(24).bool(message.gateway);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddWgIfConfigRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddWgIfConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.enclaveid = reader.string();
          break;
        case 2:
          message.config = WgIfConfig.decode(reader, reader.uint32());
          break;
        case 3:
          message.gateway = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AddWgIfConfigRequest {
    return {
      enclaveid: isSet(object.enclaveid) ? String(object.enclaveid) : "",
      config: isSet(object.config) ? WgIfConfig.fromJSON(object.config) : undefined,
      gateway: isSet(object.gateway) ? Boolean(object.gateway) : false,
    };
  },

  toJSON(message: AddWgIfConfigRequest): unknown {
    const obj: any = {};
    message.enclaveid !== undefined && (obj.enclaveid = message.enclaveid);
    message.config !== undefined && (obj.config = message.config ? WgIfConfig.toJSON(message.config) : undefined);
    message.gateway !== undefined && (obj.gateway = message.gateway);
    return obj;
  },

  create<I extends Exact<DeepPartial<AddWgIfConfigRequest>, I>>(base?: I): AddWgIfConfigRequest {
    return AddWgIfConfigRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddWgIfConfigRequest>, I>>(object: I): AddWgIfConfigRequest {
    const message = createBaseAddWgIfConfigRequest();
    message.enclaveid = object.enclaveid ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? WgIfConfig.fromPartial(object.config)
      : undefined;
    message.gateway = object.gateway ?? false;
    return message;
  },
};

function createBaseAddWgIfConfigResponse(): AddWgIfConfigResponse {
  return {};
}

export const AddWgIfConfigResponse = {
  encode(_: AddWgIfConfigResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddWgIfConfigResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddWgIfConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): AddWgIfConfigResponse {
    return {};
  },

  toJSON(_: AddWgIfConfigResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AddWgIfConfigResponse>, I>>(base?: I): AddWgIfConfigResponse {
    return AddWgIfConfigResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddWgIfConfigResponse>, I>>(_: I): AddWgIfConfigResponse {
    const message = createBaseAddWgIfConfigResponse();
    return message;
  },
};

function createBaseDelWgIfConfigRequest(): DelWgIfConfigRequest {
  return { enclaveid: "", key: "" };
}

export const DelWgIfConfigRequest = {
  encode(message: DelWgIfConfigRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enclaveid !== "") {
      writer.uint32(10).string(message.enclaveid);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DelWgIfConfigRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelWgIfConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.enclaveid = reader.string();
          break;
        case 2:
          message.key = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DelWgIfConfigRequest {
    return {
      enclaveid: isSet(object.enclaveid) ? String(object.enclaveid) : "",
      key: isSet(object.key) ? String(object.key) : "",
    };
  },

  toJSON(message: DelWgIfConfigRequest): unknown {
    const obj: any = {};
    message.enclaveid !== undefined && (obj.enclaveid = message.enclaveid);
    message.key !== undefined && (obj.key = message.key);
    return obj;
  },

  create<I extends Exact<DeepPartial<DelWgIfConfigRequest>, I>>(base?: I): DelWgIfConfigRequest {
    return DelWgIfConfigRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DelWgIfConfigRequest>, I>>(object: I): DelWgIfConfigRequest {
    const message = createBaseDelWgIfConfigRequest();
    message.enclaveid = object.enclaveid ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseDelWgIfConfigResponse(): DelWgIfConfigResponse {
  return {};
}

export const DelWgIfConfigResponse = {
  encode(_: DelWgIfConfigResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DelWgIfConfigResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelWgIfConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DelWgIfConfigResponse {
    return {};
  },

  toJSON(_: DelWgIfConfigResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DelWgIfConfigResponse>, I>>(base?: I): DelWgIfConfigResponse {
    return DelWgIfConfigResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DelWgIfConfigResponse>, I>>(_: I): DelWgIfConfigResponse {
    const message = createBaseDelWgIfConfigResponse();
    return message;
  },
};

function createBaseGetWgIfConfigRequest(): GetWgIfConfigRequest {
  return { enclaveid: "", key: "" };
}

export const GetWgIfConfigRequest = {
  encode(message: GetWgIfConfigRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enclaveid !== "") {
      writer.uint32(10).string(message.enclaveid);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWgIfConfigRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWgIfConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.enclaveid = reader.string();
          break;
        case 2:
          message.key = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetWgIfConfigRequest {
    return {
      enclaveid: isSet(object.enclaveid) ? String(object.enclaveid) : "",
      key: isSet(object.key) ? String(object.key) : "",
    };
  },

  toJSON(message: GetWgIfConfigRequest): unknown {
    const obj: any = {};
    message.enclaveid !== undefined && (obj.enclaveid = message.enclaveid);
    message.key !== undefined && (obj.key = message.key);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWgIfConfigRequest>, I>>(base?: I): GetWgIfConfigRequest {
    return GetWgIfConfigRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetWgIfConfigRequest>, I>>(object: I): GetWgIfConfigRequest {
    const message = createBaseGetWgIfConfigRequest();
    message.enclaveid = object.enclaveid ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseGetWgIfConfigResponse(): GetWgIfConfigResponse {
  return { enclaveid: "", endpoint: "" };
}

export const GetWgIfConfigResponse = {
  encode(message: GetWgIfConfigResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enclaveid !== "") {
      writer.uint32(10).string(message.enclaveid);
    }
    if (message.endpoint !== "") {
      writer.uint32(18).string(message.endpoint);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWgIfConfigResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWgIfConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.enclaveid = reader.string();
          break;
        case 2:
          message.endpoint = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetWgIfConfigResponse {
    return {
      enclaveid: isSet(object.enclaveid) ? String(object.enclaveid) : "",
      endpoint: isSet(object.endpoint) ? String(object.endpoint) : "",
    };
  },

  toJSON(message: GetWgIfConfigResponse): unknown {
    const obj: any = {};
    message.enclaveid !== undefined && (obj.enclaveid = message.enclaveid);
    message.endpoint !== undefined && (obj.endpoint = message.endpoint);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWgIfConfigResponse>, I>>(base?: I): GetWgIfConfigResponse {
    return GetWgIfConfigResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetWgIfConfigResponse>, I>>(object: I): GetWgIfConfigResponse {
    const message = createBaseGetWgIfConfigResponse();
    message.enclaveid = object.enclaveid ?? "";
    message.endpoint = object.endpoint ?? "";
    return message;
  },
};

function createBaseGetWgEnclaveRequest(): GetWgEnclaveRequest {
  return { enclaveid: "" };
}

export const GetWgEnclaveRequest = {
  encode(message: GetWgEnclaveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enclaveid !== "") {
      writer.uint32(10).string(message.enclaveid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWgEnclaveRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWgEnclaveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.enclaveid = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetWgEnclaveRequest {
    return { enclaveid: isSet(object.enclaveid) ? String(object.enclaveid) : "" };
  },

  toJSON(message: GetWgEnclaveRequest): unknown {
    const obj: any = {};
    message.enclaveid !== undefined && (obj.enclaveid = message.enclaveid);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWgEnclaveRequest>, I>>(base?: I): GetWgEnclaveRequest {
    return GetWgEnclaveRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetWgEnclaveRequest>, I>>(object: I): GetWgEnclaveRequest {
    const message = createBaseGetWgEnclaveRequest();
    message.enclaveid = object.enclaveid ?? "";
    return message;
  },
};

function createBaseGetWgEnclaveResponse(): GetWgEnclaveResponse {
  return { enclave: undefined };
}

export const GetWgEnclaveResponse = {
  encode(message: GetWgEnclaveResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enclave !== undefined) {
      WgEnclave.encode(message.enclave, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWgEnclaveResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWgEnclaveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.enclave = WgEnclave.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetWgEnclaveResponse {
    return { enclave: isSet(object.enclave) ? WgEnclave.fromJSON(object.enclave) : undefined };
  },

  toJSON(message: GetWgEnclaveResponse): unknown {
    const obj: any = {};
    message.enclave !== undefined && (obj.enclave = message.enclave ? WgEnclave.toJSON(message.enclave) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWgEnclaveResponse>, I>>(base?: I): GetWgEnclaveResponse {
    return GetWgEnclaveResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetWgEnclaveResponse>, I>>(object: I): GetWgEnclaveResponse {
    const message = createBaseGetWgEnclaveResponse();
    message.enclave = (object.enclave !== undefined && object.enclave !== null)
      ? WgEnclave.fromPartial(object.enclave)
      : undefined;
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
