/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { CableAllocation, ResourceAllocation } from "../../mergetb/xir/v0.3/core";
import { PatchStrategy } from "./patch_types";

export const protobufPackage = "portal.v1";

export interface ResourceAllocationList {
  value: ResourceAllocation[];
  revision: number;
}

export interface CableAllocationList {
  value: CableAllocation[];
  revision: number;
}

export interface AllocationTable {
  resource: { [key: string]: ResourceAllocationList };
  cable: { [key: string]: CableAllocationList };
}

export interface AllocationTable_ResourceEntry {
  key: string;
  value: ResourceAllocationList | undefined;
}

export interface AllocationTable_CableEntry {
  key: string;
  value: CableAllocationList | undefined;
}

export interface AllocationRequest {
  table: AllocationTable | undefined;
}

export interface AllocationResponse {
}

export interface FreeRequest {
  rzid: string;
}

export interface FreeResponse {
}

export interface FetchAllocationTableRequest {
}

export interface FetchAllocationTableResponse {
  table: AllocationTable | undefined;
}

export interface Pool {
  name: string;
  description: string;
  projects: string[];
  /** Per facility list of resources (as strings) */
  facilities: { [key: string]: Pool_Resources };
  creator: string;
  ver: number;
  organizations: string[];
}

export interface Pool_Resources {
  resources: string[];
}

export interface Pool_FacilitiesEntry {
  key: string;
  value: Pool_Resources | undefined;
}

export interface GetPoolsRequest {
}

export interface GetPoolsResponse {
  pools: Pool[];
}

export interface GetPoolRequest {
  name: string;
}

export interface GetPoolResponse {
  pool: Pool | undefined;
}

export interface CreatePoolRequest {
  name: string;
  description: string;
  projects: string[];
  facilities: string[];
  organizations: string[];
}

export interface CreatePoolResponse {
}

export interface DeletePoolRequest {
  name: string;
}

export interface DeletePoolResponse {
}

export interface AddProjectToPoolRequest {
  name: string;
  project: string;
}

export interface AddProjectToPoolResponse {
}

export interface RemoveProjectFromPoolRequest {
  name: string;
  project: string;
}

export interface RemoveProjectFromPoolResponse {
}

export interface AddOrganizationToPoolRequest {
  name: string;
  organization: string;
}

export interface AddOrganizationToPoolResponse {
}

export interface RemoveOrganizationFromPoolRequest {
  name: string;
  organization: string;
}

export interface RemoveOrganizationFromPoolResponse {
}

export interface AddFacilityToPoolRequest {
  name: string;
  facility: string;
  /** optional */
  resources: string[];
}

export interface AddFacilityToPoolResponse {
}

export interface RemoveFacilityFromPoolRequest {
  name: string;
  facility: string;
}

export interface RemoveFacilityFromPoolResponse {
}

export interface UpdatePoolResourcesRequest {
  pool: string;
  facility: string;
  resources: string[];
  /**
   * how to merge the given resources into the existing pool
   * replace, remove, expand, or subtract.
   */
  patchstrategy: PatchStrategy | undefined;
}

/**
 * UpdatePoolResourcesResponse contains the updates list
 * of resources for the facility in the pool.
 */
export interface UpdatePoolResourcesResponse {
  pool: string;
  facility: string;
  resources: string[];
}

function createBaseResourceAllocationList(): ResourceAllocationList {
  return { value: [], revision: 0 };
}

export const ResourceAllocationList = {
  encode(message: ResourceAllocationList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.value) {
      ResourceAllocation.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.revision !== 0) {
      writer.uint32(16).int64(message.revision);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourceAllocationList {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceAllocationList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value.push(ResourceAllocation.decode(reader, reader.uint32()));
          break;
        case 2:
          message.revision = longToNumber(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ResourceAllocationList {
    return {
      value: Array.isArray(object?.value) ? object.value.map((e: any) => ResourceAllocation.fromJSON(e)) : [],
      revision: isSet(object.revision) ? Number(object.revision) : 0,
    };
  },

  toJSON(message: ResourceAllocationList): unknown {
    const obj: any = {};
    if (message.value) {
      obj.value = message.value.map((e) => e ? ResourceAllocation.toJSON(e) : undefined);
    } else {
      obj.value = [];
    }
    message.revision !== undefined && (obj.revision = Math.round(message.revision));
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceAllocationList>, I>>(base?: I): ResourceAllocationList {
    return ResourceAllocationList.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ResourceAllocationList>, I>>(object: I): ResourceAllocationList {
    const message = createBaseResourceAllocationList();
    message.value = object.value?.map((e) => ResourceAllocation.fromPartial(e)) || [];
    message.revision = object.revision ?? 0;
    return message;
  },
};

function createBaseCableAllocationList(): CableAllocationList {
  return { value: [], revision: 0 };
}

export const CableAllocationList = {
  encode(message: CableAllocationList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.value) {
      CableAllocation.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.revision !== 0) {
      writer.uint32(16).int64(message.revision);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CableAllocationList {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCableAllocationList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.value.push(CableAllocation.decode(reader, reader.uint32()));
          break;
        case 2:
          message.revision = longToNumber(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CableAllocationList {
    return {
      value: Array.isArray(object?.value) ? object.value.map((e: any) => CableAllocation.fromJSON(e)) : [],
      revision: isSet(object.revision) ? Number(object.revision) : 0,
    };
  },

  toJSON(message: CableAllocationList): unknown {
    const obj: any = {};
    if (message.value) {
      obj.value = message.value.map((e) => e ? CableAllocation.toJSON(e) : undefined);
    } else {
      obj.value = [];
    }
    message.revision !== undefined && (obj.revision = Math.round(message.revision));
    return obj;
  },

  create<I extends Exact<DeepPartial<CableAllocationList>, I>>(base?: I): CableAllocationList {
    return CableAllocationList.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CableAllocationList>, I>>(object: I): CableAllocationList {
    const message = createBaseCableAllocationList();
    message.value = object.value?.map((e) => CableAllocation.fromPartial(e)) || [];
    message.revision = object.revision ?? 0;
    return message;
  },
};

function createBaseAllocationTable(): AllocationTable {
  return { resource: {}, cable: {} };
}

export const AllocationTable = {
  encode(message: AllocationTable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.resource).forEach(([key, value]) => {
      AllocationTable_ResourceEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    Object.entries(message.cable).forEach(([key, value]) => {
      AllocationTable_CableEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AllocationTable {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocationTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = AllocationTable_ResourceEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.resource[entry1.key] = entry1.value;
          }
          break;
        case 2:
          const entry2 = AllocationTable_CableEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.cable[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AllocationTable {
    return {
      resource: isObject(object.resource)
        ? Object.entries(object.resource).reduce<{ [key: string]: ResourceAllocationList }>((acc, [key, value]) => {
          acc[key] = ResourceAllocationList.fromJSON(value);
          return acc;
        }, {})
        : {},
      cable: isObject(object.cable)
        ? Object.entries(object.cable).reduce<{ [key: string]: CableAllocationList }>((acc, [key, value]) => {
          acc[key] = CableAllocationList.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AllocationTable): unknown {
    const obj: any = {};
    obj.resource = {};
    if (message.resource) {
      Object.entries(message.resource).forEach(([k, v]) => {
        obj.resource[k] = ResourceAllocationList.toJSON(v);
      });
    }
    obj.cable = {};
    if (message.cable) {
      Object.entries(message.cable).forEach(([k, v]) => {
        obj.cable[k] = CableAllocationList.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllocationTable>, I>>(base?: I): AllocationTable {
    return AllocationTable.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AllocationTable>, I>>(object: I): AllocationTable {
    const message = createBaseAllocationTable();
    message.resource = Object.entries(object.resource ?? {}).reduce<{ [key: string]: ResourceAllocationList }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ResourceAllocationList.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.cable = Object.entries(object.cable ?? {}).reduce<{ [key: string]: CableAllocationList }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = CableAllocationList.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAllocationTable_ResourceEntry(): AllocationTable_ResourceEntry {
  return { key: "", value: undefined };
}

export const AllocationTable_ResourceEntry = {
  encode(message: AllocationTable_ResourceEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ResourceAllocationList.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AllocationTable_ResourceEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocationTable_ResourceEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = ResourceAllocationList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AllocationTable_ResourceEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? ResourceAllocationList.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AllocationTable_ResourceEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined &&
      (obj.value = message.value ? ResourceAllocationList.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<AllocationTable_ResourceEntry>, I>>(base?: I): AllocationTable_ResourceEntry {
    return AllocationTable_ResourceEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AllocationTable_ResourceEntry>, I>>(
    object: I,
  ): AllocationTable_ResourceEntry {
    const message = createBaseAllocationTable_ResourceEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ResourceAllocationList.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAllocationTable_CableEntry(): AllocationTable_CableEntry {
  return { key: "", value: undefined };
}

export const AllocationTable_CableEntry = {
  encode(message: AllocationTable_CableEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CableAllocationList.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AllocationTable_CableEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocationTable_CableEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = CableAllocationList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AllocationTable_CableEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? CableAllocationList.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AllocationTable_CableEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? CableAllocationList.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<AllocationTable_CableEntry>, I>>(base?: I): AllocationTable_CableEntry {
    return AllocationTable_CableEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AllocationTable_CableEntry>, I>>(object: I): AllocationTable_CableEntry {
    const message = createBaseAllocationTable_CableEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CableAllocationList.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAllocationRequest(): AllocationRequest {
  return { table: undefined };
}

export const AllocationRequest = {
  encode(message: AllocationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.table !== undefined) {
      AllocationTable.encode(message.table, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AllocationRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.table = AllocationTable.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AllocationRequest {
    return { table: isSet(object.table) ? AllocationTable.fromJSON(object.table) : undefined };
  },

  toJSON(message: AllocationRequest): unknown {
    const obj: any = {};
    message.table !== undefined && (obj.table = message.table ? AllocationTable.toJSON(message.table) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<AllocationRequest>, I>>(base?: I): AllocationRequest {
    return AllocationRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AllocationRequest>, I>>(object: I): AllocationRequest {
    const message = createBaseAllocationRequest();
    message.table = (object.table !== undefined && object.table !== null)
      ? AllocationTable.fromPartial(object.table)
      : undefined;
    return message;
  },
};

function createBaseAllocationResponse(): AllocationResponse {
  return {};
}

export const AllocationResponse = {
  encode(_: AllocationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AllocationResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): AllocationResponse {
    return {};
  },

  toJSON(_: AllocationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AllocationResponse>, I>>(base?: I): AllocationResponse {
    return AllocationResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AllocationResponse>, I>>(_: I): AllocationResponse {
    const message = createBaseAllocationResponse();
    return message;
  },
};

function createBaseFreeRequest(): FreeRequest {
  return { rzid: "" };
}

export const FreeRequest = {
  encode(message: FreeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rzid !== "") {
      writer.uint32(10).string(message.rzid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FreeRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rzid = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FreeRequest {
    return { rzid: isSet(object.rzid) ? String(object.rzid) : "" };
  },

  toJSON(message: FreeRequest): unknown {
    const obj: any = {};
    message.rzid !== undefined && (obj.rzid = message.rzid);
    return obj;
  },

  create<I extends Exact<DeepPartial<FreeRequest>, I>>(base?: I): FreeRequest {
    return FreeRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<FreeRequest>, I>>(object: I): FreeRequest {
    const message = createBaseFreeRequest();
    message.rzid = object.rzid ?? "";
    return message;
  },
};

function createBaseFreeResponse(): FreeResponse {
  return {};
}

export const FreeResponse = {
  encode(_: FreeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FreeResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFreeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): FreeResponse {
    return {};
  },

  toJSON(_: FreeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<FreeResponse>, I>>(base?: I): FreeResponse {
    return FreeResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<FreeResponse>, I>>(_: I): FreeResponse {
    const message = createBaseFreeResponse();
    return message;
  },
};

function createBaseFetchAllocationTableRequest(): FetchAllocationTableRequest {
  return {};
}

export const FetchAllocationTableRequest = {
  encode(_: FetchAllocationTableRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FetchAllocationTableRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchAllocationTableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): FetchAllocationTableRequest {
    return {};
  },

  toJSON(_: FetchAllocationTableRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<FetchAllocationTableRequest>, I>>(base?: I): FetchAllocationTableRequest {
    return FetchAllocationTableRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<FetchAllocationTableRequest>, I>>(_: I): FetchAllocationTableRequest {
    const message = createBaseFetchAllocationTableRequest();
    return message;
  },
};

function createBaseFetchAllocationTableResponse(): FetchAllocationTableResponse {
  return { table: undefined };
}

export const FetchAllocationTableResponse = {
  encode(message: FetchAllocationTableResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.table !== undefined) {
      AllocationTable.encode(message.table, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FetchAllocationTableResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchAllocationTableResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.table = AllocationTable.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FetchAllocationTableResponse {
    return { table: isSet(object.table) ? AllocationTable.fromJSON(object.table) : undefined };
  },

  toJSON(message: FetchAllocationTableResponse): unknown {
    const obj: any = {};
    message.table !== undefined && (obj.table = message.table ? AllocationTable.toJSON(message.table) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<FetchAllocationTableResponse>, I>>(base?: I): FetchAllocationTableResponse {
    return FetchAllocationTableResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<FetchAllocationTableResponse>, I>>(object: I): FetchAllocationTableResponse {
    const message = createBaseFetchAllocationTableResponse();
    message.table = (object.table !== undefined && object.table !== null)
      ? AllocationTable.fromPartial(object.table)
      : undefined;
    return message;
  },
};

function createBasePool(): Pool {
  return { name: "", description: "", projects: [], facilities: {}, creator: "", ver: 0, organizations: [] };
}

export const Pool = {
  encode(message: Pool, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.projects) {
      writer.uint32(26).string(v!);
    }
    Object.entries(message.facilities).forEach(([key, value]) => {
      Pool_FacilitiesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    if (message.creator !== "") {
      writer.uint32(42).string(message.creator);
    }
    if (message.ver !== 0) {
      writer.uint32(48).int64(message.ver);
    }
    for (const v of message.organizations) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Pool {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.projects.push(reader.string());
          break;
        case 4:
          const entry4 = Pool_FacilitiesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.facilities[entry4.key] = entry4.value;
          }
          break;
        case 5:
          message.creator = reader.string();
          break;
        case 6:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        case 7:
          message.organizations.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Pool {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? String(object.description) : "",
      projects: Array.isArray(object?.projects) ? object.projects.map((e: any) => String(e)) : [],
      facilities: isObject(object.facilities)
        ? Object.entries(object.facilities).reduce<{ [key: string]: Pool_Resources }>((acc, [key, value]) => {
          acc[key] = Pool_Resources.fromJSON(value);
          return acc;
        }, {})
        : {},
      creator: isSet(object.creator) ? String(object.creator) : "",
      ver: isSet(object.ver) ? Number(object.ver) : 0,
      organizations: Array.isArray(object?.organizations) ? object.organizations.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: Pool): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.description !== undefined && (obj.description = message.description);
    if (message.projects) {
      obj.projects = message.projects.map((e) => e);
    } else {
      obj.projects = [];
    }
    obj.facilities = {};
    if (message.facilities) {
      Object.entries(message.facilities).forEach(([k, v]) => {
        obj.facilities[k] = Pool_Resources.toJSON(v);
      });
    }
    message.creator !== undefined && (obj.creator = message.creator);
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    if (message.organizations) {
      obj.organizations = message.organizations.map((e) => e);
    } else {
      obj.organizations = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pool>, I>>(base?: I): Pool {
    return Pool.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Pool>, I>>(object: I): Pool {
    const message = createBasePool();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.projects = object.projects?.map((e) => e) || [];
    message.facilities = Object.entries(object.facilities ?? {}).reduce<{ [key: string]: Pool_Resources }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Pool_Resources.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.creator = object.creator ?? "";
    message.ver = object.ver ?? 0;
    message.organizations = object.organizations?.map((e) => e) || [];
    return message;
  },
};

function createBasePool_Resources(): Pool_Resources {
  return { resources: [] };
}

export const Pool_Resources = {
  encode(message: Pool_Resources, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.resources) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Pool_Resources {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePool_Resources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.resources.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Pool_Resources {
    return { resources: Array.isArray(object?.resources) ? object.resources.map((e: any) => String(e)) : [] };
  },

  toJSON(message: Pool_Resources): unknown {
    const obj: any = {};
    if (message.resources) {
      obj.resources = message.resources.map((e) => e);
    } else {
      obj.resources = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pool_Resources>, I>>(base?: I): Pool_Resources {
    return Pool_Resources.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Pool_Resources>, I>>(object: I): Pool_Resources {
    const message = createBasePool_Resources();
    message.resources = object.resources?.map((e) => e) || [];
    return message;
  },
};

function createBasePool_FacilitiesEntry(): Pool_FacilitiesEntry {
  return { key: "", value: undefined };
}

export const Pool_FacilitiesEntry = {
  encode(message: Pool_FacilitiesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Pool_Resources.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Pool_FacilitiesEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePool_FacilitiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Pool_Resources.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Pool_FacilitiesEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Pool_Resources.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Pool_FacilitiesEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? Pool_Resources.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Pool_FacilitiesEntry>, I>>(base?: I): Pool_FacilitiesEntry {
    return Pool_FacilitiesEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Pool_FacilitiesEntry>, I>>(object: I): Pool_FacilitiesEntry {
    const message = createBasePool_FacilitiesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Pool_Resources.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetPoolsRequest(): GetPoolsRequest {
  return {};
}

export const GetPoolsRequest = {
  encode(_: GetPoolsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPoolsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPoolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetPoolsRequest {
    return {};
  },

  toJSON(_: GetPoolsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPoolsRequest>, I>>(base?: I): GetPoolsRequest {
    return GetPoolsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetPoolsRequest>, I>>(_: I): GetPoolsRequest {
    const message = createBaseGetPoolsRequest();
    return message;
  },
};

function createBaseGetPoolsResponse(): GetPoolsResponse {
  return { pools: [] };
}

export const GetPoolsResponse = {
  encode(message: GetPoolsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.pools) {
      Pool.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPoolsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPoolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pools.push(Pool.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetPoolsResponse {
    return { pools: Array.isArray(object?.pools) ? object.pools.map((e: any) => Pool.fromJSON(e)) : [] };
  },

  toJSON(message: GetPoolsResponse): unknown {
    const obj: any = {};
    if (message.pools) {
      obj.pools = message.pools.map((e) => e ? Pool.toJSON(e) : undefined);
    } else {
      obj.pools = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPoolsResponse>, I>>(base?: I): GetPoolsResponse {
    return GetPoolsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetPoolsResponse>, I>>(object: I): GetPoolsResponse {
    const message = createBaseGetPoolsResponse();
    message.pools = object.pools?.map((e) => Pool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPoolRequest(): GetPoolRequest {
  return { name: "" };
}

export const GetPoolRequest = {
  encode(message: GetPoolRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPoolRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetPoolRequest {
    return { name: isSet(object.name) ? String(object.name) : "" };
  },

  toJSON(message: GetPoolRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPoolRequest>, I>>(base?: I): GetPoolRequest {
    return GetPoolRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetPoolRequest>, I>>(object: I): GetPoolRequest {
    const message = createBaseGetPoolRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetPoolResponse(): GetPoolResponse {
  return { pool: undefined };
}

export const GetPoolResponse = {
  encode(message: GetPoolResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pool !== undefined) {
      Pool.encode(message.pool, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPoolResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pool = Pool.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetPoolResponse {
    return { pool: isSet(object.pool) ? Pool.fromJSON(object.pool) : undefined };
  },

  toJSON(message: GetPoolResponse): unknown {
    const obj: any = {};
    message.pool !== undefined && (obj.pool = message.pool ? Pool.toJSON(message.pool) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPoolResponse>, I>>(base?: I): GetPoolResponse {
    return GetPoolResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetPoolResponse>, I>>(object: I): GetPoolResponse {
    const message = createBaseGetPoolResponse();
    message.pool = (object.pool !== undefined && object.pool !== null) ? Pool.fromPartial(object.pool) : undefined;
    return message;
  },
};

function createBaseCreatePoolRequest(): CreatePoolRequest {
  return { name: "", description: "", projects: [], facilities: [], organizations: [] };
}

export const CreatePoolRequest = {
  encode(message: CreatePoolRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.projects) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.facilities) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.organizations) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePoolRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.projects.push(reader.string());
          break;
        case 4:
          message.facilities.push(reader.string());
          break;
        case 5:
          message.organizations.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CreatePoolRequest {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      description: isSet(object.description) ? String(object.description) : "",
      projects: Array.isArray(object?.projects) ? object.projects.map((e: any) => String(e)) : [],
      facilities: Array.isArray(object?.facilities) ? object.facilities.map((e: any) => String(e)) : [],
      organizations: Array.isArray(object?.organizations) ? object.organizations.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: CreatePoolRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.description !== undefined && (obj.description = message.description);
    if (message.projects) {
      obj.projects = message.projects.map((e) => e);
    } else {
      obj.projects = [];
    }
    if (message.facilities) {
      obj.facilities = message.facilities.map((e) => e);
    } else {
      obj.facilities = [];
    }
    if (message.organizations) {
      obj.organizations = message.organizations.map((e) => e);
    } else {
      obj.organizations = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePoolRequest>, I>>(base?: I): CreatePoolRequest {
    return CreatePoolRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CreatePoolRequest>, I>>(object: I): CreatePoolRequest {
    const message = createBaseCreatePoolRequest();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.projects = object.projects?.map((e) => e) || [];
    message.facilities = object.facilities?.map((e) => e) || [];
    message.organizations = object.organizations?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreatePoolResponse(): CreatePoolResponse {
  return {};
}

export const CreatePoolResponse = {
  encode(_: CreatePoolResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePoolResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): CreatePoolResponse {
    return {};
  },

  toJSON(_: CreatePoolResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePoolResponse>, I>>(base?: I): CreatePoolResponse {
    return CreatePoolResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CreatePoolResponse>, I>>(_: I): CreatePoolResponse {
    const message = createBaseCreatePoolResponse();
    return message;
  },
};

function createBaseDeletePoolRequest(): DeletePoolRequest {
  return { name: "" };
}

export const DeletePoolRequest = {
  encode(message: DeletePoolRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeletePoolRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeletePoolRequest {
    return { name: isSet(object.name) ? String(object.name) : "" };
  },

  toJSON(message: DeletePoolRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  create<I extends Exact<DeepPartial<DeletePoolRequest>, I>>(base?: I): DeletePoolRequest {
    return DeletePoolRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeletePoolRequest>, I>>(object: I): DeletePoolRequest {
    const message = createBaseDeletePoolRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeletePoolResponse(): DeletePoolResponse {
  return {};
}

export const DeletePoolResponse = {
  encode(_: DeletePoolResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeletePoolResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeletePoolResponse {
    return {};
  },

  toJSON(_: DeletePoolResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeletePoolResponse>, I>>(base?: I): DeletePoolResponse {
    return DeletePoolResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeletePoolResponse>, I>>(_: I): DeletePoolResponse {
    const message = createBaseDeletePoolResponse();
    return message;
  },
};

function createBaseAddProjectToPoolRequest(): AddProjectToPoolRequest {
  return { name: "", project: "" };
}

export const AddProjectToPoolRequest = {
  encode(message: AddProjectToPoolRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddProjectToPoolRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddProjectToPoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.project = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AddProjectToPoolRequest {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      project: isSet(object.project) ? String(object.project) : "",
    };
  },

  toJSON(message: AddProjectToPoolRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.project !== undefined && (obj.project = message.project);
    return obj;
  },

  create<I extends Exact<DeepPartial<AddProjectToPoolRequest>, I>>(base?: I): AddProjectToPoolRequest {
    return AddProjectToPoolRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddProjectToPoolRequest>, I>>(object: I): AddProjectToPoolRequest {
    const message = createBaseAddProjectToPoolRequest();
    message.name = object.name ?? "";
    message.project = object.project ?? "";
    return message;
  },
};

function createBaseAddProjectToPoolResponse(): AddProjectToPoolResponse {
  return {};
}

export const AddProjectToPoolResponse = {
  encode(_: AddProjectToPoolResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddProjectToPoolResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddProjectToPoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): AddProjectToPoolResponse {
    return {};
  },

  toJSON(_: AddProjectToPoolResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AddProjectToPoolResponse>, I>>(base?: I): AddProjectToPoolResponse {
    return AddProjectToPoolResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddProjectToPoolResponse>, I>>(_: I): AddProjectToPoolResponse {
    const message = createBaseAddProjectToPoolResponse();
    return message;
  },
};

function createBaseRemoveProjectFromPoolRequest(): RemoveProjectFromPoolRequest {
  return { name: "", project: "" };
}

export const RemoveProjectFromPoolRequest = {
  encode(message: RemoveProjectFromPoolRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveProjectFromPoolRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveProjectFromPoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.project = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RemoveProjectFromPoolRequest {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      project: isSet(object.project) ? String(object.project) : "",
    };
  },

  toJSON(message: RemoveProjectFromPoolRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.project !== undefined && (obj.project = message.project);
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveProjectFromPoolRequest>, I>>(base?: I): RemoveProjectFromPoolRequest {
    return RemoveProjectFromPoolRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RemoveProjectFromPoolRequest>, I>>(object: I): RemoveProjectFromPoolRequest {
    const message = createBaseRemoveProjectFromPoolRequest();
    message.name = object.name ?? "";
    message.project = object.project ?? "";
    return message;
  },
};

function createBaseRemoveProjectFromPoolResponse(): RemoveProjectFromPoolResponse {
  return {};
}

export const RemoveProjectFromPoolResponse = {
  encode(_: RemoveProjectFromPoolResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveProjectFromPoolResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveProjectFromPoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): RemoveProjectFromPoolResponse {
    return {};
  },

  toJSON(_: RemoveProjectFromPoolResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveProjectFromPoolResponse>, I>>(base?: I): RemoveProjectFromPoolResponse {
    return RemoveProjectFromPoolResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RemoveProjectFromPoolResponse>, I>>(_: I): RemoveProjectFromPoolResponse {
    const message = createBaseRemoveProjectFromPoolResponse();
    return message;
  },
};

function createBaseAddOrganizationToPoolRequest(): AddOrganizationToPoolRequest {
  return { name: "", organization: "" };
}

export const AddOrganizationToPoolRequest = {
  encode(message: AddOrganizationToPoolRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.organization !== "") {
      writer.uint32(18).string(message.organization);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddOrganizationToPoolRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddOrganizationToPoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.organization = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AddOrganizationToPoolRequest {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      organization: isSet(object.organization) ? String(object.organization) : "",
    };
  },

  toJSON(message: AddOrganizationToPoolRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.organization !== undefined && (obj.organization = message.organization);
    return obj;
  },

  create<I extends Exact<DeepPartial<AddOrganizationToPoolRequest>, I>>(base?: I): AddOrganizationToPoolRequest {
    return AddOrganizationToPoolRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddOrganizationToPoolRequest>, I>>(object: I): AddOrganizationToPoolRequest {
    const message = createBaseAddOrganizationToPoolRequest();
    message.name = object.name ?? "";
    message.organization = object.organization ?? "";
    return message;
  },
};

function createBaseAddOrganizationToPoolResponse(): AddOrganizationToPoolResponse {
  return {};
}

export const AddOrganizationToPoolResponse = {
  encode(_: AddOrganizationToPoolResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddOrganizationToPoolResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddOrganizationToPoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): AddOrganizationToPoolResponse {
    return {};
  },

  toJSON(_: AddOrganizationToPoolResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AddOrganizationToPoolResponse>, I>>(base?: I): AddOrganizationToPoolResponse {
    return AddOrganizationToPoolResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddOrganizationToPoolResponse>, I>>(_: I): AddOrganizationToPoolResponse {
    const message = createBaseAddOrganizationToPoolResponse();
    return message;
  },
};

function createBaseRemoveOrganizationFromPoolRequest(): RemoveOrganizationFromPoolRequest {
  return { name: "", organization: "" };
}

export const RemoveOrganizationFromPoolRequest = {
  encode(message: RemoveOrganizationFromPoolRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.organization !== "") {
      writer.uint32(18).string(message.organization);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveOrganizationFromPoolRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveOrganizationFromPoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.organization = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RemoveOrganizationFromPoolRequest {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      organization: isSet(object.organization) ? String(object.organization) : "",
    };
  },

  toJSON(message: RemoveOrganizationFromPoolRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.organization !== undefined && (obj.organization = message.organization);
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveOrganizationFromPoolRequest>, I>>(
    base?: I,
  ): RemoveOrganizationFromPoolRequest {
    return RemoveOrganizationFromPoolRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RemoveOrganizationFromPoolRequest>, I>>(
    object: I,
  ): RemoveOrganizationFromPoolRequest {
    const message = createBaseRemoveOrganizationFromPoolRequest();
    message.name = object.name ?? "";
    message.organization = object.organization ?? "";
    return message;
  },
};

function createBaseRemoveOrganizationFromPoolResponse(): RemoveOrganizationFromPoolResponse {
  return {};
}

export const RemoveOrganizationFromPoolResponse = {
  encode(_: RemoveOrganizationFromPoolResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveOrganizationFromPoolResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveOrganizationFromPoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): RemoveOrganizationFromPoolResponse {
    return {};
  },

  toJSON(_: RemoveOrganizationFromPoolResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveOrganizationFromPoolResponse>, I>>(
    base?: I,
  ): RemoveOrganizationFromPoolResponse {
    return RemoveOrganizationFromPoolResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RemoveOrganizationFromPoolResponse>, I>>(
    _: I,
  ): RemoveOrganizationFromPoolResponse {
    const message = createBaseRemoveOrganizationFromPoolResponse();
    return message;
  },
};

function createBaseAddFacilityToPoolRequest(): AddFacilityToPoolRequest {
  return { name: "", facility: "", resources: [] };
}

export const AddFacilityToPoolRequest = {
  encode(message: AddFacilityToPoolRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.facility !== "") {
      writer.uint32(18).string(message.facility);
    }
    for (const v of message.resources) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddFacilityToPoolRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddFacilityToPoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.facility = reader.string();
          break;
        case 3:
          message.resources.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AddFacilityToPoolRequest {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      facility: isSet(object.facility) ? String(object.facility) : "",
      resources: Array.isArray(object?.resources) ? object.resources.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: AddFacilityToPoolRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.facility !== undefined && (obj.facility = message.facility);
    if (message.resources) {
      obj.resources = message.resources.map((e) => e);
    } else {
      obj.resources = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddFacilityToPoolRequest>, I>>(base?: I): AddFacilityToPoolRequest {
    return AddFacilityToPoolRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddFacilityToPoolRequest>, I>>(object: I): AddFacilityToPoolRequest {
    const message = createBaseAddFacilityToPoolRequest();
    message.name = object.name ?? "";
    message.facility = object.facility ?? "";
    message.resources = object.resources?.map((e) => e) || [];
    return message;
  },
};

function createBaseAddFacilityToPoolResponse(): AddFacilityToPoolResponse {
  return {};
}

export const AddFacilityToPoolResponse = {
  encode(_: AddFacilityToPoolResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddFacilityToPoolResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddFacilityToPoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): AddFacilityToPoolResponse {
    return {};
  },

  toJSON(_: AddFacilityToPoolResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AddFacilityToPoolResponse>, I>>(base?: I): AddFacilityToPoolResponse {
    return AddFacilityToPoolResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddFacilityToPoolResponse>, I>>(_: I): AddFacilityToPoolResponse {
    const message = createBaseAddFacilityToPoolResponse();
    return message;
  },
};

function createBaseRemoveFacilityFromPoolRequest(): RemoveFacilityFromPoolRequest {
  return { name: "", facility: "" };
}

export const RemoveFacilityFromPoolRequest = {
  encode(message: RemoveFacilityFromPoolRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.facility !== "") {
      writer.uint32(18).string(message.facility);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveFacilityFromPoolRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveFacilityFromPoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.facility = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RemoveFacilityFromPoolRequest {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      facility: isSet(object.facility) ? String(object.facility) : "",
    };
  },

  toJSON(message: RemoveFacilityFromPoolRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.facility !== undefined && (obj.facility = message.facility);
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveFacilityFromPoolRequest>, I>>(base?: I): RemoveFacilityFromPoolRequest {
    return RemoveFacilityFromPoolRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RemoveFacilityFromPoolRequest>, I>>(
    object: I,
  ): RemoveFacilityFromPoolRequest {
    const message = createBaseRemoveFacilityFromPoolRequest();
    message.name = object.name ?? "";
    message.facility = object.facility ?? "";
    return message;
  },
};

function createBaseRemoveFacilityFromPoolResponse(): RemoveFacilityFromPoolResponse {
  return {};
}

export const RemoveFacilityFromPoolResponse = {
  encode(_: RemoveFacilityFromPoolResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveFacilityFromPoolResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveFacilityFromPoolResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): RemoveFacilityFromPoolResponse {
    return {};
  },

  toJSON(_: RemoveFacilityFromPoolResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveFacilityFromPoolResponse>, I>>(base?: I): RemoveFacilityFromPoolResponse {
    return RemoveFacilityFromPoolResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RemoveFacilityFromPoolResponse>, I>>(_: I): RemoveFacilityFromPoolResponse {
    const message = createBaseRemoveFacilityFromPoolResponse();
    return message;
  },
};

function createBaseUpdatePoolResourcesRequest(): UpdatePoolResourcesRequest {
  return { pool: "", facility: "", resources: [], patchstrategy: undefined };
}

export const UpdatePoolResourcesRequest = {
  encode(message: UpdatePoolResourcesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pool !== "") {
      writer.uint32(10).string(message.pool);
    }
    if (message.facility !== "") {
      writer.uint32(18).string(message.facility);
    }
    for (const v of message.resources) {
      writer.uint32(26).string(v!);
    }
    if (message.patchstrategy !== undefined) {
      PatchStrategy.encode(message.patchstrategy, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdatePoolResourcesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePoolResourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pool = reader.string();
          break;
        case 2:
          message.facility = reader.string();
          break;
        case 3:
          message.resources.push(reader.string());
          break;
        case 4:
          message.patchstrategy = PatchStrategy.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdatePoolResourcesRequest {
    return {
      pool: isSet(object.pool) ? String(object.pool) : "",
      facility: isSet(object.facility) ? String(object.facility) : "",
      resources: Array.isArray(object?.resources) ? object.resources.map((e: any) => String(e)) : [],
      patchstrategy: isSet(object.patchstrategy) ? PatchStrategy.fromJSON(object.patchstrategy) : undefined,
    };
  },

  toJSON(message: UpdatePoolResourcesRequest): unknown {
    const obj: any = {};
    message.pool !== undefined && (obj.pool = message.pool);
    message.facility !== undefined && (obj.facility = message.facility);
    if (message.resources) {
      obj.resources = message.resources.map((e) => e);
    } else {
      obj.resources = [];
    }
    message.patchstrategy !== undefined &&
      (obj.patchstrategy = message.patchstrategy ? PatchStrategy.toJSON(message.patchstrategy) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePoolResourcesRequest>, I>>(base?: I): UpdatePoolResourcesRequest {
    return UpdatePoolResourcesRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdatePoolResourcesRequest>, I>>(object: I): UpdatePoolResourcesRequest {
    const message = createBaseUpdatePoolResourcesRequest();
    message.pool = object.pool ?? "";
    message.facility = object.facility ?? "";
    message.resources = object.resources?.map((e) => e) || [];
    message.patchstrategy = (object.patchstrategy !== undefined && object.patchstrategy !== null)
      ? PatchStrategy.fromPartial(object.patchstrategy)
      : undefined;
    return message;
  },
};

function createBaseUpdatePoolResourcesResponse(): UpdatePoolResourcesResponse {
  return { pool: "", facility: "", resources: [] };
}

export const UpdatePoolResourcesResponse = {
  encode(message: UpdatePoolResourcesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pool !== "") {
      writer.uint32(10).string(message.pool);
    }
    if (message.facility !== "") {
      writer.uint32(18).string(message.facility);
    }
    for (const v of message.resources) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdatePoolResourcesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePoolResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pool = reader.string();
          break;
        case 2:
          message.facility = reader.string();
          break;
        case 3:
          message.resources.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdatePoolResourcesResponse {
    return {
      pool: isSet(object.pool) ? String(object.pool) : "",
      facility: isSet(object.facility) ? String(object.facility) : "",
      resources: Array.isArray(object?.resources) ? object.resources.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: UpdatePoolResourcesResponse): unknown {
    const obj: any = {};
    message.pool !== undefined && (obj.pool = message.pool);
    message.facility !== undefined && (obj.facility = message.facility);
    if (message.resources) {
      obj.resources = message.resources.map((e) => e);
    } else {
      obj.resources = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePoolResourcesResponse>, I>>(base?: I): UpdatePoolResourcesResponse {
    return UpdatePoolResourcesResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdatePoolResourcesResponse>, I>>(object: I): UpdatePoolResourcesResponse {
    const message = createBaseUpdatePoolResourcesResponse();
    message.pool = object.pool ?? "";
    message.facility = object.facility ?? "";
    message.resources = object.resources?.map((e) => e) || [];
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
