/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Facility as Facility1 } from "../../mergetb/xir/v0.3/core";
import { PatchStrategy } from "./patch_types";
import {
  AccessMode,
  accessModeFromJSON,
  accessModeToJSON,
  AccessModeUpdate,
  DescriptionUpdate,
  Member,
  MembershipUpdate,
} from "./workspace_types";

export const protobufPackage = "portal.v1";

export interface Facility {
  name: string;
  address: string;
  description: string;
  accessMode: AccessMode;
  members: { [key: string]: Member };
  certificate: string;
  cacertificate: string;
  ver: number;
}

export interface Facility_MembersEntry {
  key: string;
  value: Member | undefined;
}

export interface BlockPool {
  blocks: string[];
}

export interface RegisterFacilityRequest {
  facility: Facility | undefined;
  model: Facility1 | undefined;
}

export interface RegisterFacilityResponse {
  code: number;
  message: string;
}

export interface GetFacilitiesRequest {
}

export interface GetFacilitiesResponse {
  facilities: Facility[];
}

export interface GetFacilityRequest {
  name: string;
  withModel: boolean;
}

export interface GetFacilityResponse {
  facility: Facility | undefined;
  model: Facility1 | undefined;
}

export interface UpdateFacilityRequest {
  /** Name of the facility to update */
  name: string;
  /** Optional facility address update. Empty string indicates no update. */
  address: string;
  /** Optional description update. */
  description:
    | DescriptionUpdate
    | undefined;
  /** Optional access mode update. */
  accessMode:
    | AccessModeUpdate
    | undefined;
  /** Optional experiment membership update. */
  members:
    | MembershipUpdate
    | undefined;
  /** Optional cert update. Empty string indicates no update. */
  certificate: string;
  cacertificate: string;
  /** Optional model update */
  model:
    | Facility1
    | undefined;
  /** If a model is given, how to merge the model into the existing one. */
  modelPatchStrategy: PatchStrategy | undefined;
}

export interface UpdateFacilityResponse {
}

export interface DeleteFacilityRequest {
  name: string;
}

export interface DeleteFacilityResponse {
}

export interface DeactivateResourcesRequest {
  facility: string;
  resources: string[];
}

export interface DeactivateResourcesResponse {
}

export interface ActivateResourcesRequest {
  facility: string;
  resources: string[];
}

export interface ActivateResourcesResponse {
}

export interface ListBlockPoolsRequest {
}

export interface ListBlockPoolsResponse {
}

export interface InitHarborRequest {
  facility: string;
  ver: number;
  rid: string;
  eid: string;
  pid: string;
}

export interface InitHarborResponse {
}

export interface DeinitHarborRequest {
  facility: string;
  ver: number;
  rid: string;
  eid: string;
  pid: string;
}

export interface DeinitHarborResponse {
}

function createBaseFacility(): Facility {
  return {
    name: "",
    address: "",
    description: "",
    accessMode: 0,
    members: {},
    certificate: "",
    cacertificate: "",
    ver: 0,
  };
}

export const Facility = {
  encode(message: Facility, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.accessMode !== 0) {
      writer.uint32(32).int32(message.accessMode);
    }
    Object.entries(message.members).forEach(([key, value]) => {
      Facility_MembersEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    if (message.certificate !== "") {
      writer.uint32(50).string(message.certificate);
    }
    if (message.cacertificate !== "") {
      writer.uint32(58).string(message.cacertificate);
    }
    if (message.ver !== 0) {
      writer.uint32(64).int64(message.ver);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Facility {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.address = reader.string();
          break;
        case 3:
          message.description = reader.string();
          break;
        case 4:
          message.accessMode = reader.int32() as any;
          break;
        case 5:
          const entry5 = Facility_MembersEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.members[entry5.key] = entry5.value;
          }
          break;
        case 6:
          message.certificate = reader.string();
          break;
        case 7:
          message.cacertificate = reader.string();
          break;
        case 8:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Facility {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      address: isSet(object.address) ? String(object.address) : "",
      description: isSet(object.description) ? String(object.description) : "",
      accessMode: isSet(object.accessMode) ? accessModeFromJSON(object.accessMode) : 0,
      members: isObject(object.members)
        ? Object.entries(object.members).reduce<{ [key: string]: Member }>((acc, [key, value]) => {
          acc[key] = Member.fromJSON(value);
          return acc;
        }, {})
        : {},
      certificate: isSet(object.certificate) ? String(object.certificate) : "",
      cacertificate: isSet(object.cacertificate) ? String(object.cacertificate) : "",
      ver: isSet(object.ver) ? Number(object.ver) : 0,
    };
  },

  toJSON(message: Facility): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.address !== undefined && (obj.address = message.address);
    message.description !== undefined && (obj.description = message.description);
    message.accessMode !== undefined && (obj.accessMode = accessModeToJSON(message.accessMode));
    obj.members = {};
    if (message.members) {
      Object.entries(message.members).forEach(([k, v]) => {
        obj.members[k] = Member.toJSON(v);
      });
    }
    message.certificate !== undefined && (obj.certificate = message.certificate);
    message.cacertificate !== undefined && (obj.cacertificate = message.cacertificate);
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    return obj;
  },

  create<I extends Exact<DeepPartial<Facility>, I>>(base?: I): Facility {
    return Facility.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Facility>, I>>(object: I): Facility {
    const message = createBaseFacility();
    message.name = object.name ?? "";
    message.address = object.address ?? "";
    message.description = object.description ?? "";
    message.accessMode = object.accessMode ?? 0;
    message.members = Object.entries(object.members ?? {}).reduce<{ [key: string]: Member }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Member.fromPartial(value);
      }
      return acc;
    }, {});
    message.certificate = object.certificate ?? "";
    message.cacertificate = object.cacertificate ?? "";
    message.ver = object.ver ?? 0;
    return message;
  },
};

function createBaseFacility_MembersEntry(): Facility_MembersEntry {
  return { key: "", value: undefined };
}

export const Facility_MembersEntry = {
  encode(message: Facility_MembersEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Member.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Facility_MembersEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacility_MembersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Member.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Facility_MembersEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Member.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Facility_MembersEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? Member.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Facility_MembersEntry>, I>>(base?: I): Facility_MembersEntry {
    return Facility_MembersEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Facility_MembersEntry>, I>>(object: I): Facility_MembersEntry {
    const message = createBaseFacility_MembersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Member.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseBlockPool(): BlockPool {
  return { blocks: [] };
}

export const BlockPool = {
  encode(message: BlockPool, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.blocks) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockPool {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockPool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.blocks.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BlockPool {
    return { blocks: Array.isArray(object?.blocks) ? object.blocks.map((e: any) => String(e)) : [] };
  },

  toJSON(message: BlockPool): unknown {
    const obj: any = {};
    if (message.blocks) {
      obj.blocks = message.blocks.map((e) => e);
    } else {
      obj.blocks = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockPool>, I>>(base?: I): BlockPool {
    return BlockPool.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<BlockPool>, I>>(object: I): BlockPool {
    const message = createBaseBlockPool();
    message.blocks = object.blocks?.map((e) => e) || [];
    return message;
  },
};

function createBaseRegisterFacilityRequest(): RegisterFacilityRequest {
  return { facility: undefined, model: undefined };
}

export const RegisterFacilityRequest = {
  encode(message: RegisterFacilityRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.facility !== undefined) {
      Facility.encode(message.facility, writer.uint32(10).fork()).ldelim();
    }
    if (message.model !== undefined) {
      Facility1.encode(message.model, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisterFacilityRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterFacilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.facility = Facility.decode(reader, reader.uint32());
          break;
        case 2:
          message.model = Facility1.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RegisterFacilityRequest {
    return {
      facility: isSet(object.facility) ? Facility.fromJSON(object.facility) : undefined,
      model: isSet(object.model) ? Facility1.fromJSON(object.model) : undefined,
    };
  },

  toJSON(message: RegisterFacilityRequest): unknown {
    const obj: any = {};
    message.facility !== undefined && (obj.facility = message.facility ? Facility.toJSON(message.facility) : undefined);
    message.model !== undefined && (obj.model = message.model ? Facility1.toJSON(message.model) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterFacilityRequest>, I>>(base?: I): RegisterFacilityRequest {
    return RegisterFacilityRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RegisterFacilityRequest>, I>>(object: I): RegisterFacilityRequest {
    const message = createBaseRegisterFacilityRequest();
    message.facility = (object.facility !== undefined && object.facility !== null)
      ? Facility.fromPartial(object.facility)
      : undefined;
    message.model = (object.model !== undefined && object.model !== null)
      ? Facility1.fromPartial(object.model)
      : undefined;
    return message;
  },
};

function createBaseRegisterFacilityResponse(): RegisterFacilityResponse {
  return { code: 0, message: "" };
}

export const RegisterFacilityResponse = {
  encode(message: RegisterFacilityResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisterFacilityResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterFacilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.code = reader.int32();
          break;
        case 2:
          message.message = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RegisterFacilityResponse {
    return {
      code: isSet(object.code) ? Number(object.code) : 0,
      message: isSet(object.message) ? String(object.message) : "",
    };
  },

  toJSON(message: RegisterFacilityResponse): unknown {
    const obj: any = {};
    message.code !== undefined && (obj.code = Math.round(message.code));
    message.message !== undefined && (obj.message = message.message);
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterFacilityResponse>, I>>(base?: I): RegisterFacilityResponse {
    return RegisterFacilityResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RegisterFacilityResponse>, I>>(object: I): RegisterFacilityResponse {
    const message = createBaseRegisterFacilityResponse();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetFacilitiesRequest(): GetFacilitiesRequest {
  return {};
}

export const GetFacilitiesRequest = {
  encode(_: GetFacilitiesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetFacilitiesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFacilitiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetFacilitiesRequest {
    return {};
  },

  toJSON(_: GetFacilitiesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFacilitiesRequest>, I>>(base?: I): GetFacilitiesRequest {
    return GetFacilitiesRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetFacilitiesRequest>, I>>(_: I): GetFacilitiesRequest {
    const message = createBaseGetFacilitiesRequest();
    return message;
  },
};

function createBaseGetFacilitiesResponse(): GetFacilitiesResponse {
  return { facilities: [] };
}

export const GetFacilitiesResponse = {
  encode(message: GetFacilitiesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.facilities) {
      Facility.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetFacilitiesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFacilitiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.facilities.push(Facility.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetFacilitiesResponse {
    return {
      facilities: Array.isArray(object?.facilities) ? object.facilities.map((e: any) => Facility.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetFacilitiesResponse): unknown {
    const obj: any = {};
    if (message.facilities) {
      obj.facilities = message.facilities.map((e) => e ? Facility.toJSON(e) : undefined);
    } else {
      obj.facilities = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFacilitiesResponse>, I>>(base?: I): GetFacilitiesResponse {
    return GetFacilitiesResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetFacilitiesResponse>, I>>(object: I): GetFacilitiesResponse {
    const message = createBaseGetFacilitiesResponse();
    message.facilities = object.facilities?.map((e) => Facility.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetFacilityRequest(): GetFacilityRequest {
  return { name: "", withModel: false };
}

export const GetFacilityRequest = {
  encode(message: GetFacilityRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.withModel === true) {
      writer.uint32(16).bool(message.withModel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetFacilityRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFacilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.withModel = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetFacilityRequest {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      withModel: isSet(object.withModel) ? Boolean(object.withModel) : false,
    };
  },

  toJSON(message: GetFacilityRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.withModel !== undefined && (obj.withModel = message.withModel);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFacilityRequest>, I>>(base?: I): GetFacilityRequest {
    return GetFacilityRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetFacilityRequest>, I>>(object: I): GetFacilityRequest {
    const message = createBaseGetFacilityRequest();
    message.name = object.name ?? "";
    message.withModel = object.withModel ?? false;
    return message;
  },
};

function createBaseGetFacilityResponse(): GetFacilityResponse {
  return { facility: undefined, model: undefined };
}

export const GetFacilityResponse = {
  encode(message: GetFacilityResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.facility !== undefined) {
      Facility.encode(message.facility, writer.uint32(10).fork()).ldelim();
    }
    if (message.model !== undefined) {
      Facility1.encode(message.model, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetFacilityResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFacilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.facility = Facility.decode(reader, reader.uint32());
          break;
        case 2:
          message.model = Facility1.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetFacilityResponse {
    return {
      facility: isSet(object.facility) ? Facility.fromJSON(object.facility) : undefined,
      model: isSet(object.model) ? Facility1.fromJSON(object.model) : undefined,
    };
  },

  toJSON(message: GetFacilityResponse): unknown {
    const obj: any = {};
    message.facility !== undefined && (obj.facility = message.facility ? Facility.toJSON(message.facility) : undefined);
    message.model !== undefined && (obj.model = message.model ? Facility1.toJSON(message.model) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFacilityResponse>, I>>(base?: I): GetFacilityResponse {
    return GetFacilityResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<GetFacilityResponse>, I>>(object: I): GetFacilityResponse {
    const message = createBaseGetFacilityResponse();
    message.facility = (object.facility !== undefined && object.facility !== null)
      ? Facility.fromPartial(object.facility)
      : undefined;
    message.model = (object.model !== undefined && object.model !== null)
      ? Facility1.fromPartial(object.model)
      : undefined;
    return message;
  },
};

function createBaseUpdateFacilityRequest(): UpdateFacilityRequest {
  return {
    name: "",
    address: "",
    description: undefined,
    accessMode: undefined,
    members: undefined,
    certificate: "",
    cacertificate: "",
    model: undefined,
    modelPatchStrategy: undefined,
  };
}

export const UpdateFacilityRequest = {
  encode(message: UpdateFacilityRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.description !== undefined) {
      DescriptionUpdate.encode(message.description, writer.uint32(26).fork()).ldelim();
    }
    if (message.accessMode !== undefined) {
      AccessModeUpdate.encode(message.accessMode, writer.uint32(34).fork()).ldelim();
    }
    if (message.members !== undefined) {
      MembershipUpdate.encode(message.members, writer.uint32(42).fork()).ldelim();
    }
    if (message.certificate !== "") {
      writer.uint32(50).string(message.certificate);
    }
    if (message.cacertificate !== "") {
      writer.uint32(58).string(message.cacertificate);
    }
    if (message.model !== undefined) {
      Facility1.encode(message.model, writer.uint32(66).fork()).ldelim();
    }
    if (message.modelPatchStrategy !== undefined) {
      PatchStrategy.encode(message.modelPatchStrategy, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateFacilityRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFacilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.address = reader.string();
          break;
        case 3:
          message.description = DescriptionUpdate.decode(reader, reader.uint32());
          break;
        case 4:
          message.accessMode = AccessModeUpdate.decode(reader, reader.uint32());
          break;
        case 5:
          message.members = MembershipUpdate.decode(reader, reader.uint32());
          break;
        case 6:
          message.certificate = reader.string();
          break;
        case 7:
          message.cacertificate = reader.string();
          break;
        case 8:
          message.model = Facility1.decode(reader, reader.uint32());
          break;
        case 9:
          message.modelPatchStrategy = PatchStrategy.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateFacilityRequest {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      address: isSet(object.address) ? String(object.address) : "",
      description: isSet(object.description) ? DescriptionUpdate.fromJSON(object.description) : undefined,
      accessMode: isSet(object.accessMode) ? AccessModeUpdate.fromJSON(object.accessMode) : undefined,
      members: isSet(object.members) ? MembershipUpdate.fromJSON(object.members) : undefined,
      certificate: isSet(object.certificate) ? String(object.certificate) : "",
      cacertificate: isSet(object.cacertificate) ? String(object.cacertificate) : "",
      model: isSet(object.model) ? Facility1.fromJSON(object.model) : undefined,
      modelPatchStrategy: isSet(object.modelPatchStrategy)
        ? PatchStrategy.fromJSON(object.modelPatchStrategy)
        : undefined,
    };
  },

  toJSON(message: UpdateFacilityRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.address !== undefined && (obj.address = message.address);
    message.description !== undefined &&
      (obj.description = message.description ? DescriptionUpdate.toJSON(message.description) : undefined);
    message.accessMode !== undefined &&
      (obj.accessMode = message.accessMode ? AccessModeUpdate.toJSON(message.accessMode) : undefined);
    message.members !== undefined &&
      (obj.members = message.members ? MembershipUpdate.toJSON(message.members) : undefined);
    message.certificate !== undefined && (obj.certificate = message.certificate);
    message.cacertificate !== undefined && (obj.cacertificate = message.cacertificate);
    message.model !== undefined && (obj.model = message.model ? Facility1.toJSON(message.model) : undefined);
    message.modelPatchStrategy !== undefined && (obj.modelPatchStrategy = message.modelPatchStrategy
      ? PatchStrategy.toJSON(message.modelPatchStrategy)
      : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateFacilityRequest>, I>>(base?: I): UpdateFacilityRequest {
    return UpdateFacilityRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateFacilityRequest>, I>>(object: I): UpdateFacilityRequest {
    const message = createBaseUpdateFacilityRequest();
    message.name = object.name ?? "";
    message.address = object.address ?? "";
    message.description = (object.description !== undefined && object.description !== null)
      ? DescriptionUpdate.fromPartial(object.description)
      : undefined;
    message.accessMode = (object.accessMode !== undefined && object.accessMode !== null)
      ? AccessModeUpdate.fromPartial(object.accessMode)
      : undefined;
    message.members = (object.members !== undefined && object.members !== null)
      ? MembershipUpdate.fromPartial(object.members)
      : undefined;
    message.certificate = object.certificate ?? "";
    message.cacertificate = object.cacertificate ?? "";
    message.model = (object.model !== undefined && object.model !== null)
      ? Facility1.fromPartial(object.model)
      : undefined;
    message.modelPatchStrategy = (object.modelPatchStrategy !== undefined && object.modelPatchStrategy !== null)
      ? PatchStrategy.fromPartial(object.modelPatchStrategy)
      : undefined;
    return message;
  },
};

function createBaseUpdateFacilityResponse(): UpdateFacilityResponse {
  return {};
}

export const UpdateFacilityResponse = {
  encode(_: UpdateFacilityResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateFacilityResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFacilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): UpdateFacilityResponse {
    return {};
  },

  toJSON(_: UpdateFacilityResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateFacilityResponse>, I>>(base?: I): UpdateFacilityResponse {
    return UpdateFacilityResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<UpdateFacilityResponse>, I>>(_: I): UpdateFacilityResponse {
    const message = createBaseUpdateFacilityResponse();
    return message;
  },
};

function createBaseDeleteFacilityRequest(): DeleteFacilityRequest {
  return { name: "" };
}

export const DeleteFacilityRequest = {
  encode(message: DeleteFacilityRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteFacilityRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFacilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeleteFacilityRequest {
    return { name: isSet(object.name) ? String(object.name) : "" };
  },

  toJSON(message: DeleteFacilityRequest): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteFacilityRequest>, I>>(base?: I): DeleteFacilityRequest {
    return DeleteFacilityRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteFacilityRequest>, I>>(object: I): DeleteFacilityRequest {
    const message = createBaseDeleteFacilityRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteFacilityResponse(): DeleteFacilityResponse {
  return {};
}

export const DeleteFacilityResponse = {
  encode(_: DeleteFacilityResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteFacilityResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFacilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeleteFacilityResponse {
    return {};
  },

  toJSON(_: DeleteFacilityResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteFacilityResponse>, I>>(base?: I): DeleteFacilityResponse {
    return DeleteFacilityResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeleteFacilityResponse>, I>>(_: I): DeleteFacilityResponse {
    const message = createBaseDeleteFacilityResponse();
    return message;
  },
};

function createBaseDeactivateResourcesRequest(): DeactivateResourcesRequest {
  return { facility: "", resources: [] };
}

export const DeactivateResourcesRequest = {
  encode(message: DeactivateResourcesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.facility !== "") {
      writer.uint32(10).string(message.facility);
    }
    for (const v of message.resources) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeactivateResourcesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeactivateResourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.facility = reader.string();
          break;
        case 2:
          message.resources.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeactivateResourcesRequest {
    return {
      facility: isSet(object.facility) ? String(object.facility) : "",
      resources: Array.isArray(object?.resources) ? object.resources.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: DeactivateResourcesRequest): unknown {
    const obj: any = {};
    message.facility !== undefined && (obj.facility = message.facility);
    if (message.resources) {
      obj.resources = message.resources.map((e) => e);
    } else {
      obj.resources = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeactivateResourcesRequest>, I>>(base?: I): DeactivateResourcesRequest {
    return DeactivateResourcesRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeactivateResourcesRequest>, I>>(object: I): DeactivateResourcesRequest {
    const message = createBaseDeactivateResourcesRequest();
    message.facility = object.facility ?? "";
    message.resources = object.resources?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeactivateResourcesResponse(): DeactivateResourcesResponse {
  return {};
}

export const DeactivateResourcesResponse = {
  encode(_: DeactivateResourcesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeactivateResourcesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeactivateResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeactivateResourcesResponse {
    return {};
  },

  toJSON(_: DeactivateResourcesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeactivateResourcesResponse>, I>>(base?: I): DeactivateResourcesResponse {
    return DeactivateResourcesResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeactivateResourcesResponse>, I>>(_: I): DeactivateResourcesResponse {
    const message = createBaseDeactivateResourcesResponse();
    return message;
  },
};

function createBaseActivateResourcesRequest(): ActivateResourcesRequest {
  return { facility: "", resources: [] };
}

export const ActivateResourcesRequest = {
  encode(message: ActivateResourcesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.facility !== "") {
      writer.uint32(10).string(message.facility);
    }
    for (const v of message.resources) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActivateResourcesRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateResourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.facility = reader.string();
          break;
        case 2:
          message.resources.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ActivateResourcesRequest {
    return {
      facility: isSet(object.facility) ? String(object.facility) : "",
      resources: Array.isArray(object?.resources) ? object.resources.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: ActivateResourcesRequest): unknown {
    const obj: any = {};
    message.facility !== undefined && (obj.facility = message.facility);
    if (message.resources) {
      obj.resources = message.resources.map((e) => e);
    } else {
      obj.resources = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivateResourcesRequest>, I>>(base?: I): ActivateResourcesRequest {
    return ActivateResourcesRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ActivateResourcesRequest>, I>>(object: I): ActivateResourcesRequest {
    const message = createBaseActivateResourcesRequest();
    message.facility = object.facility ?? "";
    message.resources = object.resources?.map((e) => e) || [];
    return message;
  },
};

function createBaseActivateResourcesResponse(): ActivateResourcesResponse {
  return {};
}

export const ActivateResourcesResponse = {
  encode(_: ActivateResourcesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActivateResourcesResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): ActivateResourcesResponse {
    return {};
  },

  toJSON(_: ActivateResourcesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivateResourcesResponse>, I>>(base?: I): ActivateResourcesResponse {
    return ActivateResourcesResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ActivateResourcesResponse>, I>>(_: I): ActivateResourcesResponse {
    const message = createBaseActivateResourcesResponse();
    return message;
  },
};

function createBaseListBlockPoolsRequest(): ListBlockPoolsRequest {
  return {};
}

export const ListBlockPoolsRequest = {
  encode(_: ListBlockPoolsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBlockPoolsRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBlockPoolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): ListBlockPoolsRequest {
    return {};
  },

  toJSON(_: ListBlockPoolsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBlockPoolsRequest>, I>>(base?: I): ListBlockPoolsRequest {
    return ListBlockPoolsRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ListBlockPoolsRequest>, I>>(_: I): ListBlockPoolsRequest {
    const message = createBaseListBlockPoolsRequest();
    return message;
  },
};

function createBaseListBlockPoolsResponse(): ListBlockPoolsResponse {
  return {};
}

export const ListBlockPoolsResponse = {
  encode(_: ListBlockPoolsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListBlockPoolsResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBlockPoolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): ListBlockPoolsResponse {
    return {};
  },

  toJSON(_: ListBlockPoolsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBlockPoolsResponse>, I>>(base?: I): ListBlockPoolsResponse {
    return ListBlockPoolsResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ListBlockPoolsResponse>, I>>(_: I): ListBlockPoolsResponse {
    const message = createBaseListBlockPoolsResponse();
    return message;
  },
};

function createBaseInitHarborRequest(): InitHarborRequest {
  return { facility: "", ver: 0, rid: "", eid: "", pid: "" };
}

export const InitHarborRequest = {
  encode(message: InitHarborRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.facility !== "") {
      writer.uint32(10).string(message.facility);
    }
    if (message.ver !== 0) {
      writer.uint32(16).int64(message.ver);
    }
    if (message.rid !== "") {
      writer.uint32(26).string(message.rid);
    }
    if (message.eid !== "") {
      writer.uint32(34).string(message.eid);
    }
    if (message.pid !== "") {
      writer.uint32(42).string(message.pid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InitHarborRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitHarborRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.facility = reader.string();
          break;
        case 2:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        case 3:
          message.rid = reader.string();
          break;
        case 4:
          message.eid = reader.string();
          break;
        case 5:
          message.pid = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InitHarborRequest {
    return {
      facility: isSet(object.facility) ? String(object.facility) : "",
      ver: isSet(object.ver) ? Number(object.ver) : 0,
      rid: isSet(object.rid) ? String(object.rid) : "",
      eid: isSet(object.eid) ? String(object.eid) : "",
      pid: isSet(object.pid) ? String(object.pid) : "",
    };
  },

  toJSON(message: InitHarborRequest): unknown {
    const obj: any = {};
    message.facility !== undefined && (obj.facility = message.facility);
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    message.rid !== undefined && (obj.rid = message.rid);
    message.eid !== undefined && (obj.eid = message.eid);
    message.pid !== undefined && (obj.pid = message.pid);
    return obj;
  },

  create<I extends Exact<DeepPartial<InitHarborRequest>, I>>(base?: I): InitHarborRequest {
    return InitHarborRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<InitHarborRequest>, I>>(object: I): InitHarborRequest {
    const message = createBaseInitHarborRequest();
    message.facility = object.facility ?? "";
    message.ver = object.ver ?? 0;
    message.rid = object.rid ?? "";
    message.eid = object.eid ?? "";
    message.pid = object.pid ?? "";
    return message;
  },
};

function createBaseInitHarborResponse(): InitHarborResponse {
  return {};
}

export const InitHarborResponse = {
  encode(_: InitHarborResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InitHarborResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitHarborResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): InitHarborResponse {
    return {};
  },

  toJSON(_: InitHarborResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<InitHarborResponse>, I>>(base?: I): InitHarborResponse {
    return InitHarborResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<InitHarborResponse>, I>>(_: I): InitHarborResponse {
    const message = createBaseInitHarborResponse();
    return message;
  },
};

function createBaseDeinitHarborRequest(): DeinitHarborRequest {
  return { facility: "", ver: 0, rid: "", eid: "", pid: "" };
}

export const DeinitHarborRequest = {
  encode(message: DeinitHarborRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.facility !== "") {
      writer.uint32(10).string(message.facility);
    }
    if (message.ver !== 0) {
      writer.uint32(16).int64(message.ver);
    }
    if (message.rid !== "") {
      writer.uint32(26).string(message.rid);
    }
    if (message.eid !== "") {
      writer.uint32(34).string(message.eid);
    }
    if (message.pid !== "") {
      writer.uint32(42).string(message.pid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeinitHarborRequest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeinitHarborRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.facility = reader.string();
          break;
        case 2:
          message.ver = longToNumber(reader.int64() as Long);
          break;
        case 3:
          message.rid = reader.string();
          break;
        case 4:
          message.eid = reader.string();
          break;
        case 5:
          message.pid = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeinitHarborRequest {
    return {
      facility: isSet(object.facility) ? String(object.facility) : "",
      ver: isSet(object.ver) ? Number(object.ver) : 0,
      rid: isSet(object.rid) ? String(object.rid) : "",
      eid: isSet(object.eid) ? String(object.eid) : "",
      pid: isSet(object.pid) ? String(object.pid) : "",
    };
  },

  toJSON(message: DeinitHarborRequest): unknown {
    const obj: any = {};
    message.facility !== undefined && (obj.facility = message.facility);
    message.ver !== undefined && (obj.ver = Math.round(message.ver));
    message.rid !== undefined && (obj.rid = message.rid);
    message.eid !== undefined && (obj.eid = message.eid);
    message.pid !== undefined && (obj.pid = message.pid);
    return obj;
  },

  create<I extends Exact<DeepPartial<DeinitHarborRequest>, I>>(base?: I): DeinitHarborRequest {
    return DeinitHarborRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeinitHarborRequest>, I>>(object: I): DeinitHarborRequest {
    const message = createBaseDeinitHarborRequest();
    message.facility = object.facility ?? "";
    message.ver = object.ver ?? 0;
    message.rid = object.rid ?? "";
    message.eid = object.eid ?? "";
    message.pid = object.pid ?? "";
    return message;
  },
};

function createBaseDeinitHarborResponse(): DeinitHarborResponse {
  return {};
}

export const DeinitHarborResponse = {
  encode(_: DeinitHarborResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeinitHarborResponse {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeinitHarborResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): DeinitHarborResponse {
    return {};
  },

  toJSON(_: DeinitHarborResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeinitHarborResponse>, I>>(base?: I): DeinitHarborResponse {
    return DeinitHarborResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeinitHarborResponse>, I>>(_: I): DeinitHarborResponse {
    const message = createBaseDeinitHarborResponse();
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
