"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.GetUserSSHCertResponse = exports.GetUserSSHCertRequest = exports.SSHCert = exports.GetUserSSHKeysResponse = exports.GetUserSSHKeysRequest = exports.SSHKeyPair = exports.protobufPackage = void 0;
/* eslint-disable */
var long_1 = __importDefault(require("long"));
var minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "portal.v1";
function createBaseSSHKeyPair() {
    return { Public: "", Private: "", ver: 0 };
}
exports.SSHKeyPair = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.Public !== "") {
            writer.uint32(10).string(message.Public);
        }
        if (message.Private !== "") {
            writer.uint32(18).string(message.Private);
        }
        if (message.ver !== 0) {
            writer.uint32(24).int64(message.ver);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseSSHKeyPair();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.Public = reader.string();
                    break;
                case 2:
                    message.Private = reader.string();
                    break;
                case 3:
                    message.ver = longToNumber(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            Public: isSet(object.Public) ? String(object.Public) : "",
            Private: isSet(object.Private) ? String(object.Private) : "",
            ver: isSet(object.ver) ? Number(object.ver) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.Public !== undefined && (obj.Public = message.Public);
        message.Private !== undefined && (obj.Private = message.Private);
        message.ver !== undefined && (obj.ver = Math.round(message.ver));
        return obj;
    },
    create: function (base) {
        return exports.SSHKeyPair.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBaseSSHKeyPair();
        message.Public = (_a = object.Public) !== null && _a !== void 0 ? _a : "";
        message.Private = (_b = object.Private) !== null && _b !== void 0 ? _b : "";
        message.ver = (_c = object.ver) !== null && _c !== void 0 ? _c : 0;
        return message;
    }
};
function createBaseGetUserSSHKeysRequest() {
    return { Username: "" };
}
exports.GetUserSSHKeysRequest = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.Username !== "") {
            writer.uint32(10).string(message.Username);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseGetUserSSHKeysRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.Username = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { Username: isSet(object.Username) ? String(object.Username) : "" };
    },
    toJSON: function (message) {
        var obj = {};
        message.Username !== undefined && (obj.Username = message.Username);
        return obj;
    },
    create: function (base) {
        return exports.GetUserSSHKeysRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseGetUserSSHKeysRequest();
        message.Username = (_a = object.Username) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
function createBaseGetUserSSHKeysResponse() {
    return { Keys: undefined };
}
exports.GetUserSSHKeysResponse = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.Keys !== undefined) {
            exports.SSHKeyPair.encode(message.Keys, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseGetUserSSHKeysResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.Keys = exports.SSHKeyPair.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { Keys: isSet(object.Keys) ? exports.SSHKeyPair.fromJSON(object.Keys) : undefined };
    },
    toJSON: function (message) {
        var obj = {};
        message.Keys !== undefined && (obj.Keys = message.Keys ? exports.SSHKeyPair.toJSON(message.Keys) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.GetUserSSHKeysResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var message = createBaseGetUserSSHKeysResponse();
        message.Keys = (object.Keys !== undefined && object.Keys !== null)
            ? exports.SSHKeyPair.fromPartial(object.Keys)
            : undefined;
        return message;
    }
};
function createBaseSSHCert() {
    return { Cert: "", CAHostPubKey: "", ver: 0 };
}
exports.SSHCert = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.Cert !== "") {
            writer.uint32(10).string(message.Cert);
        }
        if (message.CAHostPubKey !== "") {
            writer.uint32(18).string(message.CAHostPubKey);
        }
        if (message.ver !== 0) {
            writer.uint32(24).int64(message.ver);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseSSHCert();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.Cert = reader.string();
                    break;
                case 2:
                    message.CAHostPubKey = reader.string();
                    break;
                case 3:
                    message.ver = longToNumber(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            Cert: isSet(object.Cert) ? String(object.Cert) : "",
            CAHostPubKey: isSet(object.CAHostPubKey) ? String(object.CAHostPubKey) : "",
            ver: isSet(object.ver) ? Number(object.ver) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.Cert !== undefined && (obj.Cert = message.Cert);
        message.CAHostPubKey !== undefined && (obj.CAHostPubKey = message.CAHostPubKey);
        message.ver !== undefined && (obj.ver = Math.round(message.ver));
        return obj;
    },
    create: function (base) {
        return exports.SSHCert.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBaseSSHCert();
        message.Cert = (_a = object.Cert) !== null && _a !== void 0 ? _a : "";
        message.CAHostPubKey = (_b = object.CAHostPubKey) !== null && _b !== void 0 ? _b : "";
        message.ver = (_c = object.ver) !== null && _c !== void 0 ? _c : 0;
        return message;
    }
};
function createBaseGetUserSSHCertRequest() {
    return { Username: "" };
}
exports.GetUserSSHCertRequest = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.Username !== "") {
            writer.uint32(10).string(message.Username);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseGetUserSSHCertRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.Username = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { Username: isSet(object.Username) ? String(object.Username) : "" };
    },
    toJSON: function (message) {
        var obj = {};
        message.Username !== undefined && (obj.Username = message.Username);
        return obj;
    },
    create: function (base) {
        return exports.GetUserSSHCertRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseGetUserSSHCertRequest();
        message.Username = (_a = object.Username) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
function createBaseGetUserSSHCertResponse() {
    return { Cert: undefined };
}
exports.GetUserSSHCertResponse = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.Cert !== undefined) {
            exports.SSHCert.encode(message.Cert, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseGetUserSSHCertResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.Cert = exports.SSHCert.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { Cert: isSet(object.Cert) ? exports.SSHCert.fromJSON(object.Cert) : undefined };
    },
    toJSON: function (message) {
        var obj = {};
        message.Cert !== undefined && (obj.Cert = message.Cert ? exports.SSHCert.toJSON(message.Cert) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.GetUserSSHCertResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var message = createBaseGetUserSSHCertResponse();
        message.Cert = (object.Cert !== undefined && object.Cert !== null) ? exports.SSHCert.fromPartial(object.Cert) : undefined;
        return message;
    }
};
var tsProtoGlobalThis = (function () {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (minimal_1["default"].util.Long !== long_1["default"]) {
    minimal_1["default"].util.Long = long_1["default"];
    minimal_1["default"].configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
