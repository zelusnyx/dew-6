/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "xir";

export enum Routing {
  ManualRouting = 0,
  StaticRouting = 1,
  UNRECOGNIZED = -1,
}

export function routingFromJSON(object: any): Routing {
  switch (object) {
    case 0:
    case "ManualRouting":
      return Routing.ManualRouting;
    case 1:
    case "StaticRouting":
      return Routing.StaticRouting;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Routing.UNRECOGNIZED;
  }
}

export function routingToJSON(object: Routing): string {
  switch (object) {
    case Routing.ManualRouting:
      return "ManualRouting";
    case Routing.StaticRouting:
      return "StaticRouting";
    case Routing.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Addressing {
  ManualAddressing = 0,
  IPv4Addressing = 1,
  UNRECOGNIZED = -1,
}

export function addressingFromJSON(object: any): Addressing {
  switch (object) {
    case 0:
    case "ManualAddressing":
      return Addressing.ManualAddressing;
    case 1:
    case "IPv4Addressing":
      return Addressing.IPv4Addressing;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Addressing.UNRECOGNIZED;
  }
}

export function addressingToJSON(object: Addressing): string {
  switch (object) {
    case Addressing.ManualAddressing:
      return "ManualAddressing";
    case Addressing.IPv4Addressing:
      return "IPv4Addressing";
    case Addressing.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Emulation {
  /** Netem - default */
  Netem = 0,
  Click = 1,
  UNRECOGNIZED = -1,
}

export function emulationFromJSON(object: any): Emulation {
  switch (object) {
    case 0:
    case "Netem":
      return Emulation.Netem;
    case 1:
    case "Click":
      return Emulation.Click;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Emulation.UNRECOGNIZED;
  }
}

export function emulationToJSON(object: Emulation): string {
  switch (object) {
    case Emulation.Netem:
      return "Netem";
    case Emulation.Click:
      return "Click";
    case Emulation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Protocol {
  http = 0,
  https = 1,
  tcp = 2,
  udp = 3,
  UNRECOGNIZED = -1,
}

export function protocolFromJSON(object: any): Protocol {
  switch (object) {
    case 0:
    case "http":
      return Protocol.http;
    case 1:
    case "https":
      return Protocol.https;
    case 2:
    case "tcp":
      return Protocol.tcp;
    case 3:
    case "udp":
      return Protocol.udp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Protocol.UNRECOGNIZED;
  }
}

export function protocolToJSON(object: Protocol): string {
  switch (object) {
    case Protocol.http:
      return "http";
    case Protocol.https:
      return "https";
    case Protocol.tcp:
      return "tcp";
    case Protocol.udp:
      return "udp";
    case Protocol.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ISA {
  X86_64 = 0,
  UNRECOGNIZED = -1,
}

export function iSAFromJSON(object: any): ISA {
  switch (object) {
    case 0:
    case "X86_64":
      return ISA.X86_64;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ISA.UNRECOGNIZED;
  }
}

export function iSAToJSON(object: ISA): string {
  switch (object) {
    case ISA.X86_64:
      return "X86_64";
    case ISA.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MemoryType {
  DDR3 = 0,
  DDR4 = 1,
  UNRECOGNIZED = -1,
}

export function memoryTypeFromJSON(object: any): MemoryType {
  switch (object) {
    case 0:
    case "DDR3":
      return MemoryType.DDR3;
    case 1:
    case "DDR4":
      return MemoryType.DDR4;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MemoryType.UNRECOGNIZED;
  }
}

export function memoryTypeToJSON(object: MemoryType): string {
  switch (object) {
    case MemoryType.DDR3:
      return "DDR3";
    case MemoryType.DDR4:
      return "DDR4";
    case MemoryType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NICModel {
  Intel200 = 0,
  Intel300 = 1,
  Intel500 = 2,
  Intel700 = 3,
  Intel800 = 4,
  Intel7000 = 50,
  Intel8000 = 51,
  Intel9000 = 52,
  ConnectX4 = 101,
  ConnectX5 = 102,
  ConnectX6 = 103,
  NetXtreme2 = 201,
  QCA9000 = 301,
  Virtio = 10001,
  E1000 = 10002,
  E1000E = 10003,
  UNRECOGNIZED = -1,
}

export function nICModelFromJSON(object: any): NICModel {
  switch (object) {
    case 0:
    case "Intel200":
      return NICModel.Intel200;
    case 1:
    case "Intel300":
      return NICModel.Intel300;
    case 2:
    case "Intel500":
      return NICModel.Intel500;
    case 3:
    case "Intel700":
      return NICModel.Intel700;
    case 4:
    case "Intel800":
      return NICModel.Intel800;
    case 50:
    case "Intel7000":
      return NICModel.Intel7000;
    case 51:
    case "Intel8000":
      return NICModel.Intel8000;
    case 52:
    case "Intel9000":
      return NICModel.Intel9000;
    case 101:
    case "ConnectX4":
      return NICModel.ConnectX4;
    case 102:
    case "ConnectX5":
      return NICModel.ConnectX5;
    case 103:
    case "ConnectX6":
      return NICModel.ConnectX6;
    case 201:
    case "NetXtreme2":
      return NICModel.NetXtreme2;
    case 301:
    case "QCA9000":
      return NICModel.QCA9000;
    case 10001:
    case "Virtio":
      return NICModel.Virtio;
    case 10002:
    case "E1000":
      return NICModel.E1000;
    case 10003:
    case "E1000E":
      return NICModel.E1000E;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NICModel.UNRECOGNIZED;
  }
}

export function nICModelToJSON(object: NICModel): string {
  switch (object) {
    case NICModel.Intel200:
      return "Intel200";
    case NICModel.Intel300:
      return "Intel300";
    case NICModel.Intel500:
      return "Intel500";
    case NICModel.Intel700:
      return "Intel700";
    case NICModel.Intel800:
      return "Intel800";
    case NICModel.Intel7000:
      return "Intel7000";
    case NICModel.Intel8000:
      return "Intel8000";
    case NICModel.Intel9000:
      return "Intel9000";
    case NICModel.ConnectX4:
      return "ConnectX4";
    case NICModel.ConnectX5:
      return "ConnectX5";
    case NICModel.ConnectX6:
      return "ConnectX6";
    case NICModel.NetXtreme2:
      return "NetXtreme2";
    case NICModel.QCA9000:
      return "QCA9000";
    case NICModel.Virtio:
      return "Virtio";
    case NICModel.E1000:
      return "E1000";
    case NICModel.E1000E:
      return "E1000E";
    case NICModel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NICKind {
  /** ETH - Ethernet */
  ETH = 0,
  /** ENP - Ethernet peripheral */
  ENP = 1,
  /** ENO - Ethernet onboard */
  ENO = 2,
  /** ENS - Ethernet peripheral hotplog slot */
  ENS = 3,
  /** WLP - WiFi peripheral */
  WLP = 4,
  /** SWP - Switch port */
  SWP = 5,
  /** IPMI - IPMI/BMC */
  IPMI = 6,
  /** Combo - IPMI/BMC + System Ethernet */
  Combo = 7,
  UNRECOGNIZED = -1,
}

export function nICKindFromJSON(object: any): NICKind {
  switch (object) {
    case 0:
    case "ETH":
      return NICKind.ETH;
    case 1:
    case "ENP":
      return NICKind.ENP;
    case 2:
    case "ENO":
      return NICKind.ENO;
    case 3:
    case "ENS":
      return NICKind.ENS;
    case 4:
    case "WLP":
      return NICKind.WLP;
    case 5:
    case "SWP":
      return NICKind.SWP;
    case 6:
    case "IPMI":
      return NICKind.IPMI;
    case 7:
    case "Combo":
      return NICKind.Combo;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NICKind.UNRECOGNIZED;
  }
}

export function nICKindToJSON(object: NICKind): string {
  switch (object) {
    case NICKind.ETH:
      return "ETH";
    case NICKind.ENP:
      return "ENP";
    case NICKind.ENO:
      return "ENO";
    case NICKind.ENS:
      return "ENS";
    case NICKind.WLP:
      return "WLP";
    case NICKind.SWP:
      return "SWP";
    case NICKind.IPMI:
      return "IPMI";
    case NICKind.Combo:
      return "Combo";
    case NICKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Layer1 {
  Layer1_Undefined = 0,
  /** Base100T - 100 mbps */
  Base100T = 1,
  /** Base1000T - 1 gbps */
  Base1000T = 2,
  Base1000X = 3,
  Base1000CX = 4,
  Base1000SX = 5,
  Base1000LX = 6,
  Base1000LX10 = 7,
  Base1000EX = 8,
  Base1000BX10 = 9,
  Base1000ZX = 10,
  /** GBase10T - 10 gbps */
  GBase10T = 11,
  GBase10CR = 12,
  GBase10SR = 13,
  GBase10LR = 14,
  GBase10LRM = 15,
  GBase10ER = 16,
  GBase10ZR = 17,
  GBase10LX4 = 18,
  GBase10PR = 19,
  /** GBase25CR - 25 gbps */
  GBase25CR = 20,
  GBase25SR = 21,
  GBase25LR = 22,
  GBase25ER = 23,
  /** GBase40CR4 - 40 gbps */
  GBase40CR4 = 24,
  GBase40SR4 = 25,
  GBase40LR4 = 26,
  GBase40ER4 = 27,
  /** GBase100CR4 - 100 gbps */
  GBase100CR4 = 28,
  GBase100SR4 = 29,
  GBase100SR10 = 30,
  GBase100LR4 = 31,
  GBase100ER4 = 32,
  /** RS232 - Console */
  RS232 = 33,
  Uart = 34,
  /** GBase50SR4 - 50 gbps */
  GBase50SR4 = 35,
  GBase50LR4 = 36,
  GBase50ER4 = 37,
  GBase50CR = 38,
  GBase50KR = 39,
  GBase50SR = 40,
  GBase50LR = 41,
  GBase50FR = 42,
  GBase50ER = 43,
  LAUI_2 = 44,
  GAUI50_1 = 45,
  GAUI50_2 = 46,
  /** GBase200CR4 - 200 gbps */
  GBase200CR4 = 47,
  GBase200KR4 = 48,
  GBase200SR4 = 49,
  GBase200DR4 = 50,
  GBase200FR4 = 51,
  GBase200LR4 = 52,
  GBase200ER4 = 53,
  GAUI200_4 = 54,
  GAUI200_8 = 55,
  /** GBase400SR16 - 400 gbps */
  GBase400SR16 = 56,
  GBase400SR8 = 57,
  GBase400SR4_2 = 58,
  GBase400DR4 = 59,
  GBase400FR8 = 60,
  GBase400ER8 = 61,
  GBase400ZR = 62,
  GAUI400_16 = 63,
  GAUI400_8 = 64,
  XBee = 65,
  ZWave = 66,
  Zigbee = 67,
  CXP100 = 68,
  CXP120 = 69,
  UNRECOGNIZED = -1,
}

export function layer1FromJSON(object: any): Layer1 {
  switch (object) {
    case 0:
    case "Layer1_Undefined":
      return Layer1.Layer1_Undefined;
    case 1:
    case "Base100T":
      return Layer1.Base100T;
    case 2:
    case "Base1000T":
      return Layer1.Base1000T;
    case 3:
    case "Base1000X":
      return Layer1.Base1000X;
    case 4:
    case "Base1000CX":
      return Layer1.Base1000CX;
    case 5:
    case "Base1000SX":
      return Layer1.Base1000SX;
    case 6:
    case "Base1000LX":
      return Layer1.Base1000LX;
    case 7:
    case "Base1000LX10":
      return Layer1.Base1000LX10;
    case 8:
    case "Base1000EX":
      return Layer1.Base1000EX;
    case 9:
    case "Base1000BX10":
      return Layer1.Base1000BX10;
    case 10:
    case "Base1000ZX":
      return Layer1.Base1000ZX;
    case 11:
    case "GBase10T":
      return Layer1.GBase10T;
    case 12:
    case "GBase10CR":
      return Layer1.GBase10CR;
    case 13:
    case "GBase10SR":
      return Layer1.GBase10SR;
    case 14:
    case "GBase10LR":
      return Layer1.GBase10LR;
    case 15:
    case "GBase10LRM":
      return Layer1.GBase10LRM;
    case 16:
    case "GBase10ER":
      return Layer1.GBase10ER;
    case 17:
    case "GBase10ZR":
      return Layer1.GBase10ZR;
    case 18:
    case "GBase10LX4":
      return Layer1.GBase10LX4;
    case 19:
    case "GBase10PR":
      return Layer1.GBase10PR;
    case 20:
    case "GBase25CR":
      return Layer1.GBase25CR;
    case 21:
    case "GBase25SR":
      return Layer1.GBase25SR;
    case 22:
    case "GBase25LR":
      return Layer1.GBase25LR;
    case 23:
    case "GBase25ER":
      return Layer1.GBase25ER;
    case 24:
    case "GBase40CR4":
      return Layer1.GBase40CR4;
    case 25:
    case "GBase40SR4":
      return Layer1.GBase40SR4;
    case 26:
    case "GBase40LR4":
      return Layer1.GBase40LR4;
    case 27:
    case "GBase40ER4":
      return Layer1.GBase40ER4;
    case 28:
    case "GBase100CR4":
      return Layer1.GBase100CR4;
    case 29:
    case "GBase100SR4":
      return Layer1.GBase100SR4;
    case 30:
    case "GBase100SR10":
      return Layer1.GBase100SR10;
    case 31:
    case "GBase100LR4":
      return Layer1.GBase100LR4;
    case 32:
    case "GBase100ER4":
      return Layer1.GBase100ER4;
    case 33:
    case "RS232":
      return Layer1.RS232;
    case 34:
    case "Uart":
      return Layer1.Uart;
    case 35:
    case "GBase50SR4":
      return Layer1.GBase50SR4;
    case 36:
    case "GBase50LR4":
      return Layer1.GBase50LR4;
    case 37:
    case "GBase50ER4":
      return Layer1.GBase50ER4;
    case 38:
    case "GBase50CR":
      return Layer1.GBase50CR;
    case 39:
    case "GBase50KR":
      return Layer1.GBase50KR;
    case 40:
    case "GBase50SR":
      return Layer1.GBase50SR;
    case 41:
    case "GBase50LR":
      return Layer1.GBase50LR;
    case 42:
    case "GBase50FR":
      return Layer1.GBase50FR;
    case 43:
    case "GBase50ER":
      return Layer1.GBase50ER;
    case 44:
    case "LAUI_2":
      return Layer1.LAUI_2;
    case 45:
    case "GAUI50_1":
      return Layer1.GAUI50_1;
    case 46:
    case "GAUI50_2":
      return Layer1.GAUI50_2;
    case 47:
    case "GBase200CR4":
      return Layer1.GBase200CR4;
    case 48:
    case "GBase200KR4":
      return Layer1.GBase200KR4;
    case 49:
    case "GBase200SR4":
      return Layer1.GBase200SR4;
    case 50:
    case "GBase200DR4":
      return Layer1.GBase200DR4;
    case 51:
    case "GBase200FR4":
      return Layer1.GBase200FR4;
    case 52:
    case "GBase200LR4":
      return Layer1.GBase200LR4;
    case 53:
    case "GBase200ER4":
      return Layer1.GBase200ER4;
    case 54:
    case "GAUI200_4":
      return Layer1.GAUI200_4;
    case 55:
    case "GAUI200_8":
      return Layer1.GAUI200_8;
    case 56:
    case "GBase400SR16":
      return Layer1.GBase400SR16;
    case 57:
    case "GBase400SR8":
      return Layer1.GBase400SR8;
    case 58:
    case "GBase400SR4_2":
      return Layer1.GBase400SR4_2;
    case 59:
    case "GBase400DR4":
      return Layer1.GBase400DR4;
    case 60:
    case "GBase400FR8":
      return Layer1.GBase400FR8;
    case 61:
    case "GBase400ER8":
      return Layer1.GBase400ER8;
    case 62:
    case "GBase400ZR":
      return Layer1.GBase400ZR;
    case 63:
    case "GAUI400_16":
      return Layer1.GAUI400_16;
    case 64:
    case "GAUI400_8":
      return Layer1.GAUI400_8;
    case 65:
    case "XBee":
      return Layer1.XBee;
    case 66:
    case "ZWave":
      return Layer1.ZWave;
    case 67:
    case "Zigbee":
      return Layer1.Zigbee;
    case 68:
    case "CXP100":
      return Layer1.CXP100;
    case 69:
    case "CXP120":
      return Layer1.CXP120;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Layer1.UNRECOGNIZED;
  }
}

export function layer1ToJSON(object: Layer1): string {
  switch (object) {
    case Layer1.Layer1_Undefined:
      return "Layer1_Undefined";
    case Layer1.Base100T:
      return "Base100T";
    case Layer1.Base1000T:
      return "Base1000T";
    case Layer1.Base1000X:
      return "Base1000X";
    case Layer1.Base1000CX:
      return "Base1000CX";
    case Layer1.Base1000SX:
      return "Base1000SX";
    case Layer1.Base1000LX:
      return "Base1000LX";
    case Layer1.Base1000LX10:
      return "Base1000LX10";
    case Layer1.Base1000EX:
      return "Base1000EX";
    case Layer1.Base1000BX10:
      return "Base1000BX10";
    case Layer1.Base1000ZX:
      return "Base1000ZX";
    case Layer1.GBase10T:
      return "GBase10T";
    case Layer1.GBase10CR:
      return "GBase10CR";
    case Layer1.GBase10SR:
      return "GBase10SR";
    case Layer1.GBase10LR:
      return "GBase10LR";
    case Layer1.GBase10LRM:
      return "GBase10LRM";
    case Layer1.GBase10ER:
      return "GBase10ER";
    case Layer1.GBase10ZR:
      return "GBase10ZR";
    case Layer1.GBase10LX4:
      return "GBase10LX4";
    case Layer1.GBase10PR:
      return "GBase10PR";
    case Layer1.GBase25CR:
      return "GBase25CR";
    case Layer1.GBase25SR:
      return "GBase25SR";
    case Layer1.GBase25LR:
      return "GBase25LR";
    case Layer1.GBase25ER:
      return "GBase25ER";
    case Layer1.GBase40CR4:
      return "GBase40CR4";
    case Layer1.GBase40SR4:
      return "GBase40SR4";
    case Layer1.GBase40LR4:
      return "GBase40LR4";
    case Layer1.GBase40ER4:
      return "GBase40ER4";
    case Layer1.GBase100CR4:
      return "GBase100CR4";
    case Layer1.GBase100SR4:
      return "GBase100SR4";
    case Layer1.GBase100SR10:
      return "GBase100SR10";
    case Layer1.GBase100LR4:
      return "GBase100LR4";
    case Layer1.GBase100ER4:
      return "GBase100ER4";
    case Layer1.RS232:
      return "RS232";
    case Layer1.Uart:
      return "Uart";
    case Layer1.GBase50SR4:
      return "GBase50SR4";
    case Layer1.GBase50LR4:
      return "GBase50LR4";
    case Layer1.GBase50ER4:
      return "GBase50ER4";
    case Layer1.GBase50CR:
      return "GBase50CR";
    case Layer1.GBase50KR:
      return "GBase50KR";
    case Layer1.GBase50SR:
      return "GBase50SR";
    case Layer1.GBase50LR:
      return "GBase50LR";
    case Layer1.GBase50FR:
      return "GBase50FR";
    case Layer1.GBase50ER:
      return "GBase50ER";
    case Layer1.LAUI_2:
      return "LAUI_2";
    case Layer1.GAUI50_1:
      return "GAUI50_1";
    case Layer1.GAUI50_2:
      return "GAUI50_2";
    case Layer1.GBase200CR4:
      return "GBase200CR4";
    case Layer1.GBase200KR4:
      return "GBase200KR4";
    case Layer1.GBase200SR4:
      return "GBase200SR4";
    case Layer1.GBase200DR4:
      return "GBase200DR4";
    case Layer1.GBase200FR4:
      return "GBase200FR4";
    case Layer1.GBase200LR4:
      return "GBase200LR4";
    case Layer1.GBase200ER4:
      return "GBase200ER4";
    case Layer1.GAUI200_4:
      return "GAUI200_4";
    case Layer1.GAUI200_8:
      return "GAUI200_8";
    case Layer1.GBase400SR16:
      return "GBase400SR16";
    case Layer1.GBase400SR8:
      return "GBase400SR8";
    case Layer1.GBase400SR4_2:
      return "GBase400SR4_2";
    case Layer1.GBase400DR4:
      return "GBase400DR4";
    case Layer1.GBase400FR8:
      return "GBase400FR8";
    case Layer1.GBase400ER8:
      return "GBase400ER8";
    case Layer1.GBase400ZR:
      return "GBase400ZR";
    case Layer1.GAUI400_16:
      return "GAUI400_16";
    case Layer1.GAUI400_8:
      return "GAUI400_8";
    case Layer1.XBee:
      return "XBee";
    case Layer1.ZWave:
      return "ZWave";
    case Layer1.Zigbee:
      return "Zigbee";
    case Layer1.CXP100:
      return "CXP100";
    case Layer1.CXP120:
      return "CXP120";
    case Layer1.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConnectorKind {
  ConnectorKind_Undefined = 0,
  RJ45 = 1,
  SFP = 2,
  QSFP = 3,
  SFPP = 4,
  QSFPP = 5,
  SFP28 = 6,
  QSFP28 = 7,
  CXP = 8,
  LC = 9,
  MPO = 10,
  SFP56 = 11,
  QSFP56 = 12,
  QSFPDD = 13,
  UNRECOGNIZED = -1,
}

export function connectorKindFromJSON(object: any): ConnectorKind {
  switch (object) {
    case 0:
    case "ConnectorKind_Undefined":
      return ConnectorKind.ConnectorKind_Undefined;
    case 1:
    case "RJ45":
      return ConnectorKind.RJ45;
    case 2:
    case "SFP":
      return ConnectorKind.SFP;
    case 3:
    case "QSFP":
      return ConnectorKind.QSFP;
    case 4:
    case "SFPP":
      return ConnectorKind.SFPP;
    case 5:
    case "QSFPP":
      return ConnectorKind.QSFPP;
    case 6:
    case "SFP28":
      return ConnectorKind.SFP28;
    case 7:
    case "QSFP28":
      return ConnectorKind.QSFP28;
    case 8:
    case "CXP":
      return ConnectorKind.CXP;
    case 9:
    case "LC":
      return ConnectorKind.LC;
    case 10:
    case "MPO":
      return ConnectorKind.MPO;
    case 11:
    case "SFP56":
      return ConnectorKind.SFP56;
    case 12:
    case "QSFP56":
      return ConnectorKind.QSFP56;
    case 13:
    case "QSFPDD":
      return ConnectorKind.QSFPDD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectorKind.UNRECOGNIZED;
  }
}

export function connectorKindToJSON(object: ConnectorKind): string {
  switch (object) {
    case ConnectorKind.ConnectorKind_Undefined:
      return "ConnectorKind_Undefined";
    case ConnectorKind.RJ45:
      return "RJ45";
    case ConnectorKind.SFP:
      return "SFP";
    case ConnectorKind.QSFP:
      return "QSFP";
    case ConnectorKind.SFPP:
      return "SFPP";
    case ConnectorKind.QSFPP:
      return "QSFPP";
    case ConnectorKind.SFP28:
      return "SFP28";
    case ConnectorKind.QSFP28:
      return "QSFP28";
    case ConnectorKind.CXP:
      return "CXP";
    case ConnectorKind.LC:
      return "LC";
    case ConnectorKind.MPO:
      return "MPO";
    case ConnectorKind.SFP56:
      return "SFP56";
    case ConnectorKind.QSFP56:
      return "QSFP56";
    case ConnectorKind.QSFPDD:
      return "QSFPDD";
    case ConnectorKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DiskFormFactor {
  DiskFormFactor_Undefined = 0,
  HDD35 = 1,
  HDD25 = 2,
  SSD35 = 3,
  SSD25 = 4,
  MSATA = 5,
  M2_2216 = 6,
  M2_2226 = 7,
  M2_2230 = 8,
  M2_2238 = 9,
  M2_2242 = 10,
  M2_2260 = 11,
  M2_2280 = 12,
  M2_22110 = 13,
  U2 = 14,
  EMMC = 15,
  EUSB = 16,
  UNRECOGNIZED = -1,
}

export function diskFormFactorFromJSON(object: any): DiskFormFactor {
  switch (object) {
    case 0:
    case "DiskFormFactor_Undefined":
      return DiskFormFactor.DiskFormFactor_Undefined;
    case 1:
    case "HDD35":
      return DiskFormFactor.HDD35;
    case 2:
    case "HDD25":
      return DiskFormFactor.HDD25;
    case 3:
    case "SSD35":
      return DiskFormFactor.SSD35;
    case 4:
    case "SSD25":
      return DiskFormFactor.SSD25;
    case 5:
    case "MSATA":
      return DiskFormFactor.MSATA;
    case 6:
    case "M2_2216":
      return DiskFormFactor.M2_2216;
    case 7:
    case "M2_2226":
      return DiskFormFactor.M2_2226;
    case 8:
    case "M2_2230":
      return DiskFormFactor.M2_2230;
    case 9:
    case "M2_2238":
      return DiskFormFactor.M2_2238;
    case 10:
    case "M2_2242":
      return DiskFormFactor.M2_2242;
    case 11:
    case "M2_2260":
      return DiskFormFactor.M2_2260;
    case 12:
    case "M2_2280":
      return DiskFormFactor.M2_2280;
    case 13:
    case "M2_22110":
      return DiskFormFactor.M2_22110;
    case 14:
    case "U2":
      return DiskFormFactor.U2;
    case 15:
    case "EMMC":
      return DiskFormFactor.EMMC;
    case 16:
    case "EUSB":
      return DiskFormFactor.EUSB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DiskFormFactor.UNRECOGNIZED;
  }
}

export function diskFormFactorToJSON(object: DiskFormFactor): string {
  switch (object) {
    case DiskFormFactor.DiskFormFactor_Undefined:
      return "DiskFormFactor_Undefined";
    case DiskFormFactor.HDD35:
      return "HDD35";
    case DiskFormFactor.HDD25:
      return "HDD25";
    case DiskFormFactor.SSD35:
      return "SSD35";
    case DiskFormFactor.SSD25:
      return "SSD25";
    case DiskFormFactor.MSATA:
      return "MSATA";
    case DiskFormFactor.M2_2216:
      return "M2_2216";
    case DiskFormFactor.M2_2226:
      return "M2_2226";
    case DiskFormFactor.M2_2230:
      return "M2_2230";
    case DiskFormFactor.M2_2238:
      return "M2_2238";
    case DiskFormFactor.M2_2242:
      return "M2_2242";
    case DiskFormFactor.M2_2260:
      return "M2_2260";
    case DiskFormFactor.M2_2280:
      return "M2_2280";
    case DiskFormFactor.M2_22110:
      return "M2_22110";
    case DiskFormFactor.U2:
      return "U2";
    case DiskFormFactor.EMMC:
      return "EMMC";
    case DiskFormFactor.EUSB:
      return "EUSB";
    case DiskFormFactor.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DiskInterface {
  DiskInterface_Undefined = 0,
  SATA1 = 1,
  SATA2 = 2,
  SATA3 = 3,
  NVMEx2 = 4,
  NVMEx4 = 5,
  MMC = 6,
  SD = 7,
  USB = 8,
  SAS = 9,
  VirtioBlock = 10,
  UNRECOGNIZED = -1,
}

export function diskInterfaceFromJSON(object: any): DiskInterface {
  switch (object) {
    case 0:
    case "DiskInterface_Undefined":
      return DiskInterface.DiskInterface_Undefined;
    case 1:
    case "SATA1":
      return DiskInterface.SATA1;
    case 2:
    case "SATA2":
      return DiskInterface.SATA2;
    case 3:
    case "SATA3":
      return DiskInterface.SATA3;
    case 4:
    case "NVMEx2":
      return DiskInterface.NVMEx2;
    case 5:
    case "NVMEx4":
      return DiskInterface.NVMEx4;
    case 6:
    case "MMC":
      return DiskInterface.MMC;
    case 7:
    case "SD":
      return DiskInterface.SD;
    case 8:
    case "USB":
      return DiskInterface.USB;
    case 9:
    case "SAS":
      return DiskInterface.SAS;
    case 10:
    case "VirtioBlock":
      return DiskInterface.VirtioBlock;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DiskInterface.UNRECOGNIZED;
  }
}

export function diskInterfaceToJSON(object: DiskInterface): string {
  switch (object) {
    case DiskInterface.DiskInterface_Undefined:
      return "DiskInterface_Undefined";
    case DiskInterface.SATA1:
      return "SATA1";
    case DiskInterface.SATA2:
      return "SATA2";
    case DiskInterface.SATA3:
      return "SATA3";
    case DiskInterface.NVMEx2:
      return "NVMEx2";
    case DiskInterface.NVMEx4:
      return "NVMEx4";
    case DiskInterface.MMC:
      return "MMC";
    case DiskInterface.SD:
      return "SD";
    case DiskInterface.USB:
      return "USB";
    case DiskInterface.SAS:
      return "SAS";
    case DiskInterface.VirtioBlock:
      return "VirtioBlock";
    case DiskInterface.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CableKind {
  CableKind_Undefined = 0,
  Cat5 = 1,
  Cat5e = 2,
  Cat6 = 3,
  DAC = 4,
  DACBreakout = 5,
  FiberLC = 6,
  FiberMPOTrunk = 7,
  FiberMPOBreakout = 8,
  AOC = 9,
  AOCBreakout = 10,
  GenericBreakout = 11,
  UNRECOGNIZED = -1,
}

export function cableKindFromJSON(object: any): CableKind {
  switch (object) {
    case 0:
    case "CableKind_Undefined":
      return CableKind.CableKind_Undefined;
    case 1:
    case "Cat5":
      return CableKind.Cat5;
    case 2:
    case "Cat5e":
      return CableKind.Cat5e;
    case 3:
    case "Cat6":
      return CableKind.Cat6;
    case 4:
    case "DAC":
      return CableKind.DAC;
    case 5:
    case "DACBreakout":
      return CableKind.DACBreakout;
    case 6:
    case "FiberLC":
      return CableKind.FiberLC;
    case 7:
    case "FiberMPOTrunk":
      return CableKind.FiberMPOTrunk;
    case 8:
    case "FiberMPOBreakout":
      return CableKind.FiberMPOBreakout;
    case 9:
    case "AOC":
      return CableKind.AOC;
    case 10:
    case "AOCBreakout":
      return CableKind.AOCBreakout;
    case 11:
    case "GenericBreakout":
      return CableKind.GenericBreakout;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CableKind.UNRECOGNIZED;
  }
}

export function cableKindToJSON(object: CableKind): string {
  switch (object) {
    case CableKind.CableKind_Undefined:
      return "CableKind_Undefined";
    case CableKind.Cat5:
      return "Cat5";
    case CableKind.Cat5e:
      return "Cat5e";
    case CableKind.Cat6:
      return "Cat6";
    case CableKind.DAC:
      return "DAC";
    case CableKind.DACBreakout:
      return "DACBreakout";
    case CableKind.FiberLC:
      return "FiberLC";
    case CableKind.FiberMPOTrunk:
      return "FiberMPOTrunk";
    case CableKind.FiberMPOBreakout:
      return "FiberMPOBreakout";
    case CableKind.AOC:
      return "AOC";
    case CableKind.AOCBreakout:
      return "AOCBreakout";
    case CableKind.GenericBreakout:
      return "GenericBreakout";
    case CableKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AllocMode {
  AllocMode_Undefined = 0,
  NoAlloc = 1,
  Net = 2,
  NetEmu = 3,
  Filesystem = 4,
  BlockDevice = 5,
  Physical = 6,
  Virtual = 7,
  Infrapod = 8,
  Physim = 9,
  UNRECOGNIZED = -1,
}

export function allocModeFromJSON(object: any): AllocMode {
  switch (object) {
    case 0:
    case "AllocMode_Undefined":
      return AllocMode.AllocMode_Undefined;
    case 1:
    case "NoAlloc":
      return AllocMode.NoAlloc;
    case 2:
    case "Net":
      return AllocMode.Net;
    case 3:
    case "NetEmu":
      return AllocMode.NetEmu;
    case 4:
    case "Filesystem":
      return AllocMode.Filesystem;
    case 5:
    case "BlockDevice":
      return AllocMode.BlockDevice;
    case 6:
    case "Physical":
      return AllocMode.Physical;
    case 7:
    case "Virtual":
      return AllocMode.Virtual;
    case 8:
    case "Infrapod":
      return AllocMode.Infrapod;
    case 9:
    case "Physim":
      return AllocMode.Physim;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AllocMode.UNRECOGNIZED;
  }
}

export function allocModeToJSON(object: AllocMode): string {
  switch (object) {
    case AllocMode.AllocMode_Undefined:
      return "AllocMode_Undefined";
    case AllocMode.NoAlloc:
      return "NoAlloc";
    case AllocMode.Net:
      return "Net";
    case AllocMode.NetEmu:
      return "NetEmu";
    case AllocMode.Filesystem:
      return "Filesystem";
    case AllocMode.BlockDevice:
      return "BlockDevice";
    case AllocMode.Physical:
      return "Physical";
    case AllocMode.Virtual:
      return "Virtual";
    case AllocMode.Infrapod:
      return "Infrapod";
    case AllocMode.Physim:
      return "Physim";
    case AllocMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Role {
  Role_unknown = 0,
  TbNode = 1,
  InfraServer = 2,
  ConsoleServer = 3,
  PowerController = 4,
  NetworkEmulator = 5,
  XpSwitch = 6,
  InfraSwitch = 7,
  MgmtSwitch = 8,
  Gateway = 9,
  Leaf = 10,
  Fabric = 11,
  Spine = 12,
  StorageServer = 13,
  InfrapodServer = 14,
  EtcdHost = 15,
  MinIOHost = 16,
  RexHost = 17,
  DriverHost = 18,
  ManagerHost = 19,
  CommanderHost = 20,
  SledHost = 21,
  RallyHost = 22,
  PDU = 23,
  EmuSwitch = 24,
  Hypervisor = 25,
  PhysicsSimulator = 26,
  Stem = 27,
  BorderGateway = 28,
  OpsServer = 29,
  UNRECOGNIZED = -1,
}

export function roleFromJSON(object: any): Role {
  switch (object) {
    case 0:
    case "Role_unknown":
      return Role.Role_unknown;
    case 1:
    case "TbNode":
      return Role.TbNode;
    case 2:
    case "InfraServer":
      return Role.InfraServer;
    case 3:
    case "ConsoleServer":
      return Role.ConsoleServer;
    case 4:
    case "PowerController":
      return Role.PowerController;
    case 5:
    case "NetworkEmulator":
      return Role.NetworkEmulator;
    case 6:
    case "XpSwitch":
      return Role.XpSwitch;
    case 7:
    case "InfraSwitch":
      return Role.InfraSwitch;
    case 8:
    case "MgmtSwitch":
      return Role.MgmtSwitch;
    case 9:
    case "Gateway":
      return Role.Gateway;
    case 10:
    case "Leaf":
      return Role.Leaf;
    case 11:
    case "Fabric":
      return Role.Fabric;
    case 12:
    case "Spine":
      return Role.Spine;
    case 13:
    case "StorageServer":
      return Role.StorageServer;
    case 14:
    case "InfrapodServer":
      return Role.InfrapodServer;
    case 15:
    case "EtcdHost":
      return Role.EtcdHost;
    case 16:
    case "MinIOHost":
      return Role.MinIOHost;
    case 17:
    case "RexHost":
      return Role.RexHost;
    case 18:
    case "DriverHost":
      return Role.DriverHost;
    case 19:
    case "ManagerHost":
      return Role.ManagerHost;
    case 20:
    case "CommanderHost":
      return Role.CommanderHost;
    case 21:
    case "SledHost":
      return Role.SledHost;
    case 22:
    case "RallyHost":
      return Role.RallyHost;
    case 23:
    case "PDU":
      return Role.PDU;
    case 24:
    case "EmuSwitch":
      return Role.EmuSwitch;
    case 25:
    case "Hypervisor":
      return Role.Hypervisor;
    case 26:
    case "PhysicsSimulator":
      return Role.PhysicsSimulator;
    case 27:
    case "Stem":
      return Role.Stem;
    case 28:
    case "BorderGateway":
      return Role.BorderGateway;
    case 29:
    case "OpsServer":
      return Role.OpsServer;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Role.UNRECOGNIZED;
  }
}

export function roleToJSON(object: Role): string {
  switch (object) {
    case Role.Role_unknown:
      return "Role_unknown";
    case Role.TbNode:
      return "TbNode";
    case Role.InfraServer:
      return "InfraServer";
    case Role.ConsoleServer:
      return "ConsoleServer";
    case Role.PowerController:
      return "PowerController";
    case Role.NetworkEmulator:
      return "NetworkEmulator";
    case Role.XpSwitch:
      return "XpSwitch";
    case Role.InfraSwitch:
      return "InfraSwitch";
    case Role.MgmtSwitch:
      return "MgmtSwitch";
    case Role.Gateway:
      return "Gateway";
    case Role.Leaf:
      return "Leaf";
    case Role.Fabric:
      return "Fabric";
    case Role.Spine:
      return "Spine";
    case Role.StorageServer:
      return "StorageServer";
    case Role.InfrapodServer:
      return "InfrapodServer";
    case Role.EtcdHost:
      return "EtcdHost";
    case Role.MinIOHost:
      return "MinIOHost";
    case Role.RexHost:
      return "RexHost";
    case Role.DriverHost:
      return "DriverHost";
    case Role.ManagerHost:
      return "ManagerHost";
    case Role.CommanderHost:
      return "CommanderHost";
    case Role.SledHost:
      return "SledHost";
    case Role.RallyHost:
      return "RallyHost";
    case Role.PDU:
      return "PDU";
    case Role.EmuSwitch:
      return "EmuSwitch";
    case Role.Hypervisor:
      return "Hypervisor";
    case Role.PhysicsSimulator:
      return "PhysicsSimulator";
    case Role.Stem:
      return "Stem";
    case Role.BorderGateway:
      return "BorderGateway";
    case Role.OpsServer:
      return "OpsServer";
    case Role.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LinkRole {
  LinkRole_Unspecified = 0,
  InfraLink = 1,
  XpLink = 2,
  Tor = 3,
  EmuLink = 4,
  MgmtLink = 5,
  GatewayLink = 6,
  SimLink = 7,
  HarborEndpoint = 8,
  UNRECOGNIZED = -1,
}

export function linkRoleFromJSON(object: any): LinkRole {
  switch (object) {
    case 0:
    case "LinkRole_Unspecified":
      return LinkRole.LinkRole_Unspecified;
    case 1:
    case "InfraLink":
      return LinkRole.InfraLink;
    case 2:
    case "XpLink":
      return LinkRole.XpLink;
    case 3:
    case "Tor":
      return LinkRole.Tor;
    case 4:
    case "EmuLink":
      return LinkRole.EmuLink;
    case 5:
    case "MgmtLink":
      return LinkRole.MgmtLink;
    case 6:
    case "GatewayLink":
      return LinkRole.GatewayLink;
    case 7:
    case "SimLink":
      return LinkRole.SimLink;
    case 8:
    case "HarborEndpoint":
      return LinkRole.HarborEndpoint;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LinkRole.UNRECOGNIZED;
  }
}

export function linkRoleToJSON(object: LinkRole): string {
  switch (object) {
    case LinkRole.LinkRole_Unspecified:
      return "LinkRole_Unspecified";
    case LinkRole.InfraLink:
      return "InfraLink";
    case LinkRole.XpLink:
      return "XpLink";
    case LinkRole.Tor:
      return "Tor";
    case LinkRole.EmuLink:
      return "EmuLink";
    case LinkRole.MgmtLink:
      return "MgmtLink";
    case LinkRole.GatewayLink:
      return "GatewayLink";
    case LinkRole.SimLink:
      return "SimLink";
    case LinkRole.HarborEndpoint:
      return "HarborEndpoint";
    case LinkRole.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DiskRole {
  DiskRole_Unspecified = 0,
  System = 1,
  MinIO = 2,
  Etcd = 3,
  Rally = 4,
  Mariner = 5,
  UNRECOGNIZED = -1,
}

export function diskRoleFromJSON(object: any): DiskRole {
  switch (object) {
    case 0:
    case "DiskRole_Unspecified":
      return DiskRole.DiskRole_Unspecified;
    case 1:
    case "System":
      return DiskRole.System;
    case 2:
    case "MinIO":
      return DiskRole.MinIO;
    case 3:
    case "Etcd":
      return DiskRole.Etcd;
    case 4:
    case "Rally":
      return DiskRole.Rally;
    case 5:
    case "Mariner":
      return DiskRole.Mariner;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DiskRole.UNRECOGNIZED;
  }
}

export function diskRoleToJSON(object: DiskRole): string {
  switch (object) {
    case DiskRole.DiskRole_Unspecified:
      return "DiskRole_Unspecified";
    case DiskRole.System:
      return "System";
    case DiskRole.MinIO:
      return "MinIO";
    case DiskRole.Etcd:
      return "Etcd";
    case DiskRole.Rally:
      return "Rally";
    case DiskRole.Mariner:
      return "Mariner";
    case DiskRole.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Operator {
  Op_Undefined = 0,
  LT = 1,
  LE = 2,
  GT = 3,
  GE = 4,
  EQ = 5,
  NE = 6,
  UNRECOGNIZED = -1,
}

export function operatorFromJSON(object: any): Operator {
  switch (object) {
    case 0:
    case "Op_Undefined":
      return Operator.Op_Undefined;
    case 1:
    case "LT":
      return Operator.LT;
    case 2:
    case "LE":
      return Operator.LE;
    case 3:
    case "GT":
      return Operator.GT;
    case 4:
    case "GE":
      return Operator.GE;
    case 5:
    case "EQ":
      return Operator.EQ;
    case 6:
    case "NE":
      return Operator.NE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Operator.UNRECOGNIZED;
  }
}

export function operatorToJSON(object: Operator): string {
  switch (object) {
    case Operator.Op_Undefined:
      return "Op_Undefined";
    case Operator.LT:
      return "LT";
    case Operator.LE:
      return "LE";
    case Operator.GT:
      return "GT";
    case Operator.GE:
      return "GE";
    case Operator.EQ:
      return "EQ";
    case Operator.NE:
      return "NE";
    case Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Facility {
  id: string;
  fqdn: string;
  resources: Resource[];
  cables: Cable[];
}

export interface Network {
  id: string;
  nodes: Node[];
  links: Link[];
  parameters: ExperimentParameters | undefined;
}

export interface ExperimentParameters {
  routing: RoutingConstraint | undefined;
  addressing: AddressingConstraint | undefined;
  hypervisors: string[];
  simulators: string[];
  emulators: string[];
  /** If true, resolve experiment names before infra names */
  experimentnetresolution: boolean;
  emulation: EmulationConstraint | undefined;
}

export interface Properties {
  keyvalues: { [key: string]: Properties_Values };
}

export interface Properties_Values {
  values: string[];
}

export interface Properties_KeyvaluesEntry {
  key: string;
  value: Properties_Values | undefined;
}

export interface Node {
  id: string;
  sockets: Socket[];
  proc: ProcSpec | undefined;
  memory: MemorySpec | undefined;
  NIC: NICSpec | undefined;
  disks: DiskSpec | undefined;
  metal: BoolConstraint | undefined;
  virt: BoolConstraint | undefined;
  image:
    | StringConstraint
    | undefined;
  /** TODO: should be enum? */
  platform: StringConstraint | undefined;
  viz: Visualization | undefined;
  conf:
    | NodeConfig
    | undefined;
  /** Run time and post-publish properties */
  properties: Properties | undefined;
  host: StringConstraint | undefined;
}

export interface NodeConfig {
  routes: RouteConfig[];
}

export interface RouteConfig {
  src: string;
  gw: string;
  dst: string;
}

export interface Visualization {
  color: string;
  size: number;
}

export interface Ref {
  element: string;
  index: number;
  subref: Subref | undefined;
}

export interface Subref {
  index: number;
}

export interface Socket {
  index: number;
  addrs: string[];
  endpoint: Ref | undefined;
  port: PortSpec | undefined;
}

export interface RouteConf {
  src: string;
  gw: string;
  dst: string;
}

export interface Link {
  id: string;
  latency: Uint64Constraint | undefined;
  capacity: Uint64Constraint | undefined;
  loss: FloatConstraint | undefined;
  endpoints: Endpoint[];
  kind: LinkKindConstraint | undefined;
  layer:
    | Uint64Constraint
    | undefined;
  /** Run time and post-publish properties */
  properties: Properties | undefined;
}

export enum Link_Kind {
  unspec = 0,
  ethernet = 1,
  wifi = 2,
  wifi_ac = 3,
  wifi_ax = 4,
  lte_4g = 5,
  lte_5g = 6,
  UNRECOGNIZED = -1,
}

export function link_KindFromJSON(object: any): Link_Kind {
  switch (object) {
    case 0:
    case "unspec":
      return Link_Kind.unspec;
    case 1:
    case "ethernet":
      return Link_Kind.ethernet;
    case 2:
    case "wifi":
      return Link_Kind.wifi;
    case 3:
    case "wifi_ac":
      return Link_Kind.wifi_ac;
    case 4:
    case "wifi_ax":
      return Link_Kind.wifi_ax;
    case 5:
    case "lte_4g":
      return Link_Kind.lte_4g;
    case 6:
    case "lte_5g":
      return Link_Kind.lte_5g;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Link_Kind.UNRECOGNIZED;
  }
}

export function link_KindToJSON(object: Link_Kind): string {
  switch (object) {
    case Link_Kind.unspec:
      return "unspec";
    case Link_Kind.ethernet:
      return "ethernet";
    case Link_Kind.wifi:
      return "wifi";
    case Link_Kind.wifi_ac:
      return "wifi_ac";
    case Link_Kind.wifi_ax:
      return "wifi_ax";
    case Link_Kind.lte_4g:
      return "lte_4g";
    case Link_Kind.lte_5g:
      return "lte_5g";
    case Link_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Endpoint {
  index: number;
  socket: Ref | undefined;
  connector: ConnectorSpec | undefined;
}

export interface Phyo {
  id: string;
  eqtns: string[];
}

export interface Variable {
}

export interface Bond {
}

export interface Coupling {
}

export interface Sensor {
  id: string;
  var: string;
  rate: number;
  target: string;
  tag: number;
}

export interface Actuator {
  id: string;
  var: string;
  dynamicLimits: Limits | undefined;
  staticLimits: Limits | undefined;
  tag: number;
}

export interface Limits {
  lower: number;
  upper: number;
}

export interface ProductInfo {
  Manufacturer: string;
  Model: string;
  SKU: string;
  Integrated: boolean;
  cost: number;
}

export interface Resource {
  id: string;
  facility: string;
  procs: Proc[];
  memory: Dimm[];
  NICs: NIC[];
  disks: Disk[];
  alloc: AllocMode[];
  roles: Role[];
  firmware: Firmware | undefined;
  OS: OSConfig | undefined;
  productInfo: ProductInfo | undefined;
  TPA: number;
  ipmi?: BMC | undefined;
  relayboard?: RelayBoard | undefined;
  pdu?: PowerDistributionUnit | undefined;
  raven?: Raven | undefined;
  leafConfig:
    | LeafConfig
    | undefined;
  /** indexed by vrf */
  infranetAddr: { [key: string]: AddressList };
}

export interface Resource_InfranetAddrEntry {
  key: string;
  value: AddressList | undefined;
}

export interface BMC {
  host: string;
  kind: BMC_Kind;
}

export enum BMC_Kind {
  IPMI = 0,
  RedFish = 1,
  IPMIRedFish = 2,
  UNRECOGNIZED = -1,
}

export function bMC_KindFromJSON(object: any): BMC_Kind {
  switch (object) {
    case 0:
    case "IPMI":
      return BMC_Kind.IPMI;
    case 1:
    case "RedFish":
      return BMC_Kind.RedFish;
    case 2:
    case "IPMIRedFish":
      return BMC_Kind.IPMIRedFish;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BMC_Kind.UNRECOGNIZED;
  }
}

export function bMC_KindToJSON(object: BMC_Kind): string {
  switch (object) {
    case BMC_Kind.IPMI:
      return "IPMI";
    case BMC_Kind.RedFish:
      return "RedFish";
    case BMC_Kind.IPMIRedFish:
      return "IPMIRedFish";
    case BMC_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RelayBoard {
  host: string;
  index: number;
  kind: RelayBoard_Kind;
}

export enum RelayBoard_Kind {
  NCDFusion = 0,
  UNRECOGNIZED = -1,
}

export function relayBoard_KindFromJSON(object: any): RelayBoard_Kind {
  switch (object) {
    case 0:
    case "NCDFusion":
      return RelayBoard_Kind.NCDFusion;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RelayBoard_Kind.UNRECOGNIZED;
  }
}

export function relayBoard_KindToJSON(object: RelayBoard_Kind): string {
  switch (object) {
    case RelayBoard_Kind.NCDFusion:
      return "NCDFusion";
    case RelayBoard_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PowerDistributionUnit {
  host: string;
  outlets: number[];
  kind: PowerDistributionUnit_Kind;
}

export enum PowerDistributionUnit_Kind {
  APC = 0,
  UNRECOGNIZED = -1,
}

export function powerDistributionUnit_KindFromJSON(object: any): PowerDistributionUnit_Kind {
  switch (object) {
    case 0:
    case "APC":
      return PowerDistributionUnit_Kind.APC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PowerDistributionUnit_Kind.UNRECOGNIZED;
  }
}

export function powerDistributionUnit_KindToJSON(object: PowerDistributionUnit_Kind): string {
  switch (object) {
    case PowerDistributionUnit_Kind.APC:
      return "APC";
    case PowerDistributionUnit_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Raven {
  host: string;
}

export interface Firmware {
  kind: Firmware_Kind;
}

export enum Firmware_Kind {
  Undefined = 0,
  UEFI = 1,
  BIOS = 2,
  UNRECOGNIZED = -1,
}

export function firmware_KindFromJSON(object: any): Firmware_Kind {
  switch (object) {
    case 0:
    case "Undefined":
      return Firmware_Kind.Undefined;
    case 1:
    case "UEFI":
      return Firmware_Kind.UEFI;
    case 2:
    case "BIOS":
      return Firmware_Kind.BIOS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Firmware_Kind.UNRECOGNIZED;
  }
}

export function firmware_KindToJSON(object: Firmware_Kind): string {
  switch (object) {
    case Firmware_Kind.Undefined:
      return "Undefined";
    case Firmware_Kind.UEFI:
      return "UEFI";
    case Firmware_Kind.BIOS:
      return "BIOS";
    case Firmware_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ResourceAllocation {
  resource: string;
  facility: string;
  mzid: string;
  node: string;
  procs: ProcAllocation | undefined;
  memory: MemoryAllocation | undefined;
  NICs: NICsAllocation | undefined;
  disks: DisksAllocation | undefined;
  model: Node | undefined;
  revision: number;
  virtual: boolean;
}

export interface CableAllocation {
  cable: string;
  facility: string;
  mzid: string;
  link: string;
  capacity: number;
  revision: number;
}

export interface AddressList {
  list: string[];
}

export interface LeafConfig {
  serviceAddressBlocks: AddressList | undefined;
  tenantAddressBlocks:
    | AddressList
    | undefined;
  /** interface -> address block */
  infrapodAddressBlocks: { [key: string]: AddressList };
}

export interface LeafConfig_InfrapodAddressBlocksEntry {
  key: string;
  value: AddressList | undefined;
}

export interface OSConfig {
  BGP: BGPRouterConfig[];
  bridge: BridgeConfig[];
  VLAN: VLANConfig[];
  /** map key is VxLAN VNI */
  serviceEndpoints: { [key: number]: ServiceEndpoint };
  append: string;
  rootdev: string;
  defaultImage: string;
}

export interface OSConfig_ServiceEndpointsEntry {
  key: number;
  value: ServiceEndpoint | undefined;
}

export interface ServiceEndpoint {
  address: string;
}

export interface VLANConfig {
  device: string;
  vid: number;
  addrs: string[];
  role: LinkRole;
}

export interface InterfaceConfig {
  address: string;
  interface: string;
  role: LinkRole;
}

export interface BGPRouterConfig {
  vrf: string;
  ASN: number;
  /** XXX this is not really the way of things */
  Interfaces: InterfaceConfig[];
  EVPN: EVPNConfig | undefined;
}

export interface EVPNConfig {
  TunnelEndpoints: InterfaceConfig[];
}

export interface BridgeConfig {
  name: string;
  vlanAware: boolean;
  addrs: string[];
  role: LinkRole;
}

export interface Breakout {
  index: number;
  radix: number;
}

export interface PortBond {
  name: string;
}

/** SRIOV data */
export interface sriovPf {
  MaxVFs: number;
}

export interface sriovVf {
  /** from 0 to PF's (maxVFs-1) */
  VfIndex: number;
}

export interface SRIOV {
  Pf?: sriovPf | undefined;
  Vf?:
    | sriovVf
    | undefined;
  /**
   * the following two are for quick lookup of PF ports in:
   * Resource.NICs[PfNi].Ports[PfPi] -> Port
   * Node.Nic[PfNi][PfPi] -> PortSpec
   * ResourceAllocation.NICs.Alloc[PfNi].Alloc[PfPi] -> PortAllocation
   */
  PfNi: number;
  PfPi: number;
}

export interface Port {
  parent: string;
  /** starting from 0 for all ports (excl breakouts) of all NICs within a Resource */
  index: number;
  protocols: Layer1[];
  capacity: number;
  mac: string;
  formFactor: ConnectorKind;
  connector: Ref | undefined;
  role: LinkRole;
  TPA: number;
  queues: number;
  breakout: Breakout | undefined;
  bond: PortBond | undefined;
  name: string;
  sriov: SRIOV | undefined;
}

export interface PortAllocation {
  name: string;
  mac: string;
  /**
   * for VFs: the bandwidth allocated
   * for PFs: the aggregate allocated bandwidth (across all allocated vfs)
   */
  capacity: number;
  /** when describing VM, name can be eth0, eth1, etc. while VfName will be the host's actual vf dev */
  VfName: string;
  /** for PFs: this port has indirect (VF) allocations */
  VfAlloc: boolean;
}

export interface PortRef {
  mac: string;
}

export interface PortSpec {
  protocols: Layer1[];
  capacity: Uint64Constraint | undefined;
  formFactor: ConnectorKindConstraint | undefined;
  queues: Uint64Constraint | undefined;
  model: NICModelConstraint | undefined;
  DPDK: BoolConstraint | undefined;
  SriovVF: BoolConstraint | undefined;
}

export interface Cable {
  id: string;
  facility: string;
  kind: CableKind;
  ends: End[];
  productInfo: ProductInfo | undefined;
}

export interface End {
  connectors: Connector[];
}

export interface Connector {
  parent: string;
  index: number;
  kind: ConnectorKind;
  protocols: Layer1[];
  capacity: number;
  Port: Ref | undefined;
  breakout: Breakout | undefined;
}

export interface ConnectorSpec {
  kind: ConnectorKindConstraint | undefined;
  protocols: Layer1[];
  capacity: number;
}

export interface Proc {
  isa: ISA;
  family: string;
  BaseFrequency: number;
  L2: number;
  cores: number;
  threads: number;
  tdp: number;
  hyperthreaded: boolean;
  productInfo:
    | ProductInfo
    | undefined;
  /** marked as not-available for the testbed use */
  reservedCores: number;
}

export interface SocketAllocation {
  cores: number;
}

export interface ProcAllocation {
  alloc: { [key: number]: SocketAllocation };
}

export interface ProcAllocation_AllocEntry {
  key: number;
  value: SocketAllocation | undefined;
}

export interface ProcSpec {
  isa: ISAConstraint | undefined;
  family: StringConstraint | undefined;
  BaseFrequency: Uint64Constraint | undefined;
  L2: Uint64Constraint | undefined;
  cores: Uint32Constraint | undefined;
  threads: Uint32Constraint | undefined;
  tdp: Uint32Constraint | undefined;
  sockets: Uint32Constraint | undefined;
  hyperthreaded: BoolConstraint | undefined;
}

export interface Dimm {
  type: MemoryType;
  /** total */
  capacity: number;
  frequency: number;
  productInfo:
    | ProductInfo
    | undefined;
  /** marked as not-available for the testbed use */
  reservedCapacity: number;
}

export interface DimmAllocation {
  capacity: number;
}

export interface MemoryAllocation {
  alloc: { [key: number]: DimmAllocation };
}

export interface MemoryAllocation_AllocEntry {
  key: number;
  value: DimmAllocation | undefined;
}

export interface MemorySpec {
  type: MemoryTypeConstraint | undefined;
  capacity: Uint64Constraint | undefined;
  frequency: Uint64Constraint | undefined;
  modules: Uint64Constraint | undefined;
}

export interface NIC {
  ports: Port[];
  startingIndex: number;
  kind: NICKind;
  productInfo: ProductInfo | undefined;
  DPDK: boolean;
  model: NICModel;
}

export interface NICSpec {
  ports: PortSpec[];
}

export interface NICAllocation {
  alloc: { [key: number]: PortAllocation };
}

export interface NICAllocation_AllocEntry {
  key: number;
  value: PortAllocation | undefined;
}

export interface NICsAllocation {
  alloc: { [key: number]: NICAllocation };
}

export interface NICsAllocation_AllocEntry {
  key: number;
  value: NICAllocation | undefined;
}

export interface Disk {
  capacity: number;
  formFactor: DiskFormFactor;
  diskInterface: DiskInterface;
  productInfo: ProductInfo | undefined;
  roles: DiskRole[];
  NVMEControllerIndex: number;
}

export interface DiskAllocation {
  capacity: number;
}

export interface DisksAllocation {
  alloc: { [key: number]: DiskAllocation };
}

export interface DisksAllocation_AllocEntry {
  key: number;
  value: DiskAllocation | undefined;
}

export interface DiskSpec {
  capacity: Uint64Constraint | undefined;
  formFactor: DiskFormFactorConstraint | undefined;
  diskInterface: DiskInterfaceConstraint | undefined;
  disks: Uint64Constraint | undefined;
}

export interface BoolConstraint {
  op: Operator;
  value: boolean;
}

export interface StringConstraint {
  op: Operator;
  value: string;
}

export interface Uint64Constraint {
  op: Operator;
  value: number;
}

export interface LinkKindConstraint {
  op: Operator;
  value: Link_Kind;
}

export interface Uint32Constraint {
  op: Operator;
  value: number;
}

export interface ISAConstraint {
  op: Operator;
  value: ISA;
}

export interface MemoryTypeConstraint {
  op: Operator;
  value: MemoryType;
}

export interface NICModelConstraint {
  op: Operator;
  value: NICModel;
}

export interface DiskFormFactorConstraint {
  op: Operator;
  value: DiskFormFactor;
}

export interface DiskInterfaceConstraint {
  op: Operator;
  value: DiskInterface;
}

export interface ConnectorKindConstraint {
  op: Operator;
  value: ConnectorKind;
}

export interface FloatConstraint {
  op: Operator;
  value: number;
}

export interface RoutingConstraint {
  op: Operator;
  value: Routing;
}

export interface AddressingConstraint {
  op: Operator;
  value: Addressing;
}

export interface EmulationConstraint {
  op: Operator;
  value: Emulation;
}

function createBaseFacility(): Facility {
  return { id: "", fqdn: "", resources: [], cables: [] };
}

export const Facility = {
  encode(message: Facility, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.fqdn !== "") {
      writer.uint32(18).string(message.fqdn);
    }
    for (const v of message.resources) {
      Resource.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.cables) {
      Cable.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Facility {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFacility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.fqdn = reader.string();
          break;
        case 3:
          message.resources.push(Resource.decode(reader, reader.uint32()));
          break;
        case 4:
          message.cables.push(Cable.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Facility {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      fqdn: isSet(object.fqdn) ? String(object.fqdn) : "",
      resources: Array.isArray(object?.resources) ? object.resources.map((e: any) => Resource.fromJSON(e)) : [],
      cables: Array.isArray(object?.cables) ? object.cables.map((e: any) => Cable.fromJSON(e)) : [],
    };
  },

  toJSON(message: Facility): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.fqdn !== undefined && (obj.fqdn = message.fqdn);
    if (message.resources) {
      obj.resources = message.resources.map((e) => e ? Resource.toJSON(e) : undefined);
    } else {
      obj.resources = [];
    }
    if (message.cables) {
      obj.cables = message.cables.map((e) => e ? Cable.toJSON(e) : undefined);
    } else {
      obj.cables = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Facility>, I>>(base?: I): Facility {
    return Facility.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Facility>, I>>(object: I): Facility {
    const message = createBaseFacility();
    message.id = object.id ?? "";
    message.fqdn = object.fqdn ?? "";
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || [];
    message.cables = object.cables?.map((e) => Cable.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNetwork(): Network {
  return { id: "", nodes: [], links: [], parameters: undefined };
}

export const Network = {
  encode(message: Network, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.links) {
      Link.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.parameters !== undefined) {
      ExperimentParameters.encode(message.parameters, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Network {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetwork();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.nodes.push(Node.decode(reader, reader.uint32()));
          break;
        case 3:
          message.links.push(Link.decode(reader, reader.uint32()));
          break;
        case 4:
          message.parameters = ExperimentParameters.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Network {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      nodes: Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [],
      links: Array.isArray(object?.links) ? object.links.map((e: any) => Link.fromJSON(e)) : [],
      parameters: isSet(object.parameters) ? ExperimentParameters.fromJSON(object.parameters) : undefined,
    };
  },

  toJSON(message: Network): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    if (message.nodes) {
      obj.nodes = message.nodes.map((e) => e ? Node.toJSON(e) : undefined);
    } else {
      obj.nodes = [];
    }
    if (message.links) {
      obj.links = message.links.map((e) => e ? Link.toJSON(e) : undefined);
    } else {
      obj.links = [];
    }
    message.parameters !== undefined &&
      (obj.parameters = message.parameters ? ExperimentParameters.toJSON(message.parameters) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Network>, I>>(base?: I): Network {
    return Network.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Network>, I>>(object: I): Network {
    const message = createBaseNetwork();
    message.id = object.id ?? "";
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    message.links = object.links?.map((e) => Link.fromPartial(e)) || [];
    message.parameters = (object.parameters !== undefined && object.parameters !== null)
      ? ExperimentParameters.fromPartial(object.parameters)
      : undefined;
    return message;
  },
};

function createBaseExperimentParameters(): ExperimentParameters {
  return {
    routing: undefined,
    addressing: undefined,
    hypervisors: [],
    simulators: [],
    emulators: [],
    experimentnetresolution: false,
    emulation: undefined,
  };
}

export const ExperimentParameters = {
  encode(message: ExperimentParameters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.routing !== undefined) {
      RoutingConstraint.encode(message.routing, writer.uint32(10).fork()).ldelim();
    }
    if (message.addressing !== undefined) {
      AddressingConstraint.encode(message.addressing, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.hypervisors) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.simulators) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.emulators) {
      writer.uint32(42).string(v!);
    }
    if (message.experimentnetresolution === true) {
      writer.uint32(48).bool(message.experimentnetresolution);
    }
    if (message.emulation !== undefined) {
      EmulationConstraint.encode(message.emulation, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExperimentParameters {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExperimentParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.routing = RoutingConstraint.decode(reader, reader.uint32());
          break;
        case 2:
          message.addressing = AddressingConstraint.decode(reader, reader.uint32());
          break;
        case 3:
          message.hypervisors.push(reader.string());
          break;
        case 4:
          message.simulators.push(reader.string());
          break;
        case 5:
          message.emulators.push(reader.string());
          break;
        case 6:
          message.experimentnetresolution = reader.bool();
          break;
        case 7:
          message.emulation = EmulationConstraint.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ExperimentParameters {
    return {
      routing: isSet(object.routing) ? RoutingConstraint.fromJSON(object.routing) : undefined,
      addressing: isSet(object.addressing) ? AddressingConstraint.fromJSON(object.addressing) : undefined,
      hypervisors: Array.isArray(object?.hypervisors) ? object.hypervisors.map((e: any) => String(e)) : [],
      simulators: Array.isArray(object?.simulators) ? object.simulators.map((e: any) => String(e)) : [],
      emulators: Array.isArray(object?.emulators) ? object.emulators.map((e: any) => String(e)) : [],
      experimentnetresolution: isSet(object.experimentnetresolution) ? Boolean(object.experimentnetresolution) : false,
      emulation: isSet(object.emulation) ? EmulationConstraint.fromJSON(object.emulation) : undefined,
    };
  },

  toJSON(message: ExperimentParameters): unknown {
    const obj: any = {};
    message.routing !== undefined &&
      (obj.routing = message.routing ? RoutingConstraint.toJSON(message.routing) : undefined);
    message.addressing !== undefined &&
      (obj.addressing = message.addressing ? AddressingConstraint.toJSON(message.addressing) : undefined);
    if (message.hypervisors) {
      obj.hypervisors = message.hypervisors.map((e) => e);
    } else {
      obj.hypervisors = [];
    }
    if (message.simulators) {
      obj.simulators = message.simulators.map((e) => e);
    } else {
      obj.simulators = [];
    }
    if (message.emulators) {
      obj.emulators = message.emulators.map((e) => e);
    } else {
      obj.emulators = [];
    }
    message.experimentnetresolution !== undefined && (obj.experimentnetresolution = message.experimentnetresolution);
    message.emulation !== undefined &&
      (obj.emulation = message.emulation ? EmulationConstraint.toJSON(message.emulation) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<ExperimentParameters>, I>>(base?: I): ExperimentParameters {
    return ExperimentParameters.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ExperimentParameters>, I>>(object: I): ExperimentParameters {
    const message = createBaseExperimentParameters();
    message.routing = (object.routing !== undefined && object.routing !== null)
      ? RoutingConstraint.fromPartial(object.routing)
      : undefined;
    message.addressing = (object.addressing !== undefined && object.addressing !== null)
      ? AddressingConstraint.fromPartial(object.addressing)
      : undefined;
    message.hypervisors = object.hypervisors?.map((e) => e) || [];
    message.simulators = object.simulators?.map((e) => e) || [];
    message.emulators = object.emulators?.map((e) => e) || [];
    message.experimentnetresolution = object.experimentnetresolution ?? false;
    message.emulation = (object.emulation !== undefined && object.emulation !== null)
      ? EmulationConstraint.fromPartial(object.emulation)
      : undefined;
    return message;
  },
};

function createBaseProperties(): Properties {
  return { keyvalues: {} };
}

export const Properties = {
  encode(message: Properties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.keyvalues).forEach(([key, value]) => {
      Properties_KeyvaluesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Properties {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = Properties_KeyvaluesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.keyvalues[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Properties {
    return {
      keyvalues: isObject(object.keyvalues)
        ? Object.entries(object.keyvalues).reduce<{ [key: string]: Properties_Values }>((acc, [key, value]) => {
          acc[key] = Properties_Values.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Properties): unknown {
    const obj: any = {};
    obj.keyvalues = {};
    if (message.keyvalues) {
      Object.entries(message.keyvalues).forEach(([k, v]) => {
        obj.keyvalues[k] = Properties_Values.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Properties>, I>>(base?: I): Properties {
    return Properties.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Properties>, I>>(object: I): Properties {
    const message = createBaseProperties();
    message.keyvalues = Object.entries(object.keyvalues ?? {}).reduce<{ [key: string]: Properties_Values }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Properties_Values.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseProperties_Values(): Properties_Values {
  return { values: [] };
}

export const Properties_Values = {
  encode(message: Properties_Values, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Properties_Values {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProperties_Values();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.values.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Properties_Values {
    return { values: Array.isArray(object?.values) ? object.values.map((e: any) => String(e)) : [] };
  },

  toJSON(message: Properties_Values): unknown {
    const obj: any = {};
    if (message.values) {
      obj.values = message.values.map((e) => e);
    } else {
      obj.values = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Properties_Values>, I>>(base?: I): Properties_Values {
    return Properties_Values.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Properties_Values>, I>>(object: I): Properties_Values {
    const message = createBaseProperties_Values();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseProperties_KeyvaluesEntry(): Properties_KeyvaluesEntry {
  return { key: "", value: undefined };
}

export const Properties_KeyvaluesEntry = {
  encode(message: Properties_KeyvaluesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Properties_Values.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Properties_KeyvaluesEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProperties_KeyvaluesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = Properties_Values.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Properties_KeyvaluesEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Properties_Values.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Properties_KeyvaluesEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? Properties_Values.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Properties_KeyvaluesEntry>, I>>(base?: I): Properties_KeyvaluesEntry {
    return Properties_KeyvaluesEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Properties_KeyvaluesEntry>, I>>(object: I): Properties_KeyvaluesEntry {
    const message = createBaseProperties_KeyvaluesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Properties_Values.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseNode(): Node {
  return {
    id: "",
    sockets: [],
    proc: undefined,
    memory: undefined,
    NIC: undefined,
    disks: undefined,
    metal: undefined,
    virt: undefined,
    image: undefined,
    platform: undefined,
    viz: undefined,
    conf: undefined,
    properties: undefined,
    host: undefined,
  };
}

export const Node = {
  encode(message: Node, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.sockets) {
      Socket.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.proc !== undefined) {
      ProcSpec.encode(message.proc, writer.uint32(26).fork()).ldelim();
    }
    if (message.memory !== undefined) {
      MemorySpec.encode(message.memory, writer.uint32(34).fork()).ldelim();
    }
    if (message.NIC !== undefined) {
      NICSpec.encode(message.NIC, writer.uint32(42).fork()).ldelim();
    }
    if (message.disks !== undefined) {
      DiskSpec.encode(message.disks, writer.uint32(50).fork()).ldelim();
    }
    if (message.metal !== undefined) {
      BoolConstraint.encode(message.metal, writer.uint32(58).fork()).ldelim();
    }
    if (message.virt !== undefined) {
      BoolConstraint.encode(message.virt, writer.uint32(66).fork()).ldelim();
    }
    if (message.image !== undefined) {
      StringConstraint.encode(message.image, writer.uint32(74).fork()).ldelim();
    }
    if (message.platform !== undefined) {
      StringConstraint.encode(message.platform, writer.uint32(82).fork()).ldelim();
    }
    if (message.viz !== undefined) {
      Visualization.encode(message.viz, writer.uint32(90).fork()).ldelim();
    }
    if (message.conf !== undefined) {
      NodeConfig.encode(message.conf, writer.uint32(98).fork()).ldelim();
    }
    if (message.properties !== undefined) {
      Properties.encode(message.properties, writer.uint32(106).fork()).ldelim();
    }
    if (message.host !== undefined) {
      StringConstraint.encode(message.host, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Node {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.sockets.push(Socket.decode(reader, reader.uint32()));
          break;
        case 3:
          message.proc = ProcSpec.decode(reader, reader.uint32());
          break;
        case 4:
          message.memory = MemorySpec.decode(reader, reader.uint32());
          break;
        case 5:
          message.NIC = NICSpec.decode(reader, reader.uint32());
          break;
        case 6:
          message.disks = DiskSpec.decode(reader, reader.uint32());
          break;
        case 7:
          message.metal = BoolConstraint.decode(reader, reader.uint32());
          break;
        case 8:
          message.virt = BoolConstraint.decode(reader, reader.uint32());
          break;
        case 9:
          message.image = StringConstraint.decode(reader, reader.uint32());
          break;
        case 10:
          message.platform = StringConstraint.decode(reader, reader.uint32());
          break;
        case 11:
          message.viz = Visualization.decode(reader, reader.uint32());
          break;
        case 12:
          message.conf = NodeConfig.decode(reader, reader.uint32());
          break;
        case 13:
          message.properties = Properties.decode(reader, reader.uint32());
          break;
        case 14:
          message.host = StringConstraint.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      sockets: Array.isArray(object?.sockets) ? object.sockets.map((e: any) => Socket.fromJSON(e)) : [],
      proc: isSet(object.proc) ? ProcSpec.fromJSON(object.proc) : undefined,
      memory: isSet(object.memory) ? MemorySpec.fromJSON(object.memory) : undefined,
      NIC: isSet(object.NIC) ? NICSpec.fromJSON(object.NIC) : undefined,
      disks: isSet(object.disks) ? DiskSpec.fromJSON(object.disks) : undefined,
      metal: isSet(object.metal) ? BoolConstraint.fromJSON(object.metal) : undefined,
      virt: isSet(object.virt) ? BoolConstraint.fromJSON(object.virt) : undefined,
      image: isSet(object.image) ? StringConstraint.fromJSON(object.image) : undefined,
      platform: isSet(object.platform) ? StringConstraint.fromJSON(object.platform) : undefined,
      viz: isSet(object.viz) ? Visualization.fromJSON(object.viz) : undefined,
      conf: isSet(object.conf) ? NodeConfig.fromJSON(object.conf) : undefined,
      properties: isSet(object.properties) ? Properties.fromJSON(object.properties) : undefined,
      host: isSet(object.host) ? StringConstraint.fromJSON(object.host) : undefined,
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    if (message.sockets) {
      obj.sockets = message.sockets.map((e) => e ? Socket.toJSON(e) : undefined);
    } else {
      obj.sockets = [];
    }
    message.proc !== undefined && (obj.proc = message.proc ? ProcSpec.toJSON(message.proc) : undefined);
    message.memory !== undefined && (obj.memory = message.memory ? MemorySpec.toJSON(message.memory) : undefined);
    message.NIC !== undefined && (obj.NIC = message.NIC ? NICSpec.toJSON(message.NIC) : undefined);
    message.disks !== undefined && (obj.disks = message.disks ? DiskSpec.toJSON(message.disks) : undefined);
    message.metal !== undefined && (obj.metal = message.metal ? BoolConstraint.toJSON(message.metal) : undefined);
    message.virt !== undefined && (obj.virt = message.virt ? BoolConstraint.toJSON(message.virt) : undefined);
    message.image !== undefined && (obj.image = message.image ? StringConstraint.toJSON(message.image) : undefined);
    message.platform !== undefined &&
      (obj.platform = message.platform ? StringConstraint.toJSON(message.platform) : undefined);
    message.viz !== undefined && (obj.viz = message.viz ? Visualization.toJSON(message.viz) : undefined);
    message.conf !== undefined && (obj.conf = message.conf ? NodeConfig.toJSON(message.conf) : undefined);
    message.properties !== undefined &&
      (obj.properties = message.properties ? Properties.toJSON(message.properties) : undefined);
    message.host !== undefined && (obj.host = message.host ? StringConstraint.toJSON(message.host) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Node>, I>>(base?: I): Node {
    return Node.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Node>, I>>(object: I): Node {
    const message = createBaseNode();
    message.id = object.id ?? "";
    message.sockets = object.sockets?.map((e) => Socket.fromPartial(e)) || [];
    message.proc = (object.proc !== undefined && object.proc !== null) ? ProcSpec.fromPartial(object.proc) : undefined;
    message.memory = (object.memory !== undefined && object.memory !== null)
      ? MemorySpec.fromPartial(object.memory)
      : undefined;
    message.NIC = (object.NIC !== undefined && object.NIC !== null) ? NICSpec.fromPartial(object.NIC) : undefined;
    message.disks = (object.disks !== undefined && object.disks !== null)
      ? DiskSpec.fromPartial(object.disks)
      : undefined;
    message.metal = (object.metal !== undefined && object.metal !== null)
      ? BoolConstraint.fromPartial(object.metal)
      : undefined;
    message.virt = (object.virt !== undefined && object.virt !== null)
      ? BoolConstraint.fromPartial(object.virt)
      : undefined;
    message.image = (object.image !== undefined && object.image !== null)
      ? StringConstraint.fromPartial(object.image)
      : undefined;
    message.platform = (object.platform !== undefined && object.platform !== null)
      ? StringConstraint.fromPartial(object.platform)
      : undefined;
    message.viz = (object.viz !== undefined && object.viz !== null) ? Visualization.fromPartial(object.viz) : undefined;
    message.conf = (object.conf !== undefined && object.conf !== null)
      ? NodeConfig.fromPartial(object.conf)
      : undefined;
    message.properties = (object.properties !== undefined && object.properties !== null)
      ? Properties.fromPartial(object.properties)
      : undefined;
    message.host = (object.host !== undefined && object.host !== null)
      ? StringConstraint.fromPartial(object.host)
      : undefined;
    return message;
  },
};

function createBaseNodeConfig(): NodeConfig {
  return { routes: [] };
}

export const NodeConfig = {
  encode(message: NodeConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.routes) {
      RouteConfig.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NodeConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.routes.push(RouteConfig.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NodeConfig {
    return { routes: Array.isArray(object?.routes) ? object.routes.map((e: any) => RouteConfig.fromJSON(e)) : [] };
  },

  toJSON(message: NodeConfig): unknown {
    const obj: any = {};
    if (message.routes) {
      obj.routes = message.routes.map((e) => e ? RouteConfig.toJSON(e) : undefined);
    } else {
      obj.routes = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeConfig>, I>>(base?: I): NodeConfig {
    return NodeConfig.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<NodeConfig>, I>>(object: I): NodeConfig {
    const message = createBaseNodeConfig();
    message.routes = object.routes?.map((e) => RouteConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRouteConfig(): RouteConfig {
  return { src: "", gw: "", dst: "" };
}

export const RouteConfig = {
  encode(message: RouteConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.src !== "") {
      writer.uint32(10).string(message.src);
    }
    if (message.gw !== "") {
      writer.uint32(18).string(message.gw);
    }
    if (message.dst !== "") {
      writer.uint32(26).string(message.dst);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RouteConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.src = reader.string();
          break;
        case 2:
          message.gw = reader.string();
          break;
        case 3:
          message.dst = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RouteConfig {
    return {
      src: isSet(object.src) ? String(object.src) : "",
      gw: isSet(object.gw) ? String(object.gw) : "",
      dst: isSet(object.dst) ? String(object.dst) : "",
    };
  },

  toJSON(message: RouteConfig): unknown {
    const obj: any = {};
    message.src !== undefined && (obj.src = message.src);
    message.gw !== undefined && (obj.gw = message.gw);
    message.dst !== undefined && (obj.dst = message.dst);
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteConfig>, I>>(base?: I): RouteConfig {
    return RouteConfig.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RouteConfig>, I>>(object: I): RouteConfig {
    const message = createBaseRouteConfig();
    message.src = object.src ?? "";
    message.gw = object.gw ?? "";
    message.dst = object.dst ?? "";
    return message;
  },
};

function createBaseVisualization(): Visualization {
  return { color: "", size: 0 };
}

export const Visualization = {
  encode(message: Visualization, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.color !== "") {
      writer.uint32(10).string(message.color);
    }
    if (message.size !== 0) {
      writer.uint32(16).uint32(message.size);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Visualization {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVisualization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.color = reader.string();
          break;
        case 2:
          message.size = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Visualization {
    return {
      color: isSet(object.color) ? String(object.color) : "",
      size: isSet(object.size) ? Number(object.size) : 0,
    };
  },

  toJSON(message: Visualization): unknown {
    const obj: any = {};
    message.color !== undefined && (obj.color = message.color);
    message.size !== undefined && (obj.size = Math.round(message.size));
    return obj;
  },

  create<I extends Exact<DeepPartial<Visualization>, I>>(base?: I): Visualization {
    return Visualization.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Visualization>, I>>(object: I): Visualization {
    const message = createBaseVisualization();
    message.color = object.color ?? "";
    message.size = object.size ?? 0;
    return message;
  },
};

function createBaseRef(): Ref {
  return { element: "", index: 0, subref: undefined };
}

export const Ref = {
  encode(message: Ref, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.element !== "") {
      writer.uint32(10).string(message.element);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    if (message.subref !== undefined) {
      Subref.encode(message.subref, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Ref {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.element = reader.string();
          break;
        case 2:
          message.index = reader.uint32();
          break;
        case 3:
          message.subref = Subref.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Ref {
    return {
      element: isSet(object.element) ? String(object.element) : "",
      index: isSet(object.index) ? Number(object.index) : 0,
      subref: isSet(object.subref) ? Subref.fromJSON(object.subref) : undefined,
    };
  },

  toJSON(message: Ref): unknown {
    const obj: any = {};
    message.element !== undefined && (obj.element = message.element);
    message.index !== undefined && (obj.index = Math.round(message.index));
    message.subref !== undefined && (obj.subref = message.subref ? Subref.toJSON(message.subref) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Ref>, I>>(base?: I): Ref {
    return Ref.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Ref>, I>>(object: I): Ref {
    const message = createBaseRef();
    message.element = object.element ?? "";
    message.index = object.index ?? 0;
    message.subref = (object.subref !== undefined && object.subref !== null)
      ? Subref.fromPartial(object.subref)
      : undefined;
    return message;
  },
};

function createBaseSubref(): Subref {
  return { index: 0 };
}

export const Subref = {
  encode(message: Subref, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== 0) {
      writer.uint32(8).uint32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Subref {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubref();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.index = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Subref {
    return { index: isSet(object.index) ? Number(object.index) : 0 };
  },

  toJSON(message: Subref): unknown {
    const obj: any = {};
    message.index !== undefined && (obj.index = Math.round(message.index));
    return obj;
  },

  create<I extends Exact<DeepPartial<Subref>, I>>(base?: I): Subref {
    return Subref.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Subref>, I>>(object: I): Subref {
    const message = createBaseSubref();
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseSocket(): Socket {
  return { index: 0, addrs: [], endpoint: undefined, port: undefined };
}

export const Socket = {
  encode(message: Socket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    for (const v of message.addrs) {
      writer.uint32(18).string(v!);
    }
    if (message.endpoint !== undefined) {
      Ref.encode(message.endpoint, writer.uint32(26).fork()).ldelim();
    }
    if (message.port !== undefined) {
      PortSpec.encode(message.port, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Socket {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSocket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.index = reader.int32();
          break;
        case 2:
          message.addrs.push(reader.string());
          break;
        case 3:
          message.endpoint = Ref.decode(reader, reader.uint32());
          break;
        case 4:
          message.port = PortSpec.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Socket {
    return {
      index: isSet(object.index) ? Number(object.index) : 0,
      addrs: Array.isArray(object?.addrs) ? object.addrs.map((e: any) => String(e)) : [],
      endpoint: isSet(object.endpoint) ? Ref.fromJSON(object.endpoint) : undefined,
      port: isSet(object.port) ? PortSpec.fromJSON(object.port) : undefined,
    };
  },

  toJSON(message: Socket): unknown {
    const obj: any = {};
    message.index !== undefined && (obj.index = Math.round(message.index));
    if (message.addrs) {
      obj.addrs = message.addrs.map((e) => e);
    } else {
      obj.addrs = [];
    }
    message.endpoint !== undefined && (obj.endpoint = message.endpoint ? Ref.toJSON(message.endpoint) : undefined);
    message.port !== undefined && (obj.port = message.port ? PortSpec.toJSON(message.port) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Socket>, I>>(base?: I): Socket {
    return Socket.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Socket>, I>>(object: I): Socket {
    const message = createBaseSocket();
    message.index = object.index ?? 0;
    message.addrs = object.addrs?.map((e) => e) || [];
    message.endpoint = (object.endpoint !== undefined && object.endpoint !== null)
      ? Ref.fromPartial(object.endpoint)
      : undefined;
    message.port = (object.port !== undefined && object.port !== null) ? PortSpec.fromPartial(object.port) : undefined;
    return message;
  },
};

function createBaseRouteConf(): RouteConf {
  return { src: "", gw: "", dst: "" };
}

export const RouteConf = {
  encode(message: RouteConf, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.src !== "") {
      writer.uint32(10).string(message.src);
    }
    if (message.gw !== "") {
      writer.uint32(18).string(message.gw);
    }
    if (message.dst !== "") {
      writer.uint32(26).string(message.dst);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RouteConf {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteConf();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.src = reader.string();
          break;
        case 2:
          message.gw = reader.string();
          break;
        case 3:
          message.dst = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RouteConf {
    return {
      src: isSet(object.src) ? String(object.src) : "",
      gw: isSet(object.gw) ? String(object.gw) : "",
      dst: isSet(object.dst) ? String(object.dst) : "",
    };
  },

  toJSON(message: RouteConf): unknown {
    const obj: any = {};
    message.src !== undefined && (obj.src = message.src);
    message.gw !== undefined && (obj.gw = message.gw);
    message.dst !== undefined && (obj.dst = message.dst);
    return obj;
  },

  create<I extends Exact<DeepPartial<RouteConf>, I>>(base?: I): RouteConf {
    return RouteConf.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RouteConf>, I>>(object: I): RouteConf {
    const message = createBaseRouteConf();
    message.src = object.src ?? "";
    message.gw = object.gw ?? "";
    message.dst = object.dst ?? "";
    return message;
  },
};

function createBaseLink(): Link {
  return {
    id: "",
    latency: undefined,
    capacity: undefined,
    loss: undefined,
    endpoints: [],
    kind: undefined,
    layer: undefined,
    properties: undefined,
  };
}

export const Link = {
  encode(message: Link, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.latency !== undefined) {
      Uint64Constraint.encode(message.latency, writer.uint32(18).fork()).ldelim();
    }
    if (message.capacity !== undefined) {
      Uint64Constraint.encode(message.capacity, writer.uint32(26).fork()).ldelim();
    }
    if (message.loss !== undefined) {
      FloatConstraint.encode(message.loss, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.endpoints) {
      Endpoint.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.kind !== undefined) {
      LinkKindConstraint.encode(message.kind, writer.uint32(50).fork()).ldelim();
    }
    if (message.layer !== undefined) {
      Uint64Constraint.encode(message.layer, writer.uint32(58).fork()).ldelim();
    }
    if (message.properties !== undefined) {
      Properties.encode(message.properties, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Link {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.latency = Uint64Constraint.decode(reader, reader.uint32());
          break;
        case 3:
          message.capacity = Uint64Constraint.decode(reader, reader.uint32());
          break;
        case 4:
          message.loss = FloatConstraint.decode(reader, reader.uint32());
          break;
        case 5:
          message.endpoints.push(Endpoint.decode(reader, reader.uint32()));
          break;
        case 6:
          message.kind = LinkKindConstraint.decode(reader, reader.uint32());
          break;
        case 7:
          message.layer = Uint64Constraint.decode(reader, reader.uint32());
          break;
        case 8:
          message.properties = Properties.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Link {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      latency: isSet(object.latency) ? Uint64Constraint.fromJSON(object.latency) : undefined,
      capacity: isSet(object.capacity) ? Uint64Constraint.fromJSON(object.capacity) : undefined,
      loss: isSet(object.loss) ? FloatConstraint.fromJSON(object.loss) : undefined,
      endpoints: Array.isArray(object?.endpoints) ? object.endpoints.map((e: any) => Endpoint.fromJSON(e)) : [],
      kind: isSet(object.kind) ? LinkKindConstraint.fromJSON(object.kind) : undefined,
      layer: isSet(object.layer) ? Uint64Constraint.fromJSON(object.layer) : undefined,
      properties: isSet(object.properties) ? Properties.fromJSON(object.properties) : undefined,
    };
  },

  toJSON(message: Link): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.latency !== undefined &&
      (obj.latency = message.latency ? Uint64Constraint.toJSON(message.latency) : undefined);
    message.capacity !== undefined &&
      (obj.capacity = message.capacity ? Uint64Constraint.toJSON(message.capacity) : undefined);
    message.loss !== undefined && (obj.loss = message.loss ? FloatConstraint.toJSON(message.loss) : undefined);
    if (message.endpoints) {
      obj.endpoints = message.endpoints.map((e) => e ? Endpoint.toJSON(e) : undefined);
    } else {
      obj.endpoints = [];
    }
    message.kind !== undefined && (obj.kind = message.kind ? LinkKindConstraint.toJSON(message.kind) : undefined);
    message.layer !== undefined && (obj.layer = message.layer ? Uint64Constraint.toJSON(message.layer) : undefined);
    message.properties !== undefined &&
      (obj.properties = message.properties ? Properties.toJSON(message.properties) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Link>, I>>(base?: I): Link {
    return Link.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Link>, I>>(object: I): Link {
    const message = createBaseLink();
    message.id = object.id ?? "";
    message.latency = (object.latency !== undefined && object.latency !== null)
      ? Uint64Constraint.fromPartial(object.latency)
      : undefined;
    message.capacity = (object.capacity !== undefined && object.capacity !== null)
      ? Uint64Constraint.fromPartial(object.capacity)
      : undefined;
    message.loss = (object.loss !== undefined && object.loss !== null)
      ? FloatConstraint.fromPartial(object.loss)
      : undefined;
    message.endpoints = object.endpoints?.map((e) => Endpoint.fromPartial(e)) || [];
    message.kind = (object.kind !== undefined && object.kind !== null)
      ? LinkKindConstraint.fromPartial(object.kind)
      : undefined;
    message.layer = (object.layer !== undefined && object.layer !== null)
      ? Uint64Constraint.fromPartial(object.layer)
      : undefined;
    message.properties = (object.properties !== undefined && object.properties !== null)
      ? Properties.fromPartial(object.properties)
      : undefined;
    return message;
  },
};

function createBaseEndpoint(): Endpoint {
  return { index: 0, socket: undefined, connector: undefined };
}

export const Endpoint = {
  encode(message: Endpoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.socket !== undefined) {
      Ref.encode(message.socket, writer.uint32(18).fork()).ldelim();
    }
    if (message.connector !== undefined) {
      ConnectorSpec.encode(message.connector, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Endpoint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.index = reader.int32();
          break;
        case 2:
          message.socket = Ref.decode(reader, reader.uint32());
          break;
        case 3:
          message.connector = ConnectorSpec.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Endpoint {
    return {
      index: isSet(object.index) ? Number(object.index) : 0,
      socket: isSet(object.socket) ? Ref.fromJSON(object.socket) : undefined,
      connector: isSet(object.connector) ? ConnectorSpec.fromJSON(object.connector) : undefined,
    };
  },

  toJSON(message: Endpoint): unknown {
    const obj: any = {};
    message.index !== undefined && (obj.index = Math.round(message.index));
    message.socket !== undefined && (obj.socket = message.socket ? Ref.toJSON(message.socket) : undefined);
    message.connector !== undefined &&
      (obj.connector = message.connector ? ConnectorSpec.toJSON(message.connector) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Endpoint>, I>>(base?: I): Endpoint {
    return Endpoint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Endpoint>, I>>(object: I): Endpoint {
    const message = createBaseEndpoint();
    message.index = object.index ?? 0;
    message.socket = (object.socket !== undefined && object.socket !== null)
      ? Ref.fromPartial(object.socket)
      : undefined;
    message.connector = (object.connector !== undefined && object.connector !== null)
      ? ConnectorSpec.fromPartial(object.connector)
      : undefined;
    return message;
  },
};

function createBasePhyo(): Phyo {
  return { id: "", eqtns: [] };
}

export const Phyo = {
  encode(message: Phyo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.eqtns) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Phyo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhyo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.eqtns.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Phyo {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      eqtns: Array.isArray(object?.eqtns) ? object.eqtns.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: Phyo): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    if (message.eqtns) {
      obj.eqtns = message.eqtns.map((e) => e);
    } else {
      obj.eqtns = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Phyo>, I>>(base?: I): Phyo {
    return Phyo.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Phyo>, I>>(object: I): Phyo {
    const message = createBasePhyo();
    message.id = object.id ?? "";
    message.eqtns = object.eqtns?.map((e) => e) || [];
    return message;
  },
};

function createBaseVariable(): Variable {
  return {};
}

export const Variable = {
  encode(_: Variable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Variable {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): Variable {
    return {};
  },

  toJSON(_: Variable): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Variable>, I>>(base?: I): Variable {
    return Variable.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Variable>, I>>(_: I): Variable {
    const message = createBaseVariable();
    return message;
  },
};

function createBaseBond(): Bond {
  return {};
}

export const Bond = {
  encode(_: Bond, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bond {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBond();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): Bond {
    return {};
  },

  toJSON(_: Bond): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Bond>, I>>(base?: I): Bond {
    return Bond.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Bond>, I>>(_: I): Bond {
    const message = createBaseBond();
    return message;
  },
};

function createBaseCoupling(): Coupling {
  return {};
}

export const Coupling = {
  encode(_: Coupling, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Coupling {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoupling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): Coupling {
    return {};
  },

  toJSON(_: Coupling): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Coupling>, I>>(base?: I): Coupling {
    return Coupling.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Coupling>, I>>(_: I): Coupling {
    const message = createBaseCoupling();
    return message;
  },
};

function createBaseSensor(): Sensor {
  return { id: "", var: "", rate: 0, target: "", tag: 0 };
}

export const Sensor = {
  encode(message: Sensor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.var !== "") {
      writer.uint32(18).string(message.var);
    }
    if (message.rate !== 0) {
      writer.uint32(29).float(message.rate);
    }
    if (message.target !== "") {
      writer.uint32(34).string(message.target);
    }
    if (message.tag !== 0) {
      writer.uint32(40).int32(message.tag);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Sensor {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSensor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.var = reader.string();
          break;
        case 3:
          message.rate = reader.float();
          break;
        case 4:
          message.target = reader.string();
          break;
        case 5:
          message.tag = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Sensor {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      var: isSet(object.var) ? String(object.var) : "",
      rate: isSet(object.rate) ? Number(object.rate) : 0,
      target: isSet(object.target) ? String(object.target) : "",
      tag: isSet(object.tag) ? Number(object.tag) : 0,
    };
  },

  toJSON(message: Sensor): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.var !== undefined && (obj.var = message.var);
    message.rate !== undefined && (obj.rate = message.rate);
    message.target !== undefined && (obj.target = message.target);
    message.tag !== undefined && (obj.tag = Math.round(message.tag));
    return obj;
  },

  create<I extends Exact<DeepPartial<Sensor>, I>>(base?: I): Sensor {
    return Sensor.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Sensor>, I>>(object: I): Sensor {
    const message = createBaseSensor();
    message.id = object.id ?? "";
    message.var = object.var ?? "";
    message.rate = object.rate ?? 0;
    message.target = object.target ?? "";
    message.tag = object.tag ?? 0;
    return message;
  },
};

function createBaseActuator(): Actuator {
  return { id: "", var: "", dynamicLimits: undefined, staticLimits: undefined, tag: 0 };
}

export const Actuator = {
  encode(message: Actuator, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.var !== "") {
      writer.uint32(18).string(message.var);
    }
    if (message.dynamicLimits !== undefined) {
      Limits.encode(message.dynamicLimits, writer.uint32(26).fork()).ldelim();
    }
    if (message.staticLimits !== undefined) {
      Limits.encode(message.staticLimits, writer.uint32(34).fork()).ldelim();
    }
    if (message.tag !== 0) {
      writer.uint32(40).int32(message.tag);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Actuator {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActuator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.var = reader.string();
          break;
        case 3:
          message.dynamicLimits = Limits.decode(reader, reader.uint32());
          break;
        case 4:
          message.staticLimits = Limits.decode(reader, reader.uint32());
          break;
        case 5:
          message.tag = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Actuator {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      var: isSet(object.var) ? String(object.var) : "",
      dynamicLimits: isSet(object.dynamicLimits) ? Limits.fromJSON(object.dynamicLimits) : undefined,
      staticLimits: isSet(object.staticLimits) ? Limits.fromJSON(object.staticLimits) : undefined,
      tag: isSet(object.tag) ? Number(object.tag) : 0,
    };
  },

  toJSON(message: Actuator): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.var !== undefined && (obj.var = message.var);
    message.dynamicLimits !== undefined &&
      (obj.dynamicLimits = message.dynamicLimits ? Limits.toJSON(message.dynamicLimits) : undefined);
    message.staticLimits !== undefined &&
      (obj.staticLimits = message.staticLimits ? Limits.toJSON(message.staticLimits) : undefined);
    message.tag !== undefined && (obj.tag = Math.round(message.tag));
    return obj;
  },

  create<I extends Exact<DeepPartial<Actuator>, I>>(base?: I): Actuator {
    return Actuator.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Actuator>, I>>(object: I): Actuator {
    const message = createBaseActuator();
    message.id = object.id ?? "";
    message.var = object.var ?? "";
    message.dynamicLimits = (object.dynamicLimits !== undefined && object.dynamicLimits !== null)
      ? Limits.fromPartial(object.dynamicLimits)
      : undefined;
    message.staticLimits = (object.staticLimits !== undefined && object.staticLimits !== null)
      ? Limits.fromPartial(object.staticLimits)
      : undefined;
    message.tag = object.tag ?? 0;
    return message;
  },
};

function createBaseLimits(): Limits {
  return { lower: 0, upper: 0 };
}

export const Limits = {
  encode(message: Limits, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lower !== 0) {
      writer.uint32(13).float(message.lower);
    }
    if (message.upper !== 0) {
      writer.uint32(21).float(message.upper);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Limits {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLimits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lower = reader.float();
          break;
        case 2:
          message.upper = reader.float();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Limits {
    return {
      lower: isSet(object.lower) ? Number(object.lower) : 0,
      upper: isSet(object.upper) ? Number(object.upper) : 0,
    };
  },

  toJSON(message: Limits): unknown {
    const obj: any = {};
    message.lower !== undefined && (obj.lower = message.lower);
    message.upper !== undefined && (obj.upper = message.upper);
    return obj;
  },

  create<I extends Exact<DeepPartial<Limits>, I>>(base?: I): Limits {
    return Limits.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Limits>, I>>(object: I): Limits {
    const message = createBaseLimits();
    message.lower = object.lower ?? 0;
    message.upper = object.upper ?? 0;
    return message;
  },
};

function createBaseProductInfo(): ProductInfo {
  return { Manufacturer: "", Model: "", SKU: "", Integrated: false, cost: 0 };
}

export const ProductInfo = {
  encode(message: ProductInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Manufacturer !== "") {
      writer.uint32(10).string(message.Manufacturer);
    }
    if (message.Model !== "") {
      writer.uint32(18).string(message.Model);
    }
    if (message.SKU !== "") {
      writer.uint32(26).string(message.SKU);
    }
    if (message.Integrated === true) {
      writer.uint32(32).bool(message.Integrated);
    }
    if (message.cost !== 0) {
      writer.uint32(45).float(message.cost);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProductInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.Manufacturer = reader.string();
          break;
        case 2:
          message.Model = reader.string();
          break;
        case 3:
          message.SKU = reader.string();
          break;
        case 4:
          message.Integrated = reader.bool();
          break;
        case 5:
          message.cost = reader.float();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ProductInfo {
    return {
      Manufacturer: isSet(object.Manufacturer) ? String(object.Manufacturer) : "",
      Model: isSet(object.Model) ? String(object.Model) : "",
      SKU: isSet(object.SKU) ? String(object.SKU) : "",
      Integrated: isSet(object.Integrated) ? Boolean(object.Integrated) : false,
      cost: isSet(object.cost) ? Number(object.cost) : 0,
    };
  },

  toJSON(message: ProductInfo): unknown {
    const obj: any = {};
    message.Manufacturer !== undefined && (obj.Manufacturer = message.Manufacturer);
    message.Model !== undefined && (obj.Model = message.Model);
    message.SKU !== undefined && (obj.SKU = message.SKU);
    message.Integrated !== undefined && (obj.Integrated = message.Integrated);
    message.cost !== undefined && (obj.cost = message.cost);
    return obj;
  },

  create<I extends Exact<DeepPartial<ProductInfo>, I>>(base?: I): ProductInfo {
    return ProductInfo.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ProductInfo>, I>>(object: I): ProductInfo {
    const message = createBaseProductInfo();
    message.Manufacturer = object.Manufacturer ?? "";
    message.Model = object.Model ?? "";
    message.SKU = object.SKU ?? "";
    message.Integrated = object.Integrated ?? false;
    message.cost = object.cost ?? 0;
    return message;
  },
};

function createBaseResource(): Resource {
  return {
    id: "",
    facility: "",
    procs: [],
    memory: [],
    NICs: [],
    disks: [],
    alloc: [],
    roles: [],
    firmware: undefined,
    OS: undefined,
    productInfo: undefined,
    TPA: 0,
    ipmi: undefined,
    relayboard: undefined,
    pdu: undefined,
    raven: undefined,
    leafConfig: undefined,
    infranetAddr: {},
  };
}

export const Resource = {
  encode(message: Resource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.facility !== "") {
      writer.uint32(18).string(message.facility);
    }
    for (const v of message.procs) {
      Proc.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.memory) {
      Dimm.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.NICs) {
      NIC.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.disks) {
      Disk.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    writer.uint32(58).fork();
    for (const v of message.alloc) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(66).fork();
    for (const v of message.roles) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.firmware !== undefined) {
      Firmware.encode(message.firmware, writer.uint32(74).fork()).ldelim();
    }
    if (message.OS !== undefined) {
      OSConfig.encode(message.OS, writer.uint32(82).fork()).ldelim();
    }
    if (message.productInfo !== undefined) {
      ProductInfo.encode(message.productInfo, writer.uint32(90).fork()).ldelim();
    }
    if (message.TPA !== 0) {
      writer.uint32(96).uint64(message.TPA);
    }
    if (message.ipmi !== undefined) {
      BMC.encode(message.ipmi, writer.uint32(106).fork()).ldelim();
    }
    if (message.relayboard !== undefined) {
      RelayBoard.encode(message.relayboard, writer.uint32(114).fork()).ldelim();
    }
    if (message.pdu !== undefined) {
      PowerDistributionUnit.encode(message.pdu, writer.uint32(122).fork()).ldelim();
    }
    if (message.raven !== undefined) {
      Raven.encode(message.raven, writer.uint32(130).fork()).ldelim();
    }
    if (message.leafConfig !== undefined) {
      LeafConfig.encode(message.leafConfig, writer.uint32(138).fork()).ldelim();
    }
    Object.entries(message.infranetAddr).forEach(([key, value]) => {
      Resource_InfranetAddrEntry.encode({ key: key as any, value }, writer.uint32(146).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Resource {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.facility = reader.string();
          break;
        case 3:
          message.procs.push(Proc.decode(reader, reader.uint32()));
          break;
        case 4:
          message.memory.push(Dimm.decode(reader, reader.uint32()));
          break;
        case 5:
          message.NICs.push(NIC.decode(reader, reader.uint32()));
          break;
        case 6:
          message.disks.push(Disk.decode(reader, reader.uint32()));
          break;
        case 7:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.alloc.push(reader.int32() as any);
            }
          } else {
            message.alloc.push(reader.int32() as any);
          }
          break;
        case 8:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.roles.push(reader.int32() as any);
            }
          } else {
            message.roles.push(reader.int32() as any);
          }
          break;
        case 9:
          message.firmware = Firmware.decode(reader, reader.uint32());
          break;
        case 10:
          message.OS = OSConfig.decode(reader, reader.uint32());
          break;
        case 11:
          message.productInfo = ProductInfo.decode(reader, reader.uint32());
          break;
        case 12:
          message.TPA = longToNumber(reader.uint64() as Long);
          break;
        case 13:
          message.ipmi = BMC.decode(reader, reader.uint32());
          break;
        case 14:
          message.relayboard = RelayBoard.decode(reader, reader.uint32());
          break;
        case 15:
          message.pdu = PowerDistributionUnit.decode(reader, reader.uint32());
          break;
        case 16:
          message.raven = Raven.decode(reader, reader.uint32());
          break;
        case 17:
          message.leafConfig = LeafConfig.decode(reader, reader.uint32());
          break;
        case 18:
          const entry18 = Resource_InfranetAddrEntry.decode(reader, reader.uint32());
          if (entry18.value !== undefined) {
            message.infranetAddr[entry18.key] = entry18.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Resource {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      facility: isSet(object.facility) ? String(object.facility) : "",
      procs: Array.isArray(object?.procs) ? object.procs.map((e: any) => Proc.fromJSON(e)) : [],
      memory: Array.isArray(object?.memory) ? object.memory.map((e: any) => Dimm.fromJSON(e)) : [],
      NICs: Array.isArray(object?.NICs) ? object.NICs.map((e: any) => NIC.fromJSON(e)) : [],
      disks: Array.isArray(object?.disks) ? object.disks.map((e: any) => Disk.fromJSON(e)) : [],
      alloc: Array.isArray(object?.alloc) ? object.alloc.map((e: any) => allocModeFromJSON(e)) : [],
      roles: Array.isArray(object?.roles) ? object.roles.map((e: any) => roleFromJSON(e)) : [],
      firmware: isSet(object.firmware) ? Firmware.fromJSON(object.firmware) : undefined,
      OS: isSet(object.OS) ? OSConfig.fromJSON(object.OS) : undefined,
      productInfo: isSet(object.productInfo) ? ProductInfo.fromJSON(object.productInfo) : undefined,
      TPA: isSet(object.TPA) ? Number(object.TPA) : 0,
      ipmi: isSet(object.ipmi) ? BMC.fromJSON(object.ipmi) : undefined,
      relayboard: isSet(object.relayboard) ? RelayBoard.fromJSON(object.relayboard) : undefined,
      pdu: isSet(object.pdu) ? PowerDistributionUnit.fromJSON(object.pdu) : undefined,
      raven: isSet(object.raven) ? Raven.fromJSON(object.raven) : undefined,
      leafConfig: isSet(object.leafConfig) ? LeafConfig.fromJSON(object.leafConfig) : undefined,
      infranetAddr: isObject(object.infranetAddr)
        ? Object.entries(object.infranetAddr).reduce<{ [key: string]: AddressList }>((acc, [key, value]) => {
          acc[key] = AddressList.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Resource): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.facility !== undefined && (obj.facility = message.facility);
    if (message.procs) {
      obj.procs = message.procs.map((e) => e ? Proc.toJSON(e) : undefined);
    } else {
      obj.procs = [];
    }
    if (message.memory) {
      obj.memory = message.memory.map((e) => e ? Dimm.toJSON(e) : undefined);
    } else {
      obj.memory = [];
    }
    if (message.NICs) {
      obj.NICs = message.NICs.map((e) => e ? NIC.toJSON(e) : undefined);
    } else {
      obj.NICs = [];
    }
    if (message.disks) {
      obj.disks = message.disks.map((e) => e ? Disk.toJSON(e) : undefined);
    } else {
      obj.disks = [];
    }
    if (message.alloc) {
      obj.alloc = message.alloc.map((e) => allocModeToJSON(e));
    } else {
      obj.alloc = [];
    }
    if (message.roles) {
      obj.roles = message.roles.map((e) => roleToJSON(e));
    } else {
      obj.roles = [];
    }
    message.firmware !== undefined && (obj.firmware = message.firmware ? Firmware.toJSON(message.firmware) : undefined);
    message.OS !== undefined && (obj.OS = message.OS ? OSConfig.toJSON(message.OS) : undefined);
    message.productInfo !== undefined &&
      (obj.productInfo = message.productInfo ? ProductInfo.toJSON(message.productInfo) : undefined);
    message.TPA !== undefined && (obj.TPA = Math.round(message.TPA));
    message.ipmi !== undefined && (obj.ipmi = message.ipmi ? BMC.toJSON(message.ipmi) : undefined);
    message.relayboard !== undefined &&
      (obj.relayboard = message.relayboard ? RelayBoard.toJSON(message.relayboard) : undefined);
    message.pdu !== undefined && (obj.pdu = message.pdu ? PowerDistributionUnit.toJSON(message.pdu) : undefined);
    message.raven !== undefined && (obj.raven = message.raven ? Raven.toJSON(message.raven) : undefined);
    message.leafConfig !== undefined &&
      (obj.leafConfig = message.leafConfig ? LeafConfig.toJSON(message.leafConfig) : undefined);
    obj.infranetAddr = {};
    if (message.infranetAddr) {
      Object.entries(message.infranetAddr).forEach(([k, v]) => {
        obj.infranetAddr[k] = AddressList.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resource>, I>>(base?: I): Resource {
    return Resource.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Resource>, I>>(object: I): Resource {
    const message = createBaseResource();
    message.id = object.id ?? "";
    message.facility = object.facility ?? "";
    message.procs = object.procs?.map((e) => Proc.fromPartial(e)) || [];
    message.memory = object.memory?.map((e) => Dimm.fromPartial(e)) || [];
    message.NICs = object.NICs?.map((e) => NIC.fromPartial(e)) || [];
    message.disks = object.disks?.map((e) => Disk.fromPartial(e)) || [];
    message.alloc = object.alloc?.map((e) => e) || [];
    message.roles = object.roles?.map((e) => e) || [];
    message.firmware = (object.firmware !== undefined && object.firmware !== null)
      ? Firmware.fromPartial(object.firmware)
      : undefined;
    message.OS = (object.OS !== undefined && object.OS !== null) ? OSConfig.fromPartial(object.OS) : undefined;
    message.productInfo = (object.productInfo !== undefined && object.productInfo !== null)
      ? ProductInfo.fromPartial(object.productInfo)
      : undefined;
    message.TPA = object.TPA ?? 0;
    message.ipmi = (object.ipmi !== undefined && object.ipmi !== null) ? BMC.fromPartial(object.ipmi) : undefined;
    message.relayboard = (object.relayboard !== undefined && object.relayboard !== null)
      ? RelayBoard.fromPartial(object.relayboard)
      : undefined;
    message.pdu = (object.pdu !== undefined && object.pdu !== null)
      ? PowerDistributionUnit.fromPartial(object.pdu)
      : undefined;
    message.raven = (object.raven !== undefined && object.raven !== null) ? Raven.fromPartial(object.raven) : undefined;
    message.leafConfig = (object.leafConfig !== undefined && object.leafConfig !== null)
      ? LeafConfig.fromPartial(object.leafConfig)
      : undefined;
    message.infranetAddr = Object.entries(object.infranetAddr ?? {}).reduce<{ [key: string]: AddressList }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AddressList.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseResource_InfranetAddrEntry(): Resource_InfranetAddrEntry {
  return { key: "", value: undefined };
}

export const Resource_InfranetAddrEntry = {
  encode(message: Resource_InfranetAddrEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AddressList.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Resource_InfranetAddrEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource_InfranetAddrEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = AddressList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Resource_InfranetAddrEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? AddressList.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Resource_InfranetAddrEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? AddressList.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Resource_InfranetAddrEntry>, I>>(base?: I): Resource_InfranetAddrEntry {
    return Resource_InfranetAddrEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Resource_InfranetAddrEntry>, I>>(object: I): Resource_InfranetAddrEntry {
    const message = createBaseResource_InfranetAddrEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AddressList.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseBMC(): BMC {
  return { host: "", kind: 0 };
}

export const BMC = {
  encode(message: BMC, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.kind !== 0) {
      writer.uint32(16).int32(message.kind);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BMC {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBMC();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.host = reader.string();
          break;
        case 2:
          message.kind = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BMC {
    return {
      host: isSet(object.host) ? String(object.host) : "",
      kind: isSet(object.kind) ? bMC_KindFromJSON(object.kind) : 0,
    };
  },

  toJSON(message: BMC): unknown {
    const obj: any = {};
    message.host !== undefined && (obj.host = message.host);
    message.kind !== undefined && (obj.kind = bMC_KindToJSON(message.kind));
    return obj;
  },

  create<I extends Exact<DeepPartial<BMC>, I>>(base?: I): BMC {
    return BMC.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<BMC>, I>>(object: I): BMC {
    const message = createBaseBMC();
    message.host = object.host ?? "";
    message.kind = object.kind ?? 0;
    return message;
  },
};

function createBaseRelayBoard(): RelayBoard {
  return { host: "", index: 0, kind: 0 };
}

export const RelayBoard = {
  encode(message: RelayBoard, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    if (message.kind !== 0) {
      writer.uint32(24).int32(message.kind);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RelayBoard {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelayBoard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.host = reader.string();
          break;
        case 2:
          message.index = reader.uint32();
          break;
        case 3:
          message.kind = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RelayBoard {
    return {
      host: isSet(object.host) ? String(object.host) : "",
      index: isSet(object.index) ? Number(object.index) : 0,
      kind: isSet(object.kind) ? relayBoard_KindFromJSON(object.kind) : 0,
    };
  },

  toJSON(message: RelayBoard): unknown {
    const obj: any = {};
    message.host !== undefined && (obj.host = message.host);
    message.index !== undefined && (obj.index = Math.round(message.index));
    message.kind !== undefined && (obj.kind = relayBoard_KindToJSON(message.kind));
    return obj;
  },

  create<I extends Exact<DeepPartial<RelayBoard>, I>>(base?: I): RelayBoard {
    return RelayBoard.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RelayBoard>, I>>(object: I): RelayBoard {
    const message = createBaseRelayBoard();
    message.host = object.host ?? "";
    message.index = object.index ?? 0;
    message.kind = object.kind ?? 0;
    return message;
  },
};

function createBasePowerDistributionUnit(): PowerDistributionUnit {
  return { host: "", outlets: [], kind: 0 };
}

export const PowerDistributionUnit = {
  encode(message: PowerDistributionUnit, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    writer.uint32(18).fork();
    for (const v of message.outlets) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.kind !== 0) {
      writer.uint32(24).int32(message.kind);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PowerDistributionUnit {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePowerDistributionUnit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.host = reader.string();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.outlets.push(reader.uint32());
            }
          } else {
            message.outlets.push(reader.uint32());
          }
          break;
        case 3:
          message.kind = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PowerDistributionUnit {
    return {
      host: isSet(object.host) ? String(object.host) : "",
      outlets: Array.isArray(object?.outlets) ? object.outlets.map((e: any) => Number(e)) : [],
      kind: isSet(object.kind) ? powerDistributionUnit_KindFromJSON(object.kind) : 0,
    };
  },

  toJSON(message: PowerDistributionUnit): unknown {
    const obj: any = {};
    message.host !== undefined && (obj.host = message.host);
    if (message.outlets) {
      obj.outlets = message.outlets.map((e) => Math.round(e));
    } else {
      obj.outlets = [];
    }
    message.kind !== undefined && (obj.kind = powerDistributionUnit_KindToJSON(message.kind));
    return obj;
  },

  create<I extends Exact<DeepPartial<PowerDistributionUnit>, I>>(base?: I): PowerDistributionUnit {
    return PowerDistributionUnit.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<PowerDistributionUnit>, I>>(object: I): PowerDistributionUnit {
    const message = createBasePowerDistributionUnit();
    message.host = object.host ?? "";
    message.outlets = object.outlets?.map((e) => e) || [];
    message.kind = object.kind ?? 0;
    return message;
  },
};

function createBaseRaven(): Raven {
  return { host: "" };
}

export const Raven = {
  encode(message: Raven, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Raven {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRaven();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.host = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Raven {
    return { host: isSet(object.host) ? String(object.host) : "" };
  },

  toJSON(message: Raven): unknown {
    const obj: any = {};
    message.host !== undefined && (obj.host = message.host);
    return obj;
  },

  create<I extends Exact<DeepPartial<Raven>, I>>(base?: I): Raven {
    return Raven.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Raven>, I>>(object: I): Raven {
    const message = createBaseRaven();
    message.host = object.host ?? "";
    return message;
  },
};

function createBaseFirmware(): Firmware {
  return { kind: 0 };
}

export const Firmware = {
  encode(message: Firmware, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kind !== 0) {
      writer.uint32(8).int32(message.kind);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Firmware {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFirmware();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Firmware {
    return { kind: isSet(object.kind) ? firmware_KindFromJSON(object.kind) : 0 };
  },

  toJSON(message: Firmware): unknown {
    const obj: any = {};
    message.kind !== undefined && (obj.kind = firmware_KindToJSON(message.kind));
    return obj;
  },

  create<I extends Exact<DeepPartial<Firmware>, I>>(base?: I): Firmware {
    return Firmware.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Firmware>, I>>(object: I): Firmware {
    const message = createBaseFirmware();
    message.kind = object.kind ?? 0;
    return message;
  },
};

function createBaseResourceAllocation(): ResourceAllocation {
  return {
    resource: "",
    facility: "",
    mzid: "",
    node: "",
    procs: undefined,
    memory: undefined,
    NICs: undefined,
    disks: undefined,
    model: undefined,
    revision: 0,
    virtual: false,
  };
}

export const ResourceAllocation = {
  encode(message: ResourceAllocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    if (message.facility !== "") {
      writer.uint32(18).string(message.facility);
    }
    if (message.mzid !== "") {
      writer.uint32(26).string(message.mzid);
    }
    if (message.node !== "") {
      writer.uint32(34).string(message.node);
    }
    if (message.procs !== undefined) {
      ProcAllocation.encode(message.procs, writer.uint32(42).fork()).ldelim();
    }
    if (message.memory !== undefined) {
      MemoryAllocation.encode(message.memory, writer.uint32(50).fork()).ldelim();
    }
    if (message.NICs !== undefined) {
      NICsAllocation.encode(message.NICs, writer.uint32(58).fork()).ldelim();
    }
    if (message.disks !== undefined) {
      DisksAllocation.encode(message.disks, writer.uint32(66).fork()).ldelim();
    }
    if (message.model !== undefined) {
      Node.encode(message.model, writer.uint32(74).fork()).ldelim();
    }
    if (message.revision !== 0) {
      writer.uint32(80).int64(message.revision);
    }
    if (message.virtual === true) {
      writer.uint32(88).bool(message.virtual);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResourceAllocation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.resource = reader.string();
          break;
        case 2:
          message.facility = reader.string();
          break;
        case 3:
          message.mzid = reader.string();
          break;
        case 4:
          message.node = reader.string();
          break;
        case 5:
          message.procs = ProcAllocation.decode(reader, reader.uint32());
          break;
        case 6:
          message.memory = MemoryAllocation.decode(reader, reader.uint32());
          break;
        case 7:
          message.NICs = NICsAllocation.decode(reader, reader.uint32());
          break;
        case 8:
          message.disks = DisksAllocation.decode(reader, reader.uint32());
          break;
        case 9:
          message.model = Node.decode(reader, reader.uint32());
          break;
        case 10:
          message.revision = longToNumber(reader.int64() as Long);
          break;
        case 11:
          message.virtual = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ResourceAllocation {
    return {
      resource: isSet(object.resource) ? String(object.resource) : "",
      facility: isSet(object.facility) ? String(object.facility) : "",
      mzid: isSet(object.mzid) ? String(object.mzid) : "",
      node: isSet(object.node) ? String(object.node) : "",
      procs: isSet(object.procs) ? ProcAllocation.fromJSON(object.procs) : undefined,
      memory: isSet(object.memory) ? MemoryAllocation.fromJSON(object.memory) : undefined,
      NICs: isSet(object.NICs) ? NICsAllocation.fromJSON(object.NICs) : undefined,
      disks: isSet(object.disks) ? DisksAllocation.fromJSON(object.disks) : undefined,
      model: isSet(object.model) ? Node.fromJSON(object.model) : undefined,
      revision: isSet(object.revision) ? Number(object.revision) : 0,
      virtual: isSet(object.virtual) ? Boolean(object.virtual) : false,
    };
  },

  toJSON(message: ResourceAllocation): unknown {
    const obj: any = {};
    message.resource !== undefined && (obj.resource = message.resource);
    message.facility !== undefined && (obj.facility = message.facility);
    message.mzid !== undefined && (obj.mzid = message.mzid);
    message.node !== undefined && (obj.node = message.node);
    message.procs !== undefined && (obj.procs = message.procs ? ProcAllocation.toJSON(message.procs) : undefined);
    message.memory !== undefined && (obj.memory = message.memory ? MemoryAllocation.toJSON(message.memory) : undefined);
    message.NICs !== undefined && (obj.NICs = message.NICs ? NICsAllocation.toJSON(message.NICs) : undefined);
    message.disks !== undefined && (obj.disks = message.disks ? DisksAllocation.toJSON(message.disks) : undefined);
    message.model !== undefined && (obj.model = message.model ? Node.toJSON(message.model) : undefined);
    message.revision !== undefined && (obj.revision = Math.round(message.revision));
    message.virtual !== undefined && (obj.virtual = message.virtual);
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceAllocation>, I>>(base?: I): ResourceAllocation {
    return ResourceAllocation.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ResourceAllocation>, I>>(object: I): ResourceAllocation {
    const message = createBaseResourceAllocation();
    message.resource = object.resource ?? "";
    message.facility = object.facility ?? "";
    message.mzid = object.mzid ?? "";
    message.node = object.node ?? "";
    message.procs = (object.procs !== undefined && object.procs !== null)
      ? ProcAllocation.fromPartial(object.procs)
      : undefined;
    message.memory = (object.memory !== undefined && object.memory !== null)
      ? MemoryAllocation.fromPartial(object.memory)
      : undefined;
    message.NICs = (object.NICs !== undefined && object.NICs !== null)
      ? NICsAllocation.fromPartial(object.NICs)
      : undefined;
    message.disks = (object.disks !== undefined && object.disks !== null)
      ? DisksAllocation.fromPartial(object.disks)
      : undefined;
    message.model = (object.model !== undefined && object.model !== null) ? Node.fromPartial(object.model) : undefined;
    message.revision = object.revision ?? 0;
    message.virtual = object.virtual ?? false;
    return message;
  },
};

function createBaseCableAllocation(): CableAllocation {
  return { cable: "", facility: "", mzid: "", link: "", capacity: 0, revision: 0 };
}

export const CableAllocation = {
  encode(message: CableAllocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cable !== "") {
      writer.uint32(10).string(message.cable);
    }
    if (message.facility !== "") {
      writer.uint32(18).string(message.facility);
    }
    if (message.mzid !== "") {
      writer.uint32(26).string(message.mzid);
    }
    if (message.link !== "") {
      writer.uint32(34).string(message.link);
    }
    if (message.capacity !== 0) {
      writer.uint32(40).uint64(message.capacity);
    }
    if (message.revision !== 0) {
      writer.uint32(48).int64(message.revision);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CableAllocation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCableAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cable = reader.string();
          break;
        case 2:
          message.facility = reader.string();
          break;
        case 3:
          message.mzid = reader.string();
          break;
        case 4:
          message.link = reader.string();
          break;
        case 5:
          message.capacity = longToNumber(reader.uint64() as Long);
          break;
        case 6:
          message.revision = longToNumber(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CableAllocation {
    return {
      cable: isSet(object.cable) ? String(object.cable) : "",
      facility: isSet(object.facility) ? String(object.facility) : "",
      mzid: isSet(object.mzid) ? String(object.mzid) : "",
      link: isSet(object.link) ? String(object.link) : "",
      capacity: isSet(object.capacity) ? Number(object.capacity) : 0,
      revision: isSet(object.revision) ? Number(object.revision) : 0,
    };
  },

  toJSON(message: CableAllocation): unknown {
    const obj: any = {};
    message.cable !== undefined && (obj.cable = message.cable);
    message.facility !== undefined && (obj.facility = message.facility);
    message.mzid !== undefined && (obj.mzid = message.mzid);
    message.link !== undefined && (obj.link = message.link);
    message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
    message.revision !== undefined && (obj.revision = Math.round(message.revision));
    return obj;
  },

  create<I extends Exact<DeepPartial<CableAllocation>, I>>(base?: I): CableAllocation {
    return CableAllocation.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CableAllocation>, I>>(object: I): CableAllocation {
    const message = createBaseCableAllocation();
    message.cable = object.cable ?? "";
    message.facility = object.facility ?? "";
    message.mzid = object.mzid ?? "";
    message.link = object.link ?? "";
    message.capacity = object.capacity ?? 0;
    message.revision = object.revision ?? 0;
    return message;
  },
};

function createBaseAddressList(): AddressList {
  return { list: [] };
}

export const AddressList = {
  encode(message: AddressList, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.list) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddressList {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.list.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AddressList {
    return { list: Array.isArray(object?.list) ? object.list.map((e: any) => String(e)) : [] };
  },

  toJSON(message: AddressList): unknown {
    const obj: any = {};
    if (message.list) {
      obj.list = message.list.map((e) => e);
    } else {
      obj.list = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddressList>, I>>(base?: I): AddressList {
    return AddressList.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddressList>, I>>(object: I): AddressList {
    const message = createBaseAddressList();
    message.list = object.list?.map((e) => e) || [];
    return message;
  },
};

function createBaseLeafConfig(): LeafConfig {
  return { serviceAddressBlocks: undefined, tenantAddressBlocks: undefined, infrapodAddressBlocks: {} };
}

export const LeafConfig = {
  encode(message: LeafConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serviceAddressBlocks !== undefined) {
      AddressList.encode(message.serviceAddressBlocks, writer.uint32(10).fork()).ldelim();
    }
    if (message.tenantAddressBlocks !== undefined) {
      AddressList.encode(message.tenantAddressBlocks, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.infrapodAddressBlocks).forEach(([key, value]) => {
      LeafConfig_InfrapodAddressBlocksEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LeafConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeafConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.serviceAddressBlocks = AddressList.decode(reader, reader.uint32());
          break;
        case 2:
          message.tenantAddressBlocks = AddressList.decode(reader, reader.uint32());
          break;
        case 3:
          const entry3 = LeafConfig_InfrapodAddressBlocksEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.infrapodAddressBlocks[entry3.key] = entry3.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LeafConfig {
    return {
      serviceAddressBlocks: isSet(object.serviceAddressBlocks)
        ? AddressList.fromJSON(object.serviceAddressBlocks)
        : undefined,
      tenantAddressBlocks: isSet(object.tenantAddressBlocks)
        ? AddressList.fromJSON(object.tenantAddressBlocks)
        : undefined,
      infrapodAddressBlocks: isObject(object.infrapodAddressBlocks)
        ? Object.entries(object.infrapodAddressBlocks).reduce<{ [key: string]: AddressList }>((acc, [key, value]) => {
          acc[key] = AddressList.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: LeafConfig): unknown {
    const obj: any = {};
    message.serviceAddressBlocks !== undefined && (obj.serviceAddressBlocks = message.serviceAddressBlocks
      ? AddressList.toJSON(message.serviceAddressBlocks)
      : undefined);
    message.tenantAddressBlocks !== undefined && (obj.tenantAddressBlocks = message.tenantAddressBlocks
      ? AddressList.toJSON(message.tenantAddressBlocks)
      : undefined);
    obj.infrapodAddressBlocks = {};
    if (message.infrapodAddressBlocks) {
      Object.entries(message.infrapodAddressBlocks).forEach(([k, v]) => {
        obj.infrapodAddressBlocks[k] = AddressList.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LeafConfig>, I>>(base?: I): LeafConfig {
    return LeafConfig.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<LeafConfig>, I>>(object: I): LeafConfig {
    const message = createBaseLeafConfig();
    message.serviceAddressBlocks = (object.serviceAddressBlocks !== undefined && object.serviceAddressBlocks !== null)
      ? AddressList.fromPartial(object.serviceAddressBlocks)
      : undefined;
    message.tenantAddressBlocks = (object.tenantAddressBlocks !== undefined && object.tenantAddressBlocks !== null)
      ? AddressList.fromPartial(object.tenantAddressBlocks)
      : undefined;
    message.infrapodAddressBlocks = Object.entries(object.infrapodAddressBlocks ?? {}).reduce<
      { [key: string]: AddressList }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = AddressList.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseLeafConfig_InfrapodAddressBlocksEntry(): LeafConfig_InfrapodAddressBlocksEntry {
  return { key: "", value: undefined };
}

export const LeafConfig_InfrapodAddressBlocksEntry = {
  encode(message: LeafConfig_InfrapodAddressBlocksEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AddressList.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LeafConfig_InfrapodAddressBlocksEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeafConfig_InfrapodAddressBlocksEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = AddressList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LeafConfig_InfrapodAddressBlocksEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? AddressList.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: LeafConfig_InfrapodAddressBlocksEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value ? AddressList.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<LeafConfig_InfrapodAddressBlocksEntry>, I>>(
    base?: I,
  ): LeafConfig_InfrapodAddressBlocksEntry {
    return LeafConfig_InfrapodAddressBlocksEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<LeafConfig_InfrapodAddressBlocksEntry>, I>>(
    object: I,
  ): LeafConfig_InfrapodAddressBlocksEntry {
    const message = createBaseLeafConfig_InfrapodAddressBlocksEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AddressList.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseOSConfig(): OSConfig {
  return { BGP: [], bridge: [], VLAN: [], serviceEndpoints: {}, append: "", rootdev: "", defaultImage: "" };
}

export const OSConfig = {
  encode(message: OSConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.BGP) {
      BGPRouterConfig.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.bridge) {
      BridgeConfig.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.VLAN) {
      VLANConfig.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.serviceEndpoints).forEach(([key, value]) => {
      OSConfig_ServiceEndpointsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    if (message.append !== "") {
      writer.uint32(42).string(message.append);
    }
    if (message.rootdev !== "") {
      writer.uint32(50).string(message.rootdev);
    }
    if (message.defaultImage !== "") {
      writer.uint32(58).string(message.defaultImage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OSConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOSConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.BGP.push(BGPRouterConfig.decode(reader, reader.uint32()));
          break;
        case 2:
          message.bridge.push(BridgeConfig.decode(reader, reader.uint32()));
          break;
        case 3:
          message.VLAN.push(VLANConfig.decode(reader, reader.uint32()));
          break;
        case 4:
          const entry4 = OSConfig_ServiceEndpointsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.serviceEndpoints[entry4.key] = entry4.value;
          }
          break;
        case 5:
          message.append = reader.string();
          break;
        case 6:
          message.rootdev = reader.string();
          break;
        case 7:
          message.defaultImage = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OSConfig {
    return {
      BGP: Array.isArray(object?.BGP) ? object.BGP.map((e: any) => BGPRouterConfig.fromJSON(e)) : [],
      bridge: Array.isArray(object?.bridge) ? object.bridge.map((e: any) => BridgeConfig.fromJSON(e)) : [],
      VLAN: Array.isArray(object?.VLAN) ? object.VLAN.map((e: any) => VLANConfig.fromJSON(e)) : [],
      serviceEndpoints: isObject(object.serviceEndpoints)
        ? Object.entries(object.serviceEndpoints).reduce<{ [key: number]: ServiceEndpoint }>((acc, [key, value]) => {
          acc[Number(key)] = ServiceEndpoint.fromJSON(value);
          return acc;
        }, {})
        : {},
      append: isSet(object.append) ? String(object.append) : "",
      rootdev: isSet(object.rootdev) ? String(object.rootdev) : "",
      defaultImage: isSet(object.defaultImage) ? String(object.defaultImage) : "",
    };
  },

  toJSON(message: OSConfig): unknown {
    const obj: any = {};
    if (message.BGP) {
      obj.BGP = message.BGP.map((e) => e ? BGPRouterConfig.toJSON(e) : undefined);
    } else {
      obj.BGP = [];
    }
    if (message.bridge) {
      obj.bridge = message.bridge.map((e) => e ? BridgeConfig.toJSON(e) : undefined);
    } else {
      obj.bridge = [];
    }
    if (message.VLAN) {
      obj.VLAN = message.VLAN.map((e) => e ? VLANConfig.toJSON(e) : undefined);
    } else {
      obj.VLAN = [];
    }
    obj.serviceEndpoints = {};
    if (message.serviceEndpoints) {
      Object.entries(message.serviceEndpoints).forEach(([k, v]) => {
        obj.serviceEndpoints[k] = ServiceEndpoint.toJSON(v);
      });
    }
    message.append !== undefined && (obj.append = message.append);
    message.rootdev !== undefined && (obj.rootdev = message.rootdev);
    message.defaultImage !== undefined && (obj.defaultImage = message.defaultImage);
    return obj;
  },

  create<I extends Exact<DeepPartial<OSConfig>, I>>(base?: I): OSConfig {
    return OSConfig.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<OSConfig>, I>>(object: I): OSConfig {
    const message = createBaseOSConfig();
    message.BGP = object.BGP?.map((e) => BGPRouterConfig.fromPartial(e)) || [];
    message.bridge = object.bridge?.map((e) => BridgeConfig.fromPartial(e)) || [];
    message.VLAN = object.VLAN?.map((e) => VLANConfig.fromPartial(e)) || [];
    message.serviceEndpoints = Object.entries(object.serviceEndpoints ?? {}).reduce<{ [key: number]: ServiceEndpoint }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[Number(key)] = ServiceEndpoint.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.append = object.append ?? "";
    message.rootdev = object.rootdev ?? "";
    message.defaultImage = object.defaultImage ?? "";
    return message;
  },
};

function createBaseOSConfig_ServiceEndpointsEntry(): OSConfig_ServiceEndpointsEntry {
  return { key: 0, value: undefined };
}

export const OSConfig_ServiceEndpointsEntry = {
  encode(message: OSConfig_ServiceEndpointsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      ServiceEndpoint.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OSConfig_ServiceEndpointsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOSConfig_ServiceEndpointsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.uint32();
          break;
        case 2:
          message.value = ServiceEndpoint.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): OSConfig_ServiceEndpointsEntry {
    return {
      key: isSet(object.key) ? Number(object.key) : 0,
      value: isSet(object.value) ? ServiceEndpoint.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: OSConfig_ServiceEndpointsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = Math.round(message.key));
    message.value !== undefined && (obj.value = message.value ? ServiceEndpoint.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<OSConfig_ServiceEndpointsEntry>, I>>(base?: I): OSConfig_ServiceEndpointsEntry {
    return OSConfig_ServiceEndpointsEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<OSConfig_ServiceEndpointsEntry>, I>>(
    object: I,
  ): OSConfig_ServiceEndpointsEntry {
    const message = createBaseOSConfig_ServiceEndpointsEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? ServiceEndpoint.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseServiceEndpoint(): ServiceEndpoint {
  return { address: "" };
}

export const ServiceEndpoint = {
  encode(message: ServiceEndpoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServiceEndpoint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ServiceEndpoint {
    return { address: isSet(object.address) ? String(object.address) : "" };
  },

  toJSON(message: ServiceEndpoint): unknown {
    const obj: any = {};
    message.address !== undefined && (obj.address = message.address);
    return obj;
  },

  create<I extends Exact<DeepPartial<ServiceEndpoint>, I>>(base?: I): ServiceEndpoint {
    return ServiceEndpoint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ServiceEndpoint>, I>>(object: I): ServiceEndpoint {
    const message = createBaseServiceEndpoint();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseVLANConfig(): VLANConfig {
  return { device: "", vid: 0, addrs: [], role: 0 };
}

export const VLANConfig = {
  encode(message: VLANConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.device !== "") {
      writer.uint32(10).string(message.device);
    }
    if (message.vid !== 0) {
      writer.uint32(16).uint32(message.vid);
    }
    for (const v of message.addrs) {
      writer.uint32(26).string(v!);
    }
    if (message.role !== 0) {
      writer.uint32(32).int32(message.role);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VLANConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVLANConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.device = reader.string();
          break;
        case 2:
          message.vid = reader.uint32();
          break;
        case 3:
          message.addrs.push(reader.string());
          break;
        case 4:
          message.role = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): VLANConfig {
    return {
      device: isSet(object.device) ? String(object.device) : "",
      vid: isSet(object.vid) ? Number(object.vid) : 0,
      addrs: Array.isArray(object?.addrs) ? object.addrs.map((e: any) => String(e)) : [],
      role: isSet(object.role) ? linkRoleFromJSON(object.role) : 0,
    };
  },

  toJSON(message: VLANConfig): unknown {
    const obj: any = {};
    message.device !== undefined && (obj.device = message.device);
    message.vid !== undefined && (obj.vid = Math.round(message.vid));
    if (message.addrs) {
      obj.addrs = message.addrs.map((e) => e);
    } else {
      obj.addrs = [];
    }
    message.role !== undefined && (obj.role = linkRoleToJSON(message.role));
    return obj;
  },

  create<I extends Exact<DeepPartial<VLANConfig>, I>>(base?: I): VLANConfig {
    return VLANConfig.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<VLANConfig>, I>>(object: I): VLANConfig {
    const message = createBaseVLANConfig();
    message.device = object.device ?? "";
    message.vid = object.vid ?? 0;
    message.addrs = object.addrs?.map((e) => e) || [];
    message.role = object.role ?? 0;
    return message;
  },
};

function createBaseInterfaceConfig(): InterfaceConfig {
  return { address: "", interface: "", role: 0 };
}

export const InterfaceConfig = {
  encode(message: InterfaceConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.interface !== "") {
      writer.uint32(18).string(message.interface);
    }
    if (message.role !== 0) {
      writer.uint32(24).int32(message.role);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InterfaceConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterfaceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader.string();
          break;
        case 2:
          message.interface = reader.string();
          break;
        case 3:
          message.role = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InterfaceConfig {
    return {
      address: isSet(object.address) ? String(object.address) : "",
      interface: isSet(object.interface) ? String(object.interface) : "",
      role: isSet(object.role) ? linkRoleFromJSON(object.role) : 0,
    };
  },

  toJSON(message: InterfaceConfig): unknown {
    const obj: any = {};
    message.address !== undefined && (obj.address = message.address);
    message.interface !== undefined && (obj.interface = message.interface);
    message.role !== undefined && (obj.role = linkRoleToJSON(message.role));
    return obj;
  },

  create<I extends Exact<DeepPartial<InterfaceConfig>, I>>(base?: I): InterfaceConfig {
    return InterfaceConfig.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<InterfaceConfig>, I>>(object: I): InterfaceConfig {
    const message = createBaseInterfaceConfig();
    message.address = object.address ?? "";
    message.interface = object.interface ?? "";
    message.role = object.role ?? 0;
    return message;
  },
};

function createBaseBGPRouterConfig(): BGPRouterConfig {
  return { vrf: "", ASN: 0, Interfaces: [], EVPN: undefined };
}

export const BGPRouterConfig = {
  encode(message: BGPRouterConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.vrf !== "") {
      writer.uint32(10).string(message.vrf);
    }
    if (message.ASN !== 0) {
      writer.uint32(16).uint32(message.ASN);
    }
    for (const v of message.Interfaces) {
      InterfaceConfig.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.EVPN !== undefined) {
      EVPNConfig.encode(message.EVPN, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BGPRouterConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBGPRouterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.vrf = reader.string();
          break;
        case 2:
          message.ASN = reader.uint32();
          break;
        case 3:
          message.Interfaces.push(InterfaceConfig.decode(reader, reader.uint32()));
          break;
        case 4:
          message.EVPN = EVPNConfig.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BGPRouterConfig {
    return {
      vrf: isSet(object.vrf) ? String(object.vrf) : "",
      ASN: isSet(object.ASN) ? Number(object.ASN) : 0,
      Interfaces: Array.isArray(object?.Interfaces)
        ? object.Interfaces.map((e: any) => InterfaceConfig.fromJSON(e))
        : [],
      EVPN: isSet(object.EVPN) ? EVPNConfig.fromJSON(object.EVPN) : undefined,
    };
  },

  toJSON(message: BGPRouterConfig): unknown {
    const obj: any = {};
    message.vrf !== undefined && (obj.vrf = message.vrf);
    message.ASN !== undefined && (obj.ASN = Math.round(message.ASN));
    if (message.Interfaces) {
      obj.Interfaces = message.Interfaces.map((e) => e ? InterfaceConfig.toJSON(e) : undefined);
    } else {
      obj.Interfaces = [];
    }
    message.EVPN !== undefined && (obj.EVPN = message.EVPN ? EVPNConfig.toJSON(message.EVPN) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<BGPRouterConfig>, I>>(base?: I): BGPRouterConfig {
    return BGPRouterConfig.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<BGPRouterConfig>, I>>(object: I): BGPRouterConfig {
    const message = createBaseBGPRouterConfig();
    message.vrf = object.vrf ?? "";
    message.ASN = object.ASN ?? 0;
    message.Interfaces = object.Interfaces?.map((e) => InterfaceConfig.fromPartial(e)) || [];
    message.EVPN = (object.EVPN !== undefined && object.EVPN !== null)
      ? EVPNConfig.fromPartial(object.EVPN)
      : undefined;
    return message;
  },
};

function createBaseEVPNConfig(): EVPNConfig {
  return { TunnelEndpoints: [] };
}

export const EVPNConfig = {
  encode(message: EVPNConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.TunnelEndpoints) {
      InterfaceConfig.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EVPNConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEVPNConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.TunnelEndpoints.push(InterfaceConfig.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EVPNConfig {
    return {
      TunnelEndpoints: Array.isArray(object?.TunnelEndpoints)
        ? object.TunnelEndpoints.map((e: any) => InterfaceConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EVPNConfig): unknown {
    const obj: any = {};
    if (message.TunnelEndpoints) {
      obj.TunnelEndpoints = message.TunnelEndpoints.map((e) => e ? InterfaceConfig.toJSON(e) : undefined);
    } else {
      obj.TunnelEndpoints = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EVPNConfig>, I>>(base?: I): EVPNConfig {
    return EVPNConfig.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<EVPNConfig>, I>>(object: I): EVPNConfig {
    const message = createBaseEVPNConfig();
    message.TunnelEndpoints = object.TunnelEndpoints?.map((e) => InterfaceConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBridgeConfig(): BridgeConfig {
  return { name: "", vlanAware: false, addrs: [], role: 0 };
}

export const BridgeConfig = {
  encode(message: BridgeConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.vlanAware === true) {
      writer.uint32(16).bool(message.vlanAware);
    }
    for (const v of message.addrs) {
      writer.uint32(26).string(v!);
    }
    if (message.role !== 0) {
      writer.uint32(32).int32(message.role);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BridgeConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBridgeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.vlanAware = reader.bool();
          break;
        case 3:
          message.addrs.push(reader.string());
          break;
        case 4:
          message.role = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BridgeConfig {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      vlanAware: isSet(object.vlanAware) ? Boolean(object.vlanAware) : false,
      addrs: Array.isArray(object?.addrs) ? object.addrs.map((e: any) => String(e)) : [],
      role: isSet(object.role) ? linkRoleFromJSON(object.role) : 0,
    };
  },

  toJSON(message: BridgeConfig): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.vlanAware !== undefined && (obj.vlanAware = message.vlanAware);
    if (message.addrs) {
      obj.addrs = message.addrs.map((e) => e);
    } else {
      obj.addrs = [];
    }
    message.role !== undefined && (obj.role = linkRoleToJSON(message.role));
    return obj;
  },

  create<I extends Exact<DeepPartial<BridgeConfig>, I>>(base?: I): BridgeConfig {
    return BridgeConfig.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<BridgeConfig>, I>>(object: I): BridgeConfig {
    const message = createBaseBridgeConfig();
    message.name = object.name ?? "";
    message.vlanAware = object.vlanAware ?? false;
    message.addrs = object.addrs?.map((e) => e) || [];
    message.role = object.role ?? 0;
    return message;
  },
};

function createBaseBreakout(): Breakout {
  return { index: 0, radix: 0 };
}

export const Breakout = {
  encode(message: Breakout, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== 0) {
      writer.uint32(8).uint32(message.index);
    }
    if (message.radix !== 0) {
      writer.uint32(16).uint32(message.radix);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Breakout {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBreakout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.index = reader.uint32();
          break;
        case 2:
          message.radix = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Breakout {
    return {
      index: isSet(object.index) ? Number(object.index) : 0,
      radix: isSet(object.radix) ? Number(object.radix) : 0,
    };
  },

  toJSON(message: Breakout): unknown {
    const obj: any = {};
    message.index !== undefined && (obj.index = Math.round(message.index));
    message.radix !== undefined && (obj.radix = Math.round(message.radix));
    return obj;
  },

  create<I extends Exact<DeepPartial<Breakout>, I>>(base?: I): Breakout {
    return Breakout.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Breakout>, I>>(object: I): Breakout {
    const message = createBaseBreakout();
    message.index = object.index ?? 0;
    message.radix = object.radix ?? 0;
    return message;
  },
};

function createBasePortBond(): PortBond {
  return { name: "" };
}

export const PortBond = {
  encode(message: PortBond, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PortBond {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortBond();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PortBond {
    return { name: isSet(object.name) ? String(object.name) : "" };
  },

  toJSON(message: PortBond): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  create<I extends Exact<DeepPartial<PortBond>, I>>(base?: I): PortBond {
    return PortBond.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<PortBond>, I>>(object: I): PortBond {
    const message = createBasePortBond();
    message.name = object.name ?? "";
    return message;
  },
};

function createBasesriovPf(): sriovPf {
  return { MaxVFs: 0 };
}

export const sriovPf = {
  encode(message: sriovPf, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.MaxVFs !== 0) {
      writer.uint32(8).uint32(message.MaxVFs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): sriovPf {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasesriovPf();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.MaxVFs = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): sriovPf {
    return { MaxVFs: isSet(object.MaxVFs) ? Number(object.MaxVFs) : 0 };
  },

  toJSON(message: sriovPf): unknown {
    const obj: any = {};
    message.MaxVFs !== undefined && (obj.MaxVFs = Math.round(message.MaxVFs));
    return obj;
  },

  create<I extends Exact<DeepPartial<sriovPf>, I>>(base?: I): sriovPf {
    return sriovPf.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<sriovPf>, I>>(object: I): sriovPf {
    const message = createBasesriovPf();
    message.MaxVFs = object.MaxVFs ?? 0;
    return message;
  },
};

function createBasesriovVf(): sriovVf {
  return { VfIndex: 0 };
}

export const sriovVf = {
  encode(message: sriovVf, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.VfIndex !== 0) {
      writer.uint32(8).uint32(message.VfIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): sriovVf {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasesriovVf();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.VfIndex = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): sriovVf {
    return { VfIndex: isSet(object.VfIndex) ? Number(object.VfIndex) : 0 };
  },

  toJSON(message: sriovVf): unknown {
    const obj: any = {};
    message.VfIndex !== undefined && (obj.VfIndex = Math.round(message.VfIndex));
    return obj;
  },

  create<I extends Exact<DeepPartial<sriovVf>, I>>(base?: I): sriovVf {
    return sriovVf.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<sriovVf>, I>>(object: I): sriovVf {
    const message = createBasesriovVf();
    message.VfIndex = object.VfIndex ?? 0;
    return message;
  },
};

function createBaseSRIOV(): SRIOV {
  return { Pf: undefined, Vf: undefined, PfNi: 0, PfPi: 0 };
}

export const SRIOV = {
  encode(message: SRIOV, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Pf !== undefined) {
      sriovPf.encode(message.Pf, writer.uint32(18).fork()).ldelim();
    }
    if (message.Vf !== undefined) {
      sriovVf.encode(message.Vf, writer.uint32(26).fork()).ldelim();
    }
    if (message.PfNi !== 0) {
      writer.uint32(32).uint32(message.PfNi);
    }
    if (message.PfPi !== 0) {
      writer.uint32(40).uint32(message.PfPi);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SRIOV {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSRIOV();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.Pf = sriovPf.decode(reader, reader.uint32());
          break;
        case 3:
          message.Vf = sriovVf.decode(reader, reader.uint32());
          break;
        case 4:
          message.PfNi = reader.uint32();
          break;
        case 5:
          message.PfPi = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SRIOV {
    return {
      Pf: isSet(object.Pf) ? sriovPf.fromJSON(object.Pf) : undefined,
      Vf: isSet(object.Vf) ? sriovVf.fromJSON(object.Vf) : undefined,
      PfNi: isSet(object.PfNi) ? Number(object.PfNi) : 0,
      PfPi: isSet(object.PfPi) ? Number(object.PfPi) : 0,
    };
  },

  toJSON(message: SRIOV): unknown {
    const obj: any = {};
    message.Pf !== undefined && (obj.Pf = message.Pf ? sriovPf.toJSON(message.Pf) : undefined);
    message.Vf !== undefined && (obj.Vf = message.Vf ? sriovVf.toJSON(message.Vf) : undefined);
    message.PfNi !== undefined && (obj.PfNi = Math.round(message.PfNi));
    message.PfPi !== undefined && (obj.PfPi = Math.round(message.PfPi));
    return obj;
  },

  create<I extends Exact<DeepPartial<SRIOV>, I>>(base?: I): SRIOV {
    return SRIOV.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SRIOV>, I>>(object: I): SRIOV {
    const message = createBaseSRIOV();
    message.Pf = (object.Pf !== undefined && object.Pf !== null) ? sriovPf.fromPartial(object.Pf) : undefined;
    message.Vf = (object.Vf !== undefined && object.Vf !== null) ? sriovVf.fromPartial(object.Vf) : undefined;
    message.PfNi = object.PfNi ?? 0;
    message.PfPi = object.PfPi ?? 0;
    return message;
  },
};

function createBasePort(): Port {
  return {
    parent: "",
    index: 0,
    protocols: [],
    capacity: 0,
    mac: "",
    formFactor: 0,
    connector: undefined,
    role: 0,
    TPA: 0,
    queues: 0,
    breakout: undefined,
    bond: undefined,
    name: "",
    sriov: undefined,
  };
}

export const Port = {
  encode(message: Port, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    writer.uint32(26).fork();
    for (const v of message.protocols) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.capacity !== 0) {
      writer.uint32(32).uint64(message.capacity);
    }
    if (message.mac !== "") {
      writer.uint32(42).string(message.mac);
    }
    if (message.formFactor !== 0) {
      writer.uint32(48).int32(message.formFactor);
    }
    if (message.connector !== undefined) {
      Ref.encode(message.connector, writer.uint32(58).fork()).ldelim();
    }
    if (message.role !== 0) {
      writer.uint32(64).int32(message.role);
    }
    if (message.TPA !== 0) {
      writer.uint32(72).uint64(message.TPA);
    }
    if (message.queues !== 0) {
      writer.uint32(80).uint64(message.queues);
    }
    if (message.breakout !== undefined) {
      Breakout.encode(message.breakout, writer.uint32(90).fork()).ldelim();
    }
    if (message.bond !== undefined) {
      PortBond.encode(message.bond, writer.uint32(98).fork()).ldelim();
    }
    if (message.name !== "") {
      writer.uint32(106).string(message.name);
    }
    if (message.sriov !== undefined) {
      SRIOV.encode(message.sriov, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Port {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.parent = reader.string();
          break;
        case 2:
          message.index = reader.uint32();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.protocols.push(reader.int32() as any);
            }
          } else {
            message.protocols.push(reader.int32() as any);
          }
          break;
        case 4:
          message.capacity = longToNumber(reader.uint64() as Long);
          break;
        case 5:
          message.mac = reader.string();
          break;
        case 6:
          message.formFactor = reader.int32() as any;
          break;
        case 7:
          message.connector = Ref.decode(reader, reader.uint32());
          break;
        case 8:
          message.role = reader.int32() as any;
          break;
        case 9:
          message.TPA = longToNumber(reader.uint64() as Long);
          break;
        case 10:
          message.queues = longToNumber(reader.uint64() as Long);
          break;
        case 11:
          message.breakout = Breakout.decode(reader, reader.uint32());
          break;
        case 12:
          message.bond = PortBond.decode(reader, reader.uint32());
          break;
        case 13:
          message.name = reader.string();
          break;
        case 14:
          message.sriov = SRIOV.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Port {
    return {
      parent: isSet(object.parent) ? String(object.parent) : "",
      index: isSet(object.index) ? Number(object.index) : 0,
      protocols: Array.isArray(object?.protocols) ? object.protocols.map((e: any) => layer1FromJSON(e)) : [],
      capacity: isSet(object.capacity) ? Number(object.capacity) : 0,
      mac: isSet(object.mac) ? String(object.mac) : "",
      formFactor: isSet(object.formFactor) ? connectorKindFromJSON(object.formFactor) : 0,
      connector: isSet(object.connector) ? Ref.fromJSON(object.connector) : undefined,
      role: isSet(object.role) ? linkRoleFromJSON(object.role) : 0,
      TPA: isSet(object.TPA) ? Number(object.TPA) : 0,
      queues: isSet(object.queues) ? Number(object.queues) : 0,
      breakout: isSet(object.breakout) ? Breakout.fromJSON(object.breakout) : undefined,
      bond: isSet(object.bond) ? PortBond.fromJSON(object.bond) : undefined,
      name: isSet(object.name) ? String(object.name) : "",
      sriov: isSet(object.sriov) ? SRIOV.fromJSON(object.sriov) : undefined,
    };
  },

  toJSON(message: Port): unknown {
    const obj: any = {};
    message.parent !== undefined && (obj.parent = message.parent);
    message.index !== undefined && (obj.index = Math.round(message.index));
    if (message.protocols) {
      obj.protocols = message.protocols.map((e) => layer1ToJSON(e));
    } else {
      obj.protocols = [];
    }
    message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
    message.mac !== undefined && (obj.mac = message.mac);
    message.formFactor !== undefined && (obj.formFactor = connectorKindToJSON(message.formFactor));
    message.connector !== undefined && (obj.connector = message.connector ? Ref.toJSON(message.connector) : undefined);
    message.role !== undefined && (obj.role = linkRoleToJSON(message.role));
    message.TPA !== undefined && (obj.TPA = Math.round(message.TPA));
    message.queues !== undefined && (obj.queues = Math.round(message.queues));
    message.breakout !== undefined && (obj.breakout = message.breakout ? Breakout.toJSON(message.breakout) : undefined);
    message.bond !== undefined && (obj.bond = message.bond ? PortBond.toJSON(message.bond) : undefined);
    message.name !== undefined && (obj.name = message.name);
    message.sriov !== undefined && (obj.sriov = message.sriov ? SRIOV.toJSON(message.sriov) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Port>, I>>(base?: I): Port {
    return Port.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Port>, I>>(object: I): Port {
    const message = createBasePort();
    message.parent = object.parent ?? "";
    message.index = object.index ?? 0;
    message.protocols = object.protocols?.map((e) => e) || [];
    message.capacity = object.capacity ?? 0;
    message.mac = object.mac ?? "";
    message.formFactor = object.formFactor ?? 0;
    message.connector = (object.connector !== undefined && object.connector !== null)
      ? Ref.fromPartial(object.connector)
      : undefined;
    message.role = object.role ?? 0;
    message.TPA = object.TPA ?? 0;
    message.queues = object.queues ?? 0;
    message.breakout = (object.breakout !== undefined && object.breakout !== null)
      ? Breakout.fromPartial(object.breakout)
      : undefined;
    message.bond = (object.bond !== undefined && object.bond !== null) ? PortBond.fromPartial(object.bond) : undefined;
    message.name = object.name ?? "";
    message.sriov = (object.sriov !== undefined && object.sriov !== null) ? SRIOV.fromPartial(object.sriov) : undefined;
    return message;
  },
};

function createBasePortAllocation(): PortAllocation {
  return { name: "", mac: "", capacity: 0, VfName: "", VfAlloc: false };
}

export const PortAllocation = {
  encode(message: PortAllocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.mac !== "") {
      writer.uint32(18).string(message.mac);
    }
    if (message.capacity !== 0) {
      writer.uint32(24).uint64(message.capacity);
    }
    if (message.VfName !== "") {
      writer.uint32(34).string(message.VfName);
    }
    if (message.VfAlloc === true) {
      writer.uint32(40).bool(message.VfAlloc);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PortAllocation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.mac = reader.string();
          break;
        case 3:
          message.capacity = longToNumber(reader.uint64() as Long);
          break;
        case 4:
          message.VfName = reader.string();
          break;
        case 5:
          message.VfAlloc = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PortAllocation {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      mac: isSet(object.mac) ? String(object.mac) : "",
      capacity: isSet(object.capacity) ? Number(object.capacity) : 0,
      VfName: isSet(object.VfName) ? String(object.VfName) : "",
      VfAlloc: isSet(object.VfAlloc) ? Boolean(object.VfAlloc) : false,
    };
  },

  toJSON(message: PortAllocation): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.mac !== undefined && (obj.mac = message.mac);
    message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
    message.VfName !== undefined && (obj.VfName = message.VfName);
    message.VfAlloc !== undefined && (obj.VfAlloc = message.VfAlloc);
    return obj;
  },

  create<I extends Exact<DeepPartial<PortAllocation>, I>>(base?: I): PortAllocation {
    return PortAllocation.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<PortAllocation>, I>>(object: I): PortAllocation {
    const message = createBasePortAllocation();
    message.name = object.name ?? "";
    message.mac = object.mac ?? "";
    message.capacity = object.capacity ?? 0;
    message.VfName = object.VfName ?? "";
    message.VfAlloc = object.VfAlloc ?? false;
    return message;
  },
};

function createBasePortRef(): PortRef {
  return { mac: "" };
}

export const PortRef = {
  encode(message: PortRef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mac !== "") {
      writer.uint32(10).string(message.mac);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PortRef {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mac = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PortRef {
    return { mac: isSet(object.mac) ? String(object.mac) : "" };
  },

  toJSON(message: PortRef): unknown {
    const obj: any = {};
    message.mac !== undefined && (obj.mac = message.mac);
    return obj;
  },

  create<I extends Exact<DeepPartial<PortRef>, I>>(base?: I): PortRef {
    return PortRef.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<PortRef>, I>>(object: I): PortRef {
    const message = createBasePortRef();
    message.mac = object.mac ?? "";
    return message;
  },
};

function createBasePortSpec(): PortSpec {
  return {
    protocols: [],
    capacity: undefined,
    formFactor: undefined,
    queues: undefined,
    model: undefined,
    DPDK: undefined,
    SriovVF: undefined,
  };
}

export const PortSpec = {
  encode(message: PortSpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.protocols) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.capacity !== undefined) {
      Uint64Constraint.encode(message.capacity, writer.uint32(18).fork()).ldelim();
    }
    if (message.formFactor !== undefined) {
      ConnectorKindConstraint.encode(message.formFactor, writer.uint32(26).fork()).ldelim();
    }
    if (message.queues !== undefined) {
      Uint64Constraint.encode(message.queues, writer.uint32(34).fork()).ldelim();
    }
    if (message.model !== undefined) {
      NICModelConstraint.encode(message.model, writer.uint32(42).fork()).ldelim();
    }
    if (message.DPDK !== undefined) {
      BoolConstraint.encode(message.DPDK, writer.uint32(50).fork()).ldelim();
    }
    if (message.SriovVF !== undefined) {
      BoolConstraint.encode(message.SriovVF, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PortSpec {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.protocols.push(reader.int32() as any);
            }
          } else {
            message.protocols.push(reader.int32() as any);
          }
          break;
        case 2:
          message.capacity = Uint64Constraint.decode(reader, reader.uint32());
          break;
        case 3:
          message.formFactor = ConnectorKindConstraint.decode(reader, reader.uint32());
          break;
        case 4:
          message.queues = Uint64Constraint.decode(reader, reader.uint32());
          break;
        case 5:
          message.model = NICModelConstraint.decode(reader, reader.uint32());
          break;
        case 6:
          message.DPDK = BoolConstraint.decode(reader, reader.uint32());
          break;
        case 7:
          message.SriovVF = BoolConstraint.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PortSpec {
    return {
      protocols: Array.isArray(object?.protocols) ? object.protocols.map((e: any) => layer1FromJSON(e)) : [],
      capacity: isSet(object.capacity) ? Uint64Constraint.fromJSON(object.capacity) : undefined,
      formFactor: isSet(object.formFactor) ? ConnectorKindConstraint.fromJSON(object.formFactor) : undefined,
      queues: isSet(object.queues) ? Uint64Constraint.fromJSON(object.queues) : undefined,
      model: isSet(object.model) ? NICModelConstraint.fromJSON(object.model) : undefined,
      DPDK: isSet(object.DPDK) ? BoolConstraint.fromJSON(object.DPDK) : undefined,
      SriovVF: isSet(object.SriovVF) ? BoolConstraint.fromJSON(object.SriovVF) : undefined,
    };
  },

  toJSON(message: PortSpec): unknown {
    const obj: any = {};
    if (message.protocols) {
      obj.protocols = message.protocols.map((e) => layer1ToJSON(e));
    } else {
      obj.protocols = [];
    }
    message.capacity !== undefined &&
      (obj.capacity = message.capacity ? Uint64Constraint.toJSON(message.capacity) : undefined);
    message.formFactor !== undefined &&
      (obj.formFactor = message.formFactor ? ConnectorKindConstraint.toJSON(message.formFactor) : undefined);
    message.queues !== undefined && (obj.queues = message.queues ? Uint64Constraint.toJSON(message.queues) : undefined);
    message.model !== undefined && (obj.model = message.model ? NICModelConstraint.toJSON(message.model) : undefined);
    message.DPDK !== undefined && (obj.DPDK = message.DPDK ? BoolConstraint.toJSON(message.DPDK) : undefined);
    message.SriovVF !== undefined &&
      (obj.SriovVF = message.SriovVF ? BoolConstraint.toJSON(message.SriovVF) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<PortSpec>, I>>(base?: I): PortSpec {
    return PortSpec.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<PortSpec>, I>>(object: I): PortSpec {
    const message = createBasePortSpec();
    message.protocols = object.protocols?.map((e) => e) || [];
    message.capacity = (object.capacity !== undefined && object.capacity !== null)
      ? Uint64Constraint.fromPartial(object.capacity)
      : undefined;
    message.formFactor = (object.formFactor !== undefined && object.formFactor !== null)
      ? ConnectorKindConstraint.fromPartial(object.formFactor)
      : undefined;
    message.queues = (object.queues !== undefined && object.queues !== null)
      ? Uint64Constraint.fromPartial(object.queues)
      : undefined;
    message.model = (object.model !== undefined && object.model !== null)
      ? NICModelConstraint.fromPartial(object.model)
      : undefined;
    message.DPDK = (object.DPDK !== undefined && object.DPDK !== null)
      ? BoolConstraint.fromPartial(object.DPDK)
      : undefined;
    message.SriovVF = (object.SriovVF !== undefined && object.SriovVF !== null)
      ? BoolConstraint.fromPartial(object.SriovVF)
      : undefined;
    return message;
  },
};

function createBaseCable(): Cable {
  return { id: "", facility: "", kind: 0, ends: [], productInfo: undefined };
}

export const Cable = {
  encode(message: Cable, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.facility !== "") {
      writer.uint32(18).string(message.facility);
    }
    if (message.kind !== 0) {
      writer.uint32(24).int32(message.kind);
    }
    for (const v of message.ends) {
      End.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.productInfo !== undefined) {
      ProductInfo.encode(message.productInfo, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Cable {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.facility = reader.string();
          break;
        case 3:
          message.kind = reader.int32() as any;
          break;
        case 4:
          message.ends.push(End.decode(reader, reader.uint32()));
          break;
        case 5:
          message.productInfo = ProductInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Cable {
    return {
      id: isSet(object.id) ? String(object.id) : "",
      facility: isSet(object.facility) ? String(object.facility) : "",
      kind: isSet(object.kind) ? cableKindFromJSON(object.kind) : 0,
      ends: Array.isArray(object?.ends) ? object.ends.map((e: any) => End.fromJSON(e)) : [],
      productInfo: isSet(object.productInfo) ? ProductInfo.fromJSON(object.productInfo) : undefined,
    };
  },

  toJSON(message: Cable): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = message.id);
    message.facility !== undefined && (obj.facility = message.facility);
    message.kind !== undefined && (obj.kind = cableKindToJSON(message.kind));
    if (message.ends) {
      obj.ends = message.ends.map((e) => e ? End.toJSON(e) : undefined);
    } else {
      obj.ends = [];
    }
    message.productInfo !== undefined &&
      (obj.productInfo = message.productInfo ? ProductInfo.toJSON(message.productInfo) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Cable>, I>>(base?: I): Cable {
    return Cable.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Cable>, I>>(object: I): Cable {
    const message = createBaseCable();
    message.id = object.id ?? "";
    message.facility = object.facility ?? "";
    message.kind = object.kind ?? 0;
    message.ends = object.ends?.map((e) => End.fromPartial(e)) || [];
    message.productInfo = (object.productInfo !== undefined && object.productInfo !== null)
      ? ProductInfo.fromPartial(object.productInfo)
      : undefined;
    return message;
  },
};

function createBaseEnd(): End {
  return { connectors: [] };
}

export const End = {
  encode(message: End, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.connectors) {
      Connector.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): End {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.connectors.push(Connector.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): End {
    return {
      connectors: Array.isArray(object?.connectors) ? object.connectors.map((e: any) => Connector.fromJSON(e)) : [],
    };
  },

  toJSON(message: End): unknown {
    const obj: any = {};
    if (message.connectors) {
      obj.connectors = message.connectors.map((e) => e ? Connector.toJSON(e) : undefined);
    } else {
      obj.connectors = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<End>, I>>(base?: I): End {
    return End.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<End>, I>>(object: I): End {
    const message = createBaseEnd();
    message.connectors = object.connectors?.map((e) => Connector.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConnector(): Connector {
  return { parent: "", index: 0, kind: 0, protocols: [], capacity: 0, Port: undefined, breakout: undefined };
}

export const Connector = {
  encode(message: Connector, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    if (message.kind !== 0) {
      writer.uint32(24).int32(message.kind);
    }
    writer.uint32(34).fork();
    for (const v of message.protocols) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.capacity !== 0) {
      writer.uint32(40).uint64(message.capacity);
    }
    if (message.Port !== undefined) {
      Ref.encode(message.Port, writer.uint32(50).fork()).ldelim();
    }
    if (message.breakout !== undefined) {
      Breakout.encode(message.breakout, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Connector {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.parent = reader.string();
          break;
        case 2:
          message.index = reader.uint32();
          break;
        case 3:
          message.kind = reader.int32() as any;
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.protocols.push(reader.int32() as any);
            }
          } else {
            message.protocols.push(reader.int32() as any);
          }
          break;
        case 5:
          message.capacity = longToNumber(reader.uint64() as Long);
          break;
        case 6:
          message.Port = Ref.decode(reader, reader.uint32());
          break;
        case 7:
          message.breakout = Breakout.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Connector {
    return {
      parent: isSet(object.parent) ? String(object.parent) : "",
      index: isSet(object.index) ? Number(object.index) : 0,
      kind: isSet(object.kind) ? connectorKindFromJSON(object.kind) : 0,
      protocols: Array.isArray(object?.protocols) ? object.protocols.map((e: any) => layer1FromJSON(e)) : [],
      capacity: isSet(object.capacity) ? Number(object.capacity) : 0,
      Port: isSet(object.Port) ? Ref.fromJSON(object.Port) : undefined,
      breakout: isSet(object.breakout) ? Breakout.fromJSON(object.breakout) : undefined,
    };
  },

  toJSON(message: Connector): unknown {
    const obj: any = {};
    message.parent !== undefined && (obj.parent = message.parent);
    message.index !== undefined && (obj.index = Math.round(message.index));
    message.kind !== undefined && (obj.kind = connectorKindToJSON(message.kind));
    if (message.protocols) {
      obj.protocols = message.protocols.map((e) => layer1ToJSON(e));
    } else {
      obj.protocols = [];
    }
    message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
    message.Port !== undefined && (obj.Port = message.Port ? Ref.toJSON(message.Port) : undefined);
    message.breakout !== undefined && (obj.breakout = message.breakout ? Breakout.toJSON(message.breakout) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<Connector>, I>>(base?: I): Connector {
    return Connector.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Connector>, I>>(object: I): Connector {
    const message = createBaseConnector();
    message.parent = object.parent ?? "";
    message.index = object.index ?? 0;
    message.kind = object.kind ?? 0;
    message.protocols = object.protocols?.map((e) => e) || [];
    message.capacity = object.capacity ?? 0;
    message.Port = (object.Port !== undefined && object.Port !== null) ? Ref.fromPartial(object.Port) : undefined;
    message.breakout = (object.breakout !== undefined && object.breakout !== null)
      ? Breakout.fromPartial(object.breakout)
      : undefined;
    return message;
  },
};

function createBaseConnectorSpec(): ConnectorSpec {
  return { kind: undefined, protocols: [], capacity: 0 };
}

export const ConnectorSpec = {
  encode(message: ConnectorSpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kind !== undefined) {
      ConnectorKindConstraint.encode(message.kind, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).fork();
    for (const v of message.protocols) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.capacity !== 0) {
      writer.uint32(24).uint64(message.capacity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConnectorSpec {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectorSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kind = ConnectorKindConstraint.decode(reader, reader.uint32());
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.protocols.push(reader.int32() as any);
            }
          } else {
            message.protocols.push(reader.int32() as any);
          }
          break;
        case 3:
          message.capacity = longToNumber(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ConnectorSpec {
    return {
      kind: isSet(object.kind) ? ConnectorKindConstraint.fromJSON(object.kind) : undefined,
      protocols: Array.isArray(object?.protocols) ? object.protocols.map((e: any) => layer1FromJSON(e)) : [],
      capacity: isSet(object.capacity) ? Number(object.capacity) : 0,
    };
  },

  toJSON(message: ConnectorSpec): unknown {
    const obj: any = {};
    message.kind !== undefined && (obj.kind = message.kind ? ConnectorKindConstraint.toJSON(message.kind) : undefined);
    if (message.protocols) {
      obj.protocols = message.protocols.map((e) => layer1ToJSON(e));
    } else {
      obj.protocols = [];
    }
    message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectorSpec>, I>>(base?: I): ConnectorSpec {
    return ConnectorSpec.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ConnectorSpec>, I>>(object: I): ConnectorSpec {
    const message = createBaseConnectorSpec();
    message.kind = (object.kind !== undefined && object.kind !== null)
      ? ConnectorKindConstraint.fromPartial(object.kind)
      : undefined;
    message.protocols = object.protocols?.map((e) => e) || [];
    message.capacity = object.capacity ?? 0;
    return message;
  },
};

function createBaseProc(): Proc {
  return {
    isa: 0,
    family: "",
    BaseFrequency: 0,
    L2: 0,
    cores: 0,
    threads: 0,
    tdp: 0,
    hyperthreaded: false,
    productInfo: undefined,
    reservedCores: 0,
  };
}

export const Proc = {
  encode(message: Proc, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isa !== 0) {
      writer.uint32(8).int32(message.isa);
    }
    if (message.family !== "") {
      writer.uint32(18).string(message.family);
    }
    if (message.BaseFrequency !== 0) {
      writer.uint32(24).uint64(message.BaseFrequency);
    }
    if (message.L2 !== 0) {
      writer.uint32(32).uint64(message.L2);
    }
    if (message.cores !== 0) {
      writer.uint32(40).uint32(message.cores);
    }
    if (message.threads !== 0) {
      writer.uint32(48).uint32(message.threads);
    }
    if (message.tdp !== 0) {
      writer.uint32(56).uint32(message.tdp);
    }
    if (message.hyperthreaded === true) {
      writer.uint32(64).bool(message.hyperthreaded);
    }
    if (message.productInfo !== undefined) {
      ProductInfo.encode(message.productInfo, writer.uint32(74).fork()).ldelim();
    }
    if (message.reservedCores !== 0) {
      writer.uint32(80).uint32(message.reservedCores);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Proc {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isa = reader.int32() as any;
          break;
        case 2:
          message.family = reader.string();
          break;
        case 3:
          message.BaseFrequency = longToNumber(reader.uint64() as Long);
          break;
        case 4:
          message.L2 = longToNumber(reader.uint64() as Long);
          break;
        case 5:
          message.cores = reader.uint32();
          break;
        case 6:
          message.threads = reader.uint32();
          break;
        case 7:
          message.tdp = reader.uint32();
          break;
        case 8:
          message.hyperthreaded = reader.bool();
          break;
        case 9:
          message.productInfo = ProductInfo.decode(reader, reader.uint32());
          break;
        case 10:
          message.reservedCores = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Proc {
    return {
      isa: isSet(object.isa) ? iSAFromJSON(object.isa) : 0,
      family: isSet(object.family) ? String(object.family) : "",
      BaseFrequency: isSet(object.BaseFrequency) ? Number(object.BaseFrequency) : 0,
      L2: isSet(object.L2) ? Number(object.L2) : 0,
      cores: isSet(object.cores) ? Number(object.cores) : 0,
      threads: isSet(object.threads) ? Number(object.threads) : 0,
      tdp: isSet(object.tdp) ? Number(object.tdp) : 0,
      hyperthreaded: isSet(object.hyperthreaded) ? Boolean(object.hyperthreaded) : false,
      productInfo: isSet(object.productInfo) ? ProductInfo.fromJSON(object.productInfo) : undefined,
      reservedCores: isSet(object.reservedCores) ? Number(object.reservedCores) : 0,
    };
  },

  toJSON(message: Proc): unknown {
    const obj: any = {};
    message.isa !== undefined && (obj.isa = iSAToJSON(message.isa));
    message.family !== undefined && (obj.family = message.family);
    message.BaseFrequency !== undefined && (obj.BaseFrequency = Math.round(message.BaseFrequency));
    message.L2 !== undefined && (obj.L2 = Math.round(message.L2));
    message.cores !== undefined && (obj.cores = Math.round(message.cores));
    message.threads !== undefined && (obj.threads = Math.round(message.threads));
    message.tdp !== undefined && (obj.tdp = Math.round(message.tdp));
    message.hyperthreaded !== undefined && (obj.hyperthreaded = message.hyperthreaded);
    message.productInfo !== undefined &&
      (obj.productInfo = message.productInfo ? ProductInfo.toJSON(message.productInfo) : undefined);
    message.reservedCores !== undefined && (obj.reservedCores = Math.round(message.reservedCores));
    return obj;
  },

  create<I extends Exact<DeepPartial<Proc>, I>>(base?: I): Proc {
    return Proc.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Proc>, I>>(object: I): Proc {
    const message = createBaseProc();
    message.isa = object.isa ?? 0;
    message.family = object.family ?? "";
    message.BaseFrequency = object.BaseFrequency ?? 0;
    message.L2 = object.L2 ?? 0;
    message.cores = object.cores ?? 0;
    message.threads = object.threads ?? 0;
    message.tdp = object.tdp ?? 0;
    message.hyperthreaded = object.hyperthreaded ?? false;
    message.productInfo = (object.productInfo !== undefined && object.productInfo !== null)
      ? ProductInfo.fromPartial(object.productInfo)
      : undefined;
    message.reservedCores = object.reservedCores ?? 0;
    return message;
  },
};

function createBaseSocketAllocation(): SocketAllocation {
  return { cores: 0 };
}

export const SocketAllocation = {
  encode(message: SocketAllocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cores !== 0) {
      writer.uint32(8).uint32(message.cores);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SocketAllocation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSocketAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.cores = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SocketAllocation {
    return { cores: isSet(object.cores) ? Number(object.cores) : 0 };
  },

  toJSON(message: SocketAllocation): unknown {
    const obj: any = {};
    message.cores !== undefined && (obj.cores = Math.round(message.cores));
    return obj;
  },

  create<I extends Exact<DeepPartial<SocketAllocation>, I>>(base?: I): SocketAllocation {
    return SocketAllocation.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SocketAllocation>, I>>(object: I): SocketAllocation {
    const message = createBaseSocketAllocation();
    message.cores = object.cores ?? 0;
    return message;
  },
};

function createBaseProcAllocation(): ProcAllocation {
  return { alloc: {} };
}

export const ProcAllocation = {
  encode(message: ProcAllocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.alloc).forEach(([key, value]) => {
      ProcAllocation_AllocEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProcAllocation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = ProcAllocation_AllocEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.alloc[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ProcAllocation {
    return {
      alloc: isObject(object.alloc)
        ? Object.entries(object.alloc).reduce<{ [key: number]: SocketAllocation }>((acc, [key, value]) => {
          acc[Number(key)] = SocketAllocation.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ProcAllocation): unknown {
    const obj: any = {};
    obj.alloc = {};
    if (message.alloc) {
      Object.entries(message.alloc).forEach(([k, v]) => {
        obj.alloc[k] = SocketAllocation.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcAllocation>, I>>(base?: I): ProcAllocation {
    return ProcAllocation.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ProcAllocation>, I>>(object: I): ProcAllocation {
    const message = createBaseProcAllocation();
    message.alloc = Object.entries(object.alloc ?? {}).reduce<{ [key: number]: SocketAllocation }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[Number(key)] = SocketAllocation.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseProcAllocation_AllocEntry(): ProcAllocation_AllocEntry {
  return { key: 0, value: undefined };
}

export const ProcAllocation_AllocEntry = {
  encode(message: ProcAllocation_AllocEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      SocketAllocation.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProcAllocation_AllocEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcAllocation_AllocEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.uint32();
          break;
        case 2:
          message.value = SocketAllocation.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ProcAllocation_AllocEntry {
    return {
      key: isSet(object.key) ? Number(object.key) : 0,
      value: isSet(object.value) ? SocketAllocation.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ProcAllocation_AllocEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = Math.round(message.key));
    message.value !== undefined && (obj.value = message.value ? SocketAllocation.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcAllocation_AllocEntry>, I>>(base?: I): ProcAllocation_AllocEntry {
    return ProcAllocation_AllocEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ProcAllocation_AllocEntry>, I>>(object: I): ProcAllocation_AllocEntry {
    const message = createBaseProcAllocation_AllocEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? SocketAllocation.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseProcSpec(): ProcSpec {
  return {
    isa: undefined,
    family: undefined,
    BaseFrequency: undefined,
    L2: undefined,
    cores: undefined,
    threads: undefined,
    tdp: undefined,
    sockets: undefined,
    hyperthreaded: undefined,
  };
}

export const ProcSpec = {
  encode(message: ProcSpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.isa !== undefined) {
      ISAConstraint.encode(message.isa, writer.uint32(10).fork()).ldelim();
    }
    if (message.family !== undefined) {
      StringConstraint.encode(message.family, writer.uint32(18).fork()).ldelim();
    }
    if (message.BaseFrequency !== undefined) {
      Uint64Constraint.encode(message.BaseFrequency, writer.uint32(26).fork()).ldelim();
    }
    if (message.L2 !== undefined) {
      Uint64Constraint.encode(message.L2, writer.uint32(34).fork()).ldelim();
    }
    if (message.cores !== undefined) {
      Uint32Constraint.encode(message.cores, writer.uint32(42).fork()).ldelim();
    }
    if (message.threads !== undefined) {
      Uint32Constraint.encode(message.threads, writer.uint32(50).fork()).ldelim();
    }
    if (message.tdp !== undefined) {
      Uint32Constraint.encode(message.tdp, writer.uint32(58).fork()).ldelim();
    }
    if (message.sockets !== undefined) {
      Uint32Constraint.encode(message.sockets, writer.uint32(66).fork()).ldelim();
    }
    if (message.hyperthreaded !== undefined) {
      BoolConstraint.encode(message.hyperthreaded, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProcSpec {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isa = ISAConstraint.decode(reader, reader.uint32());
          break;
        case 2:
          message.family = StringConstraint.decode(reader, reader.uint32());
          break;
        case 3:
          message.BaseFrequency = Uint64Constraint.decode(reader, reader.uint32());
          break;
        case 4:
          message.L2 = Uint64Constraint.decode(reader, reader.uint32());
          break;
        case 5:
          message.cores = Uint32Constraint.decode(reader, reader.uint32());
          break;
        case 6:
          message.threads = Uint32Constraint.decode(reader, reader.uint32());
          break;
        case 7:
          message.tdp = Uint32Constraint.decode(reader, reader.uint32());
          break;
        case 8:
          message.sockets = Uint32Constraint.decode(reader, reader.uint32());
          break;
        case 9:
          message.hyperthreaded = BoolConstraint.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ProcSpec {
    return {
      isa: isSet(object.isa) ? ISAConstraint.fromJSON(object.isa) : undefined,
      family: isSet(object.family) ? StringConstraint.fromJSON(object.family) : undefined,
      BaseFrequency: isSet(object.BaseFrequency) ? Uint64Constraint.fromJSON(object.BaseFrequency) : undefined,
      L2: isSet(object.L2) ? Uint64Constraint.fromJSON(object.L2) : undefined,
      cores: isSet(object.cores) ? Uint32Constraint.fromJSON(object.cores) : undefined,
      threads: isSet(object.threads) ? Uint32Constraint.fromJSON(object.threads) : undefined,
      tdp: isSet(object.tdp) ? Uint32Constraint.fromJSON(object.tdp) : undefined,
      sockets: isSet(object.sockets) ? Uint32Constraint.fromJSON(object.sockets) : undefined,
      hyperthreaded: isSet(object.hyperthreaded) ? BoolConstraint.fromJSON(object.hyperthreaded) : undefined,
    };
  },

  toJSON(message: ProcSpec): unknown {
    const obj: any = {};
    message.isa !== undefined && (obj.isa = message.isa ? ISAConstraint.toJSON(message.isa) : undefined);
    message.family !== undefined && (obj.family = message.family ? StringConstraint.toJSON(message.family) : undefined);
    message.BaseFrequency !== undefined &&
      (obj.BaseFrequency = message.BaseFrequency ? Uint64Constraint.toJSON(message.BaseFrequency) : undefined);
    message.L2 !== undefined && (obj.L2 = message.L2 ? Uint64Constraint.toJSON(message.L2) : undefined);
    message.cores !== undefined && (obj.cores = message.cores ? Uint32Constraint.toJSON(message.cores) : undefined);
    message.threads !== undefined &&
      (obj.threads = message.threads ? Uint32Constraint.toJSON(message.threads) : undefined);
    message.tdp !== undefined && (obj.tdp = message.tdp ? Uint32Constraint.toJSON(message.tdp) : undefined);
    message.sockets !== undefined &&
      (obj.sockets = message.sockets ? Uint32Constraint.toJSON(message.sockets) : undefined);
    message.hyperthreaded !== undefined &&
      (obj.hyperthreaded = message.hyperthreaded ? BoolConstraint.toJSON(message.hyperthreaded) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcSpec>, I>>(base?: I): ProcSpec {
    return ProcSpec.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ProcSpec>, I>>(object: I): ProcSpec {
    const message = createBaseProcSpec();
    message.isa = (object.isa !== undefined && object.isa !== null) ? ISAConstraint.fromPartial(object.isa) : undefined;
    message.family = (object.family !== undefined && object.family !== null)
      ? StringConstraint.fromPartial(object.family)
      : undefined;
    message.BaseFrequency = (object.BaseFrequency !== undefined && object.BaseFrequency !== null)
      ? Uint64Constraint.fromPartial(object.BaseFrequency)
      : undefined;
    message.L2 = (object.L2 !== undefined && object.L2 !== null) ? Uint64Constraint.fromPartial(object.L2) : undefined;
    message.cores = (object.cores !== undefined && object.cores !== null)
      ? Uint32Constraint.fromPartial(object.cores)
      : undefined;
    message.threads = (object.threads !== undefined && object.threads !== null)
      ? Uint32Constraint.fromPartial(object.threads)
      : undefined;
    message.tdp = (object.tdp !== undefined && object.tdp !== null)
      ? Uint32Constraint.fromPartial(object.tdp)
      : undefined;
    message.sockets = (object.sockets !== undefined && object.sockets !== null)
      ? Uint32Constraint.fromPartial(object.sockets)
      : undefined;
    message.hyperthreaded = (object.hyperthreaded !== undefined && object.hyperthreaded !== null)
      ? BoolConstraint.fromPartial(object.hyperthreaded)
      : undefined;
    return message;
  },
};

function createBaseDimm(): Dimm {
  return { type: 0, capacity: 0, frequency: 0, productInfo: undefined, reservedCapacity: 0 };
}

export const Dimm = {
  encode(message: Dimm, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.capacity !== 0) {
      writer.uint32(16).uint64(message.capacity);
    }
    if (message.frequency !== 0) {
      writer.uint32(24).uint64(message.frequency);
    }
    if (message.productInfo !== undefined) {
      ProductInfo.encode(message.productInfo, writer.uint32(34).fork()).ldelim();
    }
    if (message.reservedCapacity !== 0) {
      writer.uint32(40).uint64(message.reservedCapacity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Dimm {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32() as any;
          break;
        case 2:
          message.capacity = longToNumber(reader.uint64() as Long);
          break;
        case 3:
          message.frequency = longToNumber(reader.uint64() as Long);
          break;
        case 4:
          message.productInfo = ProductInfo.decode(reader, reader.uint32());
          break;
        case 5:
          message.reservedCapacity = longToNumber(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Dimm {
    return {
      type: isSet(object.type) ? memoryTypeFromJSON(object.type) : 0,
      capacity: isSet(object.capacity) ? Number(object.capacity) : 0,
      frequency: isSet(object.frequency) ? Number(object.frequency) : 0,
      productInfo: isSet(object.productInfo) ? ProductInfo.fromJSON(object.productInfo) : undefined,
      reservedCapacity: isSet(object.reservedCapacity) ? Number(object.reservedCapacity) : 0,
    };
  },

  toJSON(message: Dimm): unknown {
    const obj: any = {};
    message.type !== undefined && (obj.type = memoryTypeToJSON(message.type));
    message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
    message.frequency !== undefined && (obj.frequency = Math.round(message.frequency));
    message.productInfo !== undefined &&
      (obj.productInfo = message.productInfo ? ProductInfo.toJSON(message.productInfo) : undefined);
    message.reservedCapacity !== undefined && (obj.reservedCapacity = Math.round(message.reservedCapacity));
    return obj;
  },

  create<I extends Exact<DeepPartial<Dimm>, I>>(base?: I): Dimm {
    return Dimm.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Dimm>, I>>(object: I): Dimm {
    const message = createBaseDimm();
    message.type = object.type ?? 0;
    message.capacity = object.capacity ?? 0;
    message.frequency = object.frequency ?? 0;
    message.productInfo = (object.productInfo !== undefined && object.productInfo !== null)
      ? ProductInfo.fromPartial(object.productInfo)
      : undefined;
    message.reservedCapacity = object.reservedCapacity ?? 0;
    return message;
  },
};

function createBaseDimmAllocation(): DimmAllocation {
  return { capacity: 0 };
}

export const DimmAllocation = {
  encode(message: DimmAllocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.capacity !== 0) {
      writer.uint32(8).uint64(message.capacity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DimmAllocation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimmAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.capacity = longToNumber(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DimmAllocation {
    return { capacity: isSet(object.capacity) ? Number(object.capacity) : 0 };
  },

  toJSON(message: DimmAllocation): unknown {
    const obj: any = {};
    message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
    return obj;
  },

  create<I extends Exact<DeepPartial<DimmAllocation>, I>>(base?: I): DimmAllocation {
    return DimmAllocation.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DimmAllocation>, I>>(object: I): DimmAllocation {
    const message = createBaseDimmAllocation();
    message.capacity = object.capacity ?? 0;
    return message;
  },
};

function createBaseMemoryAllocation(): MemoryAllocation {
  return { alloc: {} };
}

export const MemoryAllocation = {
  encode(message: MemoryAllocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.alloc).forEach(([key, value]) => {
      MemoryAllocation_AllocEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MemoryAllocation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = MemoryAllocation_AllocEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.alloc[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MemoryAllocation {
    return {
      alloc: isObject(object.alloc)
        ? Object.entries(object.alloc).reduce<{ [key: number]: DimmAllocation }>((acc, [key, value]) => {
          acc[Number(key)] = DimmAllocation.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MemoryAllocation): unknown {
    const obj: any = {};
    obj.alloc = {};
    if (message.alloc) {
      Object.entries(message.alloc).forEach(([k, v]) => {
        obj.alloc[k] = DimmAllocation.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryAllocation>, I>>(base?: I): MemoryAllocation {
    return MemoryAllocation.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<MemoryAllocation>, I>>(object: I): MemoryAllocation {
    const message = createBaseMemoryAllocation();
    message.alloc = Object.entries(object.alloc ?? {}).reduce<{ [key: number]: DimmAllocation }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[Number(key)] = DimmAllocation.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMemoryAllocation_AllocEntry(): MemoryAllocation_AllocEntry {
  return { key: 0, value: undefined };
}

export const MemoryAllocation_AllocEntry = {
  encode(message: MemoryAllocation_AllocEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      DimmAllocation.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MemoryAllocation_AllocEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryAllocation_AllocEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.uint32();
          break;
        case 2:
          message.value = DimmAllocation.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MemoryAllocation_AllocEntry {
    return {
      key: isSet(object.key) ? Number(object.key) : 0,
      value: isSet(object.value) ? DimmAllocation.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MemoryAllocation_AllocEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = Math.round(message.key));
    message.value !== undefined && (obj.value = message.value ? DimmAllocation.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryAllocation_AllocEntry>, I>>(base?: I): MemoryAllocation_AllocEntry {
    return MemoryAllocation_AllocEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<MemoryAllocation_AllocEntry>, I>>(object: I): MemoryAllocation_AllocEntry {
    const message = createBaseMemoryAllocation_AllocEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? DimmAllocation.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseMemorySpec(): MemorySpec {
  return { type: undefined, capacity: undefined, frequency: undefined, modules: undefined };
}

export const MemorySpec = {
  encode(message: MemorySpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== undefined) {
      MemoryTypeConstraint.encode(message.type, writer.uint32(10).fork()).ldelim();
    }
    if (message.capacity !== undefined) {
      Uint64Constraint.encode(message.capacity, writer.uint32(18).fork()).ldelim();
    }
    if (message.frequency !== undefined) {
      Uint64Constraint.encode(message.frequency, writer.uint32(26).fork()).ldelim();
    }
    if (message.modules !== undefined) {
      Uint64Constraint.encode(message.modules, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MemorySpec {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemorySpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = MemoryTypeConstraint.decode(reader, reader.uint32());
          break;
        case 2:
          message.capacity = Uint64Constraint.decode(reader, reader.uint32());
          break;
        case 3:
          message.frequency = Uint64Constraint.decode(reader, reader.uint32());
          break;
        case 4:
          message.modules = Uint64Constraint.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MemorySpec {
    return {
      type: isSet(object.type) ? MemoryTypeConstraint.fromJSON(object.type) : undefined,
      capacity: isSet(object.capacity) ? Uint64Constraint.fromJSON(object.capacity) : undefined,
      frequency: isSet(object.frequency) ? Uint64Constraint.fromJSON(object.frequency) : undefined,
      modules: isSet(object.modules) ? Uint64Constraint.fromJSON(object.modules) : undefined,
    };
  },

  toJSON(message: MemorySpec): unknown {
    const obj: any = {};
    message.type !== undefined && (obj.type = message.type ? MemoryTypeConstraint.toJSON(message.type) : undefined);
    message.capacity !== undefined &&
      (obj.capacity = message.capacity ? Uint64Constraint.toJSON(message.capacity) : undefined);
    message.frequency !== undefined &&
      (obj.frequency = message.frequency ? Uint64Constraint.toJSON(message.frequency) : undefined);
    message.modules !== undefined &&
      (obj.modules = message.modules ? Uint64Constraint.toJSON(message.modules) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<MemorySpec>, I>>(base?: I): MemorySpec {
    return MemorySpec.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<MemorySpec>, I>>(object: I): MemorySpec {
    const message = createBaseMemorySpec();
    message.type = (object.type !== undefined && object.type !== null)
      ? MemoryTypeConstraint.fromPartial(object.type)
      : undefined;
    message.capacity = (object.capacity !== undefined && object.capacity !== null)
      ? Uint64Constraint.fromPartial(object.capacity)
      : undefined;
    message.frequency = (object.frequency !== undefined && object.frequency !== null)
      ? Uint64Constraint.fromPartial(object.frequency)
      : undefined;
    message.modules = (object.modules !== undefined && object.modules !== null)
      ? Uint64Constraint.fromPartial(object.modules)
      : undefined;
    return message;
  },
};

function createBaseNIC(): NIC {
  return { ports: [], startingIndex: 0, kind: 0, productInfo: undefined, DPDK: false, model: 0 };
}

export const NIC = {
  encode(message: NIC, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ports) {
      Port.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.startingIndex !== 0) {
      writer.uint32(16).uint32(message.startingIndex);
    }
    if (message.kind !== 0) {
      writer.uint32(24).int32(message.kind);
    }
    if (message.productInfo !== undefined) {
      ProductInfo.encode(message.productInfo, writer.uint32(34).fork()).ldelim();
    }
    if (message.DPDK === true) {
      writer.uint32(40).bool(message.DPDK);
    }
    if (message.model !== 0) {
      writer.uint32(48).int32(message.model);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NIC {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNIC();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ports.push(Port.decode(reader, reader.uint32()));
          break;
        case 2:
          message.startingIndex = reader.uint32();
          break;
        case 3:
          message.kind = reader.int32() as any;
          break;
        case 4:
          message.productInfo = ProductInfo.decode(reader, reader.uint32());
          break;
        case 5:
          message.DPDK = reader.bool();
          break;
        case 6:
          message.model = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NIC {
    return {
      ports: Array.isArray(object?.ports) ? object.ports.map((e: any) => Port.fromJSON(e)) : [],
      startingIndex: isSet(object.startingIndex) ? Number(object.startingIndex) : 0,
      kind: isSet(object.kind) ? nICKindFromJSON(object.kind) : 0,
      productInfo: isSet(object.productInfo) ? ProductInfo.fromJSON(object.productInfo) : undefined,
      DPDK: isSet(object.DPDK) ? Boolean(object.DPDK) : false,
      model: isSet(object.model) ? nICModelFromJSON(object.model) : 0,
    };
  },

  toJSON(message: NIC): unknown {
    const obj: any = {};
    if (message.ports) {
      obj.ports = message.ports.map((e) => e ? Port.toJSON(e) : undefined);
    } else {
      obj.ports = [];
    }
    message.startingIndex !== undefined && (obj.startingIndex = Math.round(message.startingIndex));
    message.kind !== undefined && (obj.kind = nICKindToJSON(message.kind));
    message.productInfo !== undefined &&
      (obj.productInfo = message.productInfo ? ProductInfo.toJSON(message.productInfo) : undefined);
    message.DPDK !== undefined && (obj.DPDK = message.DPDK);
    message.model !== undefined && (obj.model = nICModelToJSON(message.model));
    return obj;
  },

  create<I extends Exact<DeepPartial<NIC>, I>>(base?: I): NIC {
    return NIC.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<NIC>, I>>(object: I): NIC {
    const message = createBaseNIC();
    message.ports = object.ports?.map((e) => Port.fromPartial(e)) || [];
    message.startingIndex = object.startingIndex ?? 0;
    message.kind = object.kind ?? 0;
    message.productInfo = (object.productInfo !== undefined && object.productInfo !== null)
      ? ProductInfo.fromPartial(object.productInfo)
      : undefined;
    message.DPDK = object.DPDK ?? false;
    message.model = object.model ?? 0;
    return message;
  },
};

function createBaseNICSpec(): NICSpec {
  return { ports: [] };
}

export const NICSpec = {
  encode(message: NICSpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ports) {
      PortSpec.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NICSpec {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNICSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ports.push(PortSpec.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NICSpec {
    return { ports: Array.isArray(object?.ports) ? object.ports.map((e: any) => PortSpec.fromJSON(e)) : [] };
  },

  toJSON(message: NICSpec): unknown {
    const obj: any = {};
    if (message.ports) {
      obj.ports = message.ports.map((e) => e ? PortSpec.toJSON(e) : undefined);
    } else {
      obj.ports = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NICSpec>, I>>(base?: I): NICSpec {
    return NICSpec.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<NICSpec>, I>>(object: I): NICSpec {
    const message = createBaseNICSpec();
    message.ports = object.ports?.map((e) => PortSpec.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNICAllocation(): NICAllocation {
  return { alloc: {} };
}

export const NICAllocation = {
  encode(message: NICAllocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.alloc).forEach(([key, value]) => {
      NICAllocation_AllocEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NICAllocation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNICAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = NICAllocation_AllocEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.alloc[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NICAllocation {
    return {
      alloc: isObject(object.alloc)
        ? Object.entries(object.alloc).reduce<{ [key: number]: PortAllocation }>((acc, [key, value]) => {
          acc[Number(key)] = PortAllocation.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: NICAllocation): unknown {
    const obj: any = {};
    obj.alloc = {};
    if (message.alloc) {
      Object.entries(message.alloc).forEach(([k, v]) => {
        obj.alloc[k] = PortAllocation.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NICAllocation>, I>>(base?: I): NICAllocation {
    return NICAllocation.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<NICAllocation>, I>>(object: I): NICAllocation {
    const message = createBaseNICAllocation();
    message.alloc = Object.entries(object.alloc ?? {}).reduce<{ [key: number]: PortAllocation }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[Number(key)] = PortAllocation.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseNICAllocation_AllocEntry(): NICAllocation_AllocEntry {
  return { key: 0, value: undefined };
}

export const NICAllocation_AllocEntry = {
  encode(message: NICAllocation_AllocEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      PortAllocation.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NICAllocation_AllocEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNICAllocation_AllocEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.uint32();
          break;
        case 2:
          message.value = PortAllocation.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NICAllocation_AllocEntry {
    return {
      key: isSet(object.key) ? Number(object.key) : 0,
      value: isSet(object.value) ? PortAllocation.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: NICAllocation_AllocEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = Math.round(message.key));
    message.value !== undefined && (obj.value = message.value ? PortAllocation.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<NICAllocation_AllocEntry>, I>>(base?: I): NICAllocation_AllocEntry {
    return NICAllocation_AllocEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<NICAllocation_AllocEntry>, I>>(object: I): NICAllocation_AllocEntry {
    const message = createBaseNICAllocation_AllocEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? PortAllocation.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseNICsAllocation(): NICsAllocation {
  return { alloc: {} };
}

export const NICsAllocation = {
  encode(message: NICsAllocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.alloc).forEach(([key, value]) => {
      NICsAllocation_AllocEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NICsAllocation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNICsAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = NICsAllocation_AllocEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.alloc[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NICsAllocation {
    return {
      alloc: isObject(object.alloc)
        ? Object.entries(object.alloc).reduce<{ [key: number]: NICAllocation }>((acc, [key, value]) => {
          acc[Number(key)] = NICAllocation.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: NICsAllocation): unknown {
    const obj: any = {};
    obj.alloc = {};
    if (message.alloc) {
      Object.entries(message.alloc).forEach(([k, v]) => {
        obj.alloc[k] = NICAllocation.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NICsAllocation>, I>>(base?: I): NICsAllocation {
    return NICsAllocation.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<NICsAllocation>, I>>(object: I): NICsAllocation {
    const message = createBaseNICsAllocation();
    message.alloc = Object.entries(object.alloc ?? {}).reduce<{ [key: number]: NICAllocation }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[Number(key)] = NICAllocation.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseNICsAllocation_AllocEntry(): NICsAllocation_AllocEntry {
  return { key: 0, value: undefined };
}

export const NICsAllocation_AllocEntry = {
  encode(message: NICsAllocation_AllocEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      NICAllocation.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NICsAllocation_AllocEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNICsAllocation_AllocEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.uint32();
          break;
        case 2:
          message.value = NICAllocation.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NICsAllocation_AllocEntry {
    return {
      key: isSet(object.key) ? Number(object.key) : 0,
      value: isSet(object.value) ? NICAllocation.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: NICsAllocation_AllocEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = Math.round(message.key));
    message.value !== undefined && (obj.value = message.value ? NICAllocation.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<NICsAllocation_AllocEntry>, I>>(base?: I): NICsAllocation_AllocEntry {
    return NICsAllocation_AllocEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<NICsAllocation_AllocEntry>, I>>(object: I): NICsAllocation_AllocEntry {
    const message = createBaseNICsAllocation_AllocEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? NICAllocation.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDisk(): Disk {
  return { capacity: 0, formFactor: 0, diskInterface: 0, productInfo: undefined, roles: [], NVMEControllerIndex: 0 };
}

export const Disk = {
  encode(message: Disk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.capacity !== 0) {
      writer.uint32(8).uint64(message.capacity);
    }
    if (message.formFactor !== 0) {
      writer.uint32(16).int32(message.formFactor);
    }
    if (message.diskInterface !== 0) {
      writer.uint32(24).int32(message.diskInterface);
    }
    if (message.productInfo !== undefined) {
      ProductInfo.encode(message.productInfo, writer.uint32(34).fork()).ldelim();
    }
    writer.uint32(42).fork();
    for (const v of message.roles) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.NVMEControllerIndex !== 0) {
      writer.uint32(48).uint32(message.NVMEControllerIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Disk {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.capacity = longToNumber(reader.uint64() as Long);
          break;
        case 2:
          message.formFactor = reader.int32() as any;
          break;
        case 3:
          message.diskInterface = reader.int32() as any;
          break;
        case 4:
          message.productInfo = ProductInfo.decode(reader, reader.uint32());
          break;
        case 5:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.roles.push(reader.int32() as any);
            }
          } else {
            message.roles.push(reader.int32() as any);
          }
          break;
        case 6:
          message.NVMEControllerIndex = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Disk {
    return {
      capacity: isSet(object.capacity) ? Number(object.capacity) : 0,
      formFactor: isSet(object.formFactor) ? diskFormFactorFromJSON(object.formFactor) : 0,
      diskInterface: isSet(object.diskInterface) ? diskInterfaceFromJSON(object.diskInterface) : 0,
      productInfo: isSet(object.productInfo) ? ProductInfo.fromJSON(object.productInfo) : undefined,
      roles: Array.isArray(object?.roles) ? object.roles.map((e: any) => diskRoleFromJSON(e)) : [],
      NVMEControllerIndex: isSet(object.NVMEControllerIndex) ? Number(object.NVMEControllerIndex) : 0,
    };
  },

  toJSON(message: Disk): unknown {
    const obj: any = {};
    message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
    message.formFactor !== undefined && (obj.formFactor = diskFormFactorToJSON(message.formFactor));
    message.diskInterface !== undefined && (obj.diskInterface = diskInterfaceToJSON(message.diskInterface));
    message.productInfo !== undefined &&
      (obj.productInfo = message.productInfo ? ProductInfo.toJSON(message.productInfo) : undefined);
    if (message.roles) {
      obj.roles = message.roles.map((e) => diskRoleToJSON(e));
    } else {
      obj.roles = [];
    }
    message.NVMEControllerIndex !== undefined && (obj.NVMEControllerIndex = Math.round(message.NVMEControllerIndex));
    return obj;
  },

  create<I extends Exact<DeepPartial<Disk>, I>>(base?: I): Disk {
    return Disk.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Disk>, I>>(object: I): Disk {
    const message = createBaseDisk();
    message.capacity = object.capacity ?? 0;
    message.formFactor = object.formFactor ?? 0;
    message.diskInterface = object.diskInterface ?? 0;
    message.productInfo = (object.productInfo !== undefined && object.productInfo !== null)
      ? ProductInfo.fromPartial(object.productInfo)
      : undefined;
    message.roles = object.roles?.map((e) => e) || [];
    message.NVMEControllerIndex = object.NVMEControllerIndex ?? 0;
    return message;
  },
};

function createBaseDiskAllocation(): DiskAllocation {
  return { capacity: 0 };
}

export const DiskAllocation = {
  encode(message: DiskAllocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.capacity !== 0) {
      writer.uint32(8).uint64(message.capacity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DiskAllocation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiskAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.capacity = longToNumber(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DiskAllocation {
    return { capacity: isSet(object.capacity) ? Number(object.capacity) : 0 };
  },

  toJSON(message: DiskAllocation): unknown {
    const obj: any = {};
    message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
    return obj;
  },

  create<I extends Exact<DeepPartial<DiskAllocation>, I>>(base?: I): DiskAllocation {
    return DiskAllocation.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DiskAllocation>, I>>(object: I): DiskAllocation {
    const message = createBaseDiskAllocation();
    message.capacity = object.capacity ?? 0;
    return message;
  },
};

function createBaseDisksAllocation(): DisksAllocation {
  return { alloc: {} };
}

export const DisksAllocation = {
  encode(message: DisksAllocation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.alloc).forEach(([key, value]) => {
      DisksAllocation_AllocEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DisksAllocation {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisksAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          const entry1 = DisksAllocation_AllocEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.alloc[entry1.key] = entry1.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DisksAllocation {
    return {
      alloc: isObject(object.alloc)
        ? Object.entries(object.alloc).reduce<{ [key: number]: DiskAllocation }>((acc, [key, value]) => {
          acc[Number(key)] = DiskAllocation.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DisksAllocation): unknown {
    const obj: any = {};
    obj.alloc = {};
    if (message.alloc) {
      Object.entries(message.alloc).forEach(([k, v]) => {
        obj.alloc[k] = DiskAllocation.toJSON(v);
      });
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisksAllocation>, I>>(base?: I): DisksAllocation {
    return DisksAllocation.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DisksAllocation>, I>>(object: I): DisksAllocation {
    const message = createBaseDisksAllocation();
    message.alloc = Object.entries(object.alloc ?? {}).reduce<{ [key: number]: DiskAllocation }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[Number(key)] = DiskAllocation.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDisksAllocation_AllocEntry(): DisksAllocation_AllocEntry {
  return { key: 0, value: undefined };
}

export const DisksAllocation_AllocEntry = {
  encode(message: DisksAllocation_AllocEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== undefined) {
      DiskAllocation.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DisksAllocation_AllocEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisksAllocation_AllocEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.uint32();
          break;
        case 2:
          message.value = DiskAllocation.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DisksAllocation_AllocEntry {
    return {
      key: isSet(object.key) ? Number(object.key) : 0,
      value: isSet(object.value) ? DiskAllocation.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: DisksAllocation_AllocEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = Math.round(message.key));
    message.value !== undefined && (obj.value = message.value ? DiskAllocation.toJSON(message.value) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<DisksAllocation_AllocEntry>, I>>(base?: I): DisksAllocation_AllocEntry {
    return DisksAllocation_AllocEntry.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DisksAllocation_AllocEntry>, I>>(object: I): DisksAllocation_AllocEntry {
    const message = createBaseDisksAllocation_AllocEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? DiskAllocation.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDiskSpec(): DiskSpec {
  return { capacity: undefined, formFactor: undefined, diskInterface: undefined, disks: undefined };
}

export const DiskSpec = {
  encode(message: DiskSpec, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.capacity !== undefined) {
      Uint64Constraint.encode(message.capacity, writer.uint32(10).fork()).ldelim();
    }
    if (message.formFactor !== undefined) {
      DiskFormFactorConstraint.encode(message.formFactor, writer.uint32(18).fork()).ldelim();
    }
    if (message.diskInterface !== undefined) {
      DiskInterfaceConstraint.encode(message.diskInterface, writer.uint32(26).fork()).ldelim();
    }
    if (message.disks !== undefined) {
      Uint64Constraint.encode(message.disks, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DiskSpec {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiskSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.capacity = Uint64Constraint.decode(reader, reader.uint32());
          break;
        case 2:
          message.formFactor = DiskFormFactorConstraint.decode(reader, reader.uint32());
          break;
        case 3:
          message.diskInterface = DiskInterfaceConstraint.decode(reader, reader.uint32());
          break;
        case 4:
          message.disks = Uint64Constraint.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DiskSpec {
    return {
      capacity: isSet(object.capacity) ? Uint64Constraint.fromJSON(object.capacity) : undefined,
      formFactor: isSet(object.formFactor) ? DiskFormFactorConstraint.fromJSON(object.formFactor) : undefined,
      diskInterface: isSet(object.diskInterface) ? DiskInterfaceConstraint.fromJSON(object.diskInterface) : undefined,
      disks: isSet(object.disks) ? Uint64Constraint.fromJSON(object.disks) : undefined,
    };
  },

  toJSON(message: DiskSpec): unknown {
    const obj: any = {};
    message.capacity !== undefined &&
      (obj.capacity = message.capacity ? Uint64Constraint.toJSON(message.capacity) : undefined);
    message.formFactor !== undefined &&
      (obj.formFactor = message.formFactor ? DiskFormFactorConstraint.toJSON(message.formFactor) : undefined);
    message.diskInterface !== undefined &&
      (obj.diskInterface = message.diskInterface ? DiskInterfaceConstraint.toJSON(message.diskInterface) : undefined);
    message.disks !== undefined && (obj.disks = message.disks ? Uint64Constraint.toJSON(message.disks) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<DiskSpec>, I>>(base?: I): DiskSpec {
    return DiskSpec.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DiskSpec>, I>>(object: I): DiskSpec {
    const message = createBaseDiskSpec();
    message.capacity = (object.capacity !== undefined && object.capacity !== null)
      ? Uint64Constraint.fromPartial(object.capacity)
      : undefined;
    message.formFactor = (object.formFactor !== undefined && object.formFactor !== null)
      ? DiskFormFactorConstraint.fromPartial(object.formFactor)
      : undefined;
    message.diskInterface = (object.diskInterface !== undefined && object.diskInterface !== null)
      ? DiskInterfaceConstraint.fromPartial(object.diskInterface)
      : undefined;
    message.disks = (object.disks !== undefined && object.disks !== null)
      ? Uint64Constraint.fromPartial(object.disks)
      : undefined;
    return message;
  },
};

function createBaseBoolConstraint(): BoolConstraint {
  return { op: 0, value: false };
}

export const BoolConstraint = {
  encode(message: BoolConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value === true) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BoolConstraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoolConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BoolConstraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? Boolean(object.value) : false,
    };
  },

  toJSON(message: BoolConstraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  create<I extends Exact<DeepPartial<BoolConstraint>, I>>(base?: I): BoolConstraint {
    return BoolConstraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<BoolConstraint>, I>>(object: I): BoolConstraint {
    const message = createBaseBoolConstraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseStringConstraint(): StringConstraint {
  return { op: 0, value: "" };
}

export const StringConstraint = {
  encode(message: StringConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StringConstraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StringConstraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? String(object.value) : "",
    };
  },

  toJSON(message: StringConstraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  create<I extends Exact<DeepPartial<StringConstraint>, I>>(base?: I): StringConstraint {
    return StringConstraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<StringConstraint>, I>>(object: I): StringConstraint {
    const message = createBaseStringConstraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUint64Constraint(): Uint64Constraint {
  return { op: 0, value: 0 };
}

export const Uint64Constraint = {
  encode(message: Uint64Constraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint64(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Uint64Constraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUint64Constraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = longToNumber(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Uint64Constraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? Number(object.value) : 0,
    };
  },

  toJSON(message: Uint64Constraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = Math.round(message.value));
    return obj;
  },

  create<I extends Exact<DeepPartial<Uint64Constraint>, I>>(base?: I): Uint64Constraint {
    return Uint64Constraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Uint64Constraint>, I>>(object: I): Uint64Constraint {
    const message = createBaseUint64Constraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseLinkKindConstraint(): LinkKindConstraint {
  return { op: 0, value: 0 };
}

export const LinkKindConstraint = {
  encode(message: LinkKindConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LinkKindConstraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkKindConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LinkKindConstraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? link_KindFromJSON(object.value) : 0,
    };
  },

  toJSON(message: LinkKindConstraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = link_KindToJSON(message.value));
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkKindConstraint>, I>>(base?: I): LinkKindConstraint {
    return LinkKindConstraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<LinkKindConstraint>, I>>(object: I): LinkKindConstraint {
    const message = createBaseLinkKindConstraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseUint32Constraint(): Uint32Constraint {
  return { op: 0, value: 0 };
}

export const Uint32Constraint = {
  encode(message: Uint32Constraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Uint32Constraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUint32Constraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Uint32Constraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? Number(object.value) : 0,
    };
  },

  toJSON(message: Uint32Constraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = Math.round(message.value));
    return obj;
  },

  create<I extends Exact<DeepPartial<Uint32Constraint>, I>>(base?: I): Uint32Constraint {
    return Uint32Constraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Uint32Constraint>, I>>(object: I): Uint32Constraint {
    const message = createBaseUint32Constraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseISAConstraint(): ISAConstraint {
  return { op: 0, value: 0 };
}

export const ISAConstraint = {
  encode(message: ISAConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ISAConstraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseISAConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ISAConstraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? iSAFromJSON(object.value) : 0,
    };
  },

  toJSON(message: ISAConstraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = iSAToJSON(message.value));
    return obj;
  },

  create<I extends Exact<DeepPartial<ISAConstraint>, I>>(base?: I): ISAConstraint {
    return ISAConstraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ISAConstraint>, I>>(object: I): ISAConstraint {
    const message = createBaseISAConstraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseMemoryTypeConstraint(): MemoryTypeConstraint {
  return { op: 0, value: 0 };
}

export const MemoryTypeConstraint = {
  encode(message: MemoryTypeConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MemoryTypeConstraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryTypeConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MemoryTypeConstraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? memoryTypeFromJSON(object.value) : 0,
    };
  },

  toJSON(message: MemoryTypeConstraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = memoryTypeToJSON(message.value));
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryTypeConstraint>, I>>(base?: I): MemoryTypeConstraint {
    return MemoryTypeConstraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<MemoryTypeConstraint>, I>>(object: I): MemoryTypeConstraint {
    const message = createBaseMemoryTypeConstraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseNICModelConstraint(): NICModelConstraint {
  return { op: 0, value: 0 };
}

export const NICModelConstraint = {
  encode(message: NICModelConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NICModelConstraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNICModelConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NICModelConstraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? nICModelFromJSON(object.value) : 0,
    };
  },

  toJSON(message: NICModelConstraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = nICModelToJSON(message.value));
    return obj;
  },

  create<I extends Exact<DeepPartial<NICModelConstraint>, I>>(base?: I): NICModelConstraint {
    return NICModelConstraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<NICModelConstraint>, I>>(object: I): NICModelConstraint {
    const message = createBaseNICModelConstraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseDiskFormFactorConstraint(): DiskFormFactorConstraint {
  return { op: 0, value: 0 };
}

export const DiskFormFactorConstraint = {
  encode(message: DiskFormFactorConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DiskFormFactorConstraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiskFormFactorConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DiskFormFactorConstraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? diskFormFactorFromJSON(object.value) : 0,
    };
  },

  toJSON(message: DiskFormFactorConstraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = diskFormFactorToJSON(message.value));
    return obj;
  },

  create<I extends Exact<DeepPartial<DiskFormFactorConstraint>, I>>(base?: I): DiskFormFactorConstraint {
    return DiskFormFactorConstraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DiskFormFactorConstraint>, I>>(object: I): DiskFormFactorConstraint {
    const message = createBaseDiskFormFactorConstraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseDiskInterfaceConstraint(): DiskInterfaceConstraint {
  return { op: 0, value: 0 };
}

export const DiskInterfaceConstraint = {
  encode(message: DiskInterfaceConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DiskInterfaceConstraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiskInterfaceConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DiskInterfaceConstraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? diskInterfaceFromJSON(object.value) : 0,
    };
  },

  toJSON(message: DiskInterfaceConstraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = diskInterfaceToJSON(message.value));
    return obj;
  },

  create<I extends Exact<DeepPartial<DiskInterfaceConstraint>, I>>(base?: I): DiskInterfaceConstraint {
    return DiskInterfaceConstraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DiskInterfaceConstraint>, I>>(object: I): DiskInterfaceConstraint {
    const message = createBaseDiskInterfaceConstraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseConnectorKindConstraint(): ConnectorKindConstraint {
  return { op: 0, value: 0 };
}

export const ConnectorKindConstraint = {
  encode(message: ConnectorKindConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConnectorKindConstraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectorKindConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ConnectorKindConstraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? connectorKindFromJSON(object.value) : 0,
    };
  },

  toJSON(message: ConnectorKindConstraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = connectorKindToJSON(message.value));
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectorKindConstraint>, I>>(base?: I): ConnectorKindConstraint {
    return ConnectorKindConstraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ConnectorKindConstraint>, I>>(object: I): ConnectorKindConstraint {
    const message = createBaseConnectorKindConstraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseFloatConstraint(): FloatConstraint {
  return { op: 0, value: 0 };
}

export const FloatConstraint = {
  encode(message: FloatConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FloatConstraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = reader.float();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FloatConstraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? Number(object.value) : 0,
    };
  },

  toJSON(message: FloatConstraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  create<I extends Exact<DeepPartial<FloatConstraint>, I>>(base?: I): FloatConstraint {
    return FloatConstraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<FloatConstraint>, I>>(object: I): FloatConstraint {
    const message = createBaseFloatConstraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseRoutingConstraint(): RoutingConstraint {
  return { op: 0, value: 0 };
}

export const RoutingConstraint = {
  encode(message: RoutingConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RoutingConstraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutingConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RoutingConstraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? routingFromJSON(object.value) : 0,
    };
  },

  toJSON(message: RoutingConstraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = routingToJSON(message.value));
    return obj;
  },

  create<I extends Exact<DeepPartial<RoutingConstraint>, I>>(base?: I): RoutingConstraint {
    return RoutingConstraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<RoutingConstraint>, I>>(object: I): RoutingConstraint {
    const message = createBaseRoutingConstraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseAddressingConstraint(): AddressingConstraint {
  return { op: 0, value: 0 };
}

export const AddressingConstraint = {
  encode(message: AddressingConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddressingConstraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressingConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AddressingConstraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? addressingFromJSON(object.value) : 0,
    };
  },

  toJSON(message: AddressingConstraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = addressingToJSON(message.value));
    return obj;
  },

  create<I extends Exact<DeepPartial<AddressingConstraint>, I>>(base?: I): AddressingConstraint {
    return AddressingConstraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AddressingConstraint>, I>>(object: I): AddressingConstraint {
    const message = createBaseAddressingConstraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseEmulationConstraint(): EmulationConstraint {
  return { op: 0, value: 0 };
}

export const EmulationConstraint = {
  encode(message: EmulationConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EmulationConstraint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmulationConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.op = reader.int32() as any;
          break;
        case 2:
          message.value = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EmulationConstraint {
    return {
      op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? emulationFromJSON(object.value) : 0,
    };
  },

  toJSON(message: EmulationConstraint): unknown {
    const obj: any = {};
    message.op !== undefined && (obj.op = operatorToJSON(message.op));
    message.value !== undefined && (obj.value = emulationToJSON(message.value));
    return obj;
  },

  create<I extends Exact<DeepPartial<EmulationConstraint>, I>>(base?: I): EmulationConstraint {
    return EmulationConstraint.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<EmulationConstraint>, I>>(object: I): EmulationConstraint {
    const message = createBaseEmulationConstraint();
    message.op = object.op ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
