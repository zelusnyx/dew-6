"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.DiskRole = exports.linkRoleToJSON = exports.linkRoleFromJSON = exports.LinkRole = exports.roleToJSON = exports.roleFromJSON = exports.Role = exports.allocModeToJSON = exports.allocModeFromJSON = exports.AllocMode = exports.cableKindToJSON = exports.cableKindFromJSON = exports.CableKind = exports.diskInterfaceToJSON = exports.diskInterfaceFromJSON = exports.DiskInterface = exports.diskFormFactorToJSON = exports.diskFormFactorFromJSON = exports.DiskFormFactor = exports.connectorKindToJSON = exports.connectorKindFromJSON = exports.ConnectorKind = exports.layer1ToJSON = exports.layer1FromJSON = exports.Layer1 = exports.nICKindToJSON = exports.nICKindFromJSON = exports.NICKind = exports.nICModelToJSON = exports.nICModelFromJSON = exports.NICModel = exports.memoryTypeToJSON = exports.memoryTypeFromJSON = exports.MemoryType = exports.iSAToJSON = exports.iSAFromJSON = exports.ISA = exports.protocolToJSON = exports.protocolFromJSON = exports.Protocol = exports.emulationToJSON = exports.emulationFromJSON = exports.Emulation = exports.addressingToJSON = exports.addressingFromJSON = exports.Addressing = exports.routingToJSON = exports.routingFromJSON = exports.Routing = exports.protobufPackage = void 0;
exports.Raven = exports.PowerDistributionUnit = exports.RelayBoard = exports.BMC = exports.Resource_InfranetAddrEntry = exports.Resource = exports.ProductInfo = exports.Limits = exports.Actuator = exports.Sensor = exports.Coupling = exports.Bond = exports.Variable = exports.Phyo = exports.Endpoint = exports.Link = exports.RouteConf = exports.Socket = exports.Subref = exports.Ref = exports.Visualization = exports.RouteConfig = exports.NodeConfig = exports.Node = exports.Properties_KeyvaluesEntry = exports.Properties_Values = exports.Properties = exports.ExperimentParameters = exports.Network = exports.Facility = exports.firmware_KindToJSON = exports.firmware_KindFromJSON = exports.Firmware_Kind = exports.powerDistributionUnit_KindToJSON = exports.powerDistributionUnit_KindFromJSON = exports.PowerDistributionUnit_Kind = exports.relayBoard_KindToJSON = exports.relayBoard_KindFromJSON = exports.RelayBoard_Kind = exports.bMC_KindToJSON = exports.bMC_KindFromJSON = exports.BMC_Kind = exports.link_KindToJSON = exports.link_KindFromJSON = exports.Link_Kind = exports.operatorToJSON = exports.operatorFromJSON = exports.Operator = exports.diskRoleToJSON = exports.diskRoleFromJSON = void 0;
exports.StringConstraint = exports.BoolConstraint = exports.DiskSpec = exports.DisksAllocation_AllocEntry = exports.DisksAllocation = exports.DiskAllocation = exports.Disk = exports.NICsAllocation_AllocEntry = exports.NICsAllocation = exports.NICAllocation_AllocEntry = exports.NICAllocation = exports.NICSpec = exports.NIC = exports.MemorySpec = exports.MemoryAllocation_AllocEntry = exports.MemoryAllocation = exports.DimmAllocation = exports.Dimm = exports.ProcSpec = exports.ProcAllocation_AllocEntry = exports.ProcAllocation = exports.SocketAllocation = exports.Proc = exports.ConnectorSpec = exports.Connector = exports.End = exports.Cable = exports.PortSpec = exports.PortRef = exports.PortAllocation = exports.Port = exports.SRIOV = exports.sriovVf = exports.sriovPf = exports.PortBond = exports.Breakout = exports.BridgeConfig = exports.EVPNConfig = exports.BGPRouterConfig = exports.InterfaceConfig = exports.VLANConfig = exports.ServiceEndpoint = exports.OSConfig_ServiceEndpointsEntry = exports.OSConfig = exports.LeafConfig_InfrapodAddressBlocksEntry = exports.LeafConfig = exports.AddressList = exports.CableAllocation = exports.ResourceAllocation = exports.Firmware = void 0;
exports.EmulationConstraint = exports.AddressingConstraint = exports.RoutingConstraint = exports.FloatConstraint = exports.ConnectorKindConstraint = exports.DiskInterfaceConstraint = exports.DiskFormFactorConstraint = exports.NICModelConstraint = exports.MemoryTypeConstraint = exports.ISAConstraint = exports.Uint32Constraint = exports.LinkKindConstraint = exports.Uint64Constraint = void 0;
/* eslint-disable */
var long_1 = __importDefault(require("long"));
var minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "xir";
var Routing;
(function (Routing) {
    Routing[Routing["ManualRouting"] = 0] = "ManualRouting";
    Routing[Routing["StaticRouting"] = 1] = "StaticRouting";
    Routing[Routing["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Routing = exports.Routing || (exports.Routing = {}));
function routingFromJSON(object) {
    switch (object) {
        case 0:
        case "ManualRouting":
            return Routing.ManualRouting;
        case 1:
        case "StaticRouting":
            return Routing.StaticRouting;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Routing.UNRECOGNIZED;
    }
}
exports.routingFromJSON = routingFromJSON;
function routingToJSON(object) {
    switch (object) {
        case Routing.ManualRouting:
            return "ManualRouting";
        case Routing.StaticRouting:
            return "StaticRouting";
        case Routing.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.routingToJSON = routingToJSON;
var Addressing;
(function (Addressing) {
    Addressing[Addressing["ManualAddressing"] = 0] = "ManualAddressing";
    Addressing[Addressing["IPv4Addressing"] = 1] = "IPv4Addressing";
    Addressing[Addressing["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Addressing = exports.Addressing || (exports.Addressing = {}));
function addressingFromJSON(object) {
    switch (object) {
        case 0:
        case "ManualAddressing":
            return Addressing.ManualAddressing;
        case 1:
        case "IPv4Addressing":
            return Addressing.IPv4Addressing;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Addressing.UNRECOGNIZED;
    }
}
exports.addressingFromJSON = addressingFromJSON;
function addressingToJSON(object) {
    switch (object) {
        case Addressing.ManualAddressing:
            return "ManualAddressing";
        case Addressing.IPv4Addressing:
            return "IPv4Addressing";
        case Addressing.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.addressingToJSON = addressingToJSON;
var Emulation;
(function (Emulation) {
    /** Netem - default */
    Emulation[Emulation["Netem"] = 0] = "Netem";
    Emulation[Emulation["Click"] = 1] = "Click";
    Emulation[Emulation["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Emulation = exports.Emulation || (exports.Emulation = {}));
function emulationFromJSON(object) {
    switch (object) {
        case 0:
        case "Netem":
            return Emulation.Netem;
        case 1:
        case "Click":
            return Emulation.Click;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Emulation.UNRECOGNIZED;
    }
}
exports.emulationFromJSON = emulationFromJSON;
function emulationToJSON(object) {
    switch (object) {
        case Emulation.Netem:
            return "Netem";
        case Emulation.Click:
            return "Click";
        case Emulation.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.emulationToJSON = emulationToJSON;
var Protocol;
(function (Protocol) {
    Protocol[Protocol["http"] = 0] = "http";
    Protocol[Protocol["https"] = 1] = "https";
    Protocol[Protocol["tcp"] = 2] = "tcp";
    Protocol[Protocol["udp"] = 3] = "udp";
    Protocol[Protocol["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Protocol = exports.Protocol || (exports.Protocol = {}));
function protocolFromJSON(object) {
    switch (object) {
        case 0:
        case "http":
            return Protocol.http;
        case 1:
        case "https":
            return Protocol.https;
        case 2:
        case "tcp":
            return Protocol.tcp;
        case 3:
        case "udp":
            return Protocol.udp;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Protocol.UNRECOGNIZED;
    }
}
exports.protocolFromJSON = protocolFromJSON;
function protocolToJSON(object) {
    switch (object) {
        case Protocol.http:
            return "http";
        case Protocol.https:
            return "https";
        case Protocol.tcp:
            return "tcp";
        case Protocol.udp:
            return "udp";
        case Protocol.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.protocolToJSON = protocolToJSON;
var ISA;
(function (ISA) {
    ISA[ISA["X86_64"] = 0] = "X86_64";
    ISA[ISA["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ISA = exports.ISA || (exports.ISA = {}));
function iSAFromJSON(object) {
    switch (object) {
        case 0:
        case "X86_64":
            return ISA.X86_64;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ISA.UNRECOGNIZED;
    }
}
exports.iSAFromJSON = iSAFromJSON;
function iSAToJSON(object) {
    switch (object) {
        case ISA.X86_64:
            return "X86_64";
        case ISA.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.iSAToJSON = iSAToJSON;
var MemoryType;
(function (MemoryType) {
    MemoryType[MemoryType["DDR3"] = 0] = "DDR3";
    MemoryType[MemoryType["DDR4"] = 1] = "DDR4";
    MemoryType[MemoryType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MemoryType = exports.MemoryType || (exports.MemoryType = {}));
function memoryTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "DDR3":
            return MemoryType.DDR3;
        case 1:
        case "DDR4":
            return MemoryType.DDR4;
        case -1:
        case "UNRECOGNIZED":
        default:
            return MemoryType.UNRECOGNIZED;
    }
}
exports.memoryTypeFromJSON = memoryTypeFromJSON;
function memoryTypeToJSON(object) {
    switch (object) {
        case MemoryType.DDR3:
            return "DDR3";
        case MemoryType.DDR4:
            return "DDR4";
        case MemoryType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.memoryTypeToJSON = memoryTypeToJSON;
var NICModel;
(function (NICModel) {
    NICModel[NICModel["Intel200"] = 0] = "Intel200";
    NICModel[NICModel["Intel300"] = 1] = "Intel300";
    NICModel[NICModel["Intel500"] = 2] = "Intel500";
    NICModel[NICModel["Intel700"] = 3] = "Intel700";
    NICModel[NICModel["Intel800"] = 4] = "Intel800";
    NICModel[NICModel["Intel7000"] = 50] = "Intel7000";
    NICModel[NICModel["Intel8000"] = 51] = "Intel8000";
    NICModel[NICModel["Intel9000"] = 52] = "Intel9000";
    NICModel[NICModel["ConnectX4"] = 101] = "ConnectX4";
    NICModel[NICModel["ConnectX5"] = 102] = "ConnectX5";
    NICModel[NICModel["ConnectX6"] = 103] = "ConnectX6";
    NICModel[NICModel["NetXtreme2"] = 201] = "NetXtreme2";
    NICModel[NICModel["QCA9000"] = 301] = "QCA9000";
    NICModel[NICModel["Virtio"] = 10001] = "Virtio";
    NICModel[NICModel["E1000"] = 10002] = "E1000";
    NICModel[NICModel["E1000E"] = 10003] = "E1000E";
    NICModel[NICModel["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(NICModel = exports.NICModel || (exports.NICModel = {}));
function nICModelFromJSON(object) {
    switch (object) {
        case 0:
        case "Intel200":
            return NICModel.Intel200;
        case 1:
        case "Intel300":
            return NICModel.Intel300;
        case 2:
        case "Intel500":
            return NICModel.Intel500;
        case 3:
        case "Intel700":
            return NICModel.Intel700;
        case 4:
        case "Intel800":
            return NICModel.Intel800;
        case 50:
        case "Intel7000":
            return NICModel.Intel7000;
        case 51:
        case "Intel8000":
            return NICModel.Intel8000;
        case 52:
        case "Intel9000":
            return NICModel.Intel9000;
        case 101:
        case "ConnectX4":
            return NICModel.ConnectX4;
        case 102:
        case "ConnectX5":
            return NICModel.ConnectX5;
        case 103:
        case "ConnectX6":
            return NICModel.ConnectX6;
        case 201:
        case "NetXtreme2":
            return NICModel.NetXtreme2;
        case 301:
        case "QCA9000":
            return NICModel.QCA9000;
        case 10001:
        case "Virtio":
            return NICModel.Virtio;
        case 10002:
        case "E1000":
            return NICModel.E1000;
        case 10003:
        case "E1000E":
            return NICModel.E1000E;
        case -1:
        case "UNRECOGNIZED":
        default:
            return NICModel.UNRECOGNIZED;
    }
}
exports.nICModelFromJSON = nICModelFromJSON;
function nICModelToJSON(object) {
    switch (object) {
        case NICModel.Intel200:
            return "Intel200";
        case NICModel.Intel300:
            return "Intel300";
        case NICModel.Intel500:
            return "Intel500";
        case NICModel.Intel700:
            return "Intel700";
        case NICModel.Intel800:
            return "Intel800";
        case NICModel.Intel7000:
            return "Intel7000";
        case NICModel.Intel8000:
            return "Intel8000";
        case NICModel.Intel9000:
            return "Intel9000";
        case NICModel.ConnectX4:
            return "ConnectX4";
        case NICModel.ConnectX5:
            return "ConnectX5";
        case NICModel.ConnectX6:
            return "ConnectX6";
        case NICModel.NetXtreme2:
            return "NetXtreme2";
        case NICModel.QCA9000:
            return "QCA9000";
        case NICModel.Virtio:
            return "Virtio";
        case NICModel.E1000:
            return "E1000";
        case NICModel.E1000E:
            return "E1000E";
        case NICModel.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.nICModelToJSON = nICModelToJSON;
var NICKind;
(function (NICKind) {
    /** ETH - Ethernet */
    NICKind[NICKind["ETH"] = 0] = "ETH";
    /** ENP - Ethernet peripheral */
    NICKind[NICKind["ENP"] = 1] = "ENP";
    /** ENO - Ethernet onboard */
    NICKind[NICKind["ENO"] = 2] = "ENO";
    /** ENS - Ethernet peripheral hotplog slot */
    NICKind[NICKind["ENS"] = 3] = "ENS";
    /** WLP - WiFi peripheral */
    NICKind[NICKind["WLP"] = 4] = "WLP";
    /** SWP - Switch port */
    NICKind[NICKind["SWP"] = 5] = "SWP";
    /** IPMI - IPMI/BMC */
    NICKind[NICKind["IPMI"] = 6] = "IPMI";
    /** Combo - IPMI/BMC + System Ethernet */
    NICKind[NICKind["Combo"] = 7] = "Combo";
    NICKind[NICKind["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(NICKind = exports.NICKind || (exports.NICKind = {}));
function nICKindFromJSON(object) {
    switch (object) {
        case 0:
        case "ETH":
            return NICKind.ETH;
        case 1:
        case "ENP":
            return NICKind.ENP;
        case 2:
        case "ENO":
            return NICKind.ENO;
        case 3:
        case "ENS":
            return NICKind.ENS;
        case 4:
        case "WLP":
            return NICKind.WLP;
        case 5:
        case "SWP":
            return NICKind.SWP;
        case 6:
        case "IPMI":
            return NICKind.IPMI;
        case 7:
        case "Combo":
            return NICKind.Combo;
        case -1:
        case "UNRECOGNIZED":
        default:
            return NICKind.UNRECOGNIZED;
    }
}
exports.nICKindFromJSON = nICKindFromJSON;
function nICKindToJSON(object) {
    switch (object) {
        case NICKind.ETH:
            return "ETH";
        case NICKind.ENP:
            return "ENP";
        case NICKind.ENO:
            return "ENO";
        case NICKind.ENS:
            return "ENS";
        case NICKind.WLP:
            return "WLP";
        case NICKind.SWP:
            return "SWP";
        case NICKind.IPMI:
            return "IPMI";
        case NICKind.Combo:
            return "Combo";
        case NICKind.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.nICKindToJSON = nICKindToJSON;
var Layer1;
(function (Layer1) {
    Layer1[Layer1["Layer1_Undefined"] = 0] = "Layer1_Undefined";
    /** Base100T - 100 mbps */
    Layer1[Layer1["Base100T"] = 1] = "Base100T";
    /** Base1000T - 1 gbps */
    Layer1[Layer1["Base1000T"] = 2] = "Base1000T";
    Layer1[Layer1["Base1000X"] = 3] = "Base1000X";
    Layer1[Layer1["Base1000CX"] = 4] = "Base1000CX";
    Layer1[Layer1["Base1000SX"] = 5] = "Base1000SX";
    Layer1[Layer1["Base1000LX"] = 6] = "Base1000LX";
    Layer1[Layer1["Base1000LX10"] = 7] = "Base1000LX10";
    Layer1[Layer1["Base1000EX"] = 8] = "Base1000EX";
    Layer1[Layer1["Base1000BX10"] = 9] = "Base1000BX10";
    Layer1[Layer1["Base1000ZX"] = 10] = "Base1000ZX";
    /** GBase10T - 10 gbps */
    Layer1[Layer1["GBase10T"] = 11] = "GBase10T";
    Layer1[Layer1["GBase10CR"] = 12] = "GBase10CR";
    Layer1[Layer1["GBase10SR"] = 13] = "GBase10SR";
    Layer1[Layer1["GBase10LR"] = 14] = "GBase10LR";
    Layer1[Layer1["GBase10LRM"] = 15] = "GBase10LRM";
    Layer1[Layer1["GBase10ER"] = 16] = "GBase10ER";
    Layer1[Layer1["GBase10ZR"] = 17] = "GBase10ZR";
    Layer1[Layer1["GBase10LX4"] = 18] = "GBase10LX4";
    Layer1[Layer1["GBase10PR"] = 19] = "GBase10PR";
    /** GBase25CR - 25 gbps */
    Layer1[Layer1["GBase25CR"] = 20] = "GBase25CR";
    Layer1[Layer1["GBase25SR"] = 21] = "GBase25SR";
    Layer1[Layer1["GBase25LR"] = 22] = "GBase25LR";
    Layer1[Layer1["GBase25ER"] = 23] = "GBase25ER";
    /** GBase40CR4 - 40 gbps */
    Layer1[Layer1["GBase40CR4"] = 24] = "GBase40CR4";
    Layer1[Layer1["GBase40SR4"] = 25] = "GBase40SR4";
    Layer1[Layer1["GBase40LR4"] = 26] = "GBase40LR4";
    Layer1[Layer1["GBase40ER4"] = 27] = "GBase40ER4";
    /** GBase100CR4 - 100 gbps */
    Layer1[Layer1["GBase100CR4"] = 28] = "GBase100CR4";
    Layer1[Layer1["GBase100SR4"] = 29] = "GBase100SR4";
    Layer1[Layer1["GBase100SR10"] = 30] = "GBase100SR10";
    Layer1[Layer1["GBase100LR4"] = 31] = "GBase100LR4";
    Layer1[Layer1["GBase100ER4"] = 32] = "GBase100ER4";
    /** RS232 - Console */
    Layer1[Layer1["RS232"] = 33] = "RS232";
    Layer1[Layer1["Uart"] = 34] = "Uart";
    /** GBase50SR4 - 50 gbps */
    Layer1[Layer1["GBase50SR4"] = 35] = "GBase50SR4";
    Layer1[Layer1["GBase50LR4"] = 36] = "GBase50LR4";
    Layer1[Layer1["GBase50ER4"] = 37] = "GBase50ER4";
    Layer1[Layer1["GBase50CR"] = 38] = "GBase50CR";
    Layer1[Layer1["GBase50KR"] = 39] = "GBase50KR";
    Layer1[Layer1["GBase50SR"] = 40] = "GBase50SR";
    Layer1[Layer1["GBase50LR"] = 41] = "GBase50LR";
    Layer1[Layer1["GBase50FR"] = 42] = "GBase50FR";
    Layer1[Layer1["GBase50ER"] = 43] = "GBase50ER";
    Layer1[Layer1["LAUI_2"] = 44] = "LAUI_2";
    Layer1[Layer1["GAUI50_1"] = 45] = "GAUI50_1";
    Layer1[Layer1["GAUI50_2"] = 46] = "GAUI50_2";
    /** GBase200CR4 - 200 gbps */
    Layer1[Layer1["GBase200CR4"] = 47] = "GBase200CR4";
    Layer1[Layer1["GBase200KR4"] = 48] = "GBase200KR4";
    Layer1[Layer1["GBase200SR4"] = 49] = "GBase200SR4";
    Layer1[Layer1["GBase200DR4"] = 50] = "GBase200DR4";
    Layer1[Layer1["GBase200FR4"] = 51] = "GBase200FR4";
    Layer1[Layer1["GBase200LR4"] = 52] = "GBase200LR4";
    Layer1[Layer1["GBase200ER4"] = 53] = "GBase200ER4";
    Layer1[Layer1["GAUI200_4"] = 54] = "GAUI200_4";
    Layer1[Layer1["GAUI200_8"] = 55] = "GAUI200_8";
    /** GBase400SR16 - 400 gbps */
    Layer1[Layer1["GBase400SR16"] = 56] = "GBase400SR16";
    Layer1[Layer1["GBase400SR8"] = 57] = "GBase400SR8";
    Layer1[Layer1["GBase400SR4_2"] = 58] = "GBase400SR4_2";
    Layer1[Layer1["GBase400DR4"] = 59] = "GBase400DR4";
    Layer1[Layer1["GBase400FR8"] = 60] = "GBase400FR8";
    Layer1[Layer1["GBase400ER8"] = 61] = "GBase400ER8";
    Layer1[Layer1["GBase400ZR"] = 62] = "GBase400ZR";
    Layer1[Layer1["GAUI400_16"] = 63] = "GAUI400_16";
    Layer1[Layer1["GAUI400_8"] = 64] = "GAUI400_8";
    Layer1[Layer1["XBee"] = 65] = "XBee";
    Layer1[Layer1["ZWave"] = 66] = "ZWave";
    Layer1[Layer1["Zigbee"] = 67] = "Zigbee";
    Layer1[Layer1["CXP100"] = 68] = "CXP100";
    Layer1[Layer1["CXP120"] = 69] = "CXP120";
    Layer1[Layer1["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Layer1 = exports.Layer1 || (exports.Layer1 = {}));
function layer1FromJSON(object) {
    switch (object) {
        case 0:
        case "Layer1_Undefined":
            return Layer1.Layer1_Undefined;
        case 1:
        case "Base100T":
            return Layer1.Base100T;
        case 2:
        case "Base1000T":
            return Layer1.Base1000T;
        case 3:
        case "Base1000X":
            return Layer1.Base1000X;
        case 4:
        case "Base1000CX":
            return Layer1.Base1000CX;
        case 5:
        case "Base1000SX":
            return Layer1.Base1000SX;
        case 6:
        case "Base1000LX":
            return Layer1.Base1000LX;
        case 7:
        case "Base1000LX10":
            return Layer1.Base1000LX10;
        case 8:
        case "Base1000EX":
            return Layer1.Base1000EX;
        case 9:
        case "Base1000BX10":
            return Layer1.Base1000BX10;
        case 10:
        case "Base1000ZX":
            return Layer1.Base1000ZX;
        case 11:
        case "GBase10T":
            return Layer1.GBase10T;
        case 12:
        case "GBase10CR":
            return Layer1.GBase10CR;
        case 13:
        case "GBase10SR":
            return Layer1.GBase10SR;
        case 14:
        case "GBase10LR":
            return Layer1.GBase10LR;
        case 15:
        case "GBase10LRM":
            return Layer1.GBase10LRM;
        case 16:
        case "GBase10ER":
            return Layer1.GBase10ER;
        case 17:
        case "GBase10ZR":
            return Layer1.GBase10ZR;
        case 18:
        case "GBase10LX4":
            return Layer1.GBase10LX4;
        case 19:
        case "GBase10PR":
            return Layer1.GBase10PR;
        case 20:
        case "GBase25CR":
            return Layer1.GBase25CR;
        case 21:
        case "GBase25SR":
            return Layer1.GBase25SR;
        case 22:
        case "GBase25LR":
            return Layer1.GBase25LR;
        case 23:
        case "GBase25ER":
            return Layer1.GBase25ER;
        case 24:
        case "GBase40CR4":
            return Layer1.GBase40CR4;
        case 25:
        case "GBase40SR4":
            return Layer1.GBase40SR4;
        case 26:
        case "GBase40LR4":
            return Layer1.GBase40LR4;
        case 27:
        case "GBase40ER4":
            return Layer1.GBase40ER4;
        case 28:
        case "GBase100CR4":
            return Layer1.GBase100CR4;
        case 29:
        case "GBase100SR4":
            return Layer1.GBase100SR4;
        case 30:
        case "GBase100SR10":
            return Layer1.GBase100SR10;
        case 31:
        case "GBase100LR4":
            return Layer1.GBase100LR4;
        case 32:
        case "GBase100ER4":
            return Layer1.GBase100ER4;
        case 33:
        case "RS232":
            return Layer1.RS232;
        case 34:
        case "Uart":
            return Layer1.Uart;
        case 35:
        case "GBase50SR4":
            return Layer1.GBase50SR4;
        case 36:
        case "GBase50LR4":
            return Layer1.GBase50LR4;
        case 37:
        case "GBase50ER4":
            return Layer1.GBase50ER4;
        case 38:
        case "GBase50CR":
            return Layer1.GBase50CR;
        case 39:
        case "GBase50KR":
            return Layer1.GBase50KR;
        case 40:
        case "GBase50SR":
            return Layer1.GBase50SR;
        case 41:
        case "GBase50LR":
            return Layer1.GBase50LR;
        case 42:
        case "GBase50FR":
            return Layer1.GBase50FR;
        case 43:
        case "GBase50ER":
            return Layer1.GBase50ER;
        case 44:
        case "LAUI_2":
            return Layer1.LAUI_2;
        case 45:
        case "GAUI50_1":
            return Layer1.GAUI50_1;
        case 46:
        case "GAUI50_2":
            return Layer1.GAUI50_2;
        case 47:
        case "GBase200CR4":
            return Layer1.GBase200CR4;
        case 48:
        case "GBase200KR4":
            return Layer1.GBase200KR4;
        case 49:
        case "GBase200SR4":
            return Layer1.GBase200SR4;
        case 50:
        case "GBase200DR4":
            return Layer1.GBase200DR4;
        case 51:
        case "GBase200FR4":
            return Layer1.GBase200FR4;
        case 52:
        case "GBase200LR4":
            return Layer1.GBase200LR4;
        case 53:
        case "GBase200ER4":
            return Layer1.GBase200ER4;
        case 54:
        case "GAUI200_4":
            return Layer1.GAUI200_4;
        case 55:
        case "GAUI200_8":
            return Layer1.GAUI200_8;
        case 56:
        case "GBase400SR16":
            return Layer1.GBase400SR16;
        case 57:
        case "GBase400SR8":
            return Layer1.GBase400SR8;
        case 58:
        case "GBase400SR4_2":
            return Layer1.GBase400SR4_2;
        case 59:
        case "GBase400DR4":
            return Layer1.GBase400DR4;
        case 60:
        case "GBase400FR8":
            return Layer1.GBase400FR8;
        case 61:
        case "GBase400ER8":
            return Layer1.GBase400ER8;
        case 62:
        case "GBase400ZR":
            return Layer1.GBase400ZR;
        case 63:
        case "GAUI400_16":
            return Layer1.GAUI400_16;
        case 64:
        case "GAUI400_8":
            return Layer1.GAUI400_8;
        case 65:
        case "XBee":
            return Layer1.XBee;
        case 66:
        case "ZWave":
            return Layer1.ZWave;
        case 67:
        case "Zigbee":
            return Layer1.Zigbee;
        case 68:
        case "CXP100":
            return Layer1.CXP100;
        case 69:
        case "CXP120":
            return Layer1.CXP120;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Layer1.UNRECOGNIZED;
    }
}
exports.layer1FromJSON = layer1FromJSON;
function layer1ToJSON(object) {
    switch (object) {
        case Layer1.Layer1_Undefined:
            return "Layer1_Undefined";
        case Layer1.Base100T:
            return "Base100T";
        case Layer1.Base1000T:
            return "Base1000T";
        case Layer1.Base1000X:
            return "Base1000X";
        case Layer1.Base1000CX:
            return "Base1000CX";
        case Layer1.Base1000SX:
            return "Base1000SX";
        case Layer1.Base1000LX:
            return "Base1000LX";
        case Layer1.Base1000LX10:
            return "Base1000LX10";
        case Layer1.Base1000EX:
            return "Base1000EX";
        case Layer1.Base1000BX10:
            return "Base1000BX10";
        case Layer1.Base1000ZX:
            return "Base1000ZX";
        case Layer1.GBase10T:
            return "GBase10T";
        case Layer1.GBase10CR:
            return "GBase10CR";
        case Layer1.GBase10SR:
            return "GBase10SR";
        case Layer1.GBase10LR:
            return "GBase10LR";
        case Layer1.GBase10LRM:
            return "GBase10LRM";
        case Layer1.GBase10ER:
            return "GBase10ER";
        case Layer1.GBase10ZR:
            return "GBase10ZR";
        case Layer1.GBase10LX4:
            return "GBase10LX4";
        case Layer1.GBase10PR:
            return "GBase10PR";
        case Layer1.GBase25CR:
            return "GBase25CR";
        case Layer1.GBase25SR:
            return "GBase25SR";
        case Layer1.GBase25LR:
            return "GBase25LR";
        case Layer1.GBase25ER:
            return "GBase25ER";
        case Layer1.GBase40CR4:
            return "GBase40CR4";
        case Layer1.GBase40SR4:
            return "GBase40SR4";
        case Layer1.GBase40LR4:
            return "GBase40LR4";
        case Layer1.GBase40ER4:
            return "GBase40ER4";
        case Layer1.GBase100CR4:
            return "GBase100CR4";
        case Layer1.GBase100SR4:
            return "GBase100SR4";
        case Layer1.GBase100SR10:
            return "GBase100SR10";
        case Layer1.GBase100LR4:
            return "GBase100LR4";
        case Layer1.GBase100ER4:
            return "GBase100ER4";
        case Layer1.RS232:
            return "RS232";
        case Layer1.Uart:
            return "Uart";
        case Layer1.GBase50SR4:
            return "GBase50SR4";
        case Layer1.GBase50LR4:
            return "GBase50LR4";
        case Layer1.GBase50ER4:
            return "GBase50ER4";
        case Layer1.GBase50CR:
            return "GBase50CR";
        case Layer1.GBase50KR:
            return "GBase50KR";
        case Layer1.GBase50SR:
            return "GBase50SR";
        case Layer1.GBase50LR:
            return "GBase50LR";
        case Layer1.GBase50FR:
            return "GBase50FR";
        case Layer1.GBase50ER:
            return "GBase50ER";
        case Layer1.LAUI_2:
            return "LAUI_2";
        case Layer1.GAUI50_1:
            return "GAUI50_1";
        case Layer1.GAUI50_2:
            return "GAUI50_2";
        case Layer1.GBase200CR4:
            return "GBase200CR4";
        case Layer1.GBase200KR4:
            return "GBase200KR4";
        case Layer1.GBase200SR4:
            return "GBase200SR4";
        case Layer1.GBase200DR4:
            return "GBase200DR4";
        case Layer1.GBase200FR4:
            return "GBase200FR4";
        case Layer1.GBase200LR4:
            return "GBase200LR4";
        case Layer1.GBase200ER4:
            return "GBase200ER4";
        case Layer1.GAUI200_4:
            return "GAUI200_4";
        case Layer1.GAUI200_8:
            return "GAUI200_8";
        case Layer1.GBase400SR16:
            return "GBase400SR16";
        case Layer1.GBase400SR8:
            return "GBase400SR8";
        case Layer1.GBase400SR4_2:
            return "GBase400SR4_2";
        case Layer1.GBase400DR4:
            return "GBase400DR4";
        case Layer1.GBase400FR8:
            return "GBase400FR8";
        case Layer1.GBase400ER8:
            return "GBase400ER8";
        case Layer1.GBase400ZR:
            return "GBase400ZR";
        case Layer1.GAUI400_16:
            return "GAUI400_16";
        case Layer1.GAUI400_8:
            return "GAUI400_8";
        case Layer1.XBee:
            return "XBee";
        case Layer1.ZWave:
            return "ZWave";
        case Layer1.Zigbee:
            return "Zigbee";
        case Layer1.CXP100:
            return "CXP100";
        case Layer1.CXP120:
            return "CXP120";
        case Layer1.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.layer1ToJSON = layer1ToJSON;
var ConnectorKind;
(function (ConnectorKind) {
    ConnectorKind[ConnectorKind["ConnectorKind_Undefined"] = 0] = "ConnectorKind_Undefined";
    ConnectorKind[ConnectorKind["RJ45"] = 1] = "RJ45";
    ConnectorKind[ConnectorKind["SFP"] = 2] = "SFP";
    ConnectorKind[ConnectorKind["QSFP"] = 3] = "QSFP";
    ConnectorKind[ConnectorKind["SFPP"] = 4] = "SFPP";
    ConnectorKind[ConnectorKind["QSFPP"] = 5] = "QSFPP";
    ConnectorKind[ConnectorKind["SFP28"] = 6] = "SFP28";
    ConnectorKind[ConnectorKind["QSFP28"] = 7] = "QSFP28";
    ConnectorKind[ConnectorKind["CXP"] = 8] = "CXP";
    ConnectorKind[ConnectorKind["LC"] = 9] = "LC";
    ConnectorKind[ConnectorKind["MPO"] = 10] = "MPO";
    ConnectorKind[ConnectorKind["SFP56"] = 11] = "SFP56";
    ConnectorKind[ConnectorKind["QSFP56"] = 12] = "QSFP56";
    ConnectorKind[ConnectorKind["QSFPDD"] = 13] = "QSFPDD";
    ConnectorKind[ConnectorKind["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConnectorKind = exports.ConnectorKind || (exports.ConnectorKind = {}));
function connectorKindFromJSON(object) {
    switch (object) {
        case 0:
        case "ConnectorKind_Undefined":
            return ConnectorKind.ConnectorKind_Undefined;
        case 1:
        case "RJ45":
            return ConnectorKind.RJ45;
        case 2:
        case "SFP":
            return ConnectorKind.SFP;
        case 3:
        case "QSFP":
            return ConnectorKind.QSFP;
        case 4:
        case "SFPP":
            return ConnectorKind.SFPP;
        case 5:
        case "QSFPP":
            return ConnectorKind.QSFPP;
        case 6:
        case "SFP28":
            return ConnectorKind.SFP28;
        case 7:
        case "QSFP28":
            return ConnectorKind.QSFP28;
        case 8:
        case "CXP":
            return ConnectorKind.CXP;
        case 9:
        case "LC":
            return ConnectorKind.LC;
        case 10:
        case "MPO":
            return ConnectorKind.MPO;
        case 11:
        case "SFP56":
            return ConnectorKind.SFP56;
        case 12:
        case "QSFP56":
            return ConnectorKind.QSFP56;
        case 13:
        case "QSFPDD":
            return ConnectorKind.QSFPDD;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ConnectorKind.UNRECOGNIZED;
    }
}
exports.connectorKindFromJSON = connectorKindFromJSON;
function connectorKindToJSON(object) {
    switch (object) {
        case ConnectorKind.ConnectorKind_Undefined:
            return "ConnectorKind_Undefined";
        case ConnectorKind.RJ45:
            return "RJ45";
        case ConnectorKind.SFP:
            return "SFP";
        case ConnectorKind.QSFP:
            return "QSFP";
        case ConnectorKind.SFPP:
            return "SFPP";
        case ConnectorKind.QSFPP:
            return "QSFPP";
        case ConnectorKind.SFP28:
            return "SFP28";
        case ConnectorKind.QSFP28:
            return "QSFP28";
        case ConnectorKind.CXP:
            return "CXP";
        case ConnectorKind.LC:
            return "LC";
        case ConnectorKind.MPO:
            return "MPO";
        case ConnectorKind.SFP56:
            return "SFP56";
        case ConnectorKind.QSFP56:
            return "QSFP56";
        case ConnectorKind.QSFPDD:
            return "QSFPDD";
        case ConnectorKind.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.connectorKindToJSON = connectorKindToJSON;
var DiskFormFactor;
(function (DiskFormFactor) {
    DiskFormFactor[DiskFormFactor["DiskFormFactor_Undefined"] = 0] = "DiskFormFactor_Undefined";
    DiskFormFactor[DiskFormFactor["HDD35"] = 1] = "HDD35";
    DiskFormFactor[DiskFormFactor["HDD25"] = 2] = "HDD25";
    DiskFormFactor[DiskFormFactor["SSD35"] = 3] = "SSD35";
    DiskFormFactor[DiskFormFactor["SSD25"] = 4] = "SSD25";
    DiskFormFactor[DiskFormFactor["MSATA"] = 5] = "MSATA";
    DiskFormFactor[DiskFormFactor["M2_2216"] = 6] = "M2_2216";
    DiskFormFactor[DiskFormFactor["M2_2226"] = 7] = "M2_2226";
    DiskFormFactor[DiskFormFactor["M2_2230"] = 8] = "M2_2230";
    DiskFormFactor[DiskFormFactor["M2_2238"] = 9] = "M2_2238";
    DiskFormFactor[DiskFormFactor["M2_2242"] = 10] = "M2_2242";
    DiskFormFactor[DiskFormFactor["M2_2260"] = 11] = "M2_2260";
    DiskFormFactor[DiskFormFactor["M2_2280"] = 12] = "M2_2280";
    DiskFormFactor[DiskFormFactor["M2_22110"] = 13] = "M2_22110";
    DiskFormFactor[DiskFormFactor["U2"] = 14] = "U2";
    DiskFormFactor[DiskFormFactor["EMMC"] = 15] = "EMMC";
    DiskFormFactor[DiskFormFactor["EUSB"] = 16] = "EUSB";
    DiskFormFactor[DiskFormFactor["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DiskFormFactor = exports.DiskFormFactor || (exports.DiskFormFactor = {}));
function diskFormFactorFromJSON(object) {
    switch (object) {
        case 0:
        case "DiskFormFactor_Undefined":
            return DiskFormFactor.DiskFormFactor_Undefined;
        case 1:
        case "HDD35":
            return DiskFormFactor.HDD35;
        case 2:
        case "HDD25":
            return DiskFormFactor.HDD25;
        case 3:
        case "SSD35":
            return DiskFormFactor.SSD35;
        case 4:
        case "SSD25":
            return DiskFormFactor.SSD25;
        case 5:
        case "MSATA":
            return DiskFormFactor.MSATA;
        case 6:
        case "M2_2216":
            return DiskFormFactor.M2_2216;
        case 7:
        case "M2_2226":
            return DiskFormFactor.M2_2226;
        case 8:
        case "M2_2230":
            return DiskFormFactor.M2_2230;
        case 9:
        case "M2_2238":
            return DiskFormFactor.M2_2238;
        case 10:
        case "M2_2242":
            return DiskFormFactor.M2_2242;
        case 11:
        case "M2_2260":
            return DiskFormFactor.M2_2260;
        case 12:
        case "M2_2280":
            return DiskFormFactor.M2_2280;
        case 13:
        case "M2_22110":
            return DiskFormFactor.M2_22110;
        case 14:
        case "U2":
            return DiskFormFactor.U2;
        case 15:
        case "EMMC":
            return DiskFormFactor.EMMC;
        case 16:
        case "EUSB":
            return DiskFormFactor.EUSB;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DiskFormFactor.UNRECOGNIZED;
    }
}
exports.diskFormFactorFromJSON = diskFormFactorFromJSON;
function diskFormFactorToJSON(object) {
    switch (object) {
        case DiskFormFactor.DiskFormFactor_Undefined:
            return "DiskFormFactor_Undefined";
        case DiskFormFactor.HDD35:
            return "HDD35";
        case DiskFormFactor.HDD25:
            return "HDD25";
        case DiskFormFactor.SSD35:
            return "SSD35";
        case DiskFormFactor.SSD25:
            return "SSD25";
        case DiskFormFactor.MSATA:
            return "MSATA";
        case DiskFormFactor.M2_2216:
            return "M2_2216";
        case DiskFormFactor.M2_2226:
            return "M2_2226";
        case DiskFormFactor.M2_2230:
            return "M2_2230";
        case DiskFormFactor.M2_2238:
            return "M2_2238";
        case DiskFormFactor.M2_2242:
            return "M2_2242";
        case DiskFormFactor.M2_2260:
            return "M2_2260";
        case DiskFormFactor.M2_2280:
            return "M2_2280";
        case DiskFormFactor.M2_22110:
            return "M2_22110";
        case DiskFormFactor.U2:
            return "U2";
        case DiskFormFactor.EMMC:
            return "EMMC";
        case DiskFormFactor.EUSB:
            return "EUSB";
        case DiskFormFactor.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.diskFormFactorToJSON = diskFormFactorToJSON;
var DiskInterface;
(function (DiskInterface) {
    DiskInterface[DiskInterface["DiskInterface_Undefined"] = 0] = "DiskInterface_Undefined";
    DiskInterface[DiskInterface["SATA1"] = 1] = "SATA1";
    DiskInterface[DiskInterface["SATA2"] = 2] = "SATA2";
    DiskInterface[DiskInterface["SATA3"] = 3] = "SATA3";
    DiskInterface[DiskInterface["NVMEx2"] = 4] = "NVMEx2";
    DiskInterface[DiskInterface["NVMEx4"] = 5] = "NVMEx4";
    DiskInterface[DiskInterface["MMC"] = 6] = "MMC";
    DiskInterface[DiskInterface["SD"] = 7] = "SD";
    DiskInterface[DiskInterface["USB"] = 8] = "USB";
    DiskInterface[DiskInterface["SAS"] = 9] = "SAS";
    DiskInterface[DiskInterface["VirtioBlock"] = 10] = "VirtioBlock";
    DiskInterface[DiskInterface["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DiskInterface = exports.DiskInterface || (exports.DiskInterface = {}));
function diskInterfaceFromJSON(object) {
    switch (object) {
        case 0:
        case "DiskInterface_Undefined":
            return DiskInterface.DiskInterface_Undefined;
        case 1:
        case "SATA1":
            return DiskInterface.SATA1;
        case 2:
        case "SATA2":
            return DiskInterface.SATA2;
        case 3:
        case "SATA3":
            return DiskInterface.SATA3;
        case 4:
        case "NVMEx2":
            return DiskInterface.NVMEx2;
        case 5:
        case "NVMEx4":
            return DiskInterface.NVMEx4;
        case 6:
        case "MMC":
            return DiskInterface.MMC;
        case 7:
        case "SD":
            return DiskInterface.SD;
        case 8:
        case "USB":
            return DiskInterface.USB;
        case 9:
        case "SAS":
            return DiskInterface.SAS;
        case 10:
        case "VirtioBlock":
            return DiskInterface.VirtioBlock;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DiskInterface.UNRECOGNIZED;
    }
}
exports.diskInterfaceFromJSON = diskInterfaceFromJSON;
function diskInterfaceToJSON(object) {
    switch (object) {
        case DiskInterface.DiskInterface_Undefined:
            return "DiskInterface_Undefined";
        case DiskInterface.SATA1:
            return "SATA1";
        case DiskInterface.SATA2:
            return "SATA2";
        case DiskInterface.SATA3:
            return "SATA3";
        case DiskInterface.NVMEx2:
            return "NVMEx2";
        case DiskInterface.NVMEx4:
            return "NVMEx4";
        case DiskInterface.MMC:
            return "MMC";
        case DiskInterface.SD:
            return "SD";
        case DiskInterface.USB:
            return "USB";
        case DiskInterface.SAS:
            return "SAS";
        case DiskInterface.VirtioBlock:
            return "VirtioBlock";
        case DiskInterface.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.diskInterfaceToJSON = diskInterfaceToJSON;
var CableKind;
(function (CableKind) {
    CableKind[CableKind["CableKind_Undefined"] = 0] = "CableKind_Undefined";
    CableKind[CableKind["Cat5"] = 1] = "Cat5";
    CableKind[CableKind["Cat5e"] = 2] = "Cat5e";
    CableKind[CableKind["Cat6"] = 3] = "Cat6";
    CableKind[CableKind["DAC"] = 4] = "DAC";
    CableKind[CableKind["DACBreakout"] = 5] = "DACBreakout";
    CableKind[CableKind["FiberLC"] = 6] = "FiberLC";
    CableKind[CableKind["FiberMPOTrunk"] = 7] = "FiberMPOTrunk";
    CableKind[CableKind["FiberMPOBreakout"] = 8] = "FiberMPOBreakout";
    CableKind[CableKind["AOC"] = 9] = "AOC";
    CableKind[CableKind["AOCBreakout"] = 10] = "AOCBreakout";
    CableKind[CableKind["GenericBreakout"] = 11] = "GenericBreakout";
    CableKind[CableKind["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CableKind = exports.CableKind || (exports.CableKind = {}));
function cableKindFromJSON(object) {
    switch (object) {
        case 0:
        case "CableKind_Undefined":
            return CableKind.CableKind_Undefined;
        case 1:
        case "Cat5":
            return CableKind.Cat5;
        case 2:
        case "Cat5e":
            return CableKind.Cat5e;
        case 3:
        case "Cat6":
            return CableKind.Cat6;
        case 4:
        case "DAC":
            return CableKind.DAC;
        case 5:
        case "DACBreakout":
            return CableKind.DACBreakout;
        case 6:
        case "FiberLC":
            return CableKind.FiberLC;
        case 7:
        case "FiberMPOTrunk":
            return CableKind.FiberMPOTrunk;
        case 8:
        case "FiberMPOBreakout":
            return CableKind.FiberMPOBreakout;
        case 9:
        case "AOC":
            return CableKind.AOC;
        case 10:
        case "AOCBreakout":
            return CableKind.AOCBreakout;
        case 11:
        case "GenericBreakout":
            return CableKind.GenericBreakout;
        case -1:
        case "UNRECOGNIZED":
        default:
            return CableKind.UNRECOGNIZED;
    }
}
exports.cableKindFromJSON = cableKindFromJSON;
function cableKindToJSON(object) {
    switch (object) {
        case CableKind.CableKind_Undefined:
            return "CableKind_Undefined";
        case CableKind.Cat5:
            return "Cat5";
        case CableKind.Cat5e:
            return "Cat5e";
        case CableKind.Cat6:
            return "Cat6";
        case CableKind.DAC:
            return "DAC";
        case CableKind.DACBreakout:
            return "DACBreakout";
        case CableKind.FiberLC:
            return "FiberLC";
        case CableKind.FiberMPOTrunk:
            return "FiberMPOTrunk";
        case CableKind.FiberMPOBreakout:
            return "FiberMPOBreakout";
        case CableKind.AOC:
            return "AOC";
        case CableKind.AOCBreakout:
            return "AOCBreakout";
        case CableKind.GenericBreakout:
            return "GenericBreakout";
        case CableKind.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.cableKindToJSON = cableKindToJSON;
var AllocMode;
(function (AllocMode) {
    AllocMode[AllocMode["AllocMode_Undefined"] = 0] = "AllocMode_Undefined";
    AllocMode[AllocMode["NoAlloc"] = 1] = "NoAlloc";
    AllocMode[AllocMode["Net"] = 2] = "Net";
    AllocMode[AllocMode["NetEmu"] = 3] = "NetEmu";
    AllocMode[AllocMode["Filesystem"] = 4] = "Filesystem";
    AllocMode[AllocMode["BlockDevice"] = 5] = "BlockDevice";
    AllocMode[AllocMode["Physical"] = 6] = "Physical";
    AllocMode[AllocMode["Virtual"] = 7] = "Virtual";
    AllocMode[AllocMode["Infrapod"] = 8] = "Infrapod";
    AllocMode[AllocMode["Physim"] = 9] = "Physim";
    AllocMode[AllocMode["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AllocMode = exports.AllocMode || (exports.AllocMode = {}));
function allocModeFromJSON(object) {
    switch (object) {
        case 0:
        case "AllocMode_Undefined":
            return AllocMode.AllocMode_Undefined;
        case 1:
        case "NoAlloc":
            return AllocMode.NoAlloc;
        case 2:
        case "Net":
            return AllocMode.Net;
        case 3:
        case "NetEmu":
            return AllocMode.NetEmu;
        case 4:
        case "Filesystem":
            return AllocMode.Filesystem;
        case 5:
        case "BlockDevice":
            return AllocMode.BlockDevice;
        case 6:
        case "Physical":
            return AllocMode.Physical;
        case 7:
        case "Virtual":
            return AllocMode.Virtual;
        case 8:
        case "Infrapod":
            return AllocMode.Infrapod;
        case 9:
        case "Physim":
            return AllocMode.Physim;
        case -1:
        case "UNRECOGNIZED":
        default:
            return AllocMode.UNRECOGNIZED;
    }
}
exports.allocModeFromJSON = allocModeFromJSON;
function allocModeToJSON(object) {
    switch (object) {
        case AllocMode.AllocMode_Undefined:
            return "AllocMode_Undefined";
        case AllocMode.NoAlloc:
            return "NoAlloc";
        case AllocMode.Net:
            return "Net";
        case AllocMode.NetEmu:
            return "NetEmu";
        case AllocMode.Filesystem:
            return "Filesystem";
        case AllocMode.BlockDevice:
            return "BlockDevice";
        case AllocMode.Physical:
            return "Physical";
        case AllocMode.Virtual:
            return "Virtual";
        case AllocMode.Infrapod:
            return "Infrapod";
        case AllocMode.Physim:
            return "Physim";
        case AllocMode.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.allocModeToJSON = allocModeToJSON;
var Role;
(function (Role) {
    Role[Role["Role_unknown"] = 0] = "Role_unknown";
    Role[Role["TbNode"] = 1] = "TbNode";
    Role[Role["InfraServer"] = 2] = "InfraServer";
    Role[Role["ConsoleServer"] = 3] = "ConsoleServer";
    Role[Role["PowerController"] = 4] = "PowerController";
    Role[Role["NetworkEmulator"] = 5] = "NetworkEmulator";
    Role[Role["XpSwitch"] = 6] = "XpSwitch";
    Role[Role["InfraSwitch"] = 7] = "InfraSwitch";
    Role[Role["MgmtSwitch"] = 8] = "MgmtSwitch";
    Role[Role["Gateway"] = 9] = "Gateway";
    Role[Role["Leaf"] = 10] = "Leaf";
    Role[Role["Fabric"] = 11] = "Fabric";
    Role[Role["Spine"] = 12] = "Spine";
    Role[Role["StorageServer"] = 13] = "StorageServer";
    Role[Role["InfrapodServer"] = 14] = "InfrapodServer";
    Role[Role["EtcdHost"] = 15] = "EtcdHost";
    Role[Role["MinIOHost"] = 16] = "MinIOHost";
    Role[Role["RexHost"] = 17] = "RexHost";
    Role[Role["DriverHost"] = 18] = "DriverHost";
    Role[Role["ManagerHost"] = 19] = "ManagerHost";
    Role[Role["CommanderHost"] = 20] = "CommanderHost";
    Role[Role["SledHost"] = 21] = "SledHost";
    Role[Role["RallyHost"] = 22] = "RallyHost";
    Role[Role["PDU"] = 23] = "PDU";
    Role[Role["EmuSwitch"] = 24] = "EmuSwitch";
    Role[Role["Hypervisor"] = 25] = "Hypervisor";
    Role[Role["PhysicsSimulator"] = 26] = "PhysicsSimulator";
    Role[Role["Stem"] = 27] = "Stem";
    Role[Role["BorderGateway"] = 28] = "BorderGateway";
    Role[Role["OpsServer"] = 29] = "OpsServer";
    Role[Role["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Role = exports.Role || (exports.Role = {}));
function roleFromJSON(object) {
    switch (object) {
        case 0:
        case "Role_unknown":
            return Role.Role_unknown;
        case 1:
        case "TbNode":
            return Role.TbNode;
        case 2:
        case "InfraServer":
            return Role.InfraServer;
        case 3:
        case "ConsoleServer":
            return Role.ConsoleServer;
        case 4:
        case "PowerController":
            return Role.PowerController;
        case 5:
        case "NetworkEmulator":
            return Role.NetworkEmulator;
        case 6:
        case "XpSwitch":
            return Role.XpSwitch;
        case 7:
        case "InfraSwitch":
            return Role.InfraSwitch;
        case 8:
        case "MgmtSwitch":
            return Role.MgmtSwitch;
        case 9:
        case "Gateway":
            return Role.Gateway;
        case 10:
        case "Leaf":
            return Role.Leaf;
        case 11:
        case "Fabric":
            return Role.Fabric;
        case 12:
        case "Spine":
            return Role.Spine;
        case 13:
        case "StorageServer":
            return Role.StorageServer;
        case 14:
        case "InfrapodServer":
            return Role.InfrapodServer;
        case 15:
        case "EtcdHost":
            return Role.EtcdHost;
        case 16:
        case "MinIOHost":
            return Role.MinIOHost;
        case 17:
        case "RexHost":
            return Role.RexHost;
        case 18:
        case "DriverHost":
            return Role.DriverHost;
        case 19:
        case "ManagerHost":
            return Role.ManagerHost;
        case 20:
        case "CommanderHost":
            return Role.CommanderHost;
        case 21:
        case "SledHost":
            return Role.SledHost;
        case 22:
        case "RallyHost":
            return Role.RallyHost;
        case 23:
        case "PDU":
            return Role.PDU;
        case 24:
        case "EmuSwitch":
            return Role.EmuSwitch;
        case 25:
        case "Hypervisor":
            return Role.Hypervisor;
        case 26:
        case "PhysicsSimulator":
            return Role.PhysicsSimulator;
        case 27:
        case "Stem":
            return Role.Stem;
        case 28:
        case "BorderGateway":
            return Role.BorderGateway;
        case 29:
        case "OpsServer":
            return Role.OpsServer;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Role.UNRECOGNIZED;
    }
}
exports.roleFromJSON = roleFromJSON;
function roleToJSON(object) {
    switch (object) {
        case Role.Role_unknown:
            return "Role_unknown";
        case Role.TbNode:
            return "TbNode";
        case Role.InfraServer:
            return "InfraServer";
        case Role.ConsoleServer:
            return "ConsoleServer";
        case Role.PowerController:
            return "PowerController";
        case Role.NetworkEmulator:
            return "NetworkEmulator";
        case Role.XpSwitch:
            return "XpSwitch";
        case Role.InfraSwitch:
            return "InfraSwitch";
        case Role.MgmtSwitch:
            return "MgmtSwitch";
        case Role.Gateway:
            return "Gateway";
        case Role.Leaf:
            return "Leaf";
        case Role.Fabric:
            return "Fabric";
        case Role.Spine:
            return "Spine";
        case Role.StorageServer:
            return "StorageServer";
        case Role.InfrapodServer:
            return "InfrapodServer";
        case Role.EtcdHost:
            return "EtcdHost";
        case Role.MinIOHost:
            return "MinIOHost";
        case Role.RexHost:
            return "RexHost";
        case Role.DriverHost:
            return "DriverHost";
        case Role.ManagerHost:
            return "ManagerHost";
        case Role.CommanderHost:
            return "CommanderHost";
        case Role.SledHost:
            return "SledHost";
        case Role.RallyHost:
            return "RallyHost";
        case Role.PDU:
            return "PDU";
        case Role.EmuSwitch:
            return "EmuSwitch";
        case Role.Hypervisor:
            return "Hypervisor";
        case Role.PhysicsSimulator:
            return "PhysicsSimulator";
        case Role.Stem:
            return "Stem";
        case Role.BorderGateway:
            return "BorderGateway";
        case Role.OpsServer:
            return "OpsServer";
        case Role.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.roleToJSON = roleToJSON;
var LinkRole;
(function (LinkRole) {
    LinkRole[LinkRole["LinkRole_Unspecified"] = 0] = "LinkRole_Unspecified";
    LinkRole[LinkRole["InfraLink"] = 1] = "InfraLink";
    LinkRole[LinkRole["XpLink"] = 2] = "XpLink";
    LinkRole[LinkRole["Tor"] = 3] = "Tor";
    LinkRole[LinkRole["EmuLink"] = 4] = "EmuLink";
    LinkRole[LinkRole["MgmtLink"] = 5] = "MgmtLink";
    LinkRole[LinkRole["GatewayLink"] = 6] = "GatewayLink";
    LinkRole[LinkRole["SimLink"] = 7] = "SimLink";
    LinkRole[LinkRole["HarborEndpoint"] = 8] = "HarborEndpoint";
    LinkRole[LinkRole["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LinkRole = exports.LinkRole || (exports.LinkRole = {}));
function linkRoleFromJSON(object) {
    switch (object) {
        case 0:
        case "LinkRole_Unspecified":
            return LinkRole.LinkRole_Unspecified;
        case 1:
        case "InfraLink":
            return LinkRole.InfraLink;
        case 2:
        case "XpLink":
            return LinkRole.XpLink;
        case 3:
        case "Tor":
            return LinkRole.Tor;
        case 4:
        case "EmuLink":
            return LinkRole.EmuLink;
        case 5:
        case "MgmtLink":
            return LinkRole.MgmtLink;
        case 6:
        case "GatewayLink":
            return LinkRole.GatewayLink;
        case 7:
        case "SimLink":
            return LinkRole.SimLink;
        case 8:
        case "HarborEndpoint":
            return LinkRole.HarborEndpoint;
        case -1:
        case "UNRECOGNIZED":
        default:
            return LinkRole.UNRECOGNIZED;
    }
}
exports.linkRoleFromJSON = linkRoleFromJSON;
function linkRoleToJSON(object) {
    switch (object) {
        case LinkRole.LinkRole_Unspecified:
            return "LinkRole_Unspecified";
        case LinkRole.InfraLink:
            return "InfraLink";
        case LinkRole.XpLink:
            return "XpLink";
        case LinkRole.Tor:
            return "Tor";
        case LinkRole.EmuLink:
            return "EmuLink";
        case LinkRole.MgmtLink:
            return "MgmtLink";
        case LinkRole.GatewayLink:
            return "GatewayLink";
        case LinkRole.SimLink:
            return "SimLink";
        case LinkRole.HarborEndpoint:
            return "HarborEndpoint";
        case LinkRole.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.linkRoleToJSON = linkRoleToJSON;
var DiskRole;
(function (DiskRole) {
    DiskRole[DiskRole["DiskRole_Unspecified"] = 0] = "DiskRole_Unspecified";
    DiskRole[DiskRole["System"] = 1] = "System";
    DiskRole[DiskRole["MinIO"] = 2] = "MinIO";
    DiskRole[DiskRole["Etcd"] = 3] = "Etcd";
    DiskRole[DiskRole["Rally"] = 4] = "Rally";
    DiskRole[DiskRole["Mariner"] = 5] = "Mariner";
    DiskRole[DiskRole["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DiskRole = exports.DiskRole || (exports.DiskRole = {}));
function diskRoleFromJSON(object) {
    switch (object) {
        case 0:
        case "DiskRole_Unspecified":
            return DiskRole.DiskRole_Unspecified;
        case 1:
        case "System":
            return DiskRole.System;
        case 2:
        case "MinIO":
            return DiskRole.MinIO;
        case 3:
        case "Etcd":
            return DiskRole.Etcd;
        case 4:
        case "Rally":
            return DiskRole.Rally;
        case 5:
        case "Mariner":
            return DiskRole.Mariner;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DiskRole.UNRECOGNIZED;
    }
}
exports.diskRoleFromJSON = diskRoleFromJSON;
function diskRoleToJSON(object) {
    switch (object) {
        case DiskRole.DiskRole_Unspecified:
            return "DiskRole_Unspecified";
        case DiskRole.System:
            return "System";
        case DiskRole.MinIO:
            return "MinIO";
        case DiskRole.Etcd:
            return "Etcd";
        case DiskRole.Rally:
            return "Rally";
        case DiskRole.Mariner:
            return "Mariner";
        case DiskRole.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.diskRoleToJSON = diskRoleToJSON;
var Operator;
(function (Operator) {
    Operator[Operator["Op_Undefined"] = 0] = "Op_Undefined";
    Operator[Operator["LT"] = 1] = "LT";
    Operator[Operator["LE"] = 2] = "LE";
    Operator[Operator["GT"] = 3] = "GT";
    Operator[Operator["GE"] = 4] = "GE";
    Operator[Operator["EQ"] = 5] = "EQ";
    Operator[Operator["NE"] = 6] = "NE";
    Operator[Operator["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Operator = exports.Operator || (exports.Operator = {}));
function operatorFromJSON(object) {
    switch (object) {
        case 0:
        case "Op_Undefined":
            return Operator.Op_Undefined;
        case 1:
        case "LT":
            return Operator.LT;
        case 2:
        case "LE":
            return Operator.LE;
        case 3:
        case "GT":
            return Operator.GT;
        case 4:
        case "GE":
            return Operator.GE;
        case 5:
        case "EQ":
            return Operator.EQ;
        case 6:
        case "NE":
            return Operator.NE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Operator.UNRECOGNIZED;
    }
}
exports.operatorFromJSON = operatorFromJSON;
function operatorToJSON(object) {
    switch (object) {
        case Operator.Op_Undefined:
            return "Op_Undefined";
        case Operator.LT:
            return "LT";
        case Operator.LE:
            return "LE";
        case Operator.GT:
            return "GT";
        case Operator.GE:
            return "GE";
        case Operator.EQ:
            return "EQ";
        case Operator.NE:
            return "NE";
        case Operator.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.operatorToJSON = operatorToJSON;
var Link_Kind;
(function (Link_Kind) {
    Link_Kind[Link_Kind["unspec"] = 0] = "unspec";
    Link_Kind[Link_Kind["ethernet"] = 1] = "ethernet";
    Link_Kind[Link_Kind["wifi"] = 2] = "wifi";
    Link_Kind[Link_Kind["wifi_ac"] = 3] = "wifi_ac";
    Link_Kind[Link_Kind["wifi_ax"] = 4] = "wifi_ax";
    Link_Kind[Link_Kind["lte_4g"] = 5] = "lte_4g";
    Link_Kind[Link_Kind["lte_5g"] = 6] = "lte_5g";
    Link_Kind[Link_Kind["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Link_Kind = exports.Link_Kind || (exports.Link_Kind = {}));
function link_KindFromJSON(object) {
    switch (object) {
        case 0:
        case "unspec":
            return Link_Kind.unspec;
        case 1:
        case "ethernet":
            return Link_Kind.ethernet;
        case 2:
        case "wifi":
            return Link_Kind.wifi;
        case 3:
        case "wifi_ac":
            return Link_Kind.wifi_ac;
        case 4:
        case "wifi_ax":
            return Link_Kind.wifi_ax;
        case 5:
        case "lte_4g":
            return Link_Kind.lte_4g;
        case 6:
        case "lte_5g":
            return Link_Kind.lte_5g;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Link_Kind.UNRECOGNIZED;
    }
}
exports.link_KindFromJSON = link_KindFromJSON;
function link_KindToJSON(object) {
    switch (object) {
        case Link_Kind.unspec:
            return "unspec";
        case Link_Kind.ethernet:
            return "ethernet";
        case Link_Kind.wifi:
            return "wifi";
        case Link_Kind.wifi_ac:
            return "wifi_ac";
        case Link_Kind.wifi_ax:
            return "wifi_ax";
        case Link_Kind.lte_4g:
            return "lte_4g";
        case Link_Kind.lte_5g:
            return "lte_5g";
        case Link_Kind.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.link_KindToJSON = link_KindToJSON;
var BMC_Kind;
(function (BMC_Kind) {
    BMC_Kind[BMC_Kind["IPMI"] = 0] = "IPMI";
    BMC_Kind[BMC_Kind["RedFish"] = 1] = "RedFish";
    BMC_Kind[BMC_Kind["IPMIRedFish"] = 2] = "IPMIRedFish";
    BMC_Kind[BMC_Kind["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BMC_Kind = exports.BMC_Kind || (exports.BMC_Kind = {}));
function bMC_KindFromJSON(object) {
    switch (object) {
        case 0:
        case "IPMI":
            return BMC_Kind.IPMI;
        case 1:
        case "RedFish":
            return BMC_Kind.RedFish;
        case 2:
        case "IPMIRedFish":
            return BMC_Kind.IPMIRedFish;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BMC_Kind.UNRECOGNIZED;
    }
}
exports.bMC_KindFromJSON = bMC_KindFromJSON;
function bMC_KindToJSON(object) {
    switch (object) {
        case BMC_Kind.IPMI:
            return "IPMI";
        case BMC_Kind.RedFish:
            return "RedFish";
        case BMC_Kind.IPMIRedFish:
            return "IPMIRedFish";
        case BMC_Kind.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.bMC_KindToJSON = bMC_KindToJSON;
var RelayBoard_Kind;
(function (RelayBoard_Kind) {
    RelayBoard_Kind[RelayBoard_Kind["NCDFusion"] = 0] = "NCDFusion";
    RelayBoard_Kind[RelayBoard_Kind["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RelayBoard_Kind = exports.RelayBoard_Kind || (exports.RelayBoard_Kind = {}));
function relayBoard_KindFromJSON(object) {
    switch (object) {
        case 0:
        case "NCDFusion":
            return RelayBoard_Kind.NCDFusion;
        case -1:
        case "UNRECOGNIZED":
        default:
            return RelayBoard_Kind.UNRECOGNIZED;
    }
}
exports.relayBoard_KindFromJSON = relayBoard_KindFromJSON;
function relayBoard_KindToJSON(object) {
    switch (object) {
        case RelayBoard_Kind.NCDFusion:
            return "NCDFusion";
        case RelayBoard_Kind.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.relayBoard_KindToJSON = relayBoard_KindToJSON;
var PowerDistributionUnit_Kind;
(function (PowerDistributionUnit_Kind) {
    PowerDistributionUnit_Kind[PowerDistributionUnit_Kind["APC"] = 0] = "APC";
    PowerDistributionUnit_Kind[PowerDistributionUnit_Kind["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PowerDistributionUnit_Kind = exports.PowerDistributionUnit_Kind || (exports.PowerDistributionUnit_Kind = {}));
function powerDistributionUnit_KindFromJSON(object) {
    switch (object) {
        case 0:
        case "APC":
            return PowerDistributionUnit_Kind.APC;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PowerDistributionUnit_Kind.UNRECOGNIZED;
    }
}
exports.powerDistributionUnit_KindFromJSON = powerDistributionUnit_KindFromJSON;
function powerDistributionUnit_KindToJSON(object) {
    switch (object) {
        case PowerDistributionUnit_Kind.APC:
            return "APC";
        case PowerDistributionUnit_Kind.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.powerDistributionUnit_KindToJSON = powerDistributionUnit_KindToJSON;
var Firmware_Kind;
(function (Firmware_Kind) {
    Firmware_Kind[Firmware_Kind["Undefined"] = 0] = "Undefined";
    Firmware_Kind[Firmware_Kind["UEFI"] = 1] = "UEFI";
    Firmware_Kind[Firmware_Kind["BIOS"] = 2] = "BIOS";
    Firmware_Kind[Firmware_Kind["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Firmware_Kind = exports.Firmware_Kind || (exports.Firmware_Kind = {}));
function firmware_KindFromJSON(object) {
    switch (object) {
        case 0:
        case "Undefined":
            return Firmware_Kind.Undefined;
        case 1:
        case "UEFI":
            return Firmware_Kind.UEFI;
        case 2:
        case "BIOS":
            return Firmware_Kind.BIOS;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Firmware_Kind.UNRECOGNIZED;
    }
}
exports.firmware_KindFromJSON = firmware_KindFromJSON;
function firmware_KindToJSON(object) {
    switch (object) {
        case Firmware_Kind.Undefined:
            return "Undefined";
        case Firmware_Kind.UEFI:
            return "UEFI";
        case Firmware_Kind.BIOS:
            return "BIOS";
        case Firmware_Kind.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.firmware_KindToJSON = firmware_KindToJSON;
function createBaseFacility() {
    return { id: "", fqdn: "", resources: [], cables: [] };
}
exports.Facility = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.fqdn !== "") {
            writer.uint32(18).string(message.fqdn);
        }
        for (var _i = 0, _a = message.resources; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.Resource.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (var _b = 0, _c = message.cables; _b < _c.length; _b++) {
            var v = _c[_b];
            exports.Cable.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseFacility();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.fqdn = reader.string();
                    break;
                case 3:
                    message.resources.push(exports.Resource.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.cables.push(exports.Cable.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            fqdn: isSet(object.fqdn) ? String(object.fqdn) : "",
            resources: Array.isArray(object === null || object === void 0 ? void 0 : object.resources) ? object.resources.map(function (e) { return exports.Resource.fromJSON(e); }) : [],
            cables: Array.isArray(object === null || object === void 0 ? void 0 : object.cables) ? object.cables.map(function (e) { return exports.Cable.fromJSON(e); }) : []
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.fqdn !== undefined && (obj.fqdn = message.fqdn);
        if (message.resources) {
            obj.resources = message.resources.map(function (e) { return e ? exports.Resource.toJSON(e) : undefined; });
        }
        else {
            obj.resources = [];
        }
        if (message.cables) {
            obj.cables = message.cables.map(function (e) { return e ? exports.Cable.toJSON(e) : undefined; });
        }
        else {
            obj.cables = [];
        }
        return obj;
    },
    create: function (base) {
        return exports.Facility.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = createBaseFacility();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.fqdn = (_b = object.fqdn) !== null && _b !== void 0 ? _b : "";
        message.resources = ((_c = object.resources) === null || _c === void 0 ? void 0 : _c.map(function (e) { return exports.Resource.fromPartial(e); })) || [];
        message.cables = ((_d = object.cables) === null || _d === void 0 ? void 0 : _d.map(function (e) { return exports.Cable.fromPartial(e); })) || [];
        return message;
    }
};
function createBaseNetwork() {
    return { id: "", nodes: [], links: [], parameters: undefined };
}
exports.Network = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        for (var _i = 0, _a = message.nodes; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.Node.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (var _b = 0, _c = message.links; _b < _c.length; _b++) {
            var v = _c[_b];
            exports.Link.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.parameters !== undefined) {
            exports.ExperimentParameters.encode(message.parameters, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseNetwork();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.nodes.push(exports.Node.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.links.push(exports.Link.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.parameters = exports.ExperimentParameters.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            nodes: Array.isArray(object === null || object === void 0 ? void 0 : object.nodes) ? object.nodes.map(function (e) { return exports.Node.fromJSON(e); }) : [],
            links: Array.isArray(object === null || object === void 0 ? void 0 : object.links) ? object.links.map(function (e) { return exports.Link.fromJSON(e); }) : [],
            parameters: isSet(object.parameters) ? exports.ExperimentParameters.fromJSON(object.parameters) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.id !== undefined && (obj.id = message.id);
        if (message.nodes) {
            obj.nodes = message.nodes.map(function (e) { return e ? exports.Node.toJSON(e) : undefined; });
        }
        else {
            obj.nodes = [];
        }
        if (message.links) {
            obj.links = message.links.map(function (e) { return e ? exports.Link.toJSON(e) : undefined; });
        }
        else {
            obj.links = [];
        }
        message.parameters !== undefined &&
            (obj.parameters = message.parameters ? exports.ExperimentParameters.toJSON(message.parameters) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.Network.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBaseNetwork();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.nodes = ((_b = object.nodes) === null || _b === void 0 ? void 0 : _b.map(function (e) { return exports.Node.fromPartial(e); })) || [];
        message.links = ((_c = object.links) === null || _c === void 0 ? void 0 : _c.map(function (e) { return exports.Link.fromPartial(e); })) || [];
        message.parameters = (object.parameters !== undefined && object.parameters !== null)
            ? exports.ExperimentParameters.fromPartial(object.parameters)
            : undefined;
        return message;
    }
};
function createBaseExperimentParameters() {
    return {
        routing: undefined,
        addressing: undefined,
        hypervisors: [],
        simulators: [],
        emulators: [],
        experimentnetresolution: false,
        emulation: undefined
    };
}
exports.ExperimentParameters = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.routing !== undefined) {
            exports.RoutingConstraint.encode(message.routing, writer.uint32(10).fork()).ldelim();
        }
        if (message.addressing !== undefined) {
            exports.AddressingConstraint.encode(message.addressing, writer.uint32(18).fork()).ldelim();
        }
        for (var _i = 0, _a = message.hypervisors; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.uint32(26).string(v);
        }
        for (var _b = 0, _c = message.simulators; _b < _c.length; _b++) {
            var v = _c[_b];
            writer.uint32(34).string(v);
        }
        for (var _d = 0, _e = message.emulators; _d < _e.length; _d++) {
            var v = _e[_d];
            writer.uint32(42).string(v);
        }
        if (message.experimentnetresolution === true) {
            writer.uint32(48).bool(message.experimentnetresolution);
        }
        if (message.emulation !== undefined) {
            exports.EmulationConstraint.encode(message.emulation, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseExperimentParameters();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.routing = exports.RoutingConstraint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.addressing = exports.AddressingConstraint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.hypervisors.push(reader.string());
                    break;
                case 4:
                    message.simulators.push(reader.string());
                    break;
                case 5:
                    message.emulators.push(reader.string());
                    break;
                case 6:
                    message.experimentnetresolution = reader.bool();
                    break;
                case 7:
                    message.emulation = exports.EmulationConstraint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            routing: isSet(object.routing) ? exports.RoutingConstraint.fromJSON(object.routing) : undefined,
            addressing: isSet(object.addressing) ? exports.AddressingConstraint.fromJSON(object.addressing) : undefined,
            hypervisors: Array.isArray(object === null || object === void 0 ? void 0 : object.hypervisors) ? object.hypervisors.map(function (e) { return String(e); }) : [],
            simulators: Array.isArray(object === null || object === void 0 ? void 0 : object.simulators) ? object.simulators.map(function (e) { return String(e); }) : [],
            emulators: Array.isArray(object === null || object === void 0 ? void 0 : object.emulators) ? object.emulators.map(function (e) { return String(e); }) : [],
            experimentnetresolution: isSet(object.experimentnetresolution) ? Boolean(object.experimentnetresolution) : false,
            emulation: isSet(object.emulation) ? exports.EmulationConstraint.fromJSON(object.emulation) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.routing !== undefined &&
            (obj.routing = message.routing ? exports.RoutingConstraint.toJSON(message.routing) : undefined);
        message.addressing !== undefined &&
            (obj.addressing = message.addressing ? exports.AddressingConstraint.toJSON(message.addressing) : undefined);
        if (message.hypervisors) {
            obj.hypervisors = message.hypervisors.map(function (e) { return e; });
        }
        else {
            obj.hypervisors = [];
        }
        if (message.simulators) {
            obj.simulators = message.simulators.map(function (e) { return e; });
        }
        else {
            obj.simulators = [];
        }
        if (message.emulators) {
            obj.emulators = message.emulators.map(function (e) { return e; });
        }
        else {
            obj.emulators = [];
        }
        message.experimentnetresolution !== undefined && (obj.experimentnetresolution = message.experimentnetresolution);
        message.emulation !== undefined &&
            (obj.emulation = message.emulation ? exports.EmulationConstraint.toJSON(message.emulation) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.ExperimentParameters.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = createBaseExperimentParameters();
        message.routing = (object.routing !== undefined && object.routing !== null)
            ? exports.RoutingConstraint.fromPartial(object.routing)
            : undefined;
        message.addressing = (object.addressing !== undefined && object.addressing !== null)
            ? exports.AddressingConstraint.fromPartial(object.addressing)
            : undefined;
        message.hypervisors = ((_a = object.hypervisors) === null || _a === void 0 ? void 0 : _a.map(function (e) { return e; })) || [];
        message.simulators = ((_b = object.simulators) === null || _b === void 0 ? void 0 : _b.map(function (e) { return e; })) || [];
        message.emulators = ((_c = object.emulators) === null || _c === void 0 ? void 0 : _c.map(function (e) { return e; })) || [];
        message.experimentnetresolution = (_d = object.experimentnetresolution) !== null && _d !== void 0 ? _d : false;
        message.emulation = (object.emulation !== undefined && object.emulation !== null)
            ? exports.EmulationConstraint.fromPartial(object.emulation)
            : undefined;
        return message;
    }
};
function createBaseProperties() {
    return { keyvalues: {} };
}
exports.Properties = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        Object.entries(message.keyvalues).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.Properties_KeyvaluesEntry.encode({ key: key, value: value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseProperties();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    var entry1 = exports.Properties_KeyvaluesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.keyvalues[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            keyvalues: isObject(object.keyvalues)
                ? Object.entries(object.keyvalues).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[key] = exports.Properties_Values.fromJSON(value);
                    return acc;
                }, {})
                : {}
        };
    },
    toJSON: function (message) {
        var obj = {};
        obj.keyvalues = {};
        if (message.keyvalues) {
            Object.entries(message.keyvalues).forEach(function (_a) {
                var k = _a[0], v = _a[1];
                obj.keyvalues[k] = exports.Properties_Values.toJSON(v);
            });
        }
        return obj;
    },
    create: function (base) {
        return exports.Properties.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseProperties();
        message.keyvalues = Object.entries((_a = object.keyvalues) !== null && _a !== void 0 ? _a : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[key] = exports.Properties_Values.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    }
};
function createBaseProperties_Values() {
    return { values: [] };
}
exports.Properties_Values = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        for (var _i = 0, _a = message.values; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseProperties_Values();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.values.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { values: Array.isArray(object === null || object === void 0 ? void 0 : object.values) ? object.values.map(function (e) { return String(e); }) : [] };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.values) {
            obj.values = message.values.map(function (e) { return e; });
        }
        else {
            obj.values = [];
        }
        return obj;
    },
    create: function (base) {
        return exports.Properties_Values.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseProperties_Values();
        message.values = ((_a = object.values) === null || _a === void 0 ? void 0 : _a.map(function (e) { return e; })) || [];
        return message;
    }
};
function createBaseProperties_KeyvaluesEntry() {
    return { key: "", value: undefined };
}
exports.Properties_KeyvaluesEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.Properties_Values.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseProperties_KeyvaluesEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.Properties_Values.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? exports.Properties_Values.fromJSON(object.value) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? exports.Properties_Values.toJSON(message.value) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.Properties_KeyvaluesEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseProperties_KeyvaluesEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.Properties_Values.fromPartial(object.value)
            : undefined;
        return message;
    }
};
function createBaseNode() {
    return {
        id: "",
        sockets: [],
        proc: undefined,
        memory: undefined,
        NIC: undefined,
        disks: undefined,
        metal: undefined,
        virt: undefined,
        image: undefined,
        platform: undefined,
        viz: undefined,
        conf: undefined,
        properties: undefined,
        host: undefined
    };
}
exports.Node = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        for (var _i = 0, _a = message.sockets; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.Socket.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.proc !== undefined) {
            exports.ProcSpec.encode(message.proc, writer.uint32(26).fork()).ldelim();
        }
        if (message.memory !== undefined) {
            exports.MemorySpec.encode(message.memory, writer.uint32(34).fork()).ldelim();
        }
        if (message.NIC !== undefined) {
            exports.NICSpec.encode(message.NIC, writer.uint32(42).fork()).ldelim();
        }
        if (message.disks !== undefined) {
            exports.DiskSpec.encode(message.disks, writer.uint32(50).fork()).ldelim();
        }
        if (message.metal !== undefined) {
            exports.BoolConstraint.encode(message.metal, writer.uint32(58).fork()).ldelim();
        }
        if (message.virt !== undefined) {
            exports.BoolConstraint.encode(message.virt, writer.uint32(66).fork()).ldelim();
        }
        if (message.image !== undefined) {
            exports.StringConstraint.encode(message.image, writer.uint32(74).fork()).ldelim();
        }
        if (message.platform !== undefined) {
            exports.StringConstraint.encode(message.platform, writer.uint32(82).fork()).ldelim();
        }
        if (message.viz !== undefined) {
            exports.Visualization.encode(message.viz, writer.uint32(90).fork()).ldelim();
        }
        if (message.conf !== undefined) {
            exports.NodeConfig.encode(message.conf, writer.uint32(98).fork()).ldelim();
        }
        if (message.properties !== undefined) {
            exports.Properties.encode(message.properties, writer.uint32(106).fork()).ldelim();
        }
        if (message.host !== undefined) {
            exports.StringConstraint.encode(message.host, writer.uint32(114).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseNode();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.sockets.push(exports.Socket.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.proc = exports.ProcSpec.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.memory = exports.MemorySpec.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.NIC = exports.NICSpec.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.disks = exports.DiskSpec.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.metal = exports.BoolConstraint.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.virt = exports.BoolConstraint.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.image = exports.StringConstraint.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.platform = exports.StringConstraint.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.viz = exports.Visualization.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.conf = exports.NodeConfig.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.properties = exports.Properties.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.host = exports.StringConstraint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            sockets: Array.isArray(object === null || object === void 0 ? void 0 : object.sockets) ? object.sockets.map(function (e) { return exports.Socket.fromJSON(e); }) : [],
            proc: isSet(object.proc) ? exports.ProcSpec.fromJSON(object.proc) : undefined,
            memory: isSet(object.memory) ? exports.MemorySpec.fromJSON(object.memory) : undefined,
            NIC: isSet(object.NIC) ? exports.NICSpec.fromJSON(object.NIC) : undefined,
            disks: isSet(object.disks) ? exports.DiskSpec.fromJSON(object.disks) : undefined,
            metal: isSet(object.metal) ? exports.BoolConstraint.fromJSON(object.metal) : undefined,
            virt: isSet(object.virt) ? exports.BoolConstraint.fromJSON(object.virt) : undefined,
            image: isSet(object.image) ? exports.StringConstraint.fromJSON(object.image) : undefined,
            platform: isSet(object.platform) ? exports.StringConstraint.fromJSON(object.platform) : undefined,
            viz: isSet(object.viz) ? exports.Visualization.fromJSON(object.viz) : undefined,
            conf: isSet(object.conf) ? exports.NodeConfig.fromJSON(object.conf) : undefined,
            properties: isSet(object.properties) ? exports.Properties.fromJSON(object.properties) : undefined,
            host: isSet(object.host) ? exports.StringConstraint.fromJSON(object.host) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.id !== undefined && (obj.id = message.id);
        if (message.sockets) {
            obj.sockets = message.sockets.map(function (e) { return e ? exports.Socket.toJSON(e) : undefined; });
        }
        else {
            obj.sockets = [];
        }
        message.proc !== undefined && (obj.proc = message.proc ? exports.ProcSpec.toJSON(message.proc) : undefined);
        message.memory !== undefined && (obj.memory = message.memory ? exports.MemorySpec.toJSON(message.memory) : undefined);
        message.NIC !== undefined && (obj.NIC = message.NIC ? exports.NICSpec.toJSON(message.NIC) : undefined);
        message.disks !== undefined && (obj.disks = message.disks ? exports.DiskSpec.toJSON(message.disks) : undefined);
        message.metal !== undefined && (obj.metal = message.metal ? exports.BoolConstraint.toJSON(message.metal) : undefined);
        message.virt !== undefined && (obj.virt = message.virt ? exports.BoolConstraint.toJSON(message.virt) : undefined);
        message.image !== undefined && (obj.image = message.image ? exports.StringConstraint.toJSON(message.image) : undefined);
        message.platform !== undefined &&
            (obj.platform = message.platform ? exports.StringConstraint.toJSON(message.platform) : undefined);
        message.viz !== undefined && (obj.viz = message.viz ? exports.Visualization.toJSON(message.viz) : undefined);
        message.conf !== undefined && (obj.conf = message.conf ? exports.NodeConfig.toJSON(message.conf) : undefined);
        message.properties !== undefined &&
            (obj.properties = message.properties ? exports.Properties.toJSON(message.properties) : undefined);
        message.host !== undefined && (obj.host = message.host ? exports.StringConstraint.toJSON(message.host) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.Node.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseNode();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.sockets = ((_b = object.sockets) === null || _b === void 0 ? void 0 : _b.map(function (e) { return exports.Socket.fromPartial(e); })) || [];
        message.proc = (object.proc !== undefined && object.proc !== null) ? exports.ProcSpec.fromPartial(object.proc) : undefined;
        message.memory = (object.memory !== undefined && object.memory !== null)
            ? exports.MemorySpec.fromPartial(object.memory)
            : undefined;
        message.NIC = (object.NIC !== undefined && object.NIC !== null) ? exports.NICSpec.fromPartial(object.NIC) : undefined;
        message.disks = (object.disks !== undefined && object.disks !== null)
            ? exports.DiskSpec.fromPartial(object.disks)
            : undefined;
        message.metal = (object.metal !== undefined && object.metal !== null)
            ? exports.BoolConstraint.fromPartial(object.metal)
            : undefined;
        message.virt = (object.virt !== undefined && object.virt !== null)
            ? exports.BoolConstraint.fromPartial(object.virt)
            : undefined;
        message.image = (object.image !== undefined && object.image !== null)
            ? exports.StringConstraint.fromPartial(object.image)
            : undefined;
        message.platform = (object.platform !== undefined && object.platform !== null)
            ? exports.StringConstraint.fromPartial(object.platform)
            : undefined;
        message.viz = (object.viz !== undefined && object.viz !== null) ? exports.Visualization.fromPartial(object.viz) : undefined;
        message.conf = (object.conf !== undefined && object.conf !== null)
            ? exports.NodeConfig.fromPartial(object.conf)
            : undefined;
        message.properties = (object.properties !== undefined && object.properties !== null)
            ? exports.Properties.fromPartial(object.properties)
            : undefined;
        message.host = (object.host !== undefined && object.host !== null)
            ? exports.StringConstraint.fromPartial(object.host)
            : undefined;
        return message;
    }
};
function createBaseNodeConfig() {
    return { routes: [] };
}
exports.NodeConfig = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        for (var _i = 0, _a = message.routes; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.RouteConfig.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseNodeConfig();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.routes.push(exports.RouteConfig.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { routes: Array.isArray(object === null || object === void 0 ? void 0 : object.routes) ? object.routes.map(function (e) { return exports.RouteConfig.fromJSON(e); }) : [] };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.routes) {
            obj.routes = message.routes.map(function (e) { return e ? exports.RouteConfig.toJSON(e) : undefined; });
        }
        else {
            obj.routes = [];
        }
        return obj;
    },
    create: function (base) {
        return exports.NodeConfig.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseNodeConfig();
        message.routes = ((_a = object.routes) === null || _a === void 0 ? void 0 : _a.map(function (e) { return exports.RouteConfig.fromPartial(e); })) || [];
        return message;
    }
};
function createBaseRouteConfig() {
    return { src: "", gw: "", dst: "" };
}
exports.RouteConfig = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.src !== "") {
            writer.uint32(10).string(message.src);
        }
        if (message.gw !== "") {
            writer.uint32(18).string(message.gw);
        }
        if (message.dst !== "") {
            writer.uint32(26).string(message.dst);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseRouteConfig();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.src = reader.string();
                    break;
                case 2:
                    message.gw = reader.string();
                    break;
                case 3:
                    message.dst = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            src: isSet(object.src) ? String(object.src) : "",
            gw: isSet(object.gw) ? String(object.gw) : "",
            dst: isSet(object.dst) ? String(object.dst) : ""
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.src !== undefined && (obj.src = message.src);
        message.gw !== undefined && (obj.gw = message.gw);
        message.dst !== undefined && (obj.dst = message.dst);
        return obj;
    },
    create: function (base) {
        return exports.RouteConfig.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBaseRouteConfig();
        message.src = (_a = object.src) !== null && _a !== void 0 ? _a : "";
        message.gw = (_b = object.gw) !== null && _b !== void 0 ? _b : "";
        message.dst = (_c = object.dst) !== null && _c !== void 0 ? _c : "";
        return message;
    }
};
function createBaseVisualization() {
    return { color: "", size: 0 };
}
exports.Visualization = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.color !== "") {
            writer.uint32(10).string(message.color);
        }
        if (message.size !== 0) {
            writer.uint32(16).uint32(message.size);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseVisualization();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.color = reader.string();
                    break;
                case 2:
                    message.size = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            color: isSet(object.color) ? String(object.color) : "",
            size: isSet(object.size) ? Number(object.size) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.color !== undefined && (obj.color = message.color);
        message.size !== undefined && (obj.size = Math.round(message.size));
        return obj;
    },
    create: function (base) {
        return exports.Visualization.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseVisualization();
        message.color = (_a = object.color) !== null && _a !== void 0 ? _a : "";
        message.size = (_b = object.size) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseRef() {
    return { element: "", index: 0, subref: undefined };
}
exports.Ref = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.element !== "") {
            writer.uint32(10).string(message.element);
        }
        if (message.index !== 0) {
            writer.uint32(16).uint32(message.index);
        }
        if (message.subref !== undefined) {
            exports.Subref.encode(message.subref, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseRef();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.element = reader.string();
                    break;
                case 2:
                    message.index = reader.uint32();
                    break;
                case 3:
                    message.subref = exports.Subref.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            element: isSet(object.element) ? String(object.element) : "",
            index: isSet(object.index) ? Number(object.index) : 0,
            subref: isSet(object.subref) ? exports.Subref.fromJSON(object.subref) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.element !== undefined && (obj.element = message.element);
        message.index !== undefined && (obj.index = Math.round(message.index));
        message.subref !== undefined && (obj.subref = message.subref ? exports.Subref.toJSON(message.subref) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.Ref.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseRef();
        message.element = (_a = object.element) !== null && _a !== void 0 ? _a : "";
        message.index = (_b = object.index) !== null && _b !== void 0 ? _b : 0;
        message.subref = (object.subref !== undefined && object.subref !== null)
            ? exports.Subref.fromPartial(object.subref)
            : undefined;
        return message;
    }
};
function createBaseSubref() {
    return { index: 0 };
}
exports.Subref = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.index !== 0) {
            writer.uint32(8).uint32(message.index);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseSubref();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.index = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { index: isSet(object.index) ? Number(object.index) : 0 };
    },
    toJSON: function (message) {
        var obj = {};
        message.index !== undefined && (obj.index = Math.round(message.index));
        return obj;
    },
    create: function (base) {
        return exports.Subref.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseSubref();
        message.index = (_a = object.index) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBaseSocket() {
    return { index: 0, addrs: [], endpoint: undefined, port: undefined };
}
exports.Socket = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.index !== 0) {
            writer.uint32(8).int32(message.index);
        }
        for (var _i = 0, _a = message.addrs; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.uint32(18).string(v);
        }
        if (message.endpoint !== undefined) {
            exports.Ref.encode(message.endpoint, writer.uint32(26).fork()).ldelim();
        }
        if (message.port !== undefined) {
            exports.PortSpec.encode(message.port, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseSocket();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.addrs.push(reader.string());
                    break;
                case 3:
                    message.endpoint = exports.Ref.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.port = exports.PortSpec.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            index: isSet(object.index) ? Number(object.index) : 0,
            addrs: Array.isArray(object === null || object === void 0 ? void 0 : object.addrs) ? object.addrs.map(function (e) { return String(e); }) : [],
            endpoint: isSet(object.endpoint) ? exports.Ref.fromJSON(object.endpoint) : undefined,
            port: isSet(object.port) ? exports.PortSpec.fromJSON(object.port) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.index !== undefined && (obj.index = Math.round(message.index));
        if (message.addrs) {
            obj.addrs = message.addrs.map(function (e) { return e; });
        }
        else {
            obj.addrs = [];
        }
        message.endpoint !== undefined && (obj.endpoint = message.endpoint ? exports.Ref.toJSON(message.endpoint) : undefined);
        message.port !== undefined && (obj.port = message.port ? exports.PortSpec.toJSON(message.port) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.Socket.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseSocket();
        message.index = (_a = object.index) !== null && _a !== void 0 ? _a : 0;
        message.addrs = ((_b = object.addrs) === null || _b === void 0 ? void 0 : _b.map(function (e) { return e; })) || [];
        message.endpoint = (object.endpoint !== undefined && object.endpoint !== null)
            ? exports.Ref.fromPartial(object.endpoint)
            : undefined;
        message.port = (object.port !== undefined && object.port !== null) ? exports.PortSpec.fromPartial(object.port) : undefined;
        return message;
    }
};
function createBaseRouteConf() {
    return { src: "", gw: "", dst: "" };
}
exports.RouteConf = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.src !== "") {
            writer.uint32(10).string(message.src);
        }
        if (message.gw !== "") {
            writer.uint32(18).string(message.gw);
        }
        if (message.dst !== "") {
            writer.uint32(26).string(message.dst);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseRouteConf();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.src = reader.string();
                    break;
                case 2:
                    message.gw = reader.string();
                    break;
                case 3:
                    message.dst = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            src: isSet(object.src) ? String(object.src) : "",
            gw: isSet(object.gw) ? String(object.gw) : "",
            dst: isSet(object.dst) ? String(object.dst) : ""
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.src !== undefined && (obj.src = message.src);
        message.gw !== undefined && (obj.gw = message.gw);
        message.dst !== undefined && (obj.dst = message.dst);
        return obj;
    },
    create: function (base) {
        return exports.RouteConf.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBaseRouteConf();
        message.src = (_a = object.src) !== null && _a !== void 0 ? _a : "";
        message.gw = (_b = object.gw) !== null && _b !== void 0 ? _b : "";
        message.dst = (_c = object.dst) !== null && _c !== void 0 ? _c : "";
        return message;
    }
};
function createBaseLink() {
    return {
        id: "",
        latency: undefined,
        capacity: undefined,
        loss: undefined,
        endpoints: [],
        kind: undefined,
        layer: undefined,
        properties: undefined
    };
}
exports.Link = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.latency !== undefined) {
            exports.Uint64Constraint.encode(message.latency, writer.uint32(18).fork()).ldelim();
        }
        if (message.capacity !== undefined) {
            exports.Uint64Constraint.encode(message.capacity, writer.uint32(26).fork()).ldelim();
        }
        if (message.loss !== undefined) {
            exports.FloatConstraint.encode(message.loss, writer.uint32(34).fork()).ldelim();
        }
        for (var _i = 0, _a = message.endpoints; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.Endpoint.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (message.kind !== undefined) {
            exports.LinkKindConstraint.encode(message.kind, writer.uint32(50).fork()).ldelim();
        }
        if (message.layer !== undefined) {
            exports.Uint64Constraint.encode(message.layer, writer.uint32(58).fork()).ldelim();
        }
        if (message.properties !== undefined) {
            exports.Properties.encode(message.properties, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseLink();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.latency = exports.Uint64Constraint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.capacity = exports.Uint64Constraint.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.loss = exports.FloatConstraint.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.endpoints.push(exports.Endpoint.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.kind = exports.LinkKindConstraint.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.layer = exports.Uint64Constraint.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.properties = exports.Properties.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            latency: isSet(object.latency) ? exports.Uint64Constraint.fromJSON(object.latency) : undefined,
            capacity: isSet(object.capacity) ? exports.Uint64Constraint.fromJSON(object.capacity) : undefined,
            loss: isSet(object.loss) ? exports.FloatConstraint.fromJSON(object.loss) : undefined,
            endpoints: Array.isArray(object === null || object === void 0 ? void 0 : object.endpoints) ? object.endpoints.map(function (e) { return exports.Endpoint.fromJSON(e); }) : [],
            kind: isSet(object.kind) ? exports.LinkKindConstraint.fromJSON(object.kind) : undefined,
            layer: isSet(object.layer) ? exports.Uint64Constraint.fromJSON(object.layer) : undefined,
            properties: isSet(object.properties) ? exports.Properties.fromJSON(object.properties) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.latency !== undefined &&
            (obj.latency = message.latency ? exports.Uint64Constraint.toJSON(message.latency) : undefined);
        message.capacity !== undefined &&
            (obj.capacity = message.capacity ? exports.Uint64Constraint.toJSON(message.capacity) : undefined);
        message.loss !== undefined && (obj.loss = message.loss ? exports.FloatConstraint.toJSON(message.loss) : undefined);
        if (message.endpoints) {
            obj.endpoints = message.endpoints.map(function (e) { return e ? exports.Endpoint.toJSON(e) : undefined; });
        }
        else {
            obj.endpoints = [];
        }
        message.kind !== undefined && (obj.kind = message.kind ? exports.LinkKindConstraint.toJSON(message.kind) : undefined);
        message.layer !== undefined && (obj.layer = message.layer ? exports.Uint64Constraint.toJSON(message.layer) : undefined);
        message.properties !== undefined &&
            (obj.properties = message.properties ? exports.Properties.toJSON(message.properties) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.Link.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseLink();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.latency = (object.latency !== undefined && object.latency !== null)
            ? exports.Uint64Constraint.fromPartial(object.latency)
            : undefined;
        message.capacity = (object.capacity !== undefined && object.capacity !== null)
            ? exports.Uint64Constraint.fromPartial(object.capacity)
            : undefined;
        message.loss = (object.loss !== undefined && object.loss !== null)
            ? exports.FloatConstraint.fromPartial(object.loss)
            : undefined;
        message.endpoints = ((_b = object.endpoints) === null || _b === void 0 ? void 0 : _b.map(function (e) { return exports.Endpoint.fromPartial(e); })) || [];
        message.kind = (object.kind !== undefined && object.kind !== null)
            ? exports.LinkKindConstraint.fromPartial(object.kind)
            : undefined;
        message.layer = (object.layer !== undefined && object.layer !== null)
            ? exports.Uint64Constraint.fromPartial(object.layer)
            : undefined;
        message.properties = (object.properties !== undefined && object.properties !== null)
            ? exports.Properties.fromPartial(object.properties)
            : undefined;
        return message;
    }
};
function createBaseEndpoint() {
    return { index: 0, socket: undefined, connector: undefined };
}
exports.Endpoint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.index !== 0) {
            writer.uint32(8).int32(message.index);
        }
        if (message.socket !== undefined) {
            exports.Ref.encode(message.socket, writer.uint32(18).fork()).ldelim();
        }
        if (message.connector !== undefined) {
            exports.ConnectorSpec.encode(message.connector, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEndpoint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.socket = exports.Ref.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.connector = exports.ConnectorSpec.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            index: isSet(object.index) ? Number(object.index) : 0,
            socket: isSet(object.socket) ? exports.Ref.fromJSON(object.socket) : undefined,
            connector: isSet(object.connector) ? exports.ConnectorSpec.fromJSON(object.connector) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.index !== undefined && (obj.index = Math.round(message.index));
        message.socket !== undefined && (obj.socket = message.socket ? exports.Ref.toJSON(message.socket) : undefined);
        message.connector !== undefined &&
            (obj.connector = message.connector ? exports.ConnectorSpec.toJSON(message.connector) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.Endpoint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseEndpoint();
        message.index = (_a = object.index) !== null && _a !== void 0 ? _a : 0;
        message.socket = (object.socket !== undefined && object.socket !== null)
            ? exports.Ref.fromPartial(object.socket)
            : undefined;
        message.connector = (object.connector !== undefined && object.connector !== null)
            ? exports.ConnectorSpec.fromPartial(object.connector)
            : undefined;
        return message;
    }
};
function createBasePhyo() {
    return { id: "", eqtns: [] };
}
exports.Phyo = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        for (var _i = 0, _a = message.eqtns; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBasePhyo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.eqtns.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            eqtns: Array.isArray(object === null || object === void 0 ? void 0 : object.eqtns) ? object.eqtns.map(function (e) { return String(e); }) : []
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.id !== undefined && (obj.id = message.id);
        if (message.eqtns) {
            obj.eqtns = message.eqtns.map(function (e) { return e; });
        }
        else {
            obj.eqtns = [];
        }
        return obj;
    },
    create: function (base) {
        return exports.Phyo.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBasePhyo();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.eqtns = ((_b = object.eqtns) === null || _b === void 0 ? void 0 : _b.map(function (e) { return e; })) || [];
        return message;
    }
};
function createBaseVariable() {
    return {};
}
exports.Variable = {
    encode: function (_, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseVariable();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (_) {
        return {};
    },
    toJSON: function (_) {
        var obj = {};
        return obj;
    },
    create: function (base) {
        return exports.Variable.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (_) {
        var message = createBaseVariable();
        return message;
    }
};
function createBaseBond() {
    return {};
}
exports.Bond = {
    encode: function (_, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBond();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (_) {
        return {};
    },
    toJSON: function (_) {
        var obj = {};
        return obj;
    },
    create: function (base) {
        return exports.Bond.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (_) {
        var message = createBaseBond();
        return message;
    }
};
function createBaseCoupling() {
    return {};
}
exports.Coupling = {
    encode: function (_, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseCoupling();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (_) {
        return {};
    },
    toJSON: function (_) {
        var obj = {};
        return obj;
    },
    create: function (base) {
        return exports.Coupling.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (_) {
        var message = createBaseCoupling();
        return message;
    }
};
function createBaseSensor() {
    return { id: "", "var": "", rate: 0, target: "", tag: 0 };
}
exports.Sensor = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message["var"] !== "") {
            writer.uint32(18).string(message["var"]);
        }
        if (message.rate !== 0) {
            writer.uint32(29).float(message.rate);
        }
        if (message.target !== "") {
            writer.uint32(34).string(message.target);
        }
        if (message.tag !== 0) {
            writer.uint32(40).int32(message.tag);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseSensor();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message["var"] = reader.string();
                    break;
                case 3:
                    message.rate = reader.float();
                    break;
                case 4:
                    message.target = reader.string();
                    break;
                case 5:
                    message.tag = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            "var": isSet(object["var"]) ? String(object["var"]) : "",
            rate: isSet(object.rate) ? Number(object.rate) : 0,
            target: isSet(object.target) ? String(object.target) : "",
            tag: isSet(object.tag) ? Number(object.tag) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.id !== undefined && (obj.id = message.id);
        message["var"] !== undefined && (obj["var"] = message["var"]);
        message.rate !== undefined && (obj.rate = message.rate);
        message.target !== undefined && (obj.target = message.target);
        message.tag !== undefined && (obj.tag = Math.round(message.tag));
        return obj;
    },
    create: function (base) {
        return exports.Sensor.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e;
        var message = createBaseSensor();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message["var"] = (_b = object["var"]) !== null && _b !== void 0 ? _b : "";
        message.rate = (_c = object.rate) !== null && _c !== void 0 ? _c : 0;
        message.target = (_d = object.target) !== null && _d !== void 0 ? _d : "";
        message.tag = (_e = object.tag) !== null && _e !== void 0 ? _e : 0;
        return message;
    }
};
function createBaseActuator() {
    return { id: "", "var": "", dynamicLimits: undefined, staticLimits: undefined, tag: 0 };
}
exports.Actuator = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message["var"] !== "") {
            writer.uint32(18).string(message["var"]);
        }
        if (message.dynamicLimits !== undefined) {
            exports.Limits.encode(message.dynamicLimits, writer.uint32(26).fork()).ldelim();
        }
        if (message.staticLimits !== undefined) {
            exports.Limits.encode(message.staticLimits, writer.uint32(34).fork()).ldelim();
        }
        if (message.tag !== 0) {
            writer.uint32(40).int32(message.tag);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseActuator();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message["var"] = reader.string();
                    break;
                case 3:
                    message.dynamicLimits = exports.Limits.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.staticLimits = exports.Limits.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.tag = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            "var": isSet(object["var"]) ? String(object["var"]) : "",
            dynamicLimits: isSet(object.dynamicLimits) ? exports.Limits.fromJSON(object.dynamicLimits) : undefined,
            staticLimits: isSet(object.staticLimits) ? exports.Limits.fromJSON(object.staticLimits) : undefined,
            tag: isSet(object.tag) ? Number(object.tag) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.id !== undefined && (obj.id = message.id);
        message["var"] !== undefined && (obj["var"] = message["var"]);
        message.dynamicLimits !== undefined &&
            (obj.dynamicLimits = message.dynamicLimits ? exports.Limits.toJSON(message.dynamicLimits) : undefined);
        message.staticLimits !== undefined &&
            (obj.staticLimits = message.staticLimits ? exports.Limits.toJSON(message.staticLimits) : undefined);
        message.tag !== undefined && (obj.tag = Math.round(message.tag));
        return obj;
    },
    create: function (base) {
        return exports.Actuator.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBaseActuator();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message["var"] = (_b = object["var"]) !== null && _b !== void 0 ? _b : "";
        message.dynamicLimits = (object.dynamicLimits !== undefined && object.dynamicLimits !== null)
            ? exports.Limits.fromPartial(object.dynamicLimits)
            : undefined;
        message.staticLimits = (object.staticLimits !== undefined && object.staticLimits !== null)
            ? exports.Limits.fromPartial(object.staticLimits)
            : undefined;
        message.tag = (_c = object.tag) !== null && _c !== void 0 ? _c : 0;
        return message;
    }
};
function createBaseLimits() {
    return { lower: 0, upper: 0 };
}
exports.Limits = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.lower !== 0) {
            writer.uint32(13).float(message.lower);
        }
        if (message.upper !== 0) {
            writer.uint32(21).float(message.upper);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseLimits();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.lower = reader.float();
                    break;
                case 2:
                    message.upper = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            lower: isSet(object.lower) ? Number(object.lower) : 0,
            upper: isSet(object.upper) ? Number(object.upper) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.lower !== undefined && (obj.lower = message.lower);
        message.upper !== undefined && (obj.upper = message.upper);
        return obj;
    },
    create: function (base) {
        return exports.Limits.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseLimits();
        message.lower = (_a = object.lower) !== null && _a !== void 0 ? _a : 0;
        message.upper = (_b = object.upper) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseProductInfo() {
    return { Manufacturer: "", Model: "", SKU: "", Integrated: false, cost: 0 };
}
exports.ProductInfo = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.Manufacturer !== "") {
            writer.uint32(10).string(message.Manufacturer);
        }
        if (message.Model !== "") {
            writer.uint32(18).string(message.Model);
        }
        if (message.SKU !== "") {
            writer.uint32(26).string(message.SKU);
        }
        if (message.Integrated === true) {
            writer.uint32(32).bool(message.Integrated);
        }
        if (message.cost !== 0) {
            writer.uint32(45).float(message.cost);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseProductInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.Manufacturer = reader.string();
                    break;
                case 2:
                    message.Model = reader.string();
                    break;
                case 3:
                    message.SKU = reader.string();
                    break;
                case 4:
                    message.Integrated = reader.bool();
                    break;
                case 5:
                    message.cost = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            Manufacturer: isSet(object.Manufacturer) ? String(object.Manufacturer) : "",
            Model: isSet(object.Model) ? String(object.Model) : "",
            SKU: isSet(object.SKU) ? String(object.SKU) : "",
            Integrated: isSet(object.Integrated) ? Boolean(object.Integrated) : false,
            cost: isSet(object.cost) ? Number(object.cost) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.Manufacturer !== undefined && (obj.Manufacturer = message.Manufacturer);
        message.Model !== undefined && (obj.Model = message.Model);
        message.SKU !== undefined && (obj.SKU = message.SKU);
        message.Integrated !== undefined && (obj.Integrated = message.Integrated);
        message.cost !== undefined && (obj.cost = message.cost);
        return obj;
    },
    create: function (base) {
        return exports.ProductInfo.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e;
        var message = createBaseProductInfo();
        message.Manufacturer = (_a = object.Manufacturer) !== null && _a !== void 0 ? _a : "";
        message.Model = (_b = object.Model) !== null && _b !== void 0 ? _b : "";
        message.SKU = (_c = object.SKU) !== null && _c !== void 0 ? _c : "";
        message.Integrated = (_d = object.Integrated) !== null && _d !== void 0 ? _d : false;
        message.cost = (_e = object.cost) !== null && _e !== void 0 ? _e : 0;
        return message;
    }
};
function createBaseResource() {
    return {
        id: "",
        facility: "",
        procs: [],
        memory: [],
        NICs: [],
        disks: [],
        alloc: [],
        roles: [],
        firmware: undefined,
        OS: undefined,
        productInfo: undefined,
        TPA: 0,
        ipmi: undefined,
        relayboard: undefined,
        pdu: undefined,
        raven: undefined,
        leafConfig: undefined,
        infranetAddr: {}
    };
}
exports.Resource = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.facility !== "") {
            writer.uint32(18).string(message.facility);
        }
        for (var _i = 0, _a = message.procs; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.Proc.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (var _b = 0, _c = message.memory; _b < _c.length; _b++) {
            var v = _c[_b];
            exports.Dimm.encode(v, writer.uint32(34).fork()).ldelim();
        }
        for (var _d = 0, _e = message.NICs; _d < _e.length; _d++) {
            var v = _e[_d];
            exports.NIC.encode(v, writer.uint32(42).fork()).ldelim();
        }
        for (var _f = 0, _g = message.disks; _f < _g.length; _f++) {
            var v = _g[_f];
            exports.Disk.encode(v, writer.uint32(50).fork()).ldelim();
        }
        writer.uint32(58).fork();
        for (var _h = 0, _j = message.alloc; _h < _j.length; _h++) {
            var v = _j[_h];
            writer.int32(v);
        }
        writer.ldelim();
        writer.uint32(66).fork();
        for (var _k = 0, _l = message.roles; _k < _l.length; _k++) {
            var v = _l[_k];
            writer.int32(v);
        }
        writer.ldelim();
        if (message.firmware !== undefined) {
            exports.Firmware.encode(message.firmware, writer.uint32(74).fork()).ldelim();
        }
        if (message.OS !== undefined) {
            exports.OSConfig.encode(message.OS, writer.uint32(82).fork()).ldelim();
        }
        if (message.productInfo !== undefined) {
            exports.ProductInfo.encode(message.productInfo, writer.uint32(90).fork()).ldelim();
        }
        if (message.TPA !== 0) {
            writer.uint32(96).uint64(message.TPA);
        }
        if (message.ipmi !== undefined) {
            exports.BMC.encode(message.ipmi, writer.uint32(106).fork()).ldelim();
        }
        if (message.relayboard !== undefined) {
            exports.RelayBoard.encode(message.relayboard, writer.uint32(114).fork()).ldelim();
        }
        if (message.pdu !== undefined) {
            exports.PowerDistributionUnit.encode(message.pdu, writer.uint32(122).fork()).ldelim();
        }
        if (message.raven !== undefined) {
            exports.Raven.encode(message.raven, writer.uint32(130).fork()).ldelim();
        }
        if (message.leafConfig !== undefined) {
            exports.LeafConfig.encode(message.leafConfig, writer.uint32(138).fork()).ldelim();
        }
        Object.entries(message.infranetAddr).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.Resource_InfranetAddrEntry.encode({ key: key, value: value }, writer.uint32(146).fork()).ldelim();
        });
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseResource();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.facility = reader.string();
                    break;
                case 3:
                    message.procs.push(exports.Proc.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.memory.push(exports.Dimm.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.NICs.push(exports.NIC.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.disks.push(exports.Disk.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.alloc.push(reader.int32());
                        }
                    }
                    else {
                        message.alloc.push(reader.int32());
                    }
                    break;
                case 8:
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.roles.push(reader.int32());
                        }
                    }
                    else {
                        message.roles.push(reader.int32());
                    }
                    break;
                case 9:
                    message.firmware = exports.Firmware.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.OS = exports.OSConfig.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.productInfo = exports.ProductInfo.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.TPA = longToNumber(reader.uint64());
                    break;
                case 13:
                    message.ipmi = exports.BMC.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.relayboard = exports.RelayBoard.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.pdu = exports.PowerDistributionUnit.decode(reader, reader.uint32());
                    break;
                case 16:
                    message.raven = exports.Raven.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.leafConfig = exports.LeafConfig.decode(reader, reader.uint32());
                    break;
                case 18:
                    var entry18 = exports.Resource_InfranetAddrEntry.decode(reader, reader.uint32());
                    if (entry18.value !== undefined) {
                        message.infranetAddr[entry18.key] = entry18.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            facility: isSet(object.facility) ? String(object.facility) : "",
            procs: Array.isArray(object === null || object === void 0 ? void 0 : object.procs) ? object.procs.map(function (e) { return exports.Proc.fromJSON(e); }) : [],
            memory: Array.isArray(object === null || object === void 0 ? void 0 : object.memory) ? object.memory.map(function (e) { return exports.Dimm.fromJSON(e); }) : [],
            NICs: Array.isArray(object === null || object === void 0 ? void 0 : object.NICs) ? object.NICs.map(function (e) { return exports.NIC.fromJSON(e); }) : [],
            disks: Array.isArray(object === null || object === void 0 ? void 0 : object.disks) ? object.disks.map(function (e) { return exports.Disk.fromJSON(e); }) : [],
            alloc: Array.isArray(object === null || object === void 0 ? void 0 : object.alloc) ? object.alloc.map(function (e) { return allocModeFromJSON(e); }) : [],
            roles: Array.isArray(object === null || object === void 0 ? void 0 : object.roles) ? object.roles.map(function (e) { return roleFromJSON(e); }) : [],
            firmware: isSet(object.firmware) ? exports.Firmware.fromJSON(object.firmware) : undefined,
            OS: isSet(object.OS) ? exports.OSConfig.fromJSON(object.OS) : undefined,
            productInfo: isSet(object.productInfo) ? exports.ProductInfo.fromJSON(object.productInfo) : undefined,
            TPA: isSet(object.TPA) ? Number(object.TPA) : 0,
            ipmi: isSet(object.ipmi) ? exports.BMC.fromJSON(object.ipmi) : undefined,
            relayboard: isSet(object.relayboard) ? exports.RelayBoard.fromJSON(object.relayboard) : undefined,
            pdu: isSet(object.pdu) ? exports.PowerDistributionUnit.fromJSON(object.pdu) : undefined,
            raven: isSet(object.raven) ? exports.Raven.fromJSON(object.raven) : undefined,
            leafConfig: isSet(object.leafConfig) ? exports.LeafConfig.fromJSON(object.leafConfig) : undefined,
            infranetAddr: isObject(object.infranetAddr)
                ? Object.entries(object.infranetAddr).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[key] = exports.AddressList.fromJSON(value);
                    return acc;
                }, {})
                : {}
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.facility !== undefined && (obj.facility = message.facility);
        if (message.procs) {
            obj.procs = message.procs.map(function (e) { return e ? exports.Proc.toJSON(e) : undefined; });
        }
        else {
            obj.procs = [];
        }
        if (message.memory) {
            obj.memory = message.memory.map(function (e) { return e ? exports.Dimm.toJSON(e) : undefined; });
        }
        else {
            obj.memory = [];
        }
        if (message.NICs) {
            obj.NICs = message.NICs.map(function (e) { return e ? exports.NIC.toJSON(e) : undefined; });
        }
        else {
            obj.NICs = [];
        }
        if (message.disks) {
            obj.disks = message.disks.map(function (e) { return e ? exports.Disk.toJSON(e) : undefined; });
        }
        else {
            obj.disks = [];
        }
        if (message.alloc) {
            obj.alloc = message.alloc.map(function (e) { return allocModeToJSON(e); });
        }
        else {
            obj.alloc = [];
        }
        if (message.roles) {
            obj.roles = message.roles.map(function (e) { return roleToJSON(e); });
        }
        else {
            obj.roles = [];
        }
        message.firmware !== undefined && (obj.firmware = message.firmware ? exports.Firmware.toJSON(message.firmware) : undefined);
        message.OS !== undefined && (obj.OS = message.OS ? exports.OSConfig.toJSON(message.OS) : undefined);
        message.productInfo !== undefined &&
            (obj.productInfo = message.productInfo ? exports.ProductInfo.toJSON(message.productInfo) : undefined);
        message.TPA !== undefined && (obj.TPA = Math.round(message.TPA));
        message.ipmi !== undefined && (obj.ipmi = message.ipmi ? exports.BMC.toJSON(message.ipmi) : undefined);
        message.relayboard !== undefined &&
            (obj.relayboard = message.relayboard ? exports.RelayBoard.toJSON(message.relayboard) : undefined);
        message.pdu !== undefined && (obj.pdu = message.pdu ? exports.PowerDistributionUnit.toJSON(message.pdu) : undefined);
        message.raven !== undefined && (obj.raven = message.raven ? exports.Raven.toJSON(message.raven) : undefined);
        message.leafConfig !== undefined &&
            (obj.leafConfig = message.leafConfig ? exports.LeafConfig.toJSON(message.leafConfig) : undefined);
        obj.infranetAddr = {};
        if (message.infranetAddr) {
            Object.entries(message.infranetAddr).forEach(function (_a) {
                var k = _a[0], v = _a[1];
                obj.infranetAddr[k] = exports.AddressList.toJSON(v);
            });
        }
        return obj;
    },
    create: function (base) {
        return exports.Resource.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var message = createBaseResource();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.facility = (_b = object.facility) !== null && _b !== void 0 ? _b : "";
        message.procs = ((_c = object.procs) === null || _c === void 0 ? void 0 : _c.map(function (e) { return exports.Proc.fromPartial(e); })) || [];
        message.memory = ((_d = object.memory) === null || _d === void 0 ? void 0 : _d.map(function (e) { return exports.Dimm.fromPartial(e); })) || [];
        message.NICs = ((_e = object.NICs) === null || _e === void 0 ? void 0 : _e.map(function (e) { return exports.NIC.fromPartial(e); })) || [];
        message.disks = ((_f = object.disks) === null || _f === void 0 ? void 0 : _f.map(function (e) { return exports.Disk.fromPartial(e); })) || [];
        message.alloc = ((_g = object.alloc) === null || _g === void 0 ? void 0 : _g.map(function (e) { return e; })) || [];
        message.roles = ((_h = object.roles) === null || _h === void 0 ? void 0 : _h.map(function (e) { return e; })) || [];
        message.firmware = (object.firmware !== undefined && object.firmware !== null)
            ? exports.Firmware.fromPartial(object.firmware)
            : undefined;
        message.OS = (object.OS !== undefined && object.OS !== null) ? exports.OSConfig.fromPartial(object.OS) : undefined;
        message.productInfo = (object.productInfo !== undefined && object.productInfo !== null)
            ? exports.ProductInfo.fromPartial(object.productInfo)
            : undefined;
        message.TPA = (_j = object.TPA) !== null && _j !== void 0 ? _j : 0;
        message.ipmi = (object.ipmi !== undefined && object.ipmi !== null) ? exports.BMC.fromPartial(object.ipmi) : undefined;
        message.relayboard = (object.relayboard !== undefined && object.relayboard !== null)
            ? exports.RelayBoard.fromPartial(object.relayboard)
            : undefined;
        message.pdu = (object.pdu !== undefined && object.pdu !== null)
            ? exports.PowerDistributionUnit.fromPartial(object.pdu)
            : undefined;
        message.raven = (object.raven !== undefined && object.raven !== null) ? exports.Raven.fromPartial(object.raven) : undefined;
        message.leafConfig = (object.leafConfig !== undefined && object.leafConfig !== null)
            ? exports.LeafConfig.fromPartial(object.leafConfig)
            : undefined;
        message.infranetAddr = Object.entries((_k = object.infranetAddr) !== null && _k !== void 0 ? _k : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[key] = exports.AddressList.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    }
};
function createBaseResource_InfranetAddrEntry() {
    return { key: "", value: undefined };
}
exports.Resource_InfranetAddrEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.AddressList.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseResource_InfranetAddrEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.AddressList.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? exports.AddressList.fromJSON(object.value) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? exports.AddressList.toJSON(message.value) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.Resource_InfranetAddrEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseResource_InfranetAddrEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.AddressList.fromPartial(object.value)
            : undefined;
        return message;
    }
};
function createBaseBMC() {
    return { host: "", kind: 0 };
}
exports.BMC = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.host !== "") {
            writer.uint32(10).string(message.host);
        }
        if (message.kind !== 0) {
            writer.uint32(16).int32(message.kind);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBMC();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                case 2:
                    message.kind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            host: isSet(object.host) ? String(object.host) : "",
            kind: isSet(object.kind) ? bMC_KindFromJSON(object.kind) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.host !== undefined && (obj.host = message.host);
        message.kind !== undefined && (obj.kind = bMC_KindToJSON(message.kind));
        return obj;
    },
    create: function (base) {
        return exports.BMC.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseBMC();
        message.host = (_a = object.host) !== null && _a !== void 0 ? _a : "";
        message.kind = (_b = object.kind) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseRelayBoard() {
    return { host: "", index: 0, kind: 0 };
}
exports.RelayBoard = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.host !== "") {
            writer.uint32(10).string(message.host);
        }
        if (message.index !== 0) {
            writer.uint32(16).uint32(message.index);
        }
        if (message.kind !== 0) {
            writer.uint32(24).int32(message.kind);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseRelayBoard();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                case 2:
                    message.index = reader.uint32();
                    break;
                case 3:
                    message.kind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            host: isSet(object.host) ? String(object.host) : "",
            index: isSet(object.index) ? Number(object.index) : 0,
            kind: isSet(object.kind) ? relayBoard_KindFromJSON(object.kind) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.host !== undefined && (obj.host = message.host);
        message.index !== undefined && (obj.index = Math.round(message.index));
        message.kind !== undefined && (obj.kind = relayBoard_KindToJSON(message.kind));
        return obj;
    },
    create: function (base) {
        return exports.RelayBoard.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBaseRelayBoard();
        message.host = (_a = object.host) !== null && _a !== void 0 ? _a : "";
        message.index = (_b = object.index) !== null && _b !== void 0 ? _b : 0;
        message.kind = (_c = object.kind) !== null && _c !== void 0 ? _c : 0;
        return message;
    }
};
function createBasePowerDistributionUnit() {
    return { host: "", outlets: [], kind: 0 };
}
exports.PowerDistributionUnit = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.host !== "") {
            writer.uint32(10).string(message.host);
        }
        writer.uint32(18).fork();
        for (var _i = 0, _a = message.outlets; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.uint32(v);
        }
        writer.ldelim();
        if (message.kind !== 0) {
            writer.uint32(24).int32(message.kind);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBasePowerDistributionUnit();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                case 2:
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.outlets.push(reader.uint32());
                        }
                    }
                    else {
                        message.outlets.push(reader.uint32());
                    }
                    break;
                case 3:
                    message.kind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            host: isSet(object.host) ? String(object.host) : "",
            outlets: Array.isArray(object === null || object === void 0 ? void 0 : object.outlets) ? object.outlets.map(function (e) { return Number(e); }) : [],
            kind: isSet(object.kind) ? powerDistributionUnit_KindFromJSON(object.kind) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.host !== undefined && (obj.host = message.host);
        if (message.outlets) {
            obj.outlets = message.outlets.map(function (e) { return Math.round(e); });
        }
        else {
            obj.outlets = [];
        }
        message.kind !== undefined && (obj.kind = powerDistributionUnit_KindToJSON(message.kind));
        return obj;
    },
    create: function (base) {
        return exports.PowerDistributionUnit.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBasePowerDistributionUnit();
        message.host = (_a = object.host) !== null && _a !== void 0 ? _a : "";
        message.outlets = ((_b = object.outlets) === null || _b === void 0 ? void 0 : _b.map(function (e) { return e; })) || [];
        message.kind = (_c = object.kind) !== null && _c !== void 0 ? _c : 0;
        return message;
    }
};
function createBaseRaven() {
    return { host: "" };
}
exports.Raven = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.host !== "") {
            writer.uint32(10).string(message.host);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseRaven();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.host = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { host: isSet(object.host) ? String(object.host) : "" };
    },
    toJSON: function (message) {
        var obj = {};
        message.host !== undefined && (obj.host = message.host);
        return obj;
    },
    create: function (base) {
        return exports.Raven.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseRaven();
        message.host = (_a = object.host) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
function createBaseFirmware() {
    return { kind: 0 };
}
exports.Firmware = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.kind !== 0) {
            writer.uint32(8).int32(message.kind);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseFirmware();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { kind: isSet(object.kind) ? firmware_KindFromJSON(object.kind) : 0 };
    },
    toJSON: function (message) {
        var obj = {};
        message.kind !== undefined && (obj.kind = firmware_KindToJSON(message.kind));
        return obj;
    },
    create: function (base) {
        return exports.Firmware.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseFirmware();
        message.kind = (_a = object.kind) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBaseResourceAllocation() {
    return {
        resource: "",
        facility: "",
        mzid: "",
        node: "",
        procs: undefined,
        memory: undefined,
        NICs: undefined,
        disks: undefined,
        model: undefined,
        revision: 0,
        virtual: false
    };
}
exports.ResourceAllocation = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.resource !== "") {
            writer.uint32(10).string(message.resource);
        }
        if (message.facility !== "") {
            writer.uint32(18).string(message.facility);
        }
        if (message.mzid !== "") {
            writer.uint32(26).string(message.mzid);
        }
        if (message.node !== "") {
            writer.uint32(34).string(message.node);
        }
        if (message.procs !== undefined) {
            exports.ProcAllocation.encode(message.procs, writer.uint32(42).fork()).ldelim();
        }
        if (message.memory !== undefined) {
            exports.MemoryAllocation.encode(message.memory, writer.uint32(50).fork()).ldelim();
        }
        if (message.NICs !== undefined) {
            exports.NICsAllocation.encode(message.NICs, writer.uint32(58).fork()).ldelim();
        }
        if (message.disks !== undefined) {
            exports.DisksAllocation.encode(message.disks, writer.uint32(66).fork()).ldelim();
        }
        if (message.model !== undefined) {
            exports.Node.encode(message.model, writer.uint32(74).fork()).ldelim();
        }
        if (message.revision !== 0) {
            writer.uint32(80).int64(message.revision);
        }
        if (message.virtual === true) {
            writer.uint32(88).bool(message.virtual);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseResourceAllocation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.resource = reader.string();
                    break;
                case 2:
                    message.facility = reader.string();
                    break;
                case 3:
                    message.mzid = reader.string();
                    break;
                case 4:
                    message.node = reader.string();
                    break;
                case 5:
                    message.procs = exports.ProcAllocation.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.memory = exports.MemoryAllocation.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.NICs = exports.NICsAllocation.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.disks = exports.DisksAllocation.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.model = exports.Node.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.revision = longToNumber(reader.int64());
                    break;
                case 11:
                    message.virtual = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            resource: isSet(object.resource) ? String(object.resource) : "",
            facility: isSet(object.facility) ? String(object.facility) : "",
            mzid: isSet(object.mzid) ? String(object.mzid) : "",
            node: isSet(object.node) ? String(object.node) : "",
            procs: isSet(object.procs) ? exports.ProcAllocation.fromJSON(object.procs) : undefined,
            memory: isSet(object.memory) ? exports.MemoryAllocation.fromJSON(object.memory) : undefined,
            NICs: isSet(object.NICs) ? exports.NICsAllocation.fromJSON(object.NICs) : undefined,
            disks: isSet(object.disks) ? exports.DisksAllocation.fromJSON(object.disks) : undefined,
            model: isSet(object.model) ? exports.Node.fromJSON(object.model) : undefined,
            revision: isSet(object.revision) ? Number(object.revision) : 0,
            virtual: isSet(object.virtual) ? Boolean(object.virtual) : false
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.resource !== undefined && (obj.resource = message.resource);
        message.facility !== undefined && (obj.facility = message.facility);
        message.mzid !== undefined && (obj.mzid = message.mzid);
        message.node !== undefined && (obj.node = message.node);
        message.procs !== undefined && (obj.procs = message.procs ? exports.ProcAllocation.toJSON(message.procs) : undefined);
        message.memory !== undefined && (obj.memory = message.memory ? exports.MemoryAllocation.toJSON(message.memory) : undefined);
        message.NICs !== undefined && (obj.NICs = message.NICs ? exports.NICsAllocation.toJSON(message.NICs) : undefined);
        message.disks !== undefined && (obj.disks = message.disks ? exports.DisksAllocation.toJSON(message.disks) : undefined);
        message.model !== undefined && (obj.model = message.model ? exports.Node.toJSON(message.model) : undefined);
        message.revision !== undefined && (obj.revision = Math.round(message.revision));
        message.virtual !== undefined && (obj.virtual = message.virtual);
        return obj;
    },
    create: function (base) {
        return exports.ResourceAllocation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f;
        var message = createBaseResourceAllocation();
        message.resource = (_a = object.resource) !== null && _a !== void 0 ? _a : "";
        message.facility = (_b = object.facility) !== null && _b !== void 0 ? _b : "";
        message.mzid = (_c = object.mzid) !== null && _c !== void 0 ? _c : "";
        message.node = (_d = object.node) !== null && _d !== void 0 ? _d : "";
        message.procs = (object.procs !== undefined && object.procs !== null)
            ? exports.ProcAllocation.fromPartial(object.procs)
            : undefined;
        message.memory = (object.memory !== undefined && object.memory !== null)
            ? exports.MemoryAllocation.fromPartial(object.memory)
            : undefined;
        message.NICs = (object.NICs !== undefined && object.NICs !== null)
            ? exports.NICsAllocation.fromPartial(object.NICs)
            : undefined;
        message.disks = (object.disks !== undefined && object.disks !== null)
            ? exports.DisksAllocation.fromPartial(object.disks)
            : undefined;
        message.model = (object.model !== undefined && object.model !== null) ? exports.Node.fromPartial(object.model) : undefined;
        message.revision = (_e = object.revision) !== null && _e !== void 0 ? _e : 0;
        message.virtual = (_f = object.virtual) !== null && _f !== void 0 ? _f : false;
        return message;
    }
};
function createBaseCableAllocation() {
    return { cable: "", facility: "", mzid: "", link: "", capacity: 0, revision: 0 };
}
exports.CableAllocation = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.cable !== "") {
            writer.uint32(10).string(message.cable);
        }
        if (message.facility !== "") {
            writer.uint32(18).string(message.facility);
        }
        if (message.mzid !== "") {
            writer.uint32(26).string(message.mzid);
        }
        if (message.link !== "") {
            writer.uint32(34).string(message.link);
        }
        if (message.capacity !== 0) {
            writer.uint32(40).uint64(message.capacity);
        }
        if (message.revision !== 0) {
            writer.uint32(48).int64(message.revision);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseCableAllocation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cable = reader.string();
                    break;
                case 2:
                    message.facility = reader.string();
                    break;
                case 3:
                    message.mzid = reader.string();
                    break;
                case 4:
                    message.link = reader.string();
                    break;
                case 5:
                    message.capacity = longToNumber(reader.uint64());
                    break;
                case 6:
                    message.revision = longToNumber(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            cable: isSet(object.cable) ? String(object.cable) : "",
            facility: isSet(object.facility) ? String(object.facility) : "",
            mzid: isSet(object.mzid) ? String(object.mzid) : "",
            link: isSet(object.link) ? String(object.link) : "",
            capacity: isSet(object.capacity) ? Number(object.capacity) : 0,
            revision: isSet(object.revision) ? Number(object.revision) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.cable !== undefined && (obj.cable = message.cable);
        message.facility !== undefined && (obj.facility = message.facility);
        message.mzid !== undefined && (obj.mzid = message.mzid);
        message.link !== undefined && (obj.link = message.link);
        message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
        message.revision !== undefined && (obj.revision = Math.round(message.revision));
        return obj;
    },
    create: function (base) {
        return exports.CableAllocation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f;
        var message = createBaseCableAllocation();
        message.cable = (_a = object.cable) !== null && _a !== void 0 ? _a : "";
        message.facility = (_b = object.facility) !== null && _b !== void 0 ? _b : "";
        message.mzid = (_c = object.mzid) !== null && _c !== void 0 ? _c : "";
        message.link = (_d = object.link) !== null && _d !== void 0 ? _d : "";
        message.capacity = (_e = object.capacity) !== null && _e !== void 0 ? _e : 0;
        message.revision = (_f = object.revision) !== null && _f !== void 0 ? _f : 0;
        return message;
    }
};
function createBaseAddressList() {
    return { list: [] };
}
exports.AddressList = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        for (var _i = 0, _a = message.list; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseAddressList();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.list.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { list: Array.isArray(object === null || object === void 0 ? void 0 : object.list) ? object.list.map(function (e) { return String(e); }) : [] };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.list) {
            obj.list = message.list.map(function (e) { return e; });
        }
        else {
            obj.list = [];
        }
        return obj;
    },
    create: function (base) {
        return exports.AddressList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseAddressList();
        message.list = ((_a = object.list) === null || _a === void 0 ? void 0 : _a.map(function (e) { return e; })) || [];
        return message;
    }
};
function createBaseLeafConfig() {
    return { serviceAddressBlocks: undefined, tenantAddressBlocks: undefined, infrapodAddressBlocks: {} };
}
exports.LeafConfig = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.serviceAddressBlocks !== undefined) {
            exports.AddressList.encode(message.serviceAddressBlocks, writer.uint32(10).fork()).ldelim();
        }
        if (message.tenantAddressBlocks !== undefined) {
            exports.AddressList.encode(message.tenantAddressBlocks, writer.uint32(18).fork()).ldelim();
        }
        Object.entries(message.infrapodAddressBlocks).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.LeafConfig_InfrapodAddressBlocksEntry.encode({ key: key, value: value }, writer.uint32(26).fork()).ldelim();
        });
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseLeafConfig();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.serviceAddressBlocks = exports.AddressList.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.tenantAddressBlocks = exports.AddressList.decode(reader, reader.uint32());
                    break;
                case 3:
                    var entry3 = exports.LeafConfig_InfrapodAddressBlocksEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.infrapodAddressBlocks[entry3.key] = entry3.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            serviceAddressBlocks: isSet(object.serviceAddressBlocks)
                ? exports.AddressList.fromJSON(object.serviceAddressBlocks)
                : undefined,
            tenantAddressBlocks: isSet(object.tenantAddressBlocks)
                ? exports.AddressList.fromJSON(object.tenantAddressBlocks)
                : undefined,
            infrapodAddressBlocks: isObject(object.infrapodAddressBlocks)
                ? Object.entries(object.infrapodAddressBlocks).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[key] = exports.AddressList.fromJSON(value);
                    return acc;
                }, {})
                : {}
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.serviceAddressBlocks !== undefined && (obj.serviceAddressBlocks = message.serviceAddressBlocks
            ? exports.AddressList.toJSON(message.serviceAddressBlocks)
            : undefined);
        message.tenantAddressBlocks !== undefined && (obj.tenantAddressBlocks = message.tenantAddressBlocks
            ? exports.AddressList.toJSON(message.tenantAddressBlocks)
            : undefined);
        obj.infrapodAddressBlocks = {};
        if (message.infrapodAddressBlocks) {
            Object.entries(message.infrapodAddressBlocks).forEach(function (_a) {
                var k = _a[0], v = _a[1];
                obj.infrapodAddressBlocks[k] = exports.AddressList.toJSON(v);
            });
        }
        return obj;
    },
    create: function (base) {
        return exports.LeafConfig.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseLeafConfig();
        message.serviceAddressBlocks = (object.serviceAddressBlocks !== undefined && object.serviceAddressBlocks !== null)
            ? exports.AddressList.fromPartial(object.serviceAddressBlocks)
            : undefined;
        message.tenantAddressBlocks = (object.tenantAddressBlocks !== undefined && object.tenantAddressBlocks !== null)
            ? exports.AddressList.fromPartial(object.tenantAddressBlocks)
            : undefined;
        message.infrapodAddressBlocks = Object.entries((_a = object.infrapodAddressBlocks) !== null && _a !== void 0 ? _a : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[key] = exports.AddressList.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    }
};
function createBaseLeafConfig_InfrapodAddressBlocksEntry() {
    return { key: "", value: undefined };
}
exports.LeafConfig_InfrapodAddressBlocksEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.AddressList.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseLeafConfig_InfrapodAddressBlocksEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.AddressList.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? exports.AddressList.fromJSON(object.value) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? exports.AddressList.toJSON(message.value) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.LeafConfig_InfrapodAddressBlocksEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseLeafConfig_InfrapodAddressBlocksEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.AddressList.fromPartial(object.value)
            : undefined;
        return message;
    }
};
function createBaseOSConfig() {
    return { BGP: [], bridge: [], VLAN: [], serviceEndpoints: {}, append: "", rootdev: "", defaultImage: "" };
}
exports.OSConfig = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        for (var _i = 0, _a = message.BGP; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.BGPRouterConfig.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (var _b = 0, _c = message.bridge; _b < _c.length; _b++) {
            var v = _c[_b];
            exports.BridgeConfig.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (var _d = 0, _e = message.VLAN; _d < _e.length; _d++) {
            var v = _e[_d];
            exports.VLANConfig.encode(v, writer.uint32(26).fork()).ldelim();
        }
        Object.entries(message.serviceEndpoints).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.OSConfig_ServiceEndpointsEntry.encode({ key: key, value: value }, writer.uint32(34).fork()).ldelim();
        });
        if (message.append !== "") {
            writer.uint32(42).string(message.append);
        }
        if (message.rootdev !== "") {
            writer.uint32(50).string(message.rootdev);
        }
        if (message.defaultImage !== "") {
            writer.uint32(58).string(message.defaultImage);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseOSConfig();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.BGP.push(exports.BGPRouterConfig.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.bridge.push(exports.BridgeConfig.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.VLAN.push(exports.VLANConfig.decode(reader, reader.uint32()));
                    break;
                case 4:
                    var entry4 = exports.OSConfig_ServiceEndpointsEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.serviceEndpoints[entry4.key] = entry4.value;
                    }
                    break;
                case 5:
                    message.append = reader.string();
                    break;
                case 6:
                    message.rootdev = reader.string();
                    break;
                case 7:
                    message.defaultImage = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            BGP: Array.isArray(object === null || object === void 0 ? void 0 : object.BGP) ? object.BGP.map(function (e) { return exports.BGPRouterConfig.fromJSON(e); }) : [],
            bridge: Array.isArray(object === null || object === void 0 ? void 0 : object.bridge) ? object.bridge.map(function (e) { return exports.BridgeConfig.fromJSON(e); }) : [],
            VLAN: Array.isArray(object === null || object === void 0 ? void 0 : object.VLAN) ? object.VLAN.map(function (e) { return exports.VLANConfig.fromJSON(e); }) : [],
            serviceEndpoints: isObject(object.serviceEndpoints)
                ? Object.entries(object.serviceEndpoints).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[Number(key)] = exports.ServiceEndpoint.fromJSON(value);
                    return acc;
                }, {})
                : {},
            append: isSet(object.append) ? String(object.append) : "",
            rootdev: isSet(object.rootdev) ? String(object.rootdev) : "",
            defaultImage: isSet(object.defaultImage) ? String(object.defaultImage) : ""
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.BGP) {
            obj.BGP = message.BGP.map(function (e) { return e ? exports.BGPRouterConfig.toJSON(e) : undefined; });
        }
        else {
            obj.BGP = [];
        }
        if (message.bridge) {
            obj.bridge = message.bridge.map(function (e) { return e ? exports.BridgeConfig.toJSON(e) : undefined; });
        }
        else {
            obj.bridge = [];
        }
        if (message.VLAN) {
            obj.VLAN = message.VLAN.map(function (e) { return e ? exports.VLANConfig.toJSON(e) : undefined; });
        }
        else {
            obj.VLAN = [];
        }
        obj.serviceEndpoints = {};
        if (message.serviceEndpoints) {
            Object.entries(message.serviceEndpoints).forEach(function (_a) {
                var k = _a[0], v = _a[1];
                obj.serviceEndpoints[k] = exports.ServiceEndpoint.toJSON(v);
            });
        }
        message.append !== undefined && (obj.append = message.append);
        message.rootdev !== undefined && (obj.rootdev = message.rootdev);
        message.defaultImage !== undefined && (obj.defaultImage = message.defaultImage);
        return obj;
    },
    create: function (base) {
        return exports.OSConfig.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g;
        var message = createBaseOSConfig();
        message.BGP = ((_a = object.BGP) === null || _a === void 0 ? void 0 : _a.map(function (e) { return exports.BGPRouterConfig.fromPartial(e); })) || [];
        message.bridge = ((_b = object.bridge) === null || _b === void 0 ? void 0 : _b.map(function (e) { return exports.BridgeConfig.fromPartial(e); })) || [];
        message.VLAN = ((_c = object.VLAN) === null || _c === void 0 ? void 0 : _c.map(function (e) { return exports.VLANConfig.fromPartial(e); })) || [];
        message.serviceEndpoints = Object.entries((_d = object.serviceEndpoints) !== null && _d !== void 0 ? _d : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[Number(key)] = exports.ServiceEndpoint.fromPartial(value);
            }
            return acc;
        }, {});
        message.append = (_e = object.append) !== null && _e !== void 0 ? _e : "";
        message.rootdev = (_f = object.rootdev) !== null && _f !== void 0 ? _f : "";
        message.defaultImage = (_g = object.defaultImage) !== null && _g !== void 0 ? _g : "";
        return message;
    }
};
function createBaseOSConfig_ServiceEndpointsEntry() {
    return { key: 0, value: undefined };
}
exports.OSConfig_ServiceEndpointsEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.key !== 0) {
            writer.uint32(8).uint32(message.key);
        }
        if (message.value !== undefined) {
            exports.ServiceEndpoint.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseOSConfig_ServiceEndpointsEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.uint32();
                    break;
                case 2:
                    message.value = exports.ServiceEndpoint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? Number(object.key) : 0,
            value: isSet(object.value) ? exports.ServiceEndpoint.fromJSON(object.value) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.key !== undefined && (obj.key = Math.round(message.key));
        message.value !== undefined && (obj.value = message.value ? exports.ServiceEndpoint.toJSON(message.value) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.OSConfig_ServiceEndpointsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseOSConfig_ServiceEndpointsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : 0;
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.ServiceEndpoint.fromPartial(object.value)
            : undefined;
        return message;
    }
};
function createBaseServiceEndpoint() {
    return { address: "" };
}
exports.ServiceEndpoint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseServiceEndpoint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { address: isSet(object.address) ? String(object.address) : "" };
    },
    toJSON: function (message) {
        var obj = {};
        message.address !== undefined && (obj.address = message.address);
        return obj;
    },
    create: function (base) {
        return exports.ServiceEndpoint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseServiceEndpoint();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
function createBaseVLANConfig() {
    return { device: "", vid: 0, addrs: [], role: 0 };
}
exports.VLANConfig = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.device !== "") {
            writer.uint32(10).string(message.device);
        }
        if (message.vid !== 0) {
            writer.uint32(16).uint32(message.vid);
        }
        for (var _i = 0, _a = message.addrs; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.uint32(26).string(v);
        }
        if (message.role !== 0) {
            writer.uint32(32).int32(message.role);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseVLANConfig();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.device = reader.string();
                    break;
                case 2:
                    message.vid = reader.uint32();
                    break;
                case 3:
                    message.addrs.push(reader.string());
                    break;
                case 4:
                    message.role = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            device: isSet(object.device) ? String(object.device) : "",
            vid: isSet(object.vid) ? Number(object.vid) : 0,
            addrs: Array.isArray(object === null || object === void 0 ? void 0 : object.addrs) ? object.addrs.map(function (e) { return String(e); }) : [],
            role: isSet(object.role) ? linkRoleFromJSON(object.role) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.device !== undefined && (obj.device = message.device);
        message.vid !== undefined && (obj.vid = Math.round(message.vid));
        if (message.addrs) {
            obj.addrs = message.addrs.map(function (e) { return e; });
        }
        else {
            obj.addrs = [];
        }
        message.role !== undefined && (obj.role = linkRoleToJSON(message.role));
        return obj;
    },
    create: function (base) {
        return exports.VLANConfig.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = createBaseVLANConfig();
        message.device = (_a = object.device) !== null && _a !== void 0 ? _a : "";
        message.vid = (_b = object.vid) !== null && _b !== void 0 ? _b : 0;
        message.addrs = ((_c = object.addrs) === null || _c === void 0 ? void 0 : _c.map(function (e) { return e; })) || [];
        message.role = (_d = object.role) !== null && _d !== void 0 ? _d : 0;
        return message;
    }
};
function createBaseInterfaceConfig() {
    return { address: "", interface: "", role: 0 };
}
exports.InterfaceConfig = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.interface !== "") {
            writer.uint32(18).string(message.interface);
        }
        if (message.role !== 0) {
            writer.uint32(24).int32(message.role);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseInterfaceConfig();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.interface = reader.string();
                    break;
                case 3:
                    message.role = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            address: isSet(object.address) ? String(object.address) : "",
            interface: isSet(object.interface) ? String(object.interface) : "",
            role: isSet(object.role) ? linkRoleFromJSON(object.role) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.interface !== undefined && (obj.interface = message.interface);
        message.role !== undefined && (obj.role = linkRoleToJSON(message.role));
        return obj;
    },
    create: function (base) {
        return exports.InterfaceConfig.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBaseInterfaceConfig();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.interface = (_b = object.interface) !== null && _b !== void 0 ? _b : "";
        message.role = (_c = object.role) !== null && _c !== void 0 ? _c : 0;
        return message;
    }
};
function createBaseBGPRouterConfig() {
    return { vrf: "", ASN: 0, Interfaces: [], EVPN: undefined };
}
exports.BGPRouterConfig = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.vrf !== "") {
            writer.uint32(10).string(message.vrf);
        }
        if (message.ASN !== 0) {
            writer.uint32(16).uint32(message.ASN);
        }
        for (var _i = 0, _a = message.Interfaces; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.InterfaceConfig.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.EVPN !== undefined) {
            exports.EVPNConfig.encode(message.EVPN, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBGPRouterConfig();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vrf = reader.string();
                    break;
                case 2:
                    message.ASN = reader.uint32();
                    break;
                case 3:
                    message.Interfaces.push(exports.InterfaceConfig.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.EVPN = exports.EVPNConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            vrf: isSet(object.vrf) ? String(object.vrf) : "",
            ASN: isSet(object.ASN) ? Number(object.ASN) : 0,
            Interfaces: Array.isArray(object === null || object === void 0 ? void 0 : object.Interfaces)
                ? object.Interfaces.map(function (e) { return exports.InterfaceConfig.fromJSON(e); })
                : [],
            EVPN: isSet(object.EVPN) ? exports.EVPNConfig.fromJSON(object.EVPN) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.vrf !== undefined && (obj.vrf = message.vrf);
        message.ASN !== undefined && (obj.ASN = Math.round(message.ASN));
        if (message.Interfaces) {
            obj.Interfaces = message.Interfaces.map(function (e) { return e ? exports.InterfaceConfig.toJSON(e) : undefined; });
        }
        else {
            obj.Interfaces = [];
        }
        message.EVPN !== undefined && (obj.EVPN = message.EVPN ? exports.EVPNConfig.toJSON(message.EVPN) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.BGPRouterConfig.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBaseBGPRouterConfig();
        message.vrf = (_a = object.vrf) !== null && _a !== void 0 ? _a : "";
        message.ASN = (_b = object.ASN) !== null && _b !== void 0 ? _b : 0;
        message.Interfaces = ((_c = object.Interfaces) === null || _c === void 0 ? void 0 : _c.map(function (e) { return exports.InterfaceConfig.fromPartial(e); })) || [];
        message.EVPN = (object.EVPN !== undefined && object.EVPN !== null)
            ? exports.EVPNConfig.fromPartial(object.EVPN)
            : undefined;
        return message;
    }
};
function createBaseEVPNConfig() {
    return { TunnelEndpoints: [] };
}
exports.EVPNConfig = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        for (var _i = 0, _a = message.TunnelEndpoints; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.InterfaceConfig.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEVPNConfig();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.TunnelEndpoints.push(exports.InterfaceConfig.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            TunnelEndpoints: Array.isArray(object === null || object === void 0 ? void 0 : object.TunnelEndpoints)
                ? object.TunnelEndpoints.map(function (e) { return exports.InterfaceConfig.fromJSON(e); })
                : []
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.TunnelEndpoints) {
            obj.TunnelEndpoints = message.TunnelEndpoints.map(function (e) { return e ? exports.InterfaceConfig.toJSON(e) : undefined; });
        }
        else {
            obj.TunnelEndpoints = [];
        }
        return obj;
    },
    create: function (base) {
        return exports.EVPNConfig.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseEVPNConfig();
        message.TunnelEndpoints = ((_a = object.TunnelEndpoints) === null || _a === void 0 ? void 0 : _a.map(function (e) { return exports.InterfaceConfig.fromPartial(e); })) || [];
        return message;
    }
};
function createBaseBridgeConfig() {
    return { name: "", vlanAware: false, addrs: [], role: 0 };
}
exports.BridgeConfig = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.vlanAware === true) {
            writer.uint32(16).bool(message.vlanAware);
        }
        for (var _i = 0, _a = message.addrs; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.uint32(26).string(v);
        }
        if (message.role !== 0) {
            writer.uint32(32).int32(message.role);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBridgeConfig();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.vlanAware = reader.bool();
                    break;
                case 3:
                    message.addrs.push(reader.string());
                    break;
                case 4:
                    message.role = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            name: isSet(object.name) ? String(object.name) : "",
            vlanAware: isSet(object.vlanAware) ? Boolean(object.vlanAware) : false,
            addrs: Array.isArray(object === null || object === void 0 ? void 0 : object.addrs) ? object.addrs.map(function (e) { return String(e); }) : [],
            role: isSet(object.role) ? linkRoleFromJSON(object.role) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.vlanAware !== undefined && (obj.vlanAware = message.vlanAware);
        if (message.addrs) {
            obj.addrs = message.addrs.map(function (e) { return e; });
        }
        else {
            obj.addrs = [];
        }
        message.role !== undefined && (obj.role = linkRoleToJSON(message.role));
        return obj;
    },
    create: function (base) {
        return exports.BridgeConfig.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = createBaseBridgeConfig();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.vlanAware = (_b = object.vlanAware) !== null && _b !== void 0 ? _b : false;
        message.addrs = ((_c = object.addrs) === null || _c === void 0 ? void 0 : _c.map(function (e) { return e; })) || [];
        message.role = (_d = object.role) !== null && _d !== void 0 ? _d : 0;
        return message;
    }
};
function createBaseBreakout() {
    return { index: 0, radix: 0 };
}
exports.Breakout = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.index !== 0) {
            writer.uint32(8).uint32(message.index);
        }
        if (message.radix !== 0) {
            writer.uint32(16).uint32(message.radix);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBreakout();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.index = reader.uint32();
                    break;
                case 2:
                    message.radix = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            index: isSet(object.index) ? Number(object.index) : 0,
            radix: isSet(object.radix) ? Number(object.radix) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.index !== undefined && (obj.index = Math.round(message.index));
        message.radix !== undefined && (obj.radix = Math.round(message.radix));
        return obj;
    },
    create: function (base) {
        return exports.Breakout.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseBreakout();
        message.index = (_a = object.index) !== null && _a !== void 0 ? _a : 0;
        message.radix = (_b = object.radix) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBasePortBond() {
    return { name: "" };
}
exports.PortBond = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBasePortBond();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { name: isSet(object.name) ? String(object.name) : "" };
    },
    toJSON: function (message) {
        var obj = {};
        message.name !== undefined && (obj.name = message.name);
        return obj;
    },
    create: function (base) {
        return exports.PortBond.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBasePortBond();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
function createBasesriovPf() {
    return { MaxVFs: 0 };
}
exports.sriovPf = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.MaxVFs !== 0) {
            writer.uint32(8).uint32(message.MaxVFs);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBasesriovPf();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.MaxVFs = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { MaxVFs: isSet(object.MaxVFs) ? Number(object.MaxVFs) : 0 };
    },
    toJSON: function (message) {
        var obj = {};
        message.MaxVFs !== undefined && (obj.MaxVFs = Math.round(message.MaxVFs));
        return obj;
    },
    create: function (base) {
        return exports.sriovPf.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBasesriovPf();
        message.MaxVFs = (_a = object.MaxVFs) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBasesriovVf() {
    return { VfIndex: 0 };
}
exports.sriovVf = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.VfIndex !== 0) {
            writer.uint32(8).uint32(message.VfIndex);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBasesriovVf();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.VfIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { VfIndex: isSet(object.VfIndex) ? Number(object.VfIndex) : 0 };
    },
    toJSON: function (message) {
        var obj = {};
        message.VfIndex !== undefined && (obj.VfIndex = Math.round(message.VfIndex));
        return obj;
    },
    create: function (base) {
        return exports.sriovVf.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBasesriovVf();
        message.VfIndex = (_a = object.VfIndex) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBaseSRIOV() {
    return { Pf: undefined, Vf: undefined, PfNi: 0, PfPi: 0 };
}
exports.SRIOV = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.Pf !== undefined) {
            exports.sriovPf.encode(message.Pf, writer.uint32(18).fork()).ldelim();
        }
        if (message.Vf !== undefined) {
            exports.sriovVf.encode(message.Vf, writer.uint32(26).fork()).ldelim();
        }
        if (message.PfNi !== 0) {
            writer.uint32(32).uint32(message.PfNi);
        }
        if (message.PfPi !== 0) {
            writer.uint32(40).uint32(message.PfPi);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseSRIOV();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.Pf = exports.sriovPf.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.Vf = exports.sriovVf.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.PfNi = reader.uint32();
                    break;
                case 5:
                    message.PfPi = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            Pf: isSet(object.Pf) ? exports.sriovPf.fromJSON(object.Pf) : undefined,
            Vf: isSet(object.Vf) ? exports.sriovVf.fromJSON(object.Vf) : undefined,
            PfNi: isSet(object.PfNi) ? Number(object.PfNi) : 0,
            PfPi: isSet(object.PfPi) ? Number(object.PfPi) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.Pf !== undefined && (obj.Pf = message.Pf ? exports.sriovPf.toJSON(message.Pf) : undefined);
        message.Vf !== undefined && (obj.Vf = message.Vf ? exports.sriovVf.toJSON(message.Vf) : undefined);
        message.PfNi !== undefined && (obj.PfNi = Math.round(message.PfNi));
        message.PfPi !== undefined && (obj.PfPi = Math.round(message.PfPi));
        return obj;
    },
    create: function (base) {
        return exports.SRIOV.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseSRIOV();
        message.Pf = (object.Pf !== undefined && object.Pf !== null) ? exports.sriovPf.fromPartial(object.Pf) : undefined;
        message.Vf = (object.Vf !== undefined && object.Vf !== null) ? exports.sriovVf.fromPartial(object.Vf) : undefined;
        message.PfNi = (_a = object.PfNi) !== null && _a !== void 0 ? _a : 0;
        message.PfPi = (_b = object.PfPi) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBasePort() {
    return {
        parent: "",
        index: 0,
        protocols: [],
        capacity: 0,
        mac: "",
        formFactor: 0,
        connector: undefined,
        role: 0,
        TPA: 0,
        queues: 0,
        breakout: undefined,
        bond: undefined,
        name: "",
        sriov: undefined
    };
}
exports.Port = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.parent !== "") {
            writer.uint32(10).string(message.parent);
        }
        if (message.index !== 0) {
            writer.uint32(16).uint32(message.index);
        }
        writer.uint32(26).fork();
        for (var _i = 0, _a = message.protocols; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.int32(v);
        }
        writer.ldelim();
        if (message.capacity !== 0) {
            writer.uint32(32).uint64(message.capacity);
        }
        if (message.mac !== "") {
            writer.uint32(42).string(message.mac);
        }
        if (message.formFactor !== 0) {
            writer.uint32(48).int32(message.formFactor);
        }
        if (message.connector !== undefined) {
            exports.Ref.encode(message.connector, writer.uint32(58).fork()).ldelim();
        }
        if (message.role !== 0) {
            writer.uint32(64).int32(message.role);
        }
        if (message.TPA !== 0) {
            writer.uint32(72).uint64(message.TPA);
        }
        if (message.queues !== 0) {
            writer.uint32(80).uint64(message.queues);
        }
        if (message.breakout !== undefined) {
            exports.Breakout.encode(message.breakout, writer.uint32(90).fork()).ldelim();
        }
        if (message.bond !== undefined) {
            exports.PortBond.encode(message.bond, writer.uint32(98).fork()).ldelim();
        }
        if (message.name !== "") {
            writer.uint32(106).string(message.name);
        }
        if (message.sriov !== undefined) {
            exports.SRIOV.encode(message.sriov, writer.uint32(114).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBasePort();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.parent = reader.string();
                    break;
                case 2:
                    message.index = reader.uint32();
                    break;
                case 3:
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.protocols.push(reader.int32());
                        }
                    }
                    else {
                        message.protocols.push(reader.int32());
                    }
                    break;
                case 4:
                    message.capacity = longToNumber(reader.uint64());
                    break;
                case 5:
                    message.mac = reader.string();
                    break;
                case 6:
                    message.formFactor = reader.int32();
                    break;
                case 7:
                    message.connector = exports.Ref.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.role = reader.int32();
                    break;
                case 9:
                    message.TPA = longToNumber(reader.uint64());
                    break;
                case 10:
                    message.queues = longToNumber(reader.uint64());
                    break;
                case 11:
                    message.breakout = exports.Breakout.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.bond = exports.PortBond.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.name = reader.string();
                    break;
                case 14:
                    message.sriov = exports.SRIOV.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            parent: isSet(object.parent) ? String(object.parent) : "",
            index: isSet(object.index) ? Number(object.index) : 0,
            protocols: Array.isArray(object === null || object === void 0 ? void 0 : object.protocols) ? object.protocols.map(function (e) { return layer1FromJSON(e); }) : [],
            capacity: isSet(object.capacity) ? Number(object.capacity) : 0,
            mac: isSet(object.mac) ? String(object.mac) : "",
            formFactor: isSet(object.formFactor) ? connectorKindFromJSON(object.formFactor) : 0,
            connector: isSet(object.connector) ? exports.Ref.fromJSON(object.connector) : undefined,
            role: isSet(object.role) ? linkRoleFromJSON(object.role) : 0,
            TPA: isSet(object.TPA) ? Number(object.TPA) : 0,
            queues: isSet(object.queues) ? Number(object.queues) : 0,
            breakout: isSet(object.breakout) ? exports.Breakout.fromJSON(object.breakout) : undefined,
            bond: isSet(object.bond) ? exports.PortBond.fromJSON(object.bond) : undefined,
            name: isSet(object.name) ? String(object.name) : "",
            sriov: isSet(object.sriov) ? exports.SRIOV.fromJSON(object.sriov) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.parent !== undefined && (obj.parent = message.parent);
        message.index !== undefined && (obj.index = Math.round(message.index));
        if (message.protocols) {
            obj.protocols = message.protocols.map(function (e) { return layer1ToJSON(e); });
        }
        else {
            obj.protocols = [];
        }
        message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
        message.mac !== undefined && (obj.mac = message.mac);
        message.formFactor !== undefined && (obj.formFactor = connectorKindToJSON(message.formFactor));
        message.connector !== undefined && (obj.connector = message.connector ? exports.Ref.toJSON(message.connector) : undefined);
        message.role !== undefined && (obj.role = linkRoleToJSON(message.role));
        message.TPA !== undefined && (obj.TPA = Math.round(message.TPA));
        message.queues !== undefined && (obj.queues = Math.round(message.queues));
        message.breakout !== undefined && (obj.breakout = message.breakout ? exports.Breakout.toJSON(message.breakout) : undefined);
        message.bond !== undefined && (obj.bond = message.bond ? exports.PortBond.toJSON(message.bond) : undefined);
        message.name !== undefined && (obj.name = message.name);
        message.sriov !== undefined && (obj.sriov = message.sriov ? exports.SRIOV.toJSON(message.sriov) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.Port.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var message = createBasePort();
        message.parent = (_a = object.parent) !== null && _a !== void 0 ? _a : "";
        message.index = (_b = object.index) !== null && _b !== void 0 ? _b : 0;
        message.protocols = ((_c = object.protocols) === null || _c === void 0 ? void 0 : _c.map(function (e) { return e; })) || [];
        message.capacity = (_d = object.capacity) !== null && _d !== void 0 ? _d : 0;
        message.mac = (_e = object.mac) !== null && _e !== void 0 ? _e : "";
        message.formFactor = (_f = object.formFactor) !== null && _f !== void 0 ? _f : 0;
        message.connector = (object.connector !== undefined && object.connector !== null)
            ? exports.Ref.fromPartial(object.connector)
            : undefined;
        message.role = (_g = object.role) !== null && _g !== void 0 ? _g : 0;
        message.TPA = (_h = object.TPA) !== null && _h !== void 0 ? _h : 0;
        message.queues = (_j = object.queues) !== null && _j !== void 0 ? _j : 0;
        message.breakout = (object.breakout !== undefined && object.breakout !== null)
            ? exports.Breakout.fromPartial(object.breakout)
            : undefined;
        message.bond = (object.bond !== undefined && object.bond !== null) ? exports.PortBond.fromPartial(object.bond) : undefined;
        message.name = (_k = object.name) !== null && _k !== void 0 ? _k : "";
        message.sriov = (object.sriov !== undefined && object.sriov !== null) ? exports.SRIOV.fromPartial(object.sriov) : undefined;
        return message;
    }
};
function createBasePortAllocation() {
    return { name: "", mac: "", capacity: 0, VfName: "", VfAlloc: false };
}
exports.PortAllocation = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.mac !== "") {
            writer.uint32(18).string(message.mac);
        }
        if (message.capacity !== 0) {
            writer.uint32(24).uint64(message.capacity);
        }
        if (message.VfName !== "") {
            writer.uint32(34).string(message.VfName);
        }
        if (message.VfAlloc === true) {
            writer.uint32(40).bool(message.VfAlloc);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBasePortAllocation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.mac = reader.string();
                    break;
                case 3:
                    message.capacity = longToNumber(reader.uint64());
                    break;
                case 4:
                    message.VfName = reader.string();
                    break;
                case 5:
                    message.VfAlloc = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            name: isSet(object.name) ? String(object.name) : "",
            mac: isSet(object.mac) ? String(object.mac) : "",
            capacity: isSet(object.capacity) ? Number(object.capacity) : 0,
            VfName: isSet(object.VfName) ? String(object.VfName) : "",
            VfAlloc: isSet(object.VfAlloc) ? Boolean(object.VfAlloc) : false
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.mac !== undefined && (obj.mac = message.mac);
        message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
        message.VfName !== undefined && (obj.VfName = message.VfName);
        message.VfAlloc !== undefined && (obj.VfAlloc = message.VfAlloc);
        return obj;
    },
    create: function (base) {
        return exports.PortAllocation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e;
        var message = createBasePortAllocation();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.mac = (_b = object.mac) !== null && _b !== void 0 ? _b : "";
        message.capacity = (_c = object.capacity) !== null && _c !== void 0 ? _c : 0;
        message.VfName = (_d = object.VfName) !== null && _d !== void 0 ? _d : "";
        message.VfAlloc = (_e = object.VfAlloc) !== null && _e !== void 0 ? _e : false;
        return message;
    }
};
function createBasePortRef() {
    return { mac: "" };
}
exports.PortRef = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.mac !== "") {
            writer.uint32(10).string(message.mac);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBasePortRef();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mac = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { mac: isSet(object.mac) ? String(object.mac) : "" };
    },
    toJSON: function (message) {
        var obj = {};
        message.mac !== undefined && (obj.mac = message.mac);
        return obj;
    },
    create: function (base) {
        return exports.PortRef.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBasePortRef();
        message.mac = (_a = object.mac) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
function createBasePortSpec() {
    return {
        protocols: [],
        capacity: undefined,
        formFactor: undefined,
        queues: undefined,
        model: undefined,
        DPDK: undefined,
        SriovVF: undefined
    };
}
exports.PortSpec = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        writer.uint32(10).fork();
        for (var _i = 0, _a = message.protocols; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.int32(v);
        }
        writer.ldelim();
        if (message.capacity !== undefined) {
            exports.Uint64Constraint.encode(message.capacity, writer.uint32(18).fork()).ldelim();
        }
        if (message.formFactor !== undefined) {
            exports.ConnectorKindConstraint.encode(message.formFactor, writer.uint32(26).fork()).ldelim();
        }
        if (message.queues !== undefined) {
            exports.Uint64Constraint.encode(message.queues, writer.uint32(34).fork()).ldelim();
        }
        if (message.model !== undefined) {
            exports.NICModelConstraint.encode(message.model, writer.uint32(42).fork()).ldelim();
        }
        if (message.DPDK !== undefined) {
            exports.BoolConstraint.encode(message.DPDK, writer.uint32(50).fork()).ldelim();
        }
        if (message.SriovVF !== undefined) {
            exports.BoolConstraint.encode(message.SriovVF, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBasePortSpec();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.protocols.push(reader.int32());
                        }
                    }
                    else {
                        message.protocols.push(reader.int32());
                    }
                    break;
                case 2:
                    message.capacity = exports.Uint64Constraint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.formFactor = exports.ConnectorKindConstraint.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.queues = exports.Uint64Constraint.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.model = exports.NICModelConstraint.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.DPDK = exports.BoolConstraint.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.SriovVF = exports.BoolConstraint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            protocols: Array.isArray(object === null || object === void 0 ? void 0 : object.protocols) ? object.protocols.map(function (e) { return layer1FromJSON(e); }) : [],
            capacity: isSet(object.capacity) ? exports.Uint64Constraint.fromJSON(object.capacity) : undefined,
            formFactor: isSet(object.formFactor) ? exports.ConnectorKindConstraint.fromJSON(object.formFactor) : undefined,
            queues: isSet(object.queues) ? exports.Uint64Constraint.fromJSON(object.queues) : undefined,
            model: isSet(object.model) ? exports.NICModelConstraint.fromJSON(object.model) : undefined,
            DPDK: isSet(object.DPDK) ? exports.BoolConstraint.fromJSON(object.DPDK) : undefined,
            SriovVF: isSet(object.SriovVF) ? exports.BoolConstraint.fromJSON(object.SriovVF) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.protocols) {
            obj.protocols = message.protocols.map(function (e) { return layer1ToJSON(e); });
        }
        else {
            obj.protocols = [];
        }
        message.capacity !== undefined &&
            (obj.capacity = message.capacity ? exports.Uint64Constraint.toJSON(message.capacity) : undefined);
        message.formFactor !== undefined &&
            (obj.formFactor = message.formFactor ? exports.ConnectorKindConstraint.toJSON(message.formFactor) : undefined);
        message.queues !== undefined && (obj.queues = message.queues ? exports.Uint64Constraint.toJSON(message.queues) : undefined);
        message.model !== undefined && (obj.model = message.model ? exports.NICModelConstraint.toJSON(message.model) : undefined);
        message.DPDK !== undefined && (obj.DPDK = message.DPDK ? exports.BoolConstraint.toJSON(message.DPDK) : undefined);
        message.SriovVF !== undefined &&
            (obj.SriovVF = message.SriovVF ? exports.BoolConstraint.toJSON(message.SriovVF) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.PortSpec.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBasePortSpec();
        message.protocols = ((_a = object.protocols) === null || _a === void 0 ? void 0 : _a.map(function (e) { return e; })) || [];
        message.capacity = (object.capacity !== undefined && object.capacity !== null)
            ? exports.Uint64Constraint.fromPartial(object.capacity)
            : undefined;
        message.formFactor = (object.formFactor !== undefined && object.formFactor !== null)
            ? exports.ConnectorKindConstraint.fromPartial(object.formFactor)
            : undefined;
        message.queues = (object.queues !== undefined && object.queues !== null)
            ? exports.Uint64Constraint.fromPartial(object.queues)
            : undefined;
        message.model = (object.model !== undefined && object.model !== null)
            ? exports.NICModelConstraint.fromPartial(object.model)
            : undefined;
        message.DPDK = (object.DPDK !== undefined && object.DPDK !== null)
            ? exports.BoolConstraint.fromPartial(object.DPDK)
            : undefined;
        message.SriovVF = (object.SriovVF !== undefined && object.SriovVF !== null)
            ? exports.BoolConstraint.fromPartial(object.SriovVF)
            : undefined;
        return message;
    }
};
function createBaseCable() {
    return { id: "", facility: "", kind: 0, ends: [], productInfo: undefined };
}
exports.Cable = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.facility !== "") {
            writer.uint32(18).string(message.facility);
        }
        if (message.kind !== 0) {
            writer.uint32(24).int32(message.kind);
        }
        for (var _i = 0, _a = message.ends; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.End.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.productInfo !== undefined) {
            exports.ProductInfo.encode(message.productInfo, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseCable();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.facility = reader.string();
                    break;
                case 3:
                    message.kind = reader.int32();
                    break;
                case 4:
                    message.ends.push(exports.End.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.productInfo = exports.ProductInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            facility: isSet(object.facility) ? String(object.facility) : "",
            kind: isSet(object.kind) ? cableKindFromJSON(object.kind) : 0,
            ends: Array.isArray(object === null || object === void 0 ? void 0 : object.ends) ? object.ends.map(function (e) { return exports.End.fromJSON(e); }) : [],
            productInfo: isSet(object.productInfo) ? exports.ProductInfo.fromJSON(object.productInfo) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.facility !== undefined && (obj.facility = message.facility);
        message.kind !== undefined && (obj.kind = cableKindToJSON(message.kind));
        if (message.ends) {
            obj.ends = message.ends.map(function (e) { return e ? exports.End.toJSON(e) : undefined; });
        }
        else {
            obj.ends = [];
        }
        message.productInfo !== undefined &&
            (obj.productInfo = message.productInfo ? exports.ProductInfo.toJSON(message.productInfo) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.Cable.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = createBaseCable();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.facility = (_b = object.facility) !== null && _b !== void 0 ? _b : "";
        message.kind = (_c = object.kind) !== null && _c !== void 0 ? _c : 0;
        message.ends = ((_d = object.ends) === null || _d === void 0 ? void 0 : _d.map(function (e) { return exports.End.fromPartial(e); })) || [];
        message.productInfo = (object.productInfo !== undefined && object.productInfo !== null)
            ? exports.ProductInfo.fromPartial(object.productInfo)
            : undefined;
        return message;
    }
};
function createBaseEnd() {
    return { connectors: [] };
}
exports.End = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        for (var _i = 0, _a = message.connectors; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.Connector.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEnd();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.connectors.push(exports.Connector.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            connectors: Array.isArray(object === null || object === void 0 ? void 0 : object.connectors) ? object.connectors.map(function (e) { return exports.Connector.fromJSON(e); }) : []
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.connectors) {
            obj.connectors = message.connectors.map(function (e) { return e ? exports.Connector.toJSON(e) : undefined; });
        }
        else {
            obj.connectors = [];
        }
        return obj;
    },
    create: function (base) {
        return exports.End.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseEnd();
        message.connectors = ((_a = object.connectors) === null || _a === void 0 ? void 0 : _a.map(function (e) { return exports.Connector.fromPartial(e); })) || [];
        return message;
    }
};
function createBaseConnector() {
    return { parent: "", index: 0, kind: 0, protocols: [], capacity: 0, Port: undefined, breakout: undefined };
}
exports.Connector = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.parent !== "") {
            writer.uint32(10).string(message.parent);
        }
        if (message.index !== 0) {
            writer.uint32(16).uint32(message.index);
        }
        if (message.kind !== 0) {
            writer.uint32(24).int32(message.kind);
        }
        writer.uint32(34).fork();
        for (var _i = 0, _a = message.protocols; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.int32(v);
        }
        writer.ldelim();
        if (message.capacity !== 0) {
            writer.uint32(40).uint64(message.capacity);
        }
        if (message.Port !== undefined) {
            exports.Ref.encode(message.Port, writer.uint32(50).fork()).ldelim();
        }
        if (message.breakout !== undefined) {
            exports.Breakout.encode(message.breakout, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseConnector();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.parent = reader.string();
                    break;
                case 2:
                    message.index = reader.uint32();
                    break;
                case 3:
                    message.kind = reader.int32();
                    break;
                case 4:
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.protocols.push(reader.int32());
                        }
                    }
                    else {
                        message.protocols.push(reader.int32());
                    }
                    break;
                case 5:
                    message.capacity = longToNumber(reader.uint64());
                    break;
                case 6:
                    message.Port = exports.Ref.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.breakout = exports.Breakout.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            parent: isSet(object.parent) ? String(object.parent) : "",
            index: isSet(object.index) ? Number(object.index) : 0,
            kind: isSet(object.kind) ? connectorKindFromJSON(object.kind) : 0,
            protocols: Array.isArray(object === null || object === void 0 ? void 0 : object.protocols) ? object.protocols.map(function (e) { return layer1FromJSON(e); }) : [],
            capacity: isSet(object.capacity) ? Number(object.capacity) : 0,
            Port: isSet(object.Port) ? exports.Ref.fromJSON(object.Port) : undefined,
            breakout: isSet(object.breakout) ? exports.Breakout.fromJSON(object.breakout) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.parent !== undefined && (obj.parent = message.parent);
        message.index !== undefined && (obj.index = Math.round(message.index));
        message.kind !== undefined && (obj.kind = connectorKindToJSON(message.kind));
        if (message.protocols) {
            obj.protocols = message.protocols.map(function (e) { return layer1ToJSON(e); });
        }
        else {
            obj.protocols = [];
        }
        message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
        message.Port !== undefined && (obj.Port = message.Port ? exports.Ref.toJSON(message.Port) : undefined);
        message.breakout !== undefined && (obj.breakout = message.breakout ? exports.Breakout.toJSON(message.breakout) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.Connector.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e;
        var message = createBaseConnector();
        message.parent = (_a = object.parent) !== null && _a !== void 0 ? _a : "";
        message.index = (_b = object.index) !== null && _b !== void 0 ? _b : 0;
        message.kind = (_c = object.kind) !== null && _c !== void 0 ? _c : 0;
        message.protocols = ((_d = object.protocols) === null || _d === void 0 ? void 0 : _d.map(function (e) { return e; })) || [];
        message.capacity = (_e = object.capacity) !== null && _e !== void 0 ? _e : 0;
        message.Port = (object.Port !== undefined && object.Port !== null) ? exports.Ref.fromPartial(object.Port) : undefined;
        message.breakout = (object.breakout !== undefined && object.breakout !== null)
            ? exports.Breakout.fromPartial(object.breakout)
            : undefined;
        return message;
    }
};
function createBaseConnectorSpec() {
    return { kind: undefined, protocols: [], capacity: 0 };
}
exports.ConnectorSpec = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.kind !== undefined) {
            exports.ConnectorKindConstraint.encode(message.kind, writer.uint32(10).fork()).ldelim();
        }
        writer.uint32(18).fork();
        for (var _i = 0, _a = message.protocols; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.int32(v);
        }
        writer.ldelim();
        if (message.capacity !== 0) {
            writer.uint32(24).uint64(message.capacity);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseConnectorSpec();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.kind = exports.ConnectorKindConstraint.decode(reader, reader.uint32());
                    break;
                case 2:
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.protocols.push(reader.int32());
                        }
                    }
                    else {
                        message.protocols.push(reader.int32());
                    }
                    break;
                case 3:
                    message.capacity = longToNumber(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            kind: isSet(object.kind) ? exports.ConnectorKindConstraint.fromJSON(object.kind) : undefined,
            protocols: Array.isArray(object === null || object === void 0 ? void 0 : object.protocols) ? object.protocols.map(function (e) { return layer1FromJSON(e); }) : [],
            capacity: isSet(object.capacity) ? Number(object.capacity) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.kind !== undefined && (obj.kind = message.kind ? exports.ConnectorKindConstraint.toJSON(message.kind) : undefined);
        if (message.protocols) {
            obj.protocols = message.protocols.map(function (e) { return layer1ToJSON(e); });
        }
        else {
            obj.protocols = [];
        }
        message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
        return obj;
    },
    create: function (base) {
        return exports.ConnectorSpec.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseConnectorSpec();
        message.kind = (object.kind !== undefined && object.kind !== null)
            ? exports.ConnectorKindConstraint.fromPartial(object.kind)
            : undefined;
        message.protocols = ((_a = object.protocols) === null || _a === void 0 ? void 0 : _a.map(function (e) { return e; })) || [];
        message.capacity = (_b = object.capacity) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseProc() {
    return {
        isa: 0,
        family: "",
        BaseFrequency: 0,
        L2: 0,
        cores: 0,
        threads: 0,
        tdp: 0,
        hyperthreaded: false,
        productInfo: undefined,
        reservedCores: 0
    };
}
exports.Proc = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.isa !== 0) {
            writer.uint32(8).int32(message.isa);
        }
        if (message.family !== "") {
            writer.uint32(18).string(message.family);
        }
        if (message.BaseFrequency !== 0) {
            writer.uint32(24).uint64(message.BaseFrequency);
        }
        if (message.L2 !== 0) {
            writer.uint32(32).uint64(message.L2);
        }
        if (message.cores !== 0) {
            writer.uint32(40).uint32(message.cores);
        }
        if (message.threads !== 0) {
            writer.uint32(48).uint32(message.threads);
        }
        if (message.tdp !== 0) {
            writer.uint32(56).uint32(message.tdp);
        }
        if (message.hyperthreaded === true) {
            writer.uint32(64).bool(message.hyperthreaded);
        }
        if (message.productInfo !== undefined) {
            exports.ProductInfo.encode(message.productInfo, writer.uint32(74).fork()).ldelim();
        }
        if (message.reservedCores !== 0) {
            writer.uint32(80).uint32(message.reservedCores);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseProc();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isa = reader.int32();
                    break;
                case 2:
                    message.family = reader.string();
                    break;
                case 3:
                    message.BaseFrequency = longToNumber(reader.uint64());
                    break;
                case 4:
                    message.L2 = longToNumber(reader.uint64());
                    break;
                case 5:
                    message.cores = reader.uint32();
                    break;
                case 6:
                    message.threads = reader.uint32();
                    break;
                case 7:
                    message.tdp = reader.uint32();
                    break;
                case 8:
                    message.hyperthreaded = reader.bool();
                    break;
                case 9:
                    message.productInfo = exports.ProductInfo.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.reservedCores = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            isa: isSet(object.isa) ? iSAFromJSON(object.isa) : 0,
            family: isSet(object.family) ? String(object.family) : "",
            BaseFrequency: isSet(object.BaseFrequency) ? Number(object.BaseFrequency) : 0,
            L2: isSet(object.L2) ? Number(object.L2) : 0,
            cores: isSet(object.cores) ? Number(object.cores) : 0,
            threads: isSet(object.threads) ? Number(object.threads) : 0,
            tdp: isSet(object.tdp) ? Number(object.tdp) : 0,
            hyperthreaded: isSet(object.hyperthreaded) ? Boolean(object.hyperthreaded) : false,
            productInfo: isSet(object.productInfo) ? exports.ProductInfo.fromJSON(object.productInfo) : undefined,
            reservedCores: isSet(object.reservedCores) ? Number(object.reservedCores) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.isa !== undefined && (obj.isa = iSAToJSON(message.isa));
        message.family !== undefined && (obj.family = message.family);
        message.BaseFrequency !== undefined && (obj.BaseFrequency = Math.round(message.BaseFrequency));
        message.L2 !== undefined && (obj.L2 = Math.round(message.L2));
        message.cores !== undefined && (obj.cores = Math.round(message.cores));
        message.threads !== undefined && (obj.threads = Math.round(message.threads));
        message.tdp !== undefined && (obj.tdp = Math.round(message.tdp));
        message.hyperthreaded !== undefined && (obj.hyperthreaded = message.hyperthreaded);
        message.productInfo !== undefined &&
            (obj.productInfo = message.productInfo ? exports.ProductInfo.toJSON(message.productInfo) : undefined);
        message.reservedCores !== undefined && (obj.reservedCores = Math.round(message.reservedCores));
        return obj;
    },
    create: function (base) {
        return exports.Proc.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var message = createBaseProc();
        message.isa = (_a = object.isa) !== null && _a !== void 0 ? _a : 0;
        message.family = (_b = object.family) !== null && _b !== void 0 ? _b : "";
        message.BaseFrequency = (_c = object.BaseFrequency) !== null && _c !== void 0 ? _c : 0;
        message.L2 = (_d = object.L2) !== null && _d !== void 0 ? _d : 0;
        message.cores = (_e = object.cores) !== null && _e !== void 0 ? _e : 0;
        message.threads = (_f = object.threads) !== null && _f !== void 0 ? _f : 0;
        message.tdp = (_g = object.tdp) !== null && _g !== void 0 ? _g : 0;
        message.hyperthreaded = (_h = object.hyperthreaded) !== null && _h !== void 0 ? _h : false;
        message.productInfo = (object.productInfo !== undefined && object.productInfo !== null)
            ? exports.ProductInfo.fromPartial(object.productInfo)
            : undefined;
        message.reservedCores = (_j = object.reservedCores) !== null && _j !== void 0 ? _j : 0;
        return message;
    }
};
function createBaseSocketAllocation() {
    return { cores: 0 };
}
exports.SocketAllocation = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.cores !== 0) {
            writer.uint32(8).uint32(message.cores);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseSocketAllocation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cores = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { cores: isSet(object.cores) ? Number(object.cores) : 0 };
    },
    toJSON: function (message) {
        var obj = {};
        message.cores !== undefined && (obj.cores = Math.round(message.cores));
        return obj;
    },
    create: function (base) {
        return exports.SocketAllocation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseSocketAllocation();
        message.cores = (_a = object.cores) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBaseProcAllocation() {
    return { alloc: {} };
}
exports.ProcAllocation = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        Object.entries(message.alloc).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.ProcAllocation_AllocEntry.encode({ key: key, value: value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseProcAllocation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    var entry1 = exports.ProcAllocation_AllocEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.alloc[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            alloc: isObject(object.alloc)
                ? Object.entries(object.alloc).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[Number(key)] = exports.SocketAllocation.fromJSON(value);
                    return acc;
                }, {})
                : {}
        };
    },
    toJSON: function (message) {
        var obj = {};
        obj.alloc = {};
        if (message.alloc) {
            Object.entries(message.alloc).forEach(function (_a) {
                var k = _a[0], v = _a[1];
                obj.alloc[k] = exports.SocketAllocation.toJSON(v);
            });
        }
        return obj;
    },
    create: function (base) {
        return exports.ProcAllocation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseProcAllocation();
        message.alloc = Object.entries((_a = object.alloc) !== null && _a !== void 0 ? _a : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[Number(key)] = exports.SocketAllocation.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    }
};
function createBaseProcAllocation_AllocEntry() {
    return { key: 0, value: undefined };
}
exports.ProcAllocation_AllocEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.key !== 0) {
            writer.uint32(8).uint32(message.key);
        }
        if (message.value !== undefined) {
            exports.SocketAllocation.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseProcAllocation_AllocEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.uint32();
                    break;
                case 2:
                    message.value = exports.SocketAllocation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? Number(object.key) : 0,
            value: isSet(object.value) ? exports.SocketAllocation.fromJSON(object.value) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.key !== undefined && (obj.key = Math.round(message.key));
        message.value !== undefined && (obj.value = message.value ? exports.SocketAllocation.toJSON(message.value) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.ProcAllocation_AllocEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseProcAllocation_AllocEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : 0;
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.SocketAllocation.fromPartial(object.value)
            : undefined;
        return message;
    }
};
function createBaseProcSpec() {
    return {
        isa: undefined,
        family: undefined,
        BaseFrequency: undefined,
        L2: undefined,
        cores: undefined,
        threads: undefined,
        tdp: undefined,
        sockets: undefined,
        hyperthreaded: undefined
    };
}
exports.ProcSpec = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.isa !== undefined) {
            exports.ISAConstraint.encode(message.isa, writer.uint32(10).fork()).ldelim();
        }
        if (message.family !== undefined) {
            exports.StringConstraint.encode(message.family, writer.uint32(18).fork()).ldelim();
        }
        if (message.BaseFrequency !== undefined) {
            exports.Uint64Constraint.encode(message.BaseFrequency, writer.uint32(26).fork()).ldelim();
        }
        if (message.L2 !== undefined) {
            exports.Uint64Constraint.encode(message.L2, writer.uint32(34).fork()).ldelim();
        }
        if (message.cores !== undefined) {
            exports.Uint32Constraint.encode(message.cores, writer.uint32(42).fork()).ldelim();
        }
        if (message.threads !== undefined) {
            exports.Uint32Constraint.encode(message.threads, writer.uint32(50).fork()).ldelim();
        }
        if (message.tdp !== undefined) {
            exports.Uint32Constraint.encode(message.tdp, writer.uint32(58).fork()).ldelim();
        }
        if (message.sockets !== undefined) {
            exports.Uint32Constraint.encode(message.sockets, writer.uint32(66).fork()).ldelim();
        }
        if (message.hyperthreaded !== undefined) {
            exports.BoolConstraint.encode(message.hyperthreaded, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseProcSpec();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isa = exports.ISAConstraint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.family = exports.StringConstraint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.BaseFrequency = exports.Uint64Constraint.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.L2 = exports.Uint64Constraint.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.cores = exports.Uint32Constraint.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.threads = exports.Uint32Constraint.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.tdp = exports.Uint32Constraint.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.sockets = exports.Uint32Constraint.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.hyperthreaded = exports.BoolConstraint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            isa: isSet(object.isa) ? exports.ISAConstraint.fromJSON(object.isa) : undefined,
            family: isSet(object.family) ? exports.StringConstraint.fromJSON(object.family) : undefined,
            BaseFrequency: isSet(object.BaseFrequency) ? exports.Uint64Constraint.fromJSON(object.BaseFrequency) : undefined,
            L2: isSet(object.L2) ? exports.Uint64Constraint.fromJSON(object.L2) : undefined,
            cores: isSet(object.cores) ? exports.Uint32Constraint.fromJSON(object.cores) : undefined,
            threads: isSet(object.threads) ? exports.Uint32Constraint.fromJSON(object.threads) : undefined,
            tdp: isSet(object.tdp) ? exports.Uint32Constraint.fromJSON(object.tdp) : undefined,
            sockets: isSet(object.sockets) ? exports.Uint32Constraint.fromJSON(object.sockets) : undefined,
            hyperthreaded: isSet(object.hyperthreaded) ? exports.BoolConstraint.fromJSON(object.hyperthreaded) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.isa !== undefined && (obj.isa = message.isa ? exports.ISAConstraint.toJSON(message.isa) : undefined);
        message.family !== undefined && (obj.family = message.family ? exports.StringConstraint.toJSON(message.family) : undefined);
        message.BaseFrequency !== undefined &&
            (obj.BaseFrequency = message.BaseFrequency ? exports.Uint64Constraint.toJSON(message.BaseFrequency) : undefined);
        message.L2 !== undefined && (obj.L2 = message.L2 ? exports.Uint64Constraint.toJSON(message.L2) : undefined);
        message.cores !== undefined && (obj.cores = message.cores ? exports.Uint32Constraint.toJSON(message.cores) : undefined);
        message.threads !== undefined &&
            (obj.threads = message.threads ? exports.Uint32Constraint.toJSON(message.threads) : undefined);
        message.tdp !== undefined && (obj.tdp = message.tdp ? exports.Uint32Constraint.toJSON(message.tdp) : undefined);
        message.sockets !== undefined &&
            (obj.sockets = message.sockets ? exports.Uint32Constraint.toJSON(message.sockets) : undefined);
        message.hyperthreaded !== undefined &&
            (obj.hyperthreaded = message.hyperthreaded ? exports.BoolConstraint.toJSON(message.hyperthreaded) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.ProcSpec.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var message = createBaseProcSpec();
        message.isa = (object.isa !== undefined && object.isa !== null) ? exports.ISAConstraint.fromPartial(object.isa) : undefined;
        message.family = (object.family !== undefined && object.family !== null)
            ? exports.StringConstraint.fromPartial(object.family)
            : undefined;
        message.BaseFrequency = (object.BaseFrequency !== undefined && object.BaseFrequency !== null)
            ? exports.Uint64Constraint.fromPartial(object.BaseFrequency)
            : undefined;
        message.L2 = (object.L2 !== undefined && object.L2 !== null) ? exports.Uint64Constraint.fromPartial(object.L2) : undefined;
        message.cores = (object.cores !== undefined && object.cores !== null)
            ? exports.Uint32Constraint.fromPartial(object.cores)
            : undefined;
        message.threads = (object.threads !== undefined && object.threads !== null)
            ? exports.Uint32Constraint.fromPartial(object.threads)
            : undefined;
        message.tdp = (object.tdp !== undefined && object.tdp !== null)
            ? exports.Uint32Constraint.fromPartial(object.tdp)
            : undefined;
        message.sockets = (object.sockets !== undefined && object.sockets !== null)
            ? exports.Uint32Constraint.fromPartial(object.sockets)
            : undefined;
        message.hyperthreaded = (object.hyperthreaded !== undefined && object.hyperthreaded !== null)
            ? exports.BoolConstraint.fromPartial(object.hyperthreaded)
            : undefined;
        return message;
    }
};
function createBaseDimm() {
    return { type: 0, capacity: 0, frequency: 0, productInfo: undefined, reservedCapacity: 0 };
}
exports.Dimm = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.capacity !== 0) {
            writer.uint32(16).uint64(message.capacity);
        }
        if (message.frequency !== 0) {
            writer.uint32(24).uint64(message.frequency);
        }
        if (message.productInfo !== undefined) {
            exports.ProductInfo.encode(message.productInfo, writer.uint32(34).fork()).ldelim();
        }
        if (message.reservedCapacity !== 0) {
            writer.uint32(40).uint64(message.reservedCapacity);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDimm();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.capacity = longToNumber(reader.uint64());
                    break;
                case 3:
                    message.frequency = longToNumber(reader.uint64());
                    break;
                case 4:
                    message.productInfo = exports.ProductInfo.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.reservedCapacity = longToNumber(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            type: isSet(object.type) ? memoryTypeFromJSON(object.type) : 0,
            capacity: isSet(object.capacity) ? Number(object.capacity) : 0,
            frequency: isSet(object.frequency) ? Number(object.frequency) : 0,
            productInfo: isSet(object.productInfo) ? exports.ProductInfo.fromJSON(object.productInfo) : undefined,
            reservedCapacity: isSet(object.reservedCapacity) ? Number(object.reservedCapacity) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.type !== undefined && (obj.type = memoryTypeToJSON(message.type));
        message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
        message.frequency !== undefined && (obj.frequency = Math.round(message.frequency));
        message.productInfo !== undefined &&
            (obj.productInfo = message.productInfo ? exports.ProductInfo.toJSON(message.productInfo) : undefined);
        message.reservedCapacity !== undefined && (obj.reservedCapacity = Math.round(message.reservedCapacity));
        return obj;
    },
    create: function (base) {
        return exports.Dimm.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = createBaseDimm();
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
        message.capacity = (_b = object.capacity) !== null && _b !== void 0 ? _b : 0;
        message.frequency = (_c = object.frequency) !== null && _c !== void 0 ? _c : 0;
        message.productInfo = (object.productInfo !== undefined && object.productInfo !== null)
            ? exports.ProductInfo.fromPartial(object.productInfo)
            : undefined;
        message.reservedCapacity = (_d = object.reservedCapacity) !== null && _d !== void 0 ? _d : 0;
        return message;
    }
};
function createBaseDimmAllocation() {
    return { capacity: 0 };
}
exports.DimmAllocation = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.capacity !== 0) {
            writer.uint32(8).uint64(message.capacity);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDimmAllocation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.capacity = longToNumber(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { capacity: isSet(object.capacity) ? Number(object.capacity) : 0 };
    },
    toJSON: function (message) {
        var obj = {};
        message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
        return obj;
    },
    create: function (base) {
        return exports.DimmAllocation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseDimmAllocation();
        message.capacity = (_a = object.capacity) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBaseMemoryAllocation() {
    return { alloc: {} };
}
exports.MemoryAllocation = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        Object.entries(message.alloc).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.MemoryAllocation_AllocEntry.encode({ key: key, value: value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseMemoryAllocation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    var entry1 = exports.MemoryAllocation_AllocEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.alloc[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            alloc: isObject(object.alloc)
                ? Object.entries(object.alloc).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[Number(key)] = exports.DimmAllocation.fromJSON(value);
                    return acc;
                }, {})
                : {}
        };
    },
    toJSON: function (message) {
        var obj = {};
        obj.alloc = {};
        if (message.alloc) {
            Object.entries(message.alloc).forEach(function (_a) {
                var k = _a[0], v = _a[1];
                obj.alloc[k] = exports.DimmAllocation.toJSON(v);
            });
        }
        return obj;
    },
    create: function (base) {
        return exports.MemoryAllocation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseMemoryAllocation();
        message.alloc = Object.entries((_a = object.alloc) !== null && _a !== void 0 ? _a : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[Number(key)] = exports.DimmAllocation.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    }
};
function createBaseMemoryAllocation_AllocEntry() {
    return { key: 0, value: undefined };
}
exports.MemoryAllocation_AllocEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.key !== 0) {
            writer.uint32(8).uint32(message.key);
        }
        if (message.value !== undefined) {
            exports.DimmAllocation.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseMemoryAllocation_AllocEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.uint32();
                    break;
                case 2:
                    message.value = exports.DimmAllocation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? Number(object.key) : 0,
            value: isSet(object.value) ? exports.DimmAllocation.fromJSON(object.value) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.key !== undefined && (obj.key = Math.round(message.key));
        message.value !== undefined && (obj.value = message.value ? exports.DimmAllocation.toJSON(message.value) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.MemoryAllocation_AllocEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseMemoryAllocation_AllocEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : 0;
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.DimmAllocation.fromPartial(object.value)
            : undefined;
        return message;
    }
};
function createBaseMemorySpec() {
    return { type: undefined, capacity: undefined, frequency: undefined, modules: undefined };
}
exports.MemorySpec = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.type !== undefined) {
            exports.MemoryTypeConstraint.encode(message.type, writer.uint32(10).fork()).ldelim();
        }
        if (message.capacity !== undefined) {
            exports.Uint64Constraint.encode(message.capacity, writer.uint32(18).fork()).ldelim();
        }
        if (message.frequency !== undefined) {
            exports.Uint64Constraint.encode(message.frequency, writer.uint32(26).fork()).ldelim();
        }
        if (message.modules !== undefined) {
            exports.Uint64Constraint.encode(message.modules, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseMemorySpec();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = exports.MemoryTypeConstraint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.capacity = exports.Uint64Constraint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.frequency = exports.Uint64Constraint.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.modules = exports.Uint64Constraint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            type: isSet(object.type) ? exports.MemoryTypeConstraint.fromJSON(object.type) : undefined,
            capacity: isSet(object.capacity) ? exports.Uint64Constraint.fromJSON(object.capacity) : undefined,
            frequency: isSet(object.frequency) ? exports.Uint64Constraint.fromJSON(object.frequency) : undefined,
            modules: isSet(object.modules) ? exports.Uint64Constraint.fromJSON(object.modules) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.type !== undefined && (obj.type = message.type ? exports.MemoryTypeConstraint.toJSON(message.type) : undefined);
        message.capacity !== undefined &&
            (obj.capacity = message.capacity ? exports.Uint64Constraint.toJSON(message.capacity) : undefined);
        message.frequency !== undefined &&
            (obj.frequency = message.frequency ? exports.Uint64Constraint.toJSON(message.frequency) : undefined);
        message.modules !== undefined &&
            (obj.modules = message.modules ? exports.Uint64Constraint.toJSON(message.modules) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.MemorySpec.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var message = createBaseMemorySpec();
        message.type = (object.type !== undefined && object.type !== null)
            ? exports.MemoryTypeConstraint.fromPartial(object.type)
            : undefined;
        message.capacity = (object.capacity !== undefined && object.capacity !== null)
            ? exports.Uint64Constraint.fromPartial(object.capacity)
            : undefined;
        message.frequency = (object.frequency !== undefined && object.frequency !== null)
            ? exports.Uint64Constraint.fromPartial(object.frequency)
            : undefined;
        message.modules = (object.modules !== undefined && object.modules !== null)
            ? exports.Uint64Constraint.fromPartial(object.modules)
            : undefined;
        return message;
    }
};
function createBaseNIC() {
    return { ports: [], startingIndex: 0, kind: 0, productInfo: undefined, DPDK: false, model: 0 };
}
exports.NIC = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        for (var _i = 0, _a = message.ports; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.Port.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.startingIndex !== 0) {
            writer.uint32(16).uint32(message.startingIndex);
        }
        if (message.kind !== 0) {
            writer.uint32(24).int32(message.kind);
        }
        if (message.productInfo !== undefined) {
            exports.ProductInfo.encode(message.productInfo, writer.uint32(34).fork()).ldelim();
        }
        if (message.DPDK === true) {
            writer.uint32(40).bool(message.DPDK);
        }
        if (message.model !== 0) {
            writer.uint32(48).int32(message.model);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseNIC();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ports.push(exports.Port.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.startingIndex = reader.uint32();
                    break;
                case 3:
                    message.kind = reader.int32();
                    break;
                case 4:
                    message.productInfo = exports.ProductInfo.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.DPDK = reader.bool();
                    break;
                case 6:
                    message.model = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            ports: Array.isArray(object === null || object === void 0 ? void 0 : object.ports) ? object.ports.map(function (e) { return exports.Port.fromJSON(e); }) : [],
            startingIndex: isSet(object.startingIndex) ? Number(object.startingIndex) : 0,
            kind: isSet(object.kind) ? nICKindFromJSON(object.kind) : 0,
            productInfo: isSet(object.productInfo) ? exports.ProductInfo.fromJSON(object.productInfo) : undefined,
            DPDK: isSet(object.DPDK) ? Boolean(object.DPDK) : false,
            model: isSet(object.model) ? nICModelFromJSON(object.model) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.ports) {
            obj.ports = message.ports.map(function (e) { return e ? exports.Port.toJSON(e) : undefined; });
        }
        else {
            obj.ports = [];
        }
        message.startingIndex !== undefined && (obj.startingIndex = Math.round(message.startingIndex));
        message.kind !== undefined && (obj.kind = nICKindToJSON(message.kind));
        message.productInfo !== undefined &&
            (obj.productInfo = message.productInfo ? exports.ProductInfo.toJSON(message.productInfo) : undefined);
        message.DPDK !== undefined && (obj.DPDK = message.DPDK);
        message.model !== undefined && (obj.model = nICModelToJSON(message.model));
        return obj;
    },
    create: function (base) {
        return exports.NIC.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e;
        var message = createBaseNIC();
        message.ports = ((_a = object.ports) === null || _a === void 0 ? void 0 : _a.map(function (e) { return exports.Port.fromPartial(e); })) || [];
        message.startingIndex = (_b = object.startingIndex) !== null && _b !== void 0 ? _b : 0;
        message.kind = (_c = object.kind) !== null && _c !== void 0 ? _c : 0;
        message.productInfo = (object.productInfo !== undefined && object.productInfo !== null)
            ? exports.ProductInfo.fromPartial(object.productInfo)
            : undefined;
        message.DPDK = (_d = object.DPDK) !== null && _d !== void 0 ? _d : false;
        message.model = (_e = object.model) !== null && _e !== void 0 ? _e : 0;
        return message;
    }
};
function createBaseNICSpec() {
    return { ports: [] };
}
exports.NICSpec = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        for (var _i = 0, _a = message.ports; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.PortSpec.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseNICSpec();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ports.push(exports.PortSpec.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { ports: Array.isArray(object === null || object === void 0 ? void 0 : object.ports) ? object.ports.map(function (e) { return exports.PortSpec.fromJSON(e); }) : [] };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.ports) {
            obj.ports = message.ports.map(function (e) { return e ? exports.PortSpec.toJSON(e) : undefined; });
        }
        else {
            obj.ports = [];
        }
        return obj;
    },
    create: function (base) {
        return exports.NICSpec.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseNICSpec();
        message.ports = ((_a = object.ports) === null || _a === void 0 ? void 0 : _a.map(function (e) { return exports.PortSpec.fromPartial(e); })) || [];
        return message;
    }
};
function createBaseNICAllocation() {
    return { alloc: {} };
}
exports.NICAllocation = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        Object.entries(message.alloc).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.NICAllocation_AllocEntry.encode({ key: key, value: value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseNICAllocation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    var entry1 = exports.NICAllocation_AllocEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.alloc[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            alloc: isObject(object.alloc)
                ? Object.entries(object.alloc).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[Number(key)] = exports.PortAllocation.fromJSON(value);
                    return acc;
                }, {})
                : {}
        };
    },
    toJSON: function (message) {
        var obj = {};
        obj.alloc = {};
        if (message.alloc) {
            Object.entries(message.alloc).forEach(function (_a) {
                var k = _a[0], v = _a[1];
                obj.alloc[k] = exports.PortAllocation.toJSON(v);
            });
        }
        return obj;
    },
    create: function (base) {
        return exports.NICAllocation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseNICAllocation();
        message.alloc = Object.entries((_a = object.alloc) !== null && _a !== void 0 ? _a : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[Number(key)] = exports.PortAllocation.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    }
};
function createBaseNICAllocation_AllocEntry() {
    return { key: 0, value: undefined };
}
exports.NICAllocation_AllocEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.key !== 0) {
            writer.uint32(8).uint32(message.key);
        }
        if (message.value !== undefined) {
            exports.PortAllocation.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseNICAllocation_AllocEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.uint32();
                    break;
                case 2:
                    message.value = exports.PortAllocation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? Number(object.key) : 0,
            value: isSet(object.value) ? exports.PortAllocation.fromJSON(object.value) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.key !== undefined && (obj.key = Math.round(message.key));
        message.value !== undefined && (obj.value = message.value ? exports.PortAllocation.toJSON(message.value) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.NICAllocation_AllocEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseNICAllocation_AllocEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : 0;
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.PortAllocation.fromPartial(object.value)
            : undefined;
        return message;
    }
};
function createBaseNICsAllocation() {
    return { alloc: {} };
}
exports.NICsAllocation = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        Object.entries(message.alloc).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.NICsAllocation_AllocEntry.encode({ key: key, value: value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseNICsAllocation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    var entry1 = exports.NICsAllocation_AllocEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.alloc[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            alloc: isObject(object.alloc)
                ? Object.entries(object.alloc).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[Number(key)] = exports.NICAllocation.fromJSON(value);
                    return acc;
                }, {})
                : {}
        };
    },
    toJSON: function (message) {
        var obj = {};
        obj.alloc = {};
        if (message.alloc) {
            Object.entries(message.alloc).forEach(function (_a) {
                var k = _a[0], v = _a[1];
                obj.alloc[k] = exports.NICAllocation.toJSON(v);
            });
        }
        return obj;
    },
    create: function (base) {
        return exports.NICsAllocation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseNICsAllocation();
        message.alloc = Object.entries((_a = object.alloc) !== null && _a !== void 0 ? _a : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[Number(key)] = exports.NICAllocation.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    }
};
function createBaseNICsAllocation_AllocEntry() {
    return { key: 0, value: undefined };
}
exports.NICsAllocation_AllocEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.key !== 0) {
            writer.uint32(8).uint32(message.key);
        }
        if (message.value !== undefined) {
            exports.NICAllocation.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseNICsAllocation_AllocEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.uint32();
                    break;
                case 2:
                    message.value = exports.NICAllocation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? Number(object.key) : 0,
            value: isSet(object.value) ? exports.NICAllocation.fromJSON(object.value) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.key !== undefined && (obj.key = Math.round(message.key));
        message.value !== undefined && (obj.value = message.value ? exports.NICAllocation.toJSON(message.value) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.NICsAllocation_AllocEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseNICsAllocation_AllocEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : 0;
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.NICAllocation.fromPartial(object.value)
            : undefined;
        return message;
    }
};
function createBaseDisk() {
    return { capacity: 0, formFactor: 0, diskInterface: 0, productInfo: undefined, roles: [], NVMEControllerIndex: 0 };
}
exports.Disk = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.capacity !== 0) {
            writer.uint32(8).uint64(message.capacity);
        }
        if (message.formFactor !== 0) {
            writer.uint32(16).int32(message.formFactor);
        }
        if (message.diskInterface !== 0) {
            writer.uint32(24).int32(message.diskInterface);
        }
        if (message.productInfo !== undefined) {
            exports.ProductInfo.encode(message.productInfo, writer.uint32(34).fork()).ldelim();
        }
        writer.uint32(42).fork();
        for (var _i = 0, _a = message.roles; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.int32(v);
        }
        writer.ldelim();
        if (message.NVMEControllerIndex !== 0) {
            writer.uint32(48).uint32(message.NVMEControllerIndex);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDisk();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.capacity = longToNumber(reader.uint64());
                    break;
                case 2:
                    message.formFactor = reader.int32();
                    break;
                case 3:
                    message.diskInterface = reader.int32();
                    break;
                case 4:
                    message.productInfo = exports.ProductInfo.decode(reader, reader.uint32());
                    break;
                case 5:
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.roles.push(reader.int32());
                        }
                    }
                    else {
                        message.roles.push(reader.int32());
                    }
                    break;
                case 6:
                    message.NVMEControllerIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            capacity: isSet(object.capacity) ? Number(object.capacity) : 0,
            formFactor: isSet(object.formFactor) ? diskFormFactorFromJSON(object.formFactor) : 0,
            diskInterface: isSet(object.diskInterface) ? diskInterfaceFromJSON(object.diskInterface) : 0,
            productInfo: isSet(object.productInfo) ? exports.ProductInfo.fromJSON(object.productInfo) : undefined,
            roles: Array.isArray(object === null || object === void 0 ? void 0 : object.roles) ? object.roles.map(function (e) { return diskRoleFromJSON(e); }) : [],
            NVMEControllerIndex: isSet(object.NVMEControllerIndex) ? Number(object.NVMEControllerIndex) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
        message.formFactor !== undefined && (obj.formFactor = diskFormFactorToJSON(message.formFactor));
        message.diskInterface !== undefined && (obj.diskInterface = diskInterfaceToJSON(message.diskInterface));
        message.productInfo !== undefined &&
            (obj.productInfo = message.productInfo ? exports.ProductInfo.toJSON(message.productInfo) : undefined);
        if (message.roles) {
            obj.roles = message.roles.map(function (e) { return diskRoleToJSON(e); });
        }
        else {
            obj.roles = [];
        }
        message.NVMEControllerIndex !== undefined && (obj.NVMEControllerIndex = Math.round(message.NVMEControllerIndex));
        return obj;
    },
    create: function (base) {
        return exports.Disk.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e;
        var message = createBaseDisk();
        message.capacity = (_a = object.capacity) !== null && _a !== void 0 ? _a : 0;
        message.formFactor = (_b = object.formFactor) !== null && _b !== void 0 ? _b : 0;
        message.diskInterface = (_c = object.diskInterface) !== null && _c !== void 0 ? _c : 0;
        message.productInfo = (object.productInfo !== undefined && object.productInfo !== null)
            ? exports.ProductInfo.fromPartial(object.productInfo)
            : undefined;
        message.roles = ((_d = object.roles) === null || _d === void 0 ? void 0 : _d.map(function (e) { return e; })) || [];
        message.NVMEControllerIndex = (_e = object.NVMEControllerIndex) !== null && _e !== void 0 ? _e : 0;
        return message;
    }
};
function createBaseDiskAllocation() {
    return { capacity: 0 };
}
exports.DiskAllocation = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.capacity !== 0) {
            writer.uint32(8).uint64(message.capacity);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDiskAllocation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.capacity = longToNumber(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { capacity: isSet(object.capacity) ? Number(object.capacity) : 0 };
    },
    toJSON: function (message) {
        var obj = {};
        message.capacity !== undefined && (obj.capacity = Math.round(message.capacity));
        return obj;
    },
    create: function (base) {
        return exports.DiskAllocation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseDiskAllocation();
        message.capacity = (_a = object.capacity) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBaseDisksAllocation() {
    return { alloc: {} };
}
exports.DisksAllocation = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        Object.entries(message.alloc).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.DisksAllocation_AllocEntry.encode({ key: key, value: value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDisksAllocation();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    var entry1 = exports.DisksAllocation_AllocEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.alloc[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            alloc: isObject(object.alloc)
                ? Object.entries(object.alloc).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[Number(key)] = exports.DiskAllocation.fromJSON(value);
                    return acc;
                }, {})
                : {}
        };
    },
    toJSON: function (message) {
        var obj = {};
        obj.alloc = {};
        if (message.alloc) {
            Object.entries(message.alloc).forEach(function (_a) {
                var k = _a[0], v = _a[1];
                obj.alloc[k] = exports.DiskAllocation.toJSON(v);
            });
        }
        return obj;
    },
    create: function (base) {
        return exports.DisksAllocation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseDisksAllocation();
        message.alloc = Object.entries((_a = object.alloc) !== null && _a !== void 0 ? _a : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[Number(key)] = exports.DiskAllocation.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    }
};
function createBaseDisksAllocation_AllocEntry() {
    return { key: 0, value: undefined };
}
exports.DisksAllocation_AllocEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.key !== 0) {
            writer.uint32(8).uint32(message.key);
        }
        if (message.value !== undefined) {
            exports.DiskAllocation.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDisksAllocation_AllocEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.uint32();
                    break;
                case 2:
                    message.value = exports.DiskAllocation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? Number(object.key) : 0,
            value: isSet(object.value) ? exports.DiskAllocation.fromJSON(object.value) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.key !== undefined && (obj.key = Math.round(message.key));
        message.value !== undefined && (obj.value = message.value ? exports.DiskAllocation.toJSON(message.value) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.DisksAllocation_AllocEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseDisksAllocation_AllocEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : 0;
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.DiskAllocation.fromPartial(object.value)
            : undefined;
        return message;
    }
};
function createBaseDiskSpec() {
    return { capacity: undefined, formFactor: undefined, diskInterface: undefined, disks: undefined };
}
exports.DiskSpec = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.capacity !== undefined) {
            exports.Uint64Constraint.encode(message.capacity, writer.uint32(10).fork()).ldelim();
        }
        if (message.formFactor !== undefined) {
            exports.DiskFormFactorConstraint.encode(message.formFactor, writer.uint32(18).fork()).ldelim();
        }
        if (message.diskInterface !== undefined) {
            exports.DiskInterfaceConstraint.encode(message.diskInterface, writer.uint32(26).fork()).ldelim();
        }
        if (message.disks !== undefined) {
            exports.Uint64Constraint.encode(message.disks, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDiskSpec();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.capacity = exports.Uint64Constraint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.formFactor = exports.DiskFormFactorConstraint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.diskInterface = exports.DiskInterfaceConstraint.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.disks = exports.Uint64Constraint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            capacity: isSet(object.capacity) ? exports.Uint64Constraint.fromJSON(object.capacity) : undefined,
            formFactor: isSet(object.formFactor) ? exports.DiskFormFactorConstraint.fromJSON(object.formFactor) : undefined,
            diskInterface: isSet(object.diskInterface) ? exports.DiskInterfaceConstraint.fromJSON(object.diskInterface) : undefined,
            disks: isSet(object.disks) ? exports.Uint64Constraint.fromJSON(object.disks) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.capacity !== undefined &&
            (obj.capacity = message.capacity ? exports.Uint64Constraint.toJSON(message.capacity) : undefined);
        message.formFactor !== undefined &&
            (obj.formFactor = message.formFactor ? exports.DiskFormFactorConstraint.toJSON(message.formFactor) : undefined);
        message.diskInterface !== undefined &&
            (obj.diskInterface = message.diskInterface ? exports.DiskInterfaceConstraint.toJSON(message.diskInterface) : undefined);
        message.disks !== undefined && (obj.disks = message.disks ? exports.Uint64Constraint.toJSON(message.disks) : undefined);
        return obj;
    },
    create: function (base) {
        return exports.DiskSpec.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var message = createBaseDiskSpec();
        message.capacity = (object.capacity !== undefined && object.capacity !== null)
            ? exports.Uint64Constraint.fromPartial(object.capacity)
            : undefined;
        message.formFactor = (object.formFactor !== undefined && object.formFactor !== null)
            ? exports.DiskFormFactorConstraint.fromPartial(object.formFactor)
            : undefined;
        message.diskInterface = (object.diskInterface !== undefined && object.diskInterface !== null)
            ? exports.DiskInterfaceConstraint.fromPartial(object.diskInterface)
            : undefined;
        message.disks = (object.disks !== undefined && object.disks !== null)
            ? exports.Uint64Constraint.fromPartial(object.disks)
            : undefined;
        return message;
    }
};
function createBaseBoolConstraint() {
    return { op: 0, value: false };
}
exports.BoolConstraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value === true) {
            writer.uint32(16).bool(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBoolConstraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? Boolean(object.value) : false
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    create: function (base) {
        return exports.BoolConstraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseBoolConstraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : false;
        return message;
    }
};
function createBaseStringConstraint() {
    return { op: 0, value: "" };
}
exports.StringConstraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseStringConstraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? String(object.value) : ""
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    create: function (base) {
        return exports.StringConstraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseStringConstraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseUint64Constraint() {
    return { op: 0, value: 0 };
}
exports.Uint64Constraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value !== 0) {
            writer.uint32(16).uint64(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseUint64Constraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = longToNumber(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? Number(object.value) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = Math.round(message.value));
        return obj;
    },
    create: function (base) {
        return exports.Uint64Constraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseUint64Constraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseLinkKindConstraint() {
    return { op: 0, value: 0 };
}
exports.LinkKindConstraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseLinkKindConstraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? link_KindFromJSON(object.value) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = link_KindToJSON(message.value));
        return obj;
    },
    create: function (base) {
        return exports.LinkKindConstraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseLinkKindConstraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseUint32Constraint() {
    return { op: 0, value: 0 };
}
exports.Uint32Constraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value !== 0) {
            writer.uint32(16).uint32(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseUint32Constraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? Number(object.value) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = Math.round(message.value));
        return obj;
    },
    create: function (base) {
        return exports.Uint32Constraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseUint32Constraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseISAConstraint() {
    return { op: 0, value: 0 };
}
exports.ISAConstraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseISAConstraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? iSAFromJSON(object.value) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = iSAToJSON(message.value));
        return obj;
    },
    create: function (base) {
        return exports.ISAConstraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseISAConstraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseMemoryTypeConstraint() {
    return { op: 0, value: 0 };
}
exports.MemoryTypeConstraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseMemoryTypeConstraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? memoryTypeFromJSON(object.value) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = memoryTypeToJSON(message.value));
        return obj;
    },
    create: function (base) {
        return exports.MemoryTypeConstraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseMemoryTypeConstraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseNICModelConstraint() {
    return { op: 0, value: 0 };
}
exports.NICModelConstraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseNICModelConstraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? nICModelFromJSON(object.value) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = nICModelToJSON(message.value));
        return obj;
    },
    create: function (base) {
        return exports.NICModelConstraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseNICModelConstraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseDiskFormFactorConstraint() {
    return { op: 0, value: 0 };
}
exports.DiskFormFactorConstraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDiskFormFactorConstraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? diskFormFactorFromJSON(object.value) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = diskFormFactorToJSON(message.value));
        return obj;
    },
    create: function (base) {
        return exports.DiskFormFactorConstraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseDiskFormFactorConstraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseDiskInterfaceConstraint() {
    return { op: 0, value: 0 };
}
exports.DiskInterfaceConstraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDiskInterfaceConstraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? diskInterfaceFromJSON(object.value) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = diskInterfaceToJSON(message.value));
        return obj;
    },
    create: function (base) {
        return exports.DiskInterfaceConstraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseDiskInterfaceConstraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseConnectorKindConstraint() {
    return { op: 0, value: 0 };
}
exports.ConnectorKindConstraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseConnectorKindConstraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? connectorKindFromJSON(object.value) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = connectorKindToJSON(message.value));
        return obj;
    },
    create: function (base) {
        return exports.ConnectorKindConstraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseConnectorKindConstraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseFloatConstraint() {
    return { op: 0, value: 0 };
}
exports.FloatConstraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value !== 0) {
            writer.uint32(21).float(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseFloatConstraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? Number(object.value) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    create: function (base) {
        return exports.FloatConstraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseFloatConstraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseRoutingConstraint() {
    return { op: 0, value: 0 };
}
exports.RoutingConstraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseRoutingConstraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? routingFromJSON(object.value) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = routingToJSON(message.value));
        return obj;
    },
    create: function (base) {
        return exports.RoutingConstraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseRoutingConstraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseAddressingConstraint() {
    return { op: 0, value: 0 };
}
exports.AddressingConstraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseAddressingConstraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? addressingFromJSON(object.value) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = addressingToJSON(message.value));
        return obj;
    },
    create: function (base) {
        return exports.AddressingConstraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseAddressingConstraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseEmulationConstraint() {
    return { op: 0, value: 0 };
}
exports.EmulationConstraint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.op !== 0) {
            writer.uint32(8).int32(message.op);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEmulationConstraint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.op = reader.int32();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            op: isSet(object.op) ? operatorFromJSON(object.op) : 0,
            value: isSet(object.value) ? emulationFromJSON(object.value) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.op !== undefined && (obj.op = operatorToJSON(message.op));
        message.value !== undefined && (obj.value = emulationToJSON(message.value));
        return obj;
    },
    create: function (base) {
        return exports.EmulationConstraint.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseEmulationConstraint();
        message.op = (_a = object.op) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
var tsProtoGlobalThis = (function () {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (minimal_1["default"].util.Long !== long_1["default"]) {
    minimal_1["default"].util.Long = long_1["default"];
    minimal_1["default"].configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
