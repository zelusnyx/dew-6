/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Duration } from "../../../google/protobuf/duration";
import { Timestamp } from "../../../google/protobuf/timestamp";

export const protobufPackage = "reconcile";

/** ReconcilerOp is so we tell the reconciler's main function what we're doing, for synchronization. */
export enum ReconcilerOp {
  Undefined = 0,
  Idle = 1,
  Init = 2,
  Create = 3,
  Update = 4,
  Delete = 5,
  Ensure = 6,
  Health = 7,
  Pollcheck = 8,
  UNRECOGNIZED = -1,
}

export function reconcilerOpFromJSON(object: any): ReconcilerOp {
  switch (object) {
    case 0:
    case "Undefined":
      return ReconcilerOp.Undefined;
    case 1:
    case "Idle":
      return ReconcilerOp.Idle;
    case 2:
    case "Init":
      return ReconcilerOp.Init;
    case 3:
    case "Create":
      return ReconcilerOp.Create;
    case 4:
    case "Update":
      return ReconcilerOp.Update;
    case 5:
    case "Delete":
      return ReconcilerOp.Delete;
    case 6:
    case "Ensure":
      return ReconcilerOp.Ensure;
    case 7:
    case "Health":
      return ReconcilerOp.Health;
    case 8:
    case "Pollcheck":
      return ReconcilerOp.Pollcheck;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReconcilerOp.UNRECOGNIZED;
  }
}

export function reconcilerOpToJSON(object: ReconcilerOp): string {
  switch (object) {
    case ReconcilerOp.Undefined:
      return "Undefined";
    case ReconcilerOp.Idle:
      return "Idle";
    case ReconcilerOp.Init:
      return "Init";
    case ReconcilerOp.Create:
      return "Create";
    case ReconcilerOp.Update:
      return "Update";
    case ReconcilerOp.Delete:
      return "Delete";
    case ReconcilerOp.Ensure:
      return "Ensure";
    case ReconcilerOp.Health:
      return "Health";
    case ReconcilerOp.Pollcheck:
      return "Pollcheck";
    case ReconcilerOp.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * TaskGoal is either a Supergoal or a Supertask. All tasks happen under a Supertask:
 * For example,
 *   - /users/murphy
 *     - is a Supertask to create the user murphy
 *   - /users/murphy/mergefs/userhome
 *     - is a Task needed to accomplish the goal of creating the user murphy
 *
 * TaskGoal may alternatively be a Supergoal, in which other goals occur under.
 * For example:
 *   - A Materialization would be a Supergoal
 *   - Sledding the all of the images for a materialization would be a supertask
 *
 * Goals are created at the highest level, usually by an apiserver handler
 * Reconcilers should never create goals, they should only create subtasks
 */
export interface TaskGoal {
  /** The etcd key used (without the taskgoal prefix) */
  SelfKey: string;
  /** The goal's name, used for display */
  Name: string;
  /** A description of the goal, used for display */
  Desc: string;
  /** The type of goal this is */
  Type: TaskGoal_GoalType;
  /** Version of the etcd key, used for the storage interface. */
  SelfVersion: number;
  /** When the goal was first created. */
  Creation:
    | Date
    | undefined;
  /** The last time the goal was written. */
  When:
    | Date
    | undefined;
  /** The etcd subkeys of the goal. Prefixes to these subkeys are determined by the GoalType. */
  Subkeys: string[];
}

export enum TaskGoal_GoalType {
  Undefined = 0,
  /** Supergoal - Used for a super large goal, e.g. a materialization */
  Supergoal = 1,
  /** Supertask - Used for a goals that directly manage tasks, e.g. sled\ */
  Supertask = 2,
  UNRECOGNIZED = -1,
}

export function taskGoal_GoalTypeFromJSON(object: any): TaskGoal_GoalType {
  switch (object) {
    case 0:
    case "Undefined":
      return TaskGoal_GoalType.Undefined;
    case 1:
    case "Supergoal":
      return TaskGoal_GoalType.Supergoal;
    case 2:
    case "Supertask":
      return TaskGoal_GoalType.Supertask;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskGoal_GoalType.UNRECOGNIZED;
  }
}

export function taskGoal_GoalTypeToJSON(object: TaskGoal_GoalType): string {
  switch (object) {
    case TaskGoal_GoalType.Undefined:
      return "Undefined";
    case TaskGoal_GoalType.Supergoal:
      return "Supergoal";
    case TaskGoal_GoalType.Supertask:
      return "Supertask";
    case TaskGoal_GoalType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A TaskStatus is an individual step that changes the state of something to accomplish a goal. */
export interface TaskStatus {
  /** Name of the task manager for this task, AKA the reconciler name. */
  Manager: string;
  /** A short name for the task itself. */
  Name: string;
  /** A longer description of the task. Meant for human consumption. */
  Desc: string;
  /** The status of the last handle operation. */
  LastStatus: TaskStatus_StatusType;
  /** This is the value to set if you want to manually specify the status of a Task. */
  SelfVersion: number;
  /** Last reconciled version of the task key */
  TaskVersion: number;
  /** The previous value reconciled. */
  PrevValue: Uint8Array;
  /**
   * Used to determine if the status is actually up to date
   *   and when a key is deleted while the reconciler is offline
   *   so we know what exactly to teardown.
   *
   * When a TaskStatus is used inside of a TaskTree, this is set to nil
   *   to save data and to not expose these to users.
   */
  Duration:
    | Duration
    | undefined;
  /** timestamp of task */
  When:
    | Date
    | undefined;
  /** The specific etcd key for this task. e.g. /users/murphy */
  TaskKey: string;
  /** as opposed to a key under which keys are put, i.e. /users/ */
  SubtaskKeys: string[];
  /** Informational strings about the status of the task. */
  Messages: TaskMessage[];
  /** Meant for human consumption. "Couldn't create /home/murphy". */
  CurrentStatus: TaskStatus_StatusType;
  /**
   * Because the value of this depends on when the TaskStatus is read,
   *   this value will be overwritten when the TaskStatus is read.
   * So, if you want to manually set the Status of a TaskStatus for use in etcd,
   *   DO NOT SET THIS VALUE, set LastStatus instead.
   *
   * The value of this depends on:
   *  - the version and value of the currently written task key
   *    - if they don't match, the status is "Pending"
   *  - if the reconciler doesn't seem to be alive, the status is "Unresponsive."
   *  - otherwise, this is identical to LastStatus
   */
  TaskRevision: number;
}

/** These are listed in order of increasing priority */
export enum TaskStatus_StatusType {
  /** Undefined - Unknown status type */
  Undefined = 0,
  /** Success - The key handler has successfully handled a put */
  Success = 1,
  /** Deleted - The key handler has successfully handled a delete */
  Deleted = 2,
  /** Pending - The key handler has not yet started handling the key */
  Pending = 3,
  /** Unresponsive - The key handler does not seem to be responsive */
  Unresponsive = 4,
  /** Processing - The key handler is currently in progress */
  Processing = 5,
  /** Error - The key handler has error'ed out */
  Error = 6,
  UNRECOGNIZED = -1,
}

export function taskStatus_StatusTypeFromJSON(object: any): TaskStatus_StatusType {
  switch (object) {
    case 0:
    case "Undefined":
      return TaskStatus_StatusType.Undefined;
    case 1:
    case "Success":
      return TaskStatus_StatusType.Success;
    case 2:
    case "Deleted":
      return TaskStatus_StatusType.Deleted;
    case 3:
    case "Pending":
      return TaskStatus_StatusType.Pending;
    case 4:
    case "Unresponsive":
      return TaskStatus_StatusType.Unresponsive;
    case 5:
    case "Processing":
      return TaskStatus_StatusType.Processing;
    case 6:
    case "Error":
      return TaskStatus_StatusType.Error;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskStatus_StatusType.UNRECOGNIZED;
  }
}

export function taskStatus_StatusTypeToJSON(object: TaskStatus_StatusType): string {
  switch (object) {
    case TaskStatus_StatusType.Undefined:
      return "Undefined";
    case TaskStatus_StatusType.Success:
      return "Success";
    case TaskStatus_StatusType.Deleted:
      return "Deleted";
    case TaskStatus_StatusType.Pending:
      return "Pending";
    case TaskStatus_StatusType.Unresponsive:
      return "Unresponsive";
    case TaskStatus_StatusType.Processing:
      return "Processing";
    case TaskStatus_StatusType.Error:
      return "Error";
    case TaskStatus_StatusType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A container for messages with a severity level */
export interface TaskMessage {
  Level: TaskMessage_Type;
  Message: string;
}

export enum TaskMessage_Type {
  Undefined = 0,
  Error = 1,
  Warning = 2,
  Info = 3,
  Debug = 4,
  Trace = 5,
  UNRECOGNIZED = -1,
}

export function taskMessage_TypeFromJSON(object: any): TaskMessage_Type {
  switch (object) {
    case 0:
    case "Undefined":
      return TaskMessage_Type.Undefined;
    case 1:
    case "Error":
      return TaskMessage_Type.Error;
    case 2:
    case "Warning":
      return TaskMessage_Type.Warning;
    case 3:
    case "Info":
      return TaskMessage_Type.Info;
    case 4:
    case "Debug":
      return TaskMessage_Type.Debug;
    case 5:
    case "Trace":
      return TaskMessage_Type.Trace;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskMessage_Type.UNRECOGNIZED;
  }
}

export function taskMessage_TypeToJSON(object: TaskMessage_Type): string {
  switch (object) {
    case TaskMessage_Type.Undefined:
      return "Undefined";
    case TaskMessage_Type.Error:
      return "Error";
    case TaskMessage_Type.Warning:
      return "Warning";
    case TaskMessage_Type.Info:
      return "Info";
    case TaskMessage_Type.Debug:
      return "Debug";
    case TaskMessage_Type.Trace:
      return "Trace";
    case TaskMessage_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * TaskTree is the tree of tasks spawned by an etcd key entry. It's a collection of task instances and
 * task instances created by those, etc.
 * This is ephermeral, i.e. not stored in minio or etcd and sent when requested.
 */
export interface TaskTree {
  Task:
    | TaskStatus
    | undefined;
  /** The highest level status of task + subtasks */
  HighestStatus: TaskStatus_StatusType;
  /** The last time any of the subtasks/tasks were updated */
  LastUpdated:
    | Date
    | undefined;
  /** The total recursive number of subtasks this and its children has */
  NumChildTasks: number;
  Subtasks: TaskTree[];
}

/**
 * Depending on the Goal Type, Task Forest either:
 *  - Wraps up all goals underneath if it is a supergoal
 *    - For example, all subgoals across a materialization
 *  - Wraps up all tasks underneath if it is a supertask
 *    - For example, all keys across all reconcilers when /users/murphy is created
 * This is ephermeral, i.e. not stored in minio or etcd, and sent when requested.
 */
export interface TaskForest {
  Goal:
    | TaskGoal
    | undefined;
  /** The highest level status of goal + subtasks/subgoals */
  HighestStatus: TaskStatus_StatusType;
  /** The last time any of the subtasks/tasks were updated */
  LastUpdated:
    | Date
    | undefined;
  /** The total recursive number of subtasks this and its children has */
  NumChildTasks: number;
  Subgoals: TaskForest[];
  Subtasks: TaskTree[];
}

/**
 * This is a summary of a TaskForest
 * Used when we want a status of something, but we don't care about the details
 * Usually sent in addition to something, like a materialization
 * This is ephermeral, i.e. not stored in minio or etcd, and sent when requested.
 */
export interface TaskSummary {
  /** The highest level status of goal + subtasks/subgoals */
  HighestStatus: TaskStatus_StatusType;
  /** The first time any of the subtasks/tasks were updated; usually a creation time */
  FirstUpdated:
    | Date
    | undefined;
  /** The last time any of the subtasks/tasks were updated */
  LastUpdated:
    | Date
    | undefined;
  /** Informational strings about the status of the task. */
  Messages: TaskMessage[];
}

/**
 * TODO: Depreciate this.
 * This is currently here for backwards compatibility, so we can convert old statuses to new ones.
 */
export interface DeprStatus {
  /** Status result */
  result: DeprStatus_DeprResultType;
  /** The identity of the worker responsible for reporting on this status. */
  worker: string;
  /** Typically used for error or warning reporting form the worker. */
  info: string;
  /** Version of the state key this status is associated with. */
  version: number;
  /** The reconciler who owns this status. */
  reconciler: string;
  /** The event/type of status this is. */
  event: string;
  /** When the status was recorded */
  when: Date | undefined;
}

export enum DeprStatus_DeprResultType {
  ResultUndefined = 0,
  Working = 1,
  Error = 2,
  Success = 3,
  Stale = 4,
  UNRECOGNIZED = -1,
}

export function deprStatus_DeprResultTypeFromJSON(object: any): DeprStatus_DeprResultType {
  switch (object) {
    case 0:
    case "ResultUndefined":
      return DeprStatus_DeprResultType.ResultUndefined;
    case 1:
    case "Working":
      return DeprStatus_DeprResultType.Working;
    case 2:
    case "Error":
      return DeprStatus_DeprResultType.Error;
    case 3:
    case "Success":
      return DeprStatus_DeprResultType.Success;
    case 4:
    case "Stale":
      return DeprStatus_DeprResultType.Stale;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeprStatus_DeprResultType.UNRECOGNIZED;
  }
}

export function deprStatus_DeprResultTypeToJSON(object: DeprStatus_DeprResultType): string {
  switch (object) {
    case DeprStatus_DeprResultType.ResultUndefined:
      return "ResultUndefined";
    case DeprStatus_DeprResultType.Working:
      return "Working";
    case DeprStatus_DeprResultType.Error:
      return "Error";
    case DeprStatus_DeprResultType.Success:
      return "Success";
    case DeprStatus_DeprResultType.Stale:
      return "Stale";
    case DeprStatus_DeprResultType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * ReconcilerHealth is something that a reconciler periodically checks in on and writes values to.
 * This is used to see if a reconciler has gone rogue, but also for some basic performance metrics.
 */
export interface ReconcilerHealth {
  /** Name of the manager this key belongs to. */
  Manager: string;
  /** Name of the task this belongs to. */
  Name: string;
  /** Version of the reconciler health */
  SelfVersion: number;
  /** timestamp of when the reconciler was started */
  StartTime:
    | Date
    | undefined;
  /** timestamp of last check-in */
  CheckInTime:
    | Date
    | undefined;
  /** how long this check-in is good for */
  Duration:
    | Duration
    | undefined;
  /** Set (during reads) if the reconciler looks unresponsive. */
  Unresponsive: boolean;
  /** number of keys successfully handled since current startup */
  KeysHandled: number;
  /** last key processed */
  LastKey: string;
  /** when was the last key handled */
  WhenLastKey: Date | undefined;
}

/**
 * For reconcilers watching for server heartbeats, the ServerHeartbeat message indicates the
 * expected interval between heartbeats
 */
export interface ServerHeartbeat {
  Interval: number;
  When: Date | undefined;
}

function createBaseTaskGoal(): TaskGoal {
  return {
    SelfKey: "",
    Name: "",
    Desc: "",
    Type: 0,
    SelfVersion: 0,
    Creation: undefined,
    When: undefined,
    Subkeys: [],
  };
}

export const TaskGoal = {
  encode(message: TaskGoal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.SelfKey !== "") {
      writer.uint32(10).string(message.SelfKey);
    }
    if (message.Name !== "") {
      writer.uint32(18).string(message.Name);
    }
    if (message.Desc !== "") {
      writer.uint32(26).string(message.Desc);
    }
    if (message.Type !== 0) {
      writer.uint32(32).int32(message.Type);
    }
    if (message.SelfVersion !== 0) {
      writer.uint32(40).int64(message.SelfVersion);
    }
    if (message.Creation !== undefined) {
      Timestamp.encode(toTimestamp(message.Creation), writer.uint32(50).fork()).ldelim();
    }
    if (message.When !== undefined) {
      Timestamp.encode(toTimestamp(message.When), writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.Subkeys) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskGoal {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskGoal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.SelfKey = reader.string();
          break;
        case 2:
          message.Name = reader.string();
          break;
        case 3:
          message.Desc = reader.string();
          break;
        case 4:
          message.Type = reader.int32() as any;
          break;
        case 5:
          message.SelfVersion = longToNumber(reader.int64() as Long);
          break;
        case 6:
          message.Creation = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 7:
          message.When = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 8:
          message.Subkeys.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TaskGoal {
    return {
      SelfKey: isSet(object.SelfKey) ? String(object.SelfKey) : "",
      Name: isSet(object.Name) ? String(object.Name) : "",
      Desc: isSet(object.Desc) ? String(object.Desc) : "",
      Type: isSet(object.Type) ? taskGoal_GoalTypeFromJSON(object.Type) : 0,
      SelfVersion: isSet(object.SelfVersion) ? Number(object.SelfVersion) : 0,
      Creation: isSet(object.Creation) ? fromJsonTimestamp(object.Creation) : undefined,
      When: isSet(object.When) ? fromJsonTimestamp(object.When) : undefined,
      Subkeys: Array.isArray(object?.Subkeys) ? object.Subkeys.map((e: any) => String(e)) : [],
    };
  },

  toJSON(message: TaskGoal): unknown {
    const obj: any = {};
    message.SelfKey !== undefined && (obj.SelfKey = message.SelfKey);
    message.Name !== undefined && (obj.Name = message.Name);
    message.Desc !== undefined && (obj.Desc = message.Desc);
    message.Type !== undefined && (obj.Type = taskGoal_GoalTypeToJSON(message.Type));
    message.SelfVersion !== undefined && (obj.SelfVersion = Math.round(message.SelfVersion));
    message.Creation !== undefined && (obj.Creation = message.Creation.toISOString());
    message.When !== undefined && (obj.When = message.When.toISOString());
    if (message.Subkeys) {
      obj.Subkeys = message.Subkeys.map((e) => e);
    } else {
      obj.Subkeys = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskGoal>, I>>(base?: I): TaskGoal {
    return TaskGoal.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<TaskGoal>, I>>(object: I): TaskGoal {
    const message = createBaseTaskGoal();
    message.SelfKey = object.SelfKey ?? "";
    message.Name = object.Name ?? "";
    message.Desc = object.Desc ?? "";
    message.Type = object.Type ?? 0;
    message.SelfVersion = object.SelfVersion ?? 0;
    message.Creation = object.Creation ?? undefined;
    message.When = object.When ?? undefined;
    message.Subkeys = object.Subkeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseTaskStatus(): TaskStatus {
  return {
    Manager: "",
    Name: "",
    Desc: "",
    LastStatus: 0,
    SelfVersion: 0,
    TaskVersion: 0,
    PrevValue: new Uint8Array(),
    Duration: undefined,
    When: undefined,
    TaskKey: "",
    SubtaskKeys: [],
    Messages: [],
    CurrentStatus: 0,
    TaskRevision: 0,
  };
}

export const TaskStatus = {
  encode(message: TaskStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Manager !== "") {
      writer.uint32(10).string(message.Manager);
    }
    if (message.Name !== "") {
      writer.uint32(18).string(message.Name);
    }
    if (message.Desc !== "") {
      writer.uint32(26).string(message.Desc);
    }
    if (message.LastStatus !== 0) {
      writer.uint32(32).int32(message.LastStatus);
    }
    if (message.SelfVersion !== 0) {
      writer.uint32(40).int64(message.SelfVersion);
    }
    if (message.TaskVersion !== 0) {
      writer.uint32(48).int64(message.TaskVersion);
    }
    if (message.PrevValue.length !== 0) {
      writer.uint32(58).bytes(message.PrevValue);
    }
    if (message.Duration !== undefined) {
      Duration.encode(message.Duration, writer.uint32(66).fork()).ldelim();
    }
    if (message.When !== undefined) {
      Timestamp.encode(toTimestamp(message.When), writer.uint32(74).fork()).ldelim();
    }
    if (message.TaskKey !== "") {
      writer.uint32(82).string(message.TaskKey);
    }
    for (const v of message.SubtaskKeys) {
      writer.uint32(90).string(v!);
    }
    for (const v of message.Messages) {
      TaskMessage.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    if (message.CurrentStatus !== 0) {
      writer.uint32(104).int32(message.CurrentStatus);
    }
    if (message.TaskRevision !== 0) {
      writer.uint32(112).int64(message.TaskRevision);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.Manager = reader.string();
          break;
        case 2:
          message.Name = reader.string();
          break;
        case 3:
          message.Desc = reader.string();
          break;
        case 4:
          message.LastStatus = reader.int32() as any;
          break;
        case 5:
          message.SelfVersion = longToNumber(reader.int64() as Long);
          break;
        case 6:
          message.TaskVersion = longToNumber(reader.int64() as Long);
          break;
        case 7:
          message.PrevValue = reader.bytes();
          break;
        case 8:
          message.Duration = Duration.decode(reader, reader.uint32());
          break;
        case 9:
          message.When = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 10:
          message.TaskKey = reader.string();
          break;
        case 11:
          message.SubtaskKeys.push(reader.string());
          break;
        case 12:
          message.Messages.push(TaskMessage.decode(reader, reader.uint32()));
          break;
        case 13:
          message.CurrentStatus = reader.int32() as any;
          break;
        case 14:
          message.TaskRevision = longToNumber(reader.int64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TaskStatus {
    return {
      Manager: isSet(object.Manager) ? String(object.Manager) : "",
      Name: isSet(object.Name) ? String(object.Name) : "",
      Desc: isSet(object.Desc) ? String(object.Desc) : "",
      LastStatus: isSet(object.LastStatus) ? taskStatus_StatusTypeFromJSON(object.LastStatus) : 0,
      SelfVersion: isSet(object.SelfVersion) ? Number(object.SelfVersion) : 0,
      TaskVersion: isSet(object.TaskVersion) ? Number(object.TaskVersion) : 0,
      PrevValue: isSet(object.PrevValue) ? bytesFromBase64(object.PrevValue) : new Uint8Array(),
      Duration: isSet(object.Duration) ? Duration.fromJSON(object.Duration) : undefined,
      When: isSet(object.When) ? fromJsonTimestamp(object.When) : undefined,
      TaskKey: isSet(object.TaskKey) ? String(object.TaskKey) : "",
      SubtaskKeys: Array.isArray(object?.SubtaskKeys) ? object.SubtaskKeys.map((e: any) => String(e)) : [],
      Messages: Array.isArray(object?.Messages) ? object.Messages.map((e: any) => TaskMessage.fromJSON(e)) : [],
      CurrentStatus: isSet(object.CurrentStatus) ? taskStatus_StatusTypeFromJSON(object.CurrentStatus) : 0,
      TaskRevision: isSet(object.TaskRevision) ? Number(object.TaskRevision) : 0,
    };
  },

  toJSON(message: TaskStatus): unknown {
    const obj: any = {};
    message.Manager !== undefined && (obj.Manager = message.Manager);
    message.Name !== undefined && (obj.Name = message.Name);
    message.Desc !== undefined && (obj.Desc = message.Desc);
    message.LastStatus !== undefined && (obj.LastStatus = taskStatus_StatusTypeToJSON(message.LastStatus));
    message.SelfVersion !== undefined && (obj.SelfVersion = Math.round(message.SelfVersion));
    message.TaskVersion !== undefined && (obj.TaskVersion = Math.round(message.TaskVersion));
    message.PrevValue !== undefined &&
      (obj.PrevValue = base64FromBytes(message.PrevValue !== undefined ? message.PrevValue : new Uint8Array()));
    message.Duration !== undefined && (obj.Duration = message.Duration ? Duration.toJSON(message.Duration) : undefined);
    message.When !== undefined && (obj.When = message.When.toISOString());
    message.TaskKey !== undefined && (obj.TaskKey = message.TaskKey);
    if (message.SubtaskKeys) {
      obj.SubtaskKeys = message.SubtaskKeys.map((e) => e);
    } else {
      obj.SubtaskKeys = [];
    }
    if (message.Messages) {
      obj.Messages = message.Messages.map((e) => e ? TaskMessage.toJSON(e) : undefined);
    } else {
      obj.Messages = [];
    }
    message.CurrentStatus !== undefined && (obj.CurrentStatus = taskStatus_StatusTypeToJSON(message.CurrentStatus));
    message.TaskRevision !== undefined && (obj.TaskRevision = Math.round(message.TaskRevision));
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskStatus>, I>>(base?: I): TaskStatus {
    return TaskStatus.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<TaskStatus>, I>>(object: I): TaskStatus {
    const message = createBaseTaskStatus();
    message.Manager = object.Manager ?? "";
    message.Name = object.Name ?? "";
    message.Desc = object.Desc ?? "";
    message.LastStatus = object.LastStatus ?? 0;
    message.SelfVersion = object.SelfVersion ?? 0;
    message.TaskVersion = object.TaskVersion ?? 0;
    message.PrevValue = object.PrevValue ?? new Uint8Array();
    message.Duration = (object.Duration !== undefined && object.Duration !== null)
      ? Duration.fromPartial(object.Duration)
      : undefined;
    message.When = object.When ?? undefined;
    message.TaskKey = object.TaskKey ?? "";
    message.SubtaskKeys = object.SubtaskKeys?.map((e) => e) || [];
    message.Messages = object.Messages?.map((e) => TaskMessage.fromPartial(e)) || [];
    message.CurrentStatus = object.CurrentStatus ?? 0;
    message.TaskRevision = object.TaskRevision ?? 0;
    return message;
  },
};

function createBaseTaskMessage(): TaskMessage {
  return { Level: 0, Message: "" };
}

export const TaskMessage = {
  encode(message: TaskMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Level !== 0) {
      writer.uint32(8).int32(message.Level);
    }
    if (message.Message !== "") {
      writer.uint32(18).string(message.Message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskMessage {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.Level = reader.int32() as any;
          break;
        case 2:
          message.Message = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TaskMessage {
    return {
      Level: isSet(object.Level) ? taskMessage_TypeFromJSON(object.Level) : 0,
      Message: isSet(object.Message) ? String(object.Message) : "",
    };
  },

  toJSON(message: TaskMessage): unknown {
    const obj: any = {};
    message.Level !== undefined && (obj.Level = taskMessage_TypeToJSON(message.Level));
    message.Message !== undefined && (obj.Message = message.Message);
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskMessage>, I>>(base?: I): TaskMessage {
    return TaskMessage.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<TaskMessage>, I>>(object: I): TaskMessage {
    const message = createBaseTaskMessage();
    message.Level = object.Level ?? 0;
    message.Message = object.Message ?? "";
    return message;
  },
};

function createBaseTaskTree(): TaskTree {
  return { Task: undefined, HighestStatus: 0, LastUpdated: undefined, NumChildTasks: 0, Subtasks: [] };
}

export const TaskTree = {
  encode(message: TaskTree, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Task !== undefined) {
      TaskStatus.encode(message.Task, writer.uint32(10).fork()).ldelim();
    }
    if (message.HighestStatus !== 0) {
      writer.uint32(16).int32(message.HighestStatus);
    }
    if (message.LastUpdated !== undefined) {
      Timestamp.encode(toTimestamp(message.LastUpdated), writer.uint32(26).fork()).ldelim();
    }
    if (message.NumChildTasks !== 0) {
      writer.uint32(32).int64(message.NumChildTasks);
    }
    for (const v of message.Subtasks) {
      TaskTree.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskTree {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskTree();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.Task = TaskStatus.decode(reader, reader.uint32());
          break;
        case 2:
          message.HighestStatus = reader.int32() as any;
          break;
        case 3:
          message.LastUpdated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 4:
          message.NumChildTasks = longToNumber(reader.int64() as Long);
          break;
        case 5:
          message.Subtasks.push(TaskTree.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TaskTree {
    return {
      Task: isSet(object.Task) ? TaskStatus.fromJSON(object.Task) : undefined,
      HighestStatus: isSet(object.HighestStatus) ? taskStatus_StatusTypeFromJSON(object.HighestStatus) : 0,
      LastUpdated: isSet(object.LastUpdated) ? fromJsonTimestamp(object.LastUpdated) : undefined,
      NumChildTasks: isSet(object.NumChildTasks) ? Number(object.NumChildTasks) : 0,
      Subtasks: Array.isArray(object?.Subtasks) ? object.Subtasks.map((e: any) => TaskTree.fromJSON(e)) : [],
    };
  },

  toJSON(message: TaskTree): unknown {
    const obj: any = {};
    message.Task !== undefined && (obj.Task = message.Task ? TaskStatus.toJSON(message.Task) : undefined);
    message.HighestStatus !== undefined && (obj.HighestStatus = taskStatus_StatusTypeToJSON(message.HighestStatus));
    message.LastUpdated !== undefined && (obj.LastUpdated = message.LastUpdated.toISOString());
    message.NumChildTasks !== undefined && (obj.NumChildTasks = Math.round(message.NumChildTasks));
    if (message.Subtasks) {
      obj.Subtasks = message.Subtasks.map((e) => e ? TaskTree.toJSON(e) : undefined);
    } else {
      obj.Subtasks = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskTree>, I>>(base?: I): TaskTree {
    return TaskTree.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<TaskTree>, I>>(object: I): TaskTree {
    const message = createBaseTaskTree();
    message.Task = (object.Task !== undefined && object.Task !== null)
      ? TaskStatus.fromPartial(object.Task)
      : undefined;
    message.HighestStatus = object.HighestStatus ?? 0;
    message.LastUpdated = object.LastUpdated ?? undefined;
    message.NumChildTasks = object.NumChildTasks ?? 0;
    message.Subtasks = object.Subtasks?.map((e) => TaskTree.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTaskForest(): TaskForest {
  return { Goal: undefined, HighestStatus: 0, LastUpdated: undefined, NumChildTasks: 0, Subgoals: [], Subtasks: [] };
}

export const TaskForest = {
  encode(message: TaskForest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Goal !== undefined) {
      TaskGoal.encode(message.Goal, writer.uint32(10).fork()).ldelim();
    }
    if (message.HighestStatus !== 0) {
      writer.uint32(16).int32(message.HighestStatus);
    }
    if (message.LastUpdated !== undefined) {
      Timestamp.encode(toTimestamp(message.LastUpdated), writer.uint32(26).fork()).ldelim();
    }
    if (message.NumChildTasks !== 0) {
      writer.uint32(32).int64(message.NumChildTasks);
    }
    for (const v of message.Subgoals) {
      TaskForest.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.Subtasks) {
      TaskTree.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskForest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskForest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.Goal = TaskGoal.decode(reader, reader.uint32());
          break;
        case 2:
          message.HighestStatus = reader.int32() as any;
          break;
        case 3:
          message.LastUpdated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 4:
          message.NumChildTasks = longToNumber(reader.int64() as Long);
          break;
        case 5:
          message.Subgoals.push(TaskForest.decode(reader, reader.uint32()));
          break;
        case 6:
          message.Subtasks.push(TaskTree.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TaskForest {
    return {
      Goal: isSet(object.Goal) ? TaskGoal.fromJSON(object.Goal) : undefined,
      HighestStatus: isSet(object.HighestStatus) ? taskStatus_StatusTypeFromJSON(object.HighestStatus) : 0,
      LastUpdated: isSet(object.LastUpdated) ? fromJsonTimestamp(object.LastUpdated) : undefined,
      NumChildTasks: isSet(object.NumChildTasks) ? Number(object.NumChildTasks) : 0,
      Subgoals: Array.isArray(object?.Subgoals) ? object.Subgoals.map((e: any) => TaskForest.fromJSON(e)) : [],
      Subtasks: Array.isArray(object?.Subtasks) ? object.Subtasks.map((e: any) => TaskTree.fromJSON(e)) : [],
    };
  },

  toJSON(message: TaskForest): unknown {
    const obj: any = {};
    message.Goal !== undefined && (obj.Goal = message.Goal ? TaskGoal.toJSON(message.Goal) : undefined);
    message.HighestStatus !== undefined && (obj.HighestStatus = taskStatus_StatusTypeToJSON(message.HighestStatus));
    message.LastUpdated !== undefined && (obj.LastUpdated = message.LastUpdated.toISOString());
    message.NumChildTasks !== undefined && (obj.NumChildTasks = Math.round(message.NumChildTasks));
    if (message.Subgoals) {
      obj.Subgoals = message.Subgoals.map((e) => e ? TaskForest.toJSON(e) : undefined);
    } else {
      obj.Subgoals = [];
    }
    if (message.Subtasks) {
      obj.Subtasks = message.Subtasks.map((e) => e ? TaskTree.toJSON(e) : undefined);
    } else {
      obj.Subtasks = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskForest>, I>>(base?: I): TaskForest {
    return TaskForest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<TaskForest>, I>>(object: I): TaskForest {
    const message = createBaseTaskForest();
    message.Goal = (object.Goal !== undefined && object.Goal !== null) ? TaskGoal.fromPartial(object.Goal) : undefined;
    message.HighestStatus = object.HighestStatus ?? 0;
    message.LastUpdated = object.LastUpdated ?? undefined;
    message.NumChildTasks = object.NumChildTasks ?? 0;
    message.Subgoals = object.Subgoals?.map((e) => TaskForest.fromPartial(e)) || [];
    message.Subtasks = object.Subtasks?.map((e) => TaskTree.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTaskSummary(): TaskSummary {
  return { HighestStatus: 0, FirstUpdated: undefined, LastUpdated: undefined, Messages: [] };
}

export const TaskSummary = {
  encode(message: TaskSummary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.HighestStatus !== 0) {
      writer.uint32(8).int32(message.HighestStatus);
    }
    if (message.FirstUpdated !== undefined) {
      Timestamp.encode(toTimestamp(message.FirstUpdated), writer.uint32(18).fork()).ldelim();
    }
    if (message.LastUpdated !== undefined) {
      Timestamp.encode(toTimestamp(message.LastUpdated), writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.Messages) {
      TaskMessage.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskSummary {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.HighestStatus = reader.int32() as any;
          break;
        case 2:
          message.FirstUpdated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 3:
          message.LastUpdated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 4:
          message.Messages.push(TaskMessage.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TaskSummary {
    return {
      HighestStatus: isSet(object.HighestStatus) ? taskStatus_StatusTypeFromJSON(object.HighestStatus) : 0,
      FirstUpdated: isSet(object.FirstUpdated) ? fromJsonTimestamp(object.FirstUpdated) : undefined,
      LastUpdated: isSet(object.LastUpdated) ? fromJsonTimestamp(object.LastUpdated) : undefined,
      Messages: Array.isArray(object?.Messages) ? object.Messages.map((e: any) => TaskMessage.fromJSON(e)) : [],
    };
  },

  toJSON(message: TaskSummary): unknown {
    const obj: any = {};
    message.HighestStatus !== undefined && (obj.HighestStatus = taskStatus_StatusTypeToJSON(message.HighestStatus));
    message.FirstUpdated !== undefined && (obj.FirstUpdated = message.FirstUpdated.toISOString());
    message.LastUpdated !== undefined && (obj.LastUpdated = message.LastUpdated.toISOString());
    if (message.Messages) {
      obj.Messages = message.Messages.map((e) => e ? TaskMessage.toJSON(e) : undefined);
    } else {
      obj.Messages = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskSummary>, I>>(base?: I): TaskSummary {
    return TaskSummary.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<TaskSummary>, I>>(object: I): TaskSummary {
    const message = createBaseTaskSummary();
    message.HighestStatus = object.HighestStatus ?? 0;
    message.FirstUpdated = object.FirstUpdated ?? undefined;
    message.LastUpdated = object.LastUpdated ?? undefined;
    message.Messages = object.Messages?.map((e) => TaskMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeprStatus(): DeprStatus {
  return { result: 0, worker: "", info: "", version: 0, reconciler: "", event: "", when: undefined };
}

export const DeprStatus = {
  encode(message: DeprStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    if (message.worker !== "") {
      writer.uint32(18).string(message.worker);
    }
    if (message.info !== "") {
      writer.uint32(26).string(message.info);
    }
    if (message.version !== 0) {
      writer.uint32(32).int64(message.version);
    }
    if (message.reconciler !== "") {
      writer.uint32(42).string(message.reconciler);
    }
    if (message.event !== "") {
      writer.uint32(50).string(message.event);
    }
    if (message.when !== undefined) {
      Timestamp.encode(toTimestamp(message.when), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeprStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeprStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.result = reader.int32() as any;
          break;
        case 2:
          message.worker = reader.string();
          break;
        case 3:
          message.info = reader.string();
          break;
        case 4:
          message.version = longToNumber(reader.int64() as Long);
          break;
        case 5:
          message.reconciler = reader.string();
          break;
        case 6:
          message.event = reader.string();
          break;
        case 7:
          message.when = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DeprStatus {
    return {
      result: isSet(object.result) ? deprStatus_DeprResultTypeFromJSON(object.result) : 0,
      worker: isSet(object.worker) ? String(object.worker) : "",
      info: isSet(object.info) ? String(object.info) : "",
      version: isSet(object.version) ? Number(object.version) : 0,
      reconciler: isSet(object.reconciler) ? String(object.reconciler) : "",
      event: isSet(object.event) ? String(object.event) : "",
      when: isSet(object.when) ? fromJsonTimestamp(object.when) : undefined,
    };
  },

  toJSON(message: DeprStatus): unknown {
    const obj: any = {};
    message.result !== undefined && (obj.result = deprStatus_DeprResultTypeToJSON(message.result));
    message.worker !== undefined && (obj.worker = message.worker);
    message.info !== undefined && (obj.info = message.info);
    message.version !== undefined && (obj.version = Math.round(message.version));
    message.reconciler !== undefined && (obj.reconciler = message.reconciler);
    message.event !== undefined && (obj.event = message.event);
    message.when !== undefined && (obj.when = message.when.toISOString());
    return obj;
  },

  create<I extends Exact<DeepPartial<DeprStatus>, I>>(base?: I): DeprStatus {
    return DeprStatus.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DeprStatus>, I>>(object: I): DeprStatus {
    const message = createBaseDeprStatus();
    message.result = object.result ?? 0;
    message.worker = object.worker ?? "";
    message.info = object.info ?? "";
    message.version = object.version ?? 0;
    message.reconciler = object.reconciler ?? "";
    message.event = object.event ?? "";
    message.when = object.when ?? undefined;
    return message;
  },
};

function createBaseReconcilerHealth(): ReconcilerHealth {
  return {
    Manager: "",
    Name: "",
    SelfVersion: 0,
    StartTime: undefined,
    CheckInTime: undefined,
    Duration: undefined,
    Unresponsive: false,
    KeysHandled: 0,
    LastKey: "",
    WhenLastKey: undefined,
  };
}

export const ReconcilerHealth = {
  encode(message: ReconcilerHealth, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Manager !== "") {
      writer.uint32(10).string(message.Manager);
    }
    if (message.Name !== "") {
      writer.uint32(18).string(message.Name);
    }
    if (message.SelfVersion !== 0) {
      writer.uint32(24).int64(message.SelfVersion);
    }
    if (message.StartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.StartTime), writer.uint32(34).fork()).ldelim();
    }
    if (message.CheckInTime !== undefined) {
      Timestamp.encode(toTimestamp(message.CheckInTime), writer.uint32(42).fork()).ldelim();
    }
    if (message.Duration !== undefined) {
      Duration.encode(message.Duration, writer.uint32(50).fork()).ldelim();
    }
    if (message.Unresponsive === true) {
      writer.uint32(56).bool(message.Unresponsive);
    }
    if (message.KeysHandled !== 0) {
      writer.uint32(64).int64(message.KeysHandled);
    }
    if (message.LastKey !== "") {
      writer.uint32(74).string(message.LastKey);
    }
    if (message.WhenLastKey !== undefined) {
      Timestamp.encode(toTimestamp(message.WhenLastKey), writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReconcilerHealth {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconcilerHealth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.Manager = reader.string();
          break;
        case 2:
          message.Name = reader.string();
          break;
        case 3:
          message.SelfVersion = longToNumber(reader.int64() as Long);
          break;
        case 4:
          message.StartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 5:
          message.CheckInTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 6:
          message.Duration = Duration.decode(reader, reader.uint32());
          break;
        case 7:
          message.Unresponsive = reader.bool();
          break;
        case 8:
          message.KeysHandled = longToNumber(reader.int64() as Long);
          break;
        case 9:
          message.LastKey = reader.string();
          break;
        case 10:
          message.WhenLastKey = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ReconcilerHealth {
    return {
      Manager: isSet(object.Manager) ? String(object.Manager) : "",
      Name: isSet(object.Name) ? String(object.Name) : "",
      SelfVersion: isSet(object.SelfVersion) ? Number(object.SelfVersion) : 0,
      StartTime: isSet(object.StartTime) ? fromJsonTimestamp(object.StartTime) : undefined,
      CheckInTime: isSet(object.CheckInTime) ? fromJsonTimestamp(object.CheckInTime) : undefined,
      Duration: isSet(object.Duration) ? Duration.fromJSON(object.Duration) : undefined,
      Unresponsive: isSet(object.Unresponsive) ? Boolean(object.Unresponsive) : false,
      KeysHandled: isSet(object.KeysHandled) ? Number(object.KeysHandled) : 0,
      LastKey: isSet(object.LastKey) ? String(object.LastKey) : "",
      WhenLastKey: isSet(object.WhenLastKey) ? fromJsonTimestamp(object.WhenLastKey) : undefined,
    };
  },

  toJSON(message: ReconcilerHealth): unknown {
    const obj: any = {};
    message.Manager !== undefined && (obj.Manager = message.Manager);
    message.Name !== undefined && (obj.Name = message.Name);
    message.SelfVersion !== undefined && (obj.SelfVersion = Math.round(message.SelfVersion));
    message.StartTime !== undefined && (obj.StartTime = message.StartTime.toISOString());
    message.CheckInTime !== undefined && (obj.CheckInTime = message.CheckInTime.toISOString());
    message.Duration !== undefined && (obj.Duration = message.Duration ? Duration.toJSON(message.Duration) : undefined);
    message.Unresponsive !== undefined && (obj.Unresponsive = message.Unresponsive);
    message.KeysHandled !== undefined && (obj.KeysHandled = Math.round(message.KeysHandled));
    message.LastKey !== undefined && (obj.LastKey = message.LastKey);
    message.WhenLastKey !== undefined && (obj.WhenLastKey = message.WhenLastKey.toISOString());
    return obj;
  },

  create<I extends Exact<DeepPartial<ReconcilerHealth>, I>>(base?: I): ReconcilerHealth {
    return ReconcilerHealth.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ReconcilerHealth>, I>>(object: I): ReconcilerHealth {
    const message = createBaseReconcilerHealth();
    message.Manager = object.Manager ?? "";
    message.Name = object.Name ?? "";
    message.SelfVersion = object.SelfVersion ?? 0;
    message.StartTime = object.StartTime ?? undefined;
    message.CheckInTime = object.CheckInTime ?? undefined;
    message.Duration = (object.Duration !== undefined && object.Duration !== null)
      ? Duration.fromPartial(object.Duration)
      : undefined;
    message.Unresponsive = object.Unresponsive ?? false;
    message.KeysHandled = object.KeysHandled ?? 0;
    message.LastKey = object.LastKey ?? "";
    message.WhenLastKey = object.WhenLastKey ?? undefined;
    return message;
  },
};

function createBaseServerHeartbeat(): ServerHeartbeat {
  return { Interval: 0, When: undefined };
}

export const ServerHeartbeat = {
  encode(message: ServerHeartbeat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Interval !== 0) {
      writer.uint32(8).uint64(message.Interval);
    }
    if (message.When !== undefined) {
      Timestamp.encode(toTimestamp(message.When), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ServerHeartbeat {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerHeartbeat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.Interval = longToNumber(reader.uint64() as Long);
          break;
        case 2:
          message.When = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ServerHeartbeat {
    return {
      Interval: isSet(object.Interval) ? Number(object.Interval) : 0,
      When: isSet(object.When) ? fromJsonTimestamp(object.When) : undefined,
    };
  },

  toJSON(message: ServerHeartbeat): unknown {
    const obj: any = {};
    message.Interval !== undefined && (obj.Interval = Math.round(message.Interval));
    message.When !== undefined && (obj.When = message.When.toISOString());
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerHeartbeat>, I>>(base?: I): ServerHeartbeat {
    return ServerHeartbeat.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<ServerHeartbeat>, I>>(object: I): ServerHeartbeat {
    const message = createBaseServerHeartbeat();
    message.Interval = object.Interval ?? 0;
    message.When = object.When ?? undefined;
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  if (tsProtoGlobalThis.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if (tsProtoGlobalThis.Buffer) {
    return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = date.getTime() / 1_000;
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = t.seconds * 1_000;
  millis += t.nanos / 1_000_000;
  return new Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
