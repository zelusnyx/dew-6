"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.ServerHeartbeat = exports.ReconcilerHealth = exports.DeprStatus = exports.TaskSummary = exports.TaskForest = exports.TaskTree = exports.TaskMessage = exports.TaskStatus = exports.TaskGoal = exports.deprStatus_DeprResultTypeToJSON = exports.deprStatus_DeprResultTypeFromJSON = exports.DeprStatus_DeprResultType = exports.taskMessage_TypeToJSON = exports.taskMessage_TypeFromJSON = exports.TaskMessage_Type = exports.taskStatus_StatusTypeToJSON = exports.taskStatus_StatusTypeFromJSON = exports.TaskStatus_StatusType = exports.taskGoal_GoalTypeToJSON = exports.taskGoal_GoalTypeFromJSON = exports.TaskGoal_GoalType = exports.reconcilerOpToJSON = exports.reconcilerOpFromJSON = exports.ReconcilerOp = exports.protobufPackage = void 0;
/* eslint-disable */
var long_1 = __importDefault(require("long"));
var minimal_1 = __importDefault(require("protobufjs/minimal"));
var duration_1 = require("../../../google/protobuf/duration");
var timestamp_1 = require("../../../google/protobuf/timestamp");
exports.protobufPackage = "reconcile";
/** ReconcilerOp is so we tell the reconciler's main function what we're doing, for synchronization. */
var ReconcilerOp;
(function (ReconcilerOp) {
    ReconcilerOp[ReconcilerOp["Undefined"] = 0] = "Undefined";
    ReconcilerOp[ReconcilerOp["Idle"] = 1] = "Idle";
    ReconcilerOp[ReconcilerOp["Init"] = 2] = "Init";
    ReconcilerOp[ReconcilerOp["Create"] = 3] = "Create";
    ReconcilerOp[ReconcilerOp["Update"] = 4] = "Update";
    ReconcilerOp[ReconcilerOp["Delete"] = 5] = "Delete";
    ReconcilerOp[ReconcilerOp["Ensure"] = 6] = "Ensure";
    ReconcilerOp[ReconcilerOp["Health"] = 7] = "Health";
    ReconcilerOp[ReconcilerOp["Pollcheck"] = 8] = "Pollcheck";
    ReconcilerOp[ReconcilerOp["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ReconcilerOp = exports.ReconcilerOp || (exports.ReconcilerOp = {}));
function reconcilerOpFromJSON(object) {
    switch (object) {
        case 0:
        case "Undefined":
            return ReconcilerOp.Undefined;
        case 1:
        case "Idle":
            return ReconcilerOp.Idle;
        case 2:
        case "Init":
            return ReconcilerOp.Init;
        case 3:
        case "Create":
            return ReconcilerOp.Create;
        case 4:
        case "Update":
            return ReconcilerOp.Update;
        case 5:
        case "Delete":
            return ReconcilerOp.Delete;
        case 6:
        case "Ensure":
            return ReconcilerOp.Ensure;
        case 7:
        case "Health":
            return ReconcilerOp.Health;
        case 8:
        case "Pollcheck":
            return ReconcilerOp.Pollcheck;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ReconcilerOp.UNRECOGNIZED;
    }
}
exports.reconcilerOpFromJSON = reconcilerOpFromJSON;
function reconcilerOpToJSON(object) {
    switch (object) {
        case ReconcilerOp.Undefined:
            return "Undefined";
        case ReconcilerOp.Idle:
            return "Idle";
        case ReconcilerOp.Init:
            return "Init";
        case ReconcilerOp.Create:
            return "Create";
        case ReconcilerOp.Update:
            return "Update";
        case ReconcilerOp.Delete:
            return "Delete";
        case ReconcilerOp.Ensure:
            return "Ensure";
        case ReconcilerOp.Health:
            return "Health";
        case ReconcilerOp.Pollcheck:
            return "Pollcheck";
        case ReconcilerOp.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.reconcilerOpToJSON = reconcilerOpToJSON;
var TaskGoal_GoalType;
(function (TaskGoal_GoalType) {
    TaskGoal_GoalType[TaskGoal_GoalType["Undefined"] = 0] = "Undefined";
    /** Supergoal - Used for a super large goal, e.g. a materialization */
    TaskGoal_GoalType[TaskGoal_GoalType["Supergoal"] = 1] = "Supergoal";
    /** Supertask - Used for a goals that directly manage tasks, e.g. sled\ */
    TaskGoal_GoalType[TaskGoal_GoalType["Supertask"] = 2] = "Supertask";
    TaskGoal_GoalType[TaskGoal_GoalType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TaskGoal_GoalType = exports.TaskGoal_GoalType || (exports.TaskGoal_GoalType = {}));
function taskGoal_GoalTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "Undefined":
            return TaskGoal_GoalType.Undefined;
        case 1:
        case "Supergoal":
            return TaskGoal_GoalType.Supergoal;
        case 2:
        case "Supertask":
            return TaskGoal_GoalType.Supertask;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TaskGoal_GoalType.UNRECOGNIZED;
    }
}
exports.taskGoal_GoalTypeFromJSON = taskGoal_GoalTypeFromJSON;
function taskGoal_GoalTypeToJSON(object) {
    switch (object) {
        case TaskGoal_GoalType.Undefined:
            return "Undefined";
        case TaskGoal_GoalType.Supergoal:
            return "Supergoal";
        case TaskGoal_GoalType.Supertask:
            return "Supertask";
        case TaskGoal_GoalType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.taskGoal_GoalTypeToJSON = taskGoal_GoalTypeToJSON;
/** These are listed in order of increasing priority */
var TaskStatus_StatusType;
(function (TaskStatus_StatusType) {
    /** Undefined - Unknown status type */
    TaskStatus_StatusType[TaskStatus_StatusType["Undefined"] = 0] = "Undefined";
    /** Success - The key handler has successfully handled a put */
    TaskStatus_StatusType[TaskStatus_StatusType["Success"] = 1] = "Success";
    /** Deleted - The key handler has successfully handled a delete */
    TaskStatus_StatusType[TaskStatus_StatusType["Deleted"] = 2] = "Deleted";
    /** Pending - The key handler has not yet started handling the key */
    TaskStatus_StatusType[TaskStatus_StatusType["Pending"] = 3] = "Pending";
    /** Unresponsive - The key handler does not seem to be responsive */
    TaskStatus_StatusType[TaskStatus_StatusType["Unresponsive"] = 4] = "Unresponsive";
    /** Processing - The key handler is currently in progress */
    TaskStatus_StatusType[TaskStatus_StatusType["Processing"] = 5] = "Processing";
    /** Error - The key handler has error'ed out */
    TaskStatus_StatusType[TaskStatus_StatusType["Error"] = 6] = "Error";
    TaskStatus_StatusType[TaskStatus_StatusType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TaskStatus_StatusType = exports.TaskStatus_StatusType || (exports.TaskStatus_StatusType = {}));
function taskStatus_StatusTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "Undefined":
            return TaskStatus_StatusType.Undefined;
        case 1:
        case "Success":
            return TaskStatus_StatusType.Success;
        case 2:
        case "Deleted":
            return TaskStatus_StatusType.Deleted;
        case 3:
        case "Pending":
            return TaskStatus_StatusType.Pending;
        case 4:
        case "Unresponsive":
            return TaskStatus_StatusType.Unresponsive;
        case 5:
        case "Processing":
            return TaskStatus_StatusType.Processing;
        case 6:
        case "Error":
            return TaskStatus_StatusType.Error;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TaskStatus_StatusType.UNRECOGNIZED;
    }
}
exports.taskStatus_StatusTypeFromJSON = taskStatus_StatusTypeFromJSON;
function taskStatus_StatusTypeToJSON(object) {
    switch (object) {
        case TaskStatus_StatusType.Undefined:
            return "Undefined";
        case TaskStatus_StatusType.Success:
            return "Success";
        case TaskStatus_StatusType.Deleted:
            return "Deleted";
        case TaskStatus_StatusType.Pending:
            return "Pending";
        case TaskStatus_StatusType.Unresponsive:
            return "Unresponsive";
        case TaskStatus_StatusType.Processing:
            return "Processing";
        case TaskStatus_StatusType.Error:
            return "Error";
        case TaskStatus_StatusType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.taskStatus_StatusTypeToJSON = taskStatus_StatusTypeToJSON;
var TaskMessage_Type;
(function (TaskMessage_Type) {
    TaskMessage_Type[TaskMessage_Type["Undefined"] = 0] = "Undefined";
    TaskMessage_Type[TaskMessage_Type["Error"] = 1] = "Error";
    TaskMessage_Type[TaskMessage_Type["Warning"] = 2] = "Warning";
    TaskMessage_Type[TaskMessage_Type["Info"] = 3] = "Info";
    TaskMessage_Type[TaskMessage_Type["Debug"] = 4] = "Debug";
    TaskMessage_Type[TaskMessage_Type["Trace"] = 5] = "Trace";
    TaskMessage_Type[TaskMessage_Type["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TaskMessage_Type = exports.TaskMessage_Type || (exports.TaskMessage_Type = {}));
function taskMessage_TypeFromJSON(object) {
    switch (object) {
        case 0:
        case "Undefined":
            return TaskMessage_Type.Undefined;
        case 1:
        case "Error":
            return TaskMessage_Type.Error;
        case 2:
        case "Warning":
            return TaskMessage_Type.Warning;
        case 3:
        case "Info":
            return TaskMessage_Type.Info;
        case 4:
        case "Debug":
            return TaskMessage_Type.Debug;
        case 5:
        case "Trace":
            return TaskMessage_Type.Trace;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TaskMessage_Type.UNRECOGNIZED;
    }
}
exports.taskMessage_TypeFromJSON = taskMessage_TypeFromJSON;
function taskMessage_TypeToJSON(object) {
    switch (object) {
        case TaskMessage_Type.Undefined:
            return "Undefined";
        case TaskMessage_Type.Error:
            return "Error";
        case TaskMessage_Type.Warning:
            return "Warning";
        case TaskMessage_Type.Info:
            return "Info";
        case TaskMessage_Type.Debug:
            return "Debug";
        case TaskMessage_Type.Trace:
            return "Trace";
        case TaskMessage_Type.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.taskMessage_TypeToJSON = taskMessage_TypeToJSON;
var DeprStatus_DeprResultType;
(function (DeprStatus_DeprResultType) {
    DeprStatus_DeprResultType[DeprStatus_DeprResultType["ResultUndefined"] = 0] = "ResultUndefined";
    DeprStatus_DeprResultType[DeprStatus_DeprResultType["Working"] = 1] = "Working";
    DeprStatus_DeprResultType[DeprStatus_DeprResultType["Error"] = 2] = "Error";
    DeprStatus_DeprResultType[DeprStatus_DeprResultType["Success"] = 3] = "Success";
    DeprStatus_DeprResultType[DeprStatus_DeprResultType["Stale"] = 4] = "Stale";
    DeprStatus_DeprResultType[DeprStatus_DeprResultType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DeprStatus_DeprResultType = exports.DeprStatus_DeprResultType || (exports.DeprStatus_DeprResultType = {}));
function deprStatus_DeprResultTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "ResultUndefined":
            return DeprStatus_DeprResultType.ResultUndefined;
        case 1:
        case "Working":
            return DeprStatus_DeprResultType.Working;
        case 2:
        case "Error":
            return DeprStatus_DeprResultType.Error;
        case 3:
        case "Success":
            return DeprStatus_DeprResultType.Success;
        case 4:
        case "Stale":
            return DeprStatus_DeprResultType.Stale;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DeprStatus_DeprResultType.UNRECOGNIZED;
    }
}
exports.deprStatus_DeprResultTypeFromJSON = deprStatus_DeprResultTypeFromJSON;
function deprStatus_DeprResultTypeToJSON(object) {
    switch (object) {
        case DeprStatus_DeprResultType.ResultUndefined:
            return "ResultUndefined";
        case DeprStatus_DeprResultType.Working:
            return "Working";
        case DeprStatus_DeprResultType.Error:
            return "Error";
        case DeprStatus_DeprResultType.Success:
            return "Success";
        case DeprStatus_DeprResultType.Stale:
            return "Stale";
        case DeprStatus_DeprResultType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.deprStatus_DeprResultTypeToJSON = deprStatus_DeprResultTypeToJSON;
function createBaseTaskGoal() {
    return {
        SelfKey: "",
        Name: "",
        Desc: "",
        Type: 0,
        SelfVersion: 0,
        Creation: undefined,
        When: undefined,
        Subkeys: []
    };
}
exports.TaskGoal = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.SelfKey !== "") {
            writer.uint32(10).string(message.SelfKey);
        }
        if (message.Name !== "") {
            writer.uint32(18).string(message.Name);
        }
        if (message.Desc !== "") {
            writer.uint32(26).string(message.Desc);
        }
        if (message.Type !== 0) {
            writer.uint32(32).int32(message.Type);
        }
        if (message.SelfVersion !== 0) {
            writer.uint32(40).int64(message.SelfVersion);
        }
        if (message.Creation !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.Creation), writer.uint32(50).fork()).ldelim();
        }
        if (message.When !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.When), writer.uint32(58).fork()).ldelim();
        }
        for (var _i = 0, _a = message.Subkeys; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.uint32(66).string(v);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseTaskGoal();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.SelfKey = reader.string();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.Desc = reader.string();
                    break;
                case 4:
                    message.Type = reader.int32();
                    break;
                case 5:
                    message.SelfVersion = longToNumber(reader.int64());
                    break;
                case 6:
                    message.Creation = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.When = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.Subkeys.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            SelfKey: isSet(object.SelfKey) ? String(object.SelfKey) : "",
            Name: isSet(object.Name) ? String(object.Name) : "",
            Desc: isSet(object.Desc) ? String(object.Desc) : "",
            Type: isSet(object.Type) ? taskGoal_GoalTypeFromJSON(object.Type) : 0,
            SelfVersion: isSet(object.SelfVersion) ? Number(object.SelfVersion) : 0,
            Creation: isSet(object.Creation) ? fromJsonTimestamp(object.Creation) : undefined,
            When: isSet(object.When) ? fromJsonTimestamp(object.When) : undefined,
            Subkeys: Array.isArray(object === null || object === void 0 ? void 0 : object.Subkeys) ? object.Subkeys.map(function (e) { return String(e); }) : []
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.SelfKey !== undefined && (obj.SelfKey = message.SelfKey);
        message.Name !== undefined && (obj.Name = message.Name);
        message.Desc !== undefined && (obj.Desc = message.Desc);
        message.Type !== undefined && (obj.Type = taskGoal_GoalTypeToJSON(message.Type));
        message.SelfVersion !== undefined && (obj.SelfVersion = Math.round(message.SelfVersion));
        message.Creation !== undefined && (obj.Creation = message.Creation.toISOString());
        message.When !== undefined && (obj.When = message.When.toISOString());
        if (message.Subkeys) {
            obj.Subkeys = message.Subkeys.map(function (e) { return e; });
        }
        else {
            obj.Subkeys = [];
        }
        return obj;
    },
    create: function (base) {
        return exports.TaskGoal.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        var message = createBaseTaskGoal();
        message.SelfKey = (_a = object.SelfKey) !== null && _a !== void 0 ? _a : "";
        message.Name = (_b = object.Name) !== null && _b !== void 0 ? _b : "";
        message.Desc = (_c = object.Desc) !== null && _c !== void 0 ? _c : "";
        message.Type = (_d = object.Type) !== null && _d !== void 0 ? _d : 0;
        message.SelfVersion = (_e = object.SelfVersion) !== null && _e !== void 0 ? _e : 0;
        message.Creation = (_f = object.Creation) !== null && _f !== void 0 ? _f : undefined;
        message.When = (_g = object.When) !== null && _g !== void 0 ? _g : undefined;
        message.Subkeys = ((_h = object.Subkeys) === null || _h === void 0 ? void 0 : _h.map(function (e) { return e; })) || [];
        return message;
    }
};
function createBaseTaskStatus() {
    return {
        Manager: "",
        Name: "",
        Desc: "",
        LastStatus: 0,
        SelfVersion: 0,
        TaskVersion: 0,
        PrevValue: new Uint8Array(),
        Duration: undefined,
        When: undefined,
        TaskKey: "",
        SubtaskKeys: [],
        Messages: [],
        CurrentStatus: 0,
        TaskRevision: 0
    };
}
exports.TaskStatus = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.Manager !== "") {
            writer.uint32(10).string(message.Manager);
        }
        if (message.Name !== "") {
            writer.uint32(18).string(message.Name);
        }
        if (message.Desc !== "") {
            writer.uint32(26).string(message.Desc);
        }
        if (message.LastStatus !== 0) {
            writer.uint32(32).int32(message.LastStatus);
        }
        if (message.SelfVersion !== 0) {
            writer.uint32(40).int64(message.SelfVersion);
        }
        if (message.TaskVersion !== 0) {
            writer.uint32(48).int64(message.TaskVersion);
        }
        if (message.PrevValue.length !== 0) {
            writer.uint32(58).bytes(message.PrevValue);
        }
        if (message.Duration !== undefined) {
            duration_1.Duration.encode(message.Duration, writer.uint32(66).fork()).ldelim();
        }
        if (message.When !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.When), writer.uint32(74).fork()).ldelim();
        }
        if (message.TaskKey !== "") {
            writer.uint32(82).string(message.TaskKey);
        }
        for (var _i = 0, _a = message.SubtaskKeys; _i < _a.length; _i++) {
            var v = _a[_i];
            writer.uint32(90).string(v);
        }
        for (var _b = 0, _c = message.Messages; _b < _c.length; _b++) {
            var v = _c[_b];
            exports.TaskMessage.encode(v, writer.uint32(98).fork()).ldelim();
        }
        if (message.CurrentStatus !== 0) {
            writer.uint32(104).int32(message.CurrentStatus);
        }
        if (message.TaskRevision !== 0) {
            writer.uint32(112).int64(message.TaskRevision);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseTaskStatus();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.Manager = reader.string();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.Desc = reader.string();
                    break;
                case 4:
                    message.LastStatus = reader.int32();
                    break;
                case 5:
                    message.SelfVersion = longToNumber(reader.int64());
                    break;
                case 6:
                    message.TaskVersion = longToNumber(reader.int64());
                    break;
                case 7:
                    message.PrevValue = reader.bytes();
                    break;
                case 8:
                    message.Duration = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.When = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.TaskKey = reader.string();
                    break;
                case 11:
                    message.SubtaskKeys.push(reader.string());
                    break;
                case 12:
                    message.Messages.push(exports.TaskMessage.decode(reader, reader.uint32()));
                    break;
                case 13:
                    message.CurrentStatus = reader.int32();
                    break;
                case 14:
                    message.TaskRevision = longToNumber(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            Manager: isSet(object.Manager) ? String(object.Manager) : "",
            Name: isSet(object.Name) ? String(object.Name) : "",
            Desc: isSet(object.Desc) ? String(object.Desc) : "",
            LastStatus: isSet(object.LastStatus) ? taskStatus_StatusTypeFromJSON(object.LastStatus) : 0,
            SelfVersion: isSet(object.SelfVersion) ? Number(object.SelfVersion) : 0,
            TaskVersion: isSet(object.TaskVersion) ? Number(object.TaskVersion) : 0,
            PrevValue: isSet(object.PrevValue) ? bytesFromBase64(object.PrevValue) : new Uint8Array(),
            Duration: isSet(object.Duration) ? duration_1.Duration.fromJSON(object.Duration) : undefined,
            When: isSet(object.When) ? fromJsonTimestamp(object.When) : undefined,
            TaskKey: isSet(object.TaskKey) ? String(object.TaskKey) : "",
            SubtaskKeys: Array.isArray(object === null || object === void 0 ? void 0 : object.SubtaskKeys) ? object.SubtaskKeys.map(function (e) { return String(e); }) : [],
            Messages: Array.isArray(object === null || object === void 0 ? void 0 : object.Messages) ? object.Messages.map(function (e) { return exports.TaskMessage.fromJSON(e); }) : [],
            CurrentStatus: isSet(object.CurrentStatus) ? taskStatus_StatusTypeFromJSON(object.CurrentStatus) : 0,
            TaskRevision: isSet(object.TaskRevision) ? Number(object.TaskRevision) : 0
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.Manager !== undefined && (obj.Manager = message.Manager);
        message.Name !== undefined && (obj.Name = message.Name);
        message.Desc !== undefined && (obj.Desc = message.Desc);
        message.LastStatus !== undefined && (obj.LastStatus = taskStatus_StatusTypeToJSON(message.LastStatus));
        message.SelfVersion !== undefined && (obj.SelfVersion = Math.round(message.SelfVersion));
        message.TaskVersion !== undefined && (obj.TaskVersion = Math.round(message.TaskVersion));
        message.PrevValue !== undefined &&
            (obj.PrevValue = base64FromBytes(message.PrevValue !== undefined ? message.PrevValue : new Uint8Array()));
        message.Duration !== undefined && (obj.Duration = message.Duration ? duration_1.Duration.toJSON(message.Duration) : undefined);
        message.When !== undefined && (obj.When = message.When.toISOString());
        message.TaskKey !== undefined && (obj.TaskKey = message.TaskKey);
        if (message.SubtaskKeys) {
            obj.SubtaskKeys = message.SubtaskKeys.map(function (e) { return e; });
        }
        else {
            obj.SubtaskKeys = [];
        }
        if (message.Messages) {
            obj.Messages = message.Messages.map(function (e) { return e ? exports.TaskMessage.toJSON(e) : undefined; });
        }
        else {
            obj.Messages = [];
        }
        message.CurrentStatus !== undefined && (obj.CurrentStatus = taskStatus_StatusTypeToJSON(message.CurrentStatus));
        message.TaskRevision !== undefined && (obj.TaskRevision = Math.round(message.TaskRevision));
        return obj;
    },
    create: function (base) {
        return exports.TaskStatus.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        var message = createBaseTaskStatus();
        message.Manager = (_a = object.Manager) !== null && _a !== void 0 ? _a : "";
        message.Name = (_b = object.Name) !== null && _b !== void 0 ? _b : "";
        message.Desc = (_c = object.Desc) !== null && _c !== void 0 ? _c : "";
        message.LastStatus = (_d = object.LastStatus) !== null && _d !== void 0 ? _d : 0;
        message.SelfVersion = (_e = object.SelfVersion) !== null && _e !== void 0 ? _e : 0;
        message.TaskVersion = (_f = object.TaskVersion) !== null && _f !== void 0 ? _f : 0;
        message.PrevValue = (_g = object.PrevValue) !== null && _g !== void 0 ? _g : new Uint8Array();
        message.Duration = (object.Duration !== undefined && object.Duration !== null)
            ? duration_1.Duration.fromPartial(object.Duration)
            : undefined;
        message.When = (_h = object.When) !== null && _h !== void 0 ? _h : undefined;
        message.TaskKey = (_j = object.TaskKey) !== null && _j !== void 0 ? _j : "";
        message.SubtaskKeys = ((_k = object.SubtaskKeys) === null || _k === void 0 ? void 0 : _k.map(function (e) { return e; })) || [];
        message.Messages = ((_l = object.Messages) === null || _l === void 0 ? void 0 : _l.map(function (e) { return exports.TaskMessage.fromPartial(e); })) || [];
        message.CurrentStatus = (_m = object.CurrentStatus) !== null && _m !== void 0 ? _m : 0;
        message.TaskRevision = (_o = object.TaskRevision) !== null && _o !== void 0 ? _o : 0;
        return message;
    }
};
function createBaseTaskMessage() {
    return { Level: 0, Message: "" };
}
exports.TaskMessage = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.Level !== 0) {
            writer.uint32(8).int32(message.Level);
        }
        if (message.Message !== "") {
            writer.uint32(18).string(message.Message);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseTaskMessage();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.Level = reader.int32();
                    break;
                case 2:
                    message.Message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            Level: isSet(object.Level) ? taskMessage_TypeFromJSON(object.Level) : 0,
            Message: isSet(object.Message) ? String(object.Message) : ""
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.Level !== undefined && (obj.Level = taskMessage_TypeToJSON(message.Level));
        message.Message !== undefined && (obj.Message = message.Message);
        return obj;
    },
    create: function (base) {
        return exports.TaskMessage.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseTaskMessage();
        message.Level = (_a = object.Level) !== null && _a !== void 0 ? _a : 0;
        message.Message = (_b = object.Message) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseTaskTree() {
    return { Task: undefined, HighestStatus: 0, LastUpdated: undefined, NumChildTasks: 0, Subtasks: [] };
}
exports.TaskTree = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.Task !== undefined) {
            exports.TaskStatus.encode(message.Task, writer.uint32(10).fork()).ldelim();
        }
        if (message.HighestStatus !== 0) {
            writer.uint32(16).int32(message.HighestStatus);
        }
        if (message.LastUpdated !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.LastUpdated), writer.uint32(26).fork()).ldelim();
        }
        if (message.NumChildTasks !== 0) {
            writer.uint32(32).int64(message.NumChildTasks);
        }
        for (var _i = 0, _a = message.Subtasks; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.TaskTree.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseTaskTree();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.Task = exports.TaskStatus.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.HighestStatus = reader.int32();
                    break;
                case 3:
                    message.LastUpdated = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.NumChildTasks = longToNumber(reader.int64());
                    break;
                case 5:
                    message.Subtasks.push(exports.TaskTree.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            Task: isSet(object.Task) ? exports.TaskStatus.fromJSON(object.Task) : undefined,
            HighestStatus: isSet(object.HighestStatus) ? taskStatus_StatusTypeFromJSON(object.HighestStatus) : 0,
            LastUpdated: isSet(object.LastUpdated) ? fromJsonTimestamp(object.LastUpdated) : undefined,
            NumChildTasks: isSet(object.NumChildTasks) ? Number(object.NumChildTasks) : 0,
            Subtasks: Array.isArray(object === null || object === void 0 ? void 0 : object.Subtasks) ? object.Subtasks.map(function (e) { return exports.TaskTree.fromJSON(e); }) : []
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.Task !== undefined && (obj.Task = message.Task ? exports.TaskStatus.toJSON(message.Task) : undefined);
        message.HighestStatus !== undefined && (obj.HighestStatus = taskStatus_StatusTypeToJSON(message.HighestStatus));
        message.LastUpdated !== undefined && (obj.LastUpdated = message.LastUpdated.toISOString());
        message.NumChildTasks !== undefined && (obj.NumChildTasks = Math.round(message.NumChildTasks));
        if (message.Subtasks) {
            obj.Subtasks = message.Subtasks.map(function (e) { return e ? exports.TaskTree.toJSON(e) : undefined; });
        }
        else {
            obj.Subtasks = [];
        }
        return obj;
    },
    create: function (base) {
        return exports.TaskTree.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = createBaseTaskTree();
        message.Task = (object.Task !== undefined && object.Task !== null)
            ? exports.TaskStatus.fromPartial(object.Task)
            : undefined;
        message.HighestStatus = (_a = object.HighestStatus) !== null && _a !== void 0 ? _a : 0;
        message.LastUpdated = (_b = object.LastUpdated) !== null && _b !== void 0 ? _b : undefined;
        message.NumChildTasks = (_c = object.NumChildTasks) !== null && _c !== void 0 ? _c : 0;
        message.Subtasks = ((_d = object.Subtasks) === null || _d === void 0 ? void 0 : _d.map(function (e) { return exports.TaskTree.fromPartial(e); })) || [];
        return message;
    }
};
function createBaseTaskForest() {
    return { Goal: undefined, HighestStatus: 0, LastUpdated: undefined, NumChildTasks: 0, Subgoals: [], Subtasks: [] };
}
exports.TaskForest = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.Goal !== undefined) {
            exports.TaskGoal.encode(message.Goal, writer.uint32(10).fork()).ldelim();
        }
        if (message.HighestStatus !== 0) {
            writer.uint32(16).int32(message.HighestStatus);
        }
        if (message.LastUpdated !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.LastUpdated), writer.uint32(26).fork()).ldelim();
        }
        if (message.NumChildTasks !== 0) {
            writer.uint32(32).int64(message.NumChildTasks);
        }
        for (var _i = 0, _a = message.Subgoals; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.TaskForest.encode(v, writer.uint32(42).fork()).ldelim();
        }
        for (var _b = 0, _c = message.Subtasks; _b < _c.length; _b++) {
            var v = _c[_b];
            exports.TaskTree.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseTaskForest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.Goal = exports.TaskGoal.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.HighestStatus = reader.int32();
                    break;
                case 3:
                    message.LastUpdated = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.NumChildTasks = longToNumber(reader.int64());
                    break;
                case 5:
                    message.Subgoals.push(exports.TaskForest.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.Subtasks.push(exports.TaskTree.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            Goal: isSet(object.Goal) ? exports.TaskGoal.fromJSON(object.Goal) : undefined,
            HighestStatus: isSet(object.HighestStatus) ? taskStatus_StatusTypeFromJSON(object.HighestStatus) : 0,
            LastUpdated: isSet(object.LastUpdated) ? fromJsonTimestamp(object.LastUpdated) : undefined,
            NumChildTasks: isSet(object.NumChildTasks) ? Number(object.NumChildTasks) : 0,
            Subgoals: Array.isArray(object === null || object === void 0 ? void 0 : object.Subgoals) ? object.Subgoals.map(function (e) { return exports.TaskForest.fromJSON(e); }) : [],
            Subtasks: Array.isArray(object === null || object === void 0 ? void 0 : object.Subtasks) ? object.Subtasks.map(function (e) { return exports.TaskTree.fromJSON(e); }) : []
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.Goal !== undefined && (obj.Goal = message.Goal ? exports.TaskGoal.toJSON(message.Goal) : undefined);
        message.HighestStatus !== undefined && (obj.HighestStatus = taskStatus_StatusTypeToJSON(message.HighestStatus));
        message.LastUpdated !== undefined && (obj.LastUpdated = message.LastUpdated.toISOString());
        message.NumChildTasks !== undefined && (obj.NumChildTasks = Math.round(message.NumChildTasks));
        if (message.Subgoals) {
            obj.Subgoals = message.Subgoals.map(function (e) { return e ? exports.TaskForest.toJSON(e) : undefined; });
        }
        else {
            obj.Subgoals = [];
        }
        if (message.Subtasks) {
            obj.Subtasks = message.Subtasks.map(function (e) { return e ? exports.TaskTree.toJSON(e) : undefined; });
        }
        else {
            obj.Subtasks = [];
        }
        return obj;
    },
    create: function (base) {
        return exports.TaskForest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e;
        var message = createBaseTaskForest();
        message.Goal = (object.Goal !== undefined && object.Goal !== null) ? exports.TaskGoal.fromPartial(object.Goal) : undefined;
        message.HighestStatus = (_a = object.HighestStatus) !== null && _a !== void 0 ? _a : 0;
        message.LastUpdated = (_b = object.LastUpdated) !== null && _b !== void 0 ? _b : undefined;
        message.NumChildTasks = (_c = object.NumChildTasks) !== null && _c !== void 0 ? _c : 0;
        message.Subgoals = ((_d = object.Subgoals) === null || _d === void 0 ? void 0 : _d.map(function (e) { return exports.TaskForest.fromPartial(e); })) || [];
        message.Subtasks = ((_e = object.Subtasks) === null || _e === void 0 ? void 0 : _e.map(function (e) { return exports.TaskTree.fromPartial(e); })) || [];
        return message;
    }
};
function createBaseTaskSummary() {
    return { HighestStatus: 0, FirstUpdated: undefined, LastUpdated: undefined, Messages: [] };
}
exports.TaskSummary = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.HighestStatus !== 0) {
            writer.uint32(8).int32(message.HighestStatus);
        }
        if (message.FirstUpdated !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.FirstUpdated), writer.uint32(18).fork()).ldelim();
        }
        if (message.LastUpdated !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.LastUpdated), writer.uint32(26).fork()).ldelim();
        }
        for (var _i = 0, _a = message.Messages; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.TaskMessage.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseTaskSummary();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.HighestStatus = reader.int32();
                    break;
                case 2:
                    message.FirstUpdated = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.LastUpdated = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.Messages.push(exports.TaskMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            HighestStatus: isSet(object.HighestStatus) ? taskStatus_StatusTypeFromJSON(object.HighestStatus) : 0,
            FirstUpdated: isSet(object.FirstUpdated) ? fromJsonTimestamp(object.FirstUpdated) : undefined,
            LastUpdated: isSet(object.LastUpdated) ? fromJsonTimestamp(object.LastUpdated) : undefined,
            Messages: Array.isArray(object === null || object === void 0 ? void 0 : object.Messages) ? object.Messages.map(function (e) { return exports.TaskMessage.fromJSON(e); }) : []
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.HighestStatus !== undefined && (obj.HighestStatus = taskStatus_StatusTypeToJSON(message.HighestStatus));
        message.FirstUpdated !== undefined && (obj.FirstUpdated = message.FirstUpdated.toISOString());
        message.LastUpdated !== undefined && (obj.LastUpdated = message.LastUpdated.toISOString());
        if (message.Messages) {
            obj.Messages = message.Messages.map(function (e) { return e ? exports.TaskMessage.toJSON(e) : undefined; });
        }
        else {
            obj.Messages = [];
        }
        return obj;
    },
    create: function (base) {
        return exports.TaskSummary.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = createBaseTaskSummary();
        message.HighestStatus = (_a = object.HighestStatus) !== null && _a !== void 0 ? _a : 0;
        message.FirstUpdated = (_b = object.FirstUpdated) !== null && _b !== void 0 ? _b : undefined;
        message.LastUpdated = (_c = object.LastUpdated) !== null && _c !== void 0 ? _c : undefined;
        message.Messages = ((_d = object.Messages) === null || _d === void 0 ? void 0 : _d.map(function (e) { return exports.TaskMessage.fromPartial(e); })) || [];
        return message;
    }
};
function createBaseDeprStatus() {
    return { result: 0, worker: "", info: "", version: 0, reconciler: "", event: "", when: undefined };
}
exports.DeprStatus = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.result !== 0) {
            writer.uint32(8).int32(message.result);
        }
        if (message.worker !== "") {
            writer.uint32(18).string(message.worker);
        }
        if (message.info !== "") {
            writer.uint32(26).string(message.info);
        }
        if (message.version !== 0) {
            writer.uint32(32).int64(message.version);
        }
        if (message.reconciler !== "") {
            writer.uint32(42).string(message.reconciler);
        }
        if (message.event !== "") {
            writer.uint32(50).string(message.event);
        }
        if (message.when !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.when), writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDeprStatus();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.worker = reader.string();
                    break;
                case 3:
                    message.info = reader.string();
                    break;
                case 4:
                    message.version = longToNumber(reader.int64());
                    break;
                case 5:
                    message.reconciler = reader.string();
                    break;
                case 6:
                    message.event = reader.string();
                    break;
                case 7:
                    message.when = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            result: isSet(object.result) ? deprStatus_DeprResultTypeFromJSON(object.result) : 0,
            worker: isSet(object.worker) ? String(object.worker) : "",
            info: isSet(object.info) ? String(object.info) : "",
            version: isSet(object.version) ? Number(object.version) : 0,
            reconciler: isSet(object.reconciler) ? String(object.reconciler) : "",
            event: isSet(object.event) ? String(object.event) : "",
            when: isSet(object.when) ? fromJsonTimestamp(object.when) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.result !== undefined && (obj.result = deprStatus_DeprResultTypeToJSON(message.result));
        message.worker !== undefined && (obj.worker = message.worker);
        message.info !== undefined && (obj.info = message.info);
        message.version !== undefined && (obj.version = Math.round(message.version));
        message.reconciler !== undefined && (obj.reconciler = message.reconciler);
        message.event !== undefined && (obj.event = message.event);
        message.when !== undefined && (obj.when = message.when.toISOString());
        return obj;
    },
    create: function (base) {
        return exports.DeprStatus.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g;
        var message = createBaseDeprStatus();
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        message.worker = (_b = object.worker) !== null && _b !== void 0 ? _b : "";
        message.info = (_c = object.info) !== null && _c !== void 0 ? _c : "";
        message.version = (_d = object.version) !== null && _d !== void 0 ? _d : 0;
        message.reconciler = (_e = object.reconciler) !== null && _e !== void 0 ? _e : "";
        message.event = (_f = object.event) !== null && _f !== void 0 ? _f : "";
        message.when = (_g = object.when) !== null && _g !== void 0 ? _g : undefined;
        return message;
    }
};
function createBaseReconcilerHealth() {
    return {
        Manager: "",
        Name: "",
        SelfVersion: 0,
        StartTime: undefined,
        CheckInTime: undefined,
        Duration: undefined,
        Unresponsive: false,
        KeysHandled: 0,
        LastKey: "",
        WhenLastKey: undefined
    };
}
exports.ReconcilerHealth = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.Manager !== "") {
            writer.uint32(10).string(message.Manager);
        }
        if (message.Name !== "") {
            writer.uint32(18).string(message.Name);
        }
        if (message.SelfVersion !== 0) {
            writer.uint32(24).int64(message.SelfVersion);
        }
        if (message.StartTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.StartTime), writer.uint32(34).fork()).ldelim();
        }
        if (message.CheckInTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.CheckInTime), writer.uint32(42).fork()).ldelim();
        }
        if (message.Duration !== undefined) {
            duration_1.Duration.encode(message.Duration, writer.uint32(50).fork()).ldelim();
        }
        if (message.Unresponsive === true) {
            writer.uint32(56).bool(message.Unresponsive);
        }
        if (message.KeysHandled !== 0) {
            writer.uint32(64).int64(message.KeysHandled);
        }
        if (message.LastKey !== "") {
            writer.uint32(74).string(message.LastKey);
        }
        if (message.WhenLastKey !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.WhenLastKey), writer.uint32(82).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseReconcilerHealth();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.Manager = reader.string();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.SelfVersion = longToNumber(reader.int64());
                    break;
                case 4:
                    message.StartTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.CheckInTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.Duration = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.Unresponsive = reader.bool();
                    break;
                case 8:
                    message.KeysHandled = longToNumber(reader.int64());
                    break;
                case 9:
                    message.LastKey = reader.string();
                    break;
                case 10:
                    message.WhenLastKey = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            Manager: isSet(object.Manager) ? String(object.Manager) : "",
            Name: isSet(object.Name) ? String(object.Name) : "",
            SelfVersion: isSet(object.SelfVersion) ? Number(object.SelfVersion) : 0,
            StartTime: isSet(object.StartTime) ? fromJsonTimestamp(object.StartTime) : undefined,
            CheckInTime: isSet(object.CheckInTime) ? fromJsonTimestamp(object.CheckInTime) : undefined,
            Duration: isSet(object.Duration) ? duration_1.Duration.fromJSON(object.Duration) : undefined,
            Unresponsive: isSet(object.Unresponsive) ? Boolean(object.Unresponsive) : false,
            KeysHandled: isSet(object.KeysHandled) ? Number(object.KeysHandled) : 0,
            LastKey: isSet(object.LastKey) ? String(object.LastKey) : "",
            WhenLastKey: isSet(object.WhenLastKey) ? fromJsonTimestamp(object.WhenLastKey) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.Manager !== undefined && (obj.Manager = message.Manager);
        message.Name !== undefined && (obj.Name = message.Name);
        message.SelfVersion !== undefined && (obj.SelfVersion = Math.round(message.SelfVersion));
        message.StartTime !== undefined && (obj.StartTime = message.StartTime.toISOString());
        message.CheckInTime !== undefined && (obj.CheckInTime = message.CheckInTime.toISOString());
        message.Duration !== undefined && (obj.Duration = message.Duration ? duration_1.Duration.toJSON(message.Duration) : undefined);
        message.Unresponsive !== undefined && (obj.Unresponsive = message.Unresponsive);
        message.KeysHandled !== undefined && (obj.KeysHandled = Math.round(message.KeysHandled));
        message.LastKey !== undefined && (obj.LastKey = message.LastKey);
        message.WhenLastKey !== undefined && (obj.WhenLastKey = message.WhenLastKey.toISOString());
        return obj;
    },
    create: function (base) {
        return exports.ReconcilerHealth.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var message = createBaseReconcilerHealth();
        message.Manager = (_a = object.Manager) !== null && _a !== void 0 ? _a : "";
        message.Name = (_b = object.Name) !== null && _b !== void 0 ? _b : "";
        message.SelfVersion = (_c = object.SelfVersion) !== null && _c !== void 0 ? _c : 0;
        message.StartTime = (_d = object.StartTime) !== null && _d !== void 0 ? _d : undefined;
        message.CheckInTime = (_e = object.CheckInTime) !== null && _e !== void 0 ? _e : undefined;
        message.Duration = (object.Duration !== undefined && object.Duration !== null)
            ? duration_1.Duration.fromPartial(object.Duration)
            : undefined;
        message.Unresponsive = (_f = object.Unresponsive) !== null && _f !== void 0 ? _f : false;
        message.KeysHandled = (_g = object.KeysHandled) !== null && _g !== void 0 ? _g : 0;
        message.LastKey = (_h = object.LastKey) !== null && _h !== void 0 ? _h : "";
        message.WhenLastKey = (_j = object.WhenLastKey) !== null && _j !== void 0 ? _j : undefined;
        return message;
    }
};
function createBaseServerHeartbeat() {
    return { Interval: 0, When: undefined };
}
exports.ServerHeartbeat = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1["default"].Writer.create(); }
        if (message.Interval !== 0) {
            writer.uint32(8).uint64(message.Interval);
        }
        if (message.When !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.When), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1["default"].Reader ? input : new minimal_1["default"].Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseServerHeartbeat();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.Interval = longToNumber(reader.uint64());
                    break;
                case 2:
                    message.When = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            Interval: isSet(object.Interval) ? Number(object.Interval) : 0,
            When: isSet(object.When) ? fromJsonTimestamp(object.When) : undefined
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.Interval !== undefined && (obj.Interval = Math.round(message.Interval));
        message.When !== undefined && (obj.When = message.When.toISOString());
        return obj;
    },
    create: function (base) {
        return exports.ServerHeartbeat.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseServerHeartbeat();
        message.Interval = (_a = object.Interval) !== null && _a !== void 0 ? _a : 0;
        message.When = (_b = object.When) !== null && _b !== void 0 ? _b : undefined;
        return message;
    }
};
var tsProtoGlobalThis = (function () {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (tsProtoGlobalThis.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
    }
    else {
        var bin = tsProtoGlobalThis.atob(b64);
        var arr = new Uint8Array(bin.length);
        for (var i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (tsProtoGlobalThis.Buffer) {
        return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
    }
    else {
        var bin_1 = [];
        arr.forEach(function (byte) {
            bin_1.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis.btoa(bin_1.join(""));
    }
}
function toTimestamp(date) {
    var seconds = date.getTime() / 1000;
    var nanos = (date.getTime() % 1000) * 1000000;
    return { seconds: seconds, nanos: nanos };
}
function fromTimestamp(t) {
    var millis = t.seconds * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
    }
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (minimal_1["default"].util.Long !== long_1["default"]) {
    minimal_1["default"].util.Long = long_1["default"];
    minimal_1["default"].configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
